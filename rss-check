#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;
  
  # See POD at end for documentation
  
  use 5.00503;
  use strict;
  use Carp        ();
  use Config      ();
  use File::Spec  ();
  use File::Which ();
  
  # Globals
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};
  BEGIN {
  	$VERSION = '1.00';
  
  	# Inherit manually
  	require Exporter;
  	@ISA       = qw{ Exporter };
  	@EXPORT    = qw{ home     };
  	@EXPORT_OK = qw{
  		home
  		my_home
  		my_desktop
  		my_documents
  		my_music
  		my_pictures
  		my_videos
  		my_data
  		my_dist_config
  		my_dist_data
  		users_home
  		users_desktop
  		users_documents
  		users_music
  		users_pictures
  		users_videos
  		users_data
  	};
  
  	# %~ doesn't need (and won't take) exporting, as it's a magic
  	# symbol name that's always looked for in package 'main'.
  }
  
  # Inlined Params::Util functions
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  
  # Platform detection
  if ( $IMPLEMENTED_BY ) {
  	# Allow for custom HomeDir classes
  	# Leave it as the existing value
  } elsif ( $^O eq 'MSWin32' ) {
  	# All versions of Windows
  	$IMPLEMENTED_BY = 'File::HomeDir::Windows';
  } elsif ( $^O eq 'darwin') {
  	# 1st: try Mac::SystemDirectory by chansen
  	if ( eval { require Mac::SystemDirectory; 1 } ) {
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Cocoa';
  	} elsif ( eval { require Mac::Files; 1 } ) {
  		# 2nd try Mac::Files: Carbon - unmaintained since 2006 except some 64bit fixes
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Carbon';
  	} else {
  		# 3rd: fallback: pure perl
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin';
  	}
  } elsif ( $^O eq 'MacOS' ) {
  	# Legacy Mac OS
  	$IMPLEMENTED_BY = 'File::HomeDir::MacOS9';
  } elsif ( File::Which::which('xdg-user-dir') ) {
  	# freedesktop unixes
  	$IMPLEMENTED_BY = 'File::HomeDir::FreeDesktop';
  } else {
  	# Default to Unix semantics
  	$IMPLEMENTED_BY = 'File::HomeDir::Unix';
  }
  unless ( _DRIVER($IMPLEMENTED_BY, 'File::HomeDir::Driver') ) {
  	Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY");
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	$IMPLEMENTED_BY->my_home;
  }
  
  sub my_desktop {
  	$IMPLEMENTED_BY->can('my_desktop')
  		? $IMPLEMENTED_BY->my_desktop
  		: Carp::croak("The my_desktop method is not implemented on this platform");
  }
  
  sub my_documents {
  	$IMPLEMENTED_BY->can('my_documents')
  		? $IMPLEMENTED_BY->my_documents
  		: Carp::croak("The my_documents method is not implemented on this platform");
  }
  
  sub my_music {
  	$IMPLEMENTED_BY->can('my_music')
  		? $IMPLEMENTED_BY->my_music
  		: Carp::croak("The my_music method is not implemented on this platform");
  }
  
  sub my_pictures {
  	$IMPLEMENTED_BY->can('my_pictures')
  		? $IMPLEMENTED_BY->my_pictures
  		: Carp::croak("The my_pictures method is not implemented on this platform");
  }
  
  sub my_videos {
  	$IMPLEMENTED_BY->can('my_videos')
  		? $IMPLEMENTED_BY->my_videos
  		: Carp::croak("The my_videos method is not implemented on this platform");
  }
  
  sub my_data {
  	$IMPLEMENTED_BY->can('my_data')
  		? $IMPLEMENTED_BY->my_data
  		: Carp::croak("The my_data method is not implemented on this platform");
  }
  
  
  sub my_dist_data {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_data method requires an argument");
  	my $data   = my_data();
  
          # If datadir is not defined, there's nothing we can do: bail out
          # and return nothing...	
  	return undef unless defined $data;
  
          # On traditional unixes, hide the top-level directory
  	my $var = $data eq home()
  		? File::Spec->catdir( $data, '.perl', 'dist', $dist )
  		: File::Spec->catdir( $data, 'Perl',  'dist', $dist );
  
  	# directory exists: return it
  	return $var if -d $var;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $var );
  	return $var;
  }
  
  sub my_dist_config {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_config method requires an argument");
  
  	# not all platforms support a specific my_config() method
  	my $config = $IMPLEMENTED_BY->can('my_config')
  		? $IMPLEMENTED_BY->my_config
  		: $IMPLEMENTED_BY->my_documents;
  
  	# If neither configdir nor my_documents is defined, there's
  	# nothing we can do: bail out and return nothing...	
  	return undef unless defined $config;
  
  	# On traditional unixes, hide the top-level dir
  	my $etc = $config eq home()
  		? File::Spec->catdir( $config, '.perl', $dist )
  		: File::Spec->catdir( $config, 'Perl',  $dist );
  
  	# directory exists: return it
  	return $etc if -d $etc;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $etc );
  	return $etc;
  }
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	$IMPLEMENTED_BY->can('users_home')
  		? $IMPLEMENTED_BY->users_home( $_[-1] )
  		: Carp::croak("The users_home method is not implemented on this platform");
  }
  
  sub users_desktop {
  	$IMPLEMENTED_BY->can('users_desktop')
  		? $IMPLEMENTED_BY->users_desktop( $_[-1] )
  		: Carp::croak("The users_desktop method is not implemented on this platform");
  }
  
  sub users_documents {
  	$IMPLEMENTED_BY->can('users_documents')
  		? $IMPLEMENTED_BY->users_documents( $_[-1] )
  		: Carp::croak("The users_documents method is not implemented on this platform");
  }
  
  sub users_music {
  	$IMPLEMENTED_BY->can('users_music')
  		? $IMPLEMENTED_BY->users_music( $_[-1] )
  		: Carp::croak("The users_music method is not implemented on this platform");
  }
  
  sub users_pictures {
  	$IMPLEMENTED_BY->can('users_pictures')
  		? $IMPLEMENTED_BY->users_pictures( $_[-1] )
  		: Carp::croak("The users_pictures method is not implemented on this platform");
  }
  
  sub users_videos {
  	$IMPLEMENTED_BY->can('users_videos')
  		? $IMPLEMENTED_BY->users_videos( $_[-1] )
  		: Carp::croak("The users_videos method is not implemented on this platform");
  }
  
  sub users_data {
  	$IMPLEMENTED_BY->can('users_data')
  		? $IMPLEMENTED_BY->users_data( $_[-1] )
  		: Carp::croak("The users_data method is not implemented on this platform");
  }
  
  
  
  
  
  #####################################################################
  # Legacy Methods
  
  # Find the home directory of an arbitrary user
  sub home (;$) {
  	# Allow to be called as a method
  	if ( $_[0] and $_[0] eq 'File::HomeDir' ) {
  		shift();
  	}
  
  	# No params means my home
  	return my_home() unless @_;
  
  	# Check the param
  	my $name = shift;
  	if ( ! defined $name ) {
  		Carp::croak("Can't use undef as a username");
  	}
  	if ( ! length $name ) {
  		Carp::croak("Can't use empty-string (\"\") as a username");
  	}
  
  	# A dot also means my home
  	### Is this meant to mean File::Spec->curdir?
  	if ( $name eq '.' ) {
  		return my_home();
  	}
  
  	# Now hand off to the implementor
  	$IMPLEMENTED_BY->users_home($name);
  }
  
  
  
  
  
  #####################################################################
  # Tie-Based Interface
  
  # Okay, things below this point get scary
  
  CLASS: {
  	# Make the class for the %~ tied hash:
  	package File::HomeDir::TIE;
  
  	# Make the singleton object.
  	# (We don't use the hash for anything, though)
  	### THEN WHY MAKE IT???
  	my $SINGLETON = bless {};
  
  	sub TIEHASH { $SINGLETON }
  
  	sub FETCH {
  		# Catch a bad username
  		unless ( defined $_[1] ) {
  			Carp::croak("Can't use undef as a username");
  		}
  
  		# Get our homedir
  		unless ( length $_[1] ) {
  			return File::HomeDir::my_home();
  		}
  
  		# Get a named user's homedir
  		Carp::carp("The tied %~ hash has been deprecated");
  		return File::HomeDir::home($_[1]);
  	}
  
  	sub STORE    { _bad('STORE')    }
  	sub EXISTS   { _bad('EXISTS')   }
  	sub DELETE   { _bad('DELETE')   }
  	sub CLEAR    { _bad('CLEAR')    }
  	sub FIRSTKEY { _bad('FIRSTKEY') }
  	sub NEXTKEY  { _bad('NEXTKEY')  }
  
  	sub _bad ($) {
  		Carp::croak("You can't $_[0] with the %~ hash")
  	}
  }
  
  # Do the actual tie of the global %~ variable
  tie %~, 'File::HomeDir::TIE';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir - Find your home and other directories on any platform
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Modern Interface (Current User)
    $home     = File::HomeDir->my_home;
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $dist     = File::HomeDir->my_dist_data('File-HomeDir');
    $dist     = File::HomeDir->my_dist_config('File-HomeDir');
    
    # Modern Interface (Other Users)
    $home    = File::HomeDir->users_home('foo');
    $desktop = File::HomeDir->users_desktop('foo');
    $docs    = File::HomeDir->users_documents('foo');
    $music   = File::HomeDir->users_music('foo');
    $pics    = File::HomeDir->users_pictures('foo');
    $video   = File::HomeDir->users_videos('foo');
    $data    = File::HomeDir->users_data('foo');
  
  =head1 DESCRIPTION
  
  B<File::HomeDir> is a module for locating the directories that are "owned"
  by a user (typicaly your user) and to solve the various issues that arise
  trying to find them consistently across a wide variety of platforms.
  
  The end result is a single API that can find your resources on any platform,
  making it relatively trivial to create Perl software that works elegantly
  and correctly no matter where you run it.
  
  This module provides two main interfaces.
  
  The first is a modern L<File::Spec>-style interface with a consistent
  OO API and different implementation modules to support various
  platforms. You are B<strongly> recommended to use this interface.
  
  The second interface is for legacy support of the original 0.07 interface
  that exported a C<home()> function by default and tied the C<%~> variable.
  
  It is generally not recommended that you use this interface, but due to
  back-compatibility reasons they will remain supported until at least 2010.
  
  The C<%~> interface has been deprecated. Documentation was removed in 2009,
  Unit test were removed in 2011, usage will issue warnings from 2012, and the
  interface will be removed entirely in 2015  (in line with the general Perl
  toolchain convention of a 10 year support period for legacy APIs that
  are potentially or actually in common use).
  
  =head2 Platform Neutrality
  
  In the Unix world, many different types of data can be mixed together
  in your home directory (although on some Unix platforms this is no longer
  the case, particularly for "desktop"-oriented platforms).
  
  On some non-Unix platforms, separate directories are allocated for
  different types of data and have been for a long time.
  
  When writing applications on top of B<File::HomeDir>, you should thus
  always try to use the most specific method you can. User documents should
  be saved in C<my_documents>, data that supports an application but isn't
  normally editing by the user directory should go into C<my_data>.
  
  On platforms that do not make any distinction, all these different
  methods will harmlessly degrade to the main home directory, but on
  platforms that care B<File::HomeDir> will always try to Do The Right
  Thing(tm).
  
  =head1 METHODS
  
  Two types of methods are provided. The C<my_method> series of methods for
  finding resources for the current user, and the C<users_method> (read as
  "user's method") series for finding resources for arbitrary users.
  
  This split is necessary, as on most platforms it is B<much> easier to find
  information about the current user compared to other users, and indeed
  on a number you cannot find out information such as C<users_desktop> at
  all, due to security restrictions.
  
  All methods will double check (using a C<-d> test) that a directory
  actually exists before returning it, so you may trust in the values
  that are returned (subject to the usual caveats of race conditions of
  directories being deleted at the moment between a directory being returned
  and you using it).
  
  However, because in some cases platforms may not support the concept of home
  directories at all, any method may return C<undef> (both in scalar and list
  context) to indicate that there is no matching directory on the system.
  
  For example, most untrusted 'nobody'-type users do not have a home
  directory. So any modules that are used in a CGI application that
  at some level of recursion use your code, will result in calls to
  File::HomeDir returning undef, even for a basic home() call.
  
  =head2 my_home
  
  The C<my_home> method takes no arguments and returns the main home/profile
  directory for the current user.
  
  If the distinction is important to you, the term "current" refers to the
  real user, and not the effective user.
  
  This is also the case for all of the other "my" methods.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a home directory, or dies on error.
  
  =head2 my_desktop
  
  The C<my_desktop> method takes no arguments and returns the "desktop"
  directory for the current user.
  
  Due to the diversity and complexity of implementions required to deal with
  implementing the required functionality fully and completely, the
  C<my_desktop> method may or may not be implemented on each platform.
  
  That said, I am extremely interested in code to implement C<my_desktop> on
  Unix, as long as it is capable of dealing (as the Windows implementation
  does) with internationalisation. It should also avoid false positive
  results by making sure it only returns the appropriate directories for the
  appropriate platforms.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a desktop directory, or dies on error.
  
  =head2 my_documents
  
  The C<my_documents> method takes no arguments and returns the directory (for
  the current user) where the user's documents are stored.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a documents directory, or dies on error.
  
  =head2 my_music
  
  The C<my_music> method takes no arguments and returns the directory
  where the current user's music is stored.
  
  No bias is made to any particular music type or music program, rather the
  concept of a directory to hold the user's music is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_pictures
  
  The C<my_pictures> method takes no arguments and returns the directory
  where the current user's pictures are stored.
  
  No bias is made to any particular picture type or picture program, rather the
  concept of a directory to hold the user's pictures is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_videos
  
  The C<my_videos> method takes no arguments and returns the directory
  where the current user's videos are stored.
  
  No bias is made to any particular video type or video program, rather the
  concept of a directory to hold the user's videos is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_data
  
  The C<my_data> method takes no arguments and returns the directory where
  local applications should stored their internal data for the current
  user.
  
  Generally an application would create a subdirectory such as C<.foo>,
  beneath this directory, and store its data there. By creating your
  directory this way, you get an accurate result on the maximum number of
  platforms. But see the documentation about C<my_dist_config()> or
  C<my_dist_data()> below.
  
  For example, on Unix you get C<~/.foo> and on Win32 you get
  C<~/Local Settings/Application Data/.foo>
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a data directory, or dies on error.
  
  
  =head2 my_dist_config
  
    File::HomeDir->my_dist_config( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_config( 'File-HomeDir' );
    File::HomeDir->my_dist_config( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_config> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal configuration.
  
  The base directory will be either C<my_config> if the platform supports
  it, or C<my_documents> otherwise. The subdirectory itself will be 
  C<BASE/Perl/Dist-Name>. If the base directory is the user's homedir,
  C<my_dist_config> will be in C<~/.perl/Dist-Name> (and thus be hidden on
  all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  
  =head2 my_dist_data
  
    File::HomeDir->my_dist_data( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_data( 'File-HomeDir' );
    File::HomeDir->my_dist_data( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_data> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal data.
  
  This directory will be of course a subdirectory of C<my_data>. Platforms
  supporting data-specific directories will use
  C<DATA_DIR/perl/dist/Dist-Name> following the common
  "DATA/vendor/application" pattern. If the C<my_data> directory is the
  user's homedir, C<my_dist_data> will be in C<~/.perl/dist/Dist-Name>
  (and thus be hidden on all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  =head2 users_home
  
    $home = File::HomeDir->users_home('foo');
  
  The C<users_home> method takes a single param and is used to locate the
  parent home/profile directory for an identified user on the system.
  
  While most of the time this identifier would be some form of user name,
  it is permitted to vary per-platform to support user ids or UUIDs as
  applicable for that platform.
  
  Returns the directory path as a string, C<undef> if that user
  does not have a home directory, or dies on error.
  
  =head2 users_documents
  
    $docs = File::HomeDir->users_documents('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a documents directory, or dies on error.
  
  =head2 users_data
  
    $data = File::HomeDir->users_data('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a data directory, or dies on error.
  
  =head1 FUNCTIONS
  
  =head2 home
  
    use File::HomeDir;
    $home = home();
    $home = home('foo');
    $home = File::HomeDir::home();
    $home = File::HomeDir::home('foo');
  
  The C<home> function is exported by default and is provided for
  compatibility with legacy applications. In new applications, you should
  use the newer method-based interface above.
  
  Returns the directory path to a named user's home/profile directory.
  
  If provided no param, returns the directory path to the current user's
  home/profile directory.
  
  =head1 TO DO
  
  =over 4
  
  =item * Add more granularity to Unix, and add support to VMS and other
  esoteric platforms, so we can consider going core.
  
  =item * Add consistent support for users_* methods 
  
  =back
  
  =head1 SUPPORT
  
  This module is stored in an Open Repository at the following address.
  
  L<http://svn.ali.as/cpan/trunk/File-HomeDir>
  
  Write access to the repository is made available automatically to any
  published CPAN author, and to most other volunteers on request.
  
  If you are able to submit your bug report in the form of new (failing)
  unit tests, or can apply your fix directly instead of submitting a patch,
  you are B<strongly> encouraged to do so as the author currently maintains
  over 100 modules and it can take some time to deal with non-Critical bug
  reports or patches.
  
  This will guarantee that your issue will be addressed in the next
  release of the module.
  
  If you cannot provide a direct test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the CPAN
  bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-HomeDir>
  
  For other issues, for commercial enhancement or support, or to have your
  write access enabled for the repository, contact the author at the email
  address above.
  
  =head1 ACKNOWLEDGEMENTS
  
  The biggest acknowledgement goes to Chris Nandor, who wielded his
  legendary Mac-fu and turned my initial fairly ordinary Darwin
  implementation into something that actually worked properly everywhere,
  and then donated a Mac OS X license to allow it to be maintained properly.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  Chris Nandor E<lt>cnandor@cpan.orgE<gt>
  
  Stephen Steneker E<lt>stennie@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  Some parts copyright 2006 Chris Nandor.
  
  Some parts copyright 2006 Stephen Steneker.
  
  Some parts copyright 2009-2011 Jérôme Quelin.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;
  
  use 5.00503;
  use strict;
  use Cwd                 ();
  use Carp                ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	my $home = (getpwuid($<))[7];
  	return $home if $home && -d $home;
  
  	return undef;
  }
  
  sub _my_home {
  	my($class, $path) = @_;
  	my $home = $class->my_home;
  	return undef unless defined $home;
  
  	my $folder = "$home/$path";
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  sub my_desktop {
  	my $class = shift;
  	$class->_my_home('Desktop');
  }
  
  sub my_documents {
  	my $class = shift;
  	$class->_my_home('Documents');
  }
  
  sub my_data {
  	my $class = shift;
  	$class->_my_home('Library/Application Support');
  }
  
  sub my_music {
  	my $class = shift;
  	$class->_my_home('Music');
  }
  
  sub my_pictures {
  	my $class = shift;
  	$class->_my_home('Pictures');
  }
  
  sub my_videos {
  	my $class = shift;
  	$class->_my_home('Movies');
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Mac OS X specific file path for determining
  common user directories in pure perl, by just using C<$ENV{HOME}>
  without Carbon nor Cocoa API calls. In normal usage this module will
  always be used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;
  
  # Basic implementation for the Dawin family of operating systems.
  # This includes (most prominently) Mac OS X.
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  
  	# This is only a child class of the pure Perl darwin
  	# class so that we can do homedir detection of all three
  	# drivers at one via ->isa.
  	@ISA = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kCurrentUserFolderType(),
  	);
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDesktopFolderType(),
  	);
  }
  
  sub my_documents {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDocumentsFolderType(),
  	);
  }
  
  sub my_data {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kApplicationSupportFolderType(),
  	);
  }
  
  sub my_music {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMusicDocumentsFolderType(),
  	);
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kPictureDocumentsFolderType(),
  	);
  }
  
  sub my_videos {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMovieDocumentsFolderType(),
  	);
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::Files;
  	my $folder = Mac::Files::FindFolder(
  		Mac::Files::kUserDomain(),
  		$name,
  	);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  # in theory this can be done, but for now, let's cheat, since the
  # rest is Hard
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Note -- since this module requires Mac::Carbon and Mac::Carbon does
  not work with 64-bit perls, on such systems, File::HomeDir will try
  L<File::HomeDir::Darwin::Cocoa> and then fall back to the (pure Perl)
  L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
  
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =head1 TODO
  
  =over 4
  
  =item * Test with Mac OS (versions 7, 8, 9)
  
  =item * Some better way for users_* ?
  
  =back
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::SystemDirectory'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::SystemDirectory;
  	return Mac::SystemDirectory::HomeDirectory();
  }
  
  # from 10.4
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())
  	}
  	||
  	$class->SUPER::my_desktop;
  }
  
  # from 10.2
  sub my_documents {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())
  	}
  	||
  	$class->SUPER::my_documents;
  }
  
  # from 10.4
  sub my_data {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())
  	}
  	||
  	$class->SUPER::my_data;
  }
  
  # from 10.6
  sub my_music {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())
  	}
  	||
  	$class->SUPER::my_music;
  }
  
  # from 10.6
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())
  	}
  	||
  	$class->SUPER::my_pictures;
  }
  
  # from 10.6
  sub my_videos {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())
  	}
  	||
  	$class->SUPER::my_videos;
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::SystemDirectory;
  	my $folder = Mac::SystemDirectory::FindDirectory($name);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin::Cocoa - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories using Cocoa API through
  L<Mac::SystemDirectory>.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Theoretically, this should return the same paths as both of the other
  Darwin drivers.
  
  Because this module requires L<Mac::SystemDirectory>, if the module
  is not installed, L<File::HomeDir> will fall back to L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;
  
  # Abstract base class that provides no functionality,
  # but confirms the class is a File::HomeDir driver class.
  
  use 5.00503;
  use strict;
  use Carp ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.00';
  }
  
  sub my_home {
  	Carp::croak("$_[0] does not implement compulsory method $_[1]");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Driver - Base class for all File::HomeDir drivers
  
  =head1 DESCRIPTION
  
  This module is the base class for all L<File::HomeDir> drivers, and must
  be inherited from to identify a class as a driver.
  
  It is primarily provided as a convenience for this specific identification
  purpose, as L<File::HomeDir> supports the specification of custom drivers
  and an C<-E<gt>isa> check is used during the loading of the driver.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;
  
  # Specific functionality for unixes running free desktops
  # compatible with (but not using) File-BaseDir-0.03
  
  # See POD at the end of the file for more documentation.
  
  use 5.00503;
  use strict;
  use Carp                ();
  use File::Spec          ();
  use File::Which         ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  # xdg uses $ENV{XDG_CONFIG_HOME}/user-dirs.dirs to know where are the
  # various "my xxx" directories. That is a shell file. The official API
  # is the xdg-user-dir executable. It has no provision for assessing
  # the directories of a user that is different than the one we are
  # running under; the standard substitute user mechanisms are needed to
  # overcome this.
  
  my $xdgprog = File::Which::which('xdg-user-dir');
  
  sub _my {
  	# No quoting because input is hard-coded and only comes from this module
  	my $thingy = qx($xdgprog $_[1]);
  	chomp $thingy;
  	return $thingy;
  }
  
  # Simple stuff
  sub my_desktop   { shift->_my('DESKTOP')   }
  sub my_documents { shift->_my('DOCUMENTS') }
  sub my_music     { shift->_my('MUSIC')     }
  sub my_pictures  { shift->_my('PICTURES')  }
  sub my_videos    { shift->_my('VIDEOS')    }
  
  sub my_data {
  	$ENV{XDG_DATA_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .local share }
  	);
  }
  
  sub my_config {
  	$ENV{XDG_CONFIG_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .config }
  	);
  }
  
  # Custom locations (currently undocumented)
  sub my_download    { shift->_my('DOWNLOAD')    }
  sub my_publicshare { shift->_my('PUBLICSHARE') }
  sub my_templates   { shift->_my('TEMPLATES')   }
  
  sub my_cache {
      $ENV{XDG_CACHE_HOME}
      ||
      File::Spec->catdir(shift->my_home, qw{ .cache });
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_desktop   { Carp::croak('The users_desktop method is not available on an XDG based system.');   }
  sub users_documents { Carp::croak('The users_documents method is not available on an XDG based system.'); }
  sub users_music     { Carp::croak('The users_music method is not available on an XDG based system.');     }
  sub users_pictures  { Carp::croak('The users_pictures method is not available on an XDG based system.');  }
  sub users_videos    { Carp::croak('The users_videos method is not available on an XDG based system.');    }
  sub users_data      { Carp::croak('The users_data method is not available on an XDG based system.');      }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::FreeDesktop - Find your home and other directories on FreeDesktop.org Unix
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;
    $docs    = File::HomeDir->my_documents;
    $music   = File::HomeDir->my_music;
    $pics    = File::HomeDir->my_pictures;
    $videos  = File::HomeDir->my_videos;
    $data    = File::HomeDir->my_data;
  
  =head1 AUTHORS
  
  Jerome Quelin E<lt>jquellin@cpan.org<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Jerome Quelin.
  
  Some parts copyright 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;
  
  # Half-assed implementation for the legacy Mac OS9 operating system.
  # Provided mainly to provide legacy compatibility. May be removed at
  # a later date.
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  # Load early if in a forking environment and we have
  # prefork, or at run-time if not.
  SCOPE: {
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# Try for $ENV{HOME} if we have it
  	if ( defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	### DESPERATION SETS IN
  
  	# We could use the desktop
  	SCOPE: {
  		local $@;
  		eval {
  			my $home = $class->my_desktop;
  			return $home if $home and -d $home;
  		};
  	}
  
  	# Desperation on any platform
  	SCOPE: {
  		# On some platforms getpwuid dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	Carp::croak("Could not locate current user's home directory");
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# Find the desktop via Mac::Files
  	local $SIG{'__DIE__'} = '';
  	require Mac::Files;
  	my $home = Mac::Files::FindFolder(
  		Mac::Files::kOnSystemDisk(),
  		Mac::Files::kDesktopFolderType(),
  		);
  	return $home if $home and -d $home;
  
  	Carp::croak("Could not locate current user's desktop");
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	SCOPE: {
  		# On some platforms getpwnam dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwnam($name))[7];
  		return $home if defined $home and -d $home;
  	}
  
  	Carp::croak("Failed to find home directory for user '$name'");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::MacOS9 - Find your home and other directories on legacy Macs
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;
    $desktop = File::HomeDir->my_desktop;
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories on legacy Mac hosts. In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module is no longer actively maintained, and is included only for
  extreme back-compatibility.
  
  Only the C<my_home> and C<my_desktop> methods are supported.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::Temp            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA %DIR $ENABLED};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  	%DIR     = ();
  	$ENABLED = 0;
  }
  
  # Special magic use in test scripts
  sub import {
  	my $class = shift;
  	die "Attempted to initialise File::HomeDir::Test trice" if %DIR;
  
  	# Fill the test directories
  	my $BASE  = File::Temp::tempdir( CLEANUP => 1 );
  	%DIR = map { $_ => File::Spec->catdir( $BASE, $_ ) } qw{
  		my_home
  		my_desktop
  		my_documents
  		my_data
  		my_music
  		my_pictures
  		my_videos
  	};
  
  	# Hijack HOME to the home directory
  	$ENV{HOME} = $DIR{my_home};
  
  	# Make File::HomeDir load us instead of the native driver
  	$File::HomeDir::IMPLEMENTED_BY = # Prevent a warning
  	$File::HomeDir::IMPLEMENTED_BY = 'File::HomeDir::Test';
  
  	# Ready to go
  	$ENABLED = 1;
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	mkdir($DIR{my_home}, 0755) unless -d $DIR{my_home};
  	return $DIR{my_home};
  }
  
  sub my_desktop {
  	mkdir($DIR{my_desktop}, 0755) unless -d $DIR{my_desktop};
  	return $DIR{my_desktop};
  }
  
  sub my_documents {
  	mkdir($DIR{my_documents}, 0755) unless -f $DIR{my_documents};
  	return $DIR{my_documents};
  }
  
  sub my_data {
  	mkdir($DIR{my_data}, 0755) unless -d $DIR{my_data};
  	return $DIR{my_data};
  }
  
  sub my_music {
  	mkdir($DIR{my_music}, 0755) unless -d $DIR{my_music};
  	return $DIR{my_music};
  }
  
  sub my_pictures {
  	mkdir($DIR{my_pictures}, 0755) unless -d $DIR{my_pictures};
  	return $DIR{my_pictures};
  }
  
  sub my_videos {
  	mkdir($DIR{my_videos}, 0755) unless -d $DIR{my_videos};
  	return $DIR{my_videos};
  }
  
  sub users_home {
  	return undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Test - Prevent the accidental creation of user-owned files during testing
  
  =head1 SYNOPSIS
  
    use Test::More test => 1;
    use File::HomeDir::Test;
    use File::HomeDir;
  
  =head1 DESCRIPTION
  
  B<File::HomeDir::Test> is a L<File::HomeDir> driver intended for use in the test scripts
  of modules or applications that write files into user-owned directories.
  
  It is designed to prevent the pollution of user directories with files that are not part
  of the application install itself, but were created during testing. These files can leak
  state information from the tests into the run-time usage of an application, and on Unix
  systems also prevents tests (which may be executed as root via sudo) from writing files
  which cannot later be modified or removed by the regular user.
  
  =head1 SUPPORT
  
  See the support section of the main L<File::HomeDir> documentation.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  	my $home  = $class->_my_home(@_);
  
  	# On Unix in general, a non-existant home means "no home"
  	# For example, "nobody"-like users might use /nonexistant
  	if ( defined $home and ! -d $home ) {
  		$home = undef;
  	}
  
  	return $home;
  }
  
  sub _my_home {
  	my $class = shift;
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# This is from the original code, but I'm guessing
  	# it means "login directory" and exists on some Unixes.
  	if ( exists $ENV{LOGDIR} and $ENV{LOGDIR} ) {
  		return $ENV{LOGDIR};
  	}
  
  	### More-desperate methods
  
  	# Light desperation on any (Unixish) platform
  	SCOPE: {
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  # On unix by default, everything is under the same folder
  sub my_desktop {
  	shift->my_home;
  }
  
  sub my_documents {
  	shift->my_home;
  }
  
  sub my_data {
  	shift->my_home;
  }
  
  sub my_music {
  	shift->my_home;
  }
  
  sub my_pictures {
  	shift->my_home;
  }
  
  sub my_videos {
  	shift->my_home;
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	# IF and only if we have getpwuid support, and the
  	# name of the user is our own, shortcut to my_home.
  	# This is needed to handle HOME environment settings.
  	if ( $name eq getpwuid($<) ) {
  		return $class->my_home;
  	}
  
  	SCOPE: {
  		my $home = (getpwnam($name))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  sub users_desktop {
  	shift->users_home(@_);
  }
  
  sub users_documents {
  	shift->users_home(@_);
  }
  
  sub users_data {
  	shift->users_home(@_);
  }
  
  sub users_music {
  	shift->users_home(@_);
  }
  
  sub users_pictures {
  	shift->users_home(@_);
  }
  
  sub users_videos {
  	shift->users_home(@_);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Unix - Find your home and other directories on legacy Unix
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;     # All of these will... 
    $docs    = File::HomeDir->my_documents;   # ...default to home...
    $music   = File::HomeDir->my_music;       # ...directory
    $pics    = File::HomeDir->my_pictures;    #
    $videos  = File::HomeDir->my_videos;      #
    $data    = File::HomeDir->my_data;        # 
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  sub CREATE () { 1 }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# Do we have a user profile?
  	if ( exists $ENV{USERPROFILE} and $ENV{USERPROFILE} ) {
  		return $ENV{USERPROFILE};
  	}
  
  	# Some Windows use something like $ENV{HOME}
  	if ( exists $ENV{HOMEDRIVE} and exists $ENV{HOMEPATH} and $ENV{HOMEDRIVE} and $ENV{HOMEPATH} ) {
  		return File::Spec->catpath(
  			$ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '',
  		);
  	}
  
  	return undef;
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# The most correct way to find the desktop
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_DESKTOP(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	# MSWindows sets WINDIR, MS WinNT sets USERPROFILE.
  	foreach my $e ( 'USERPROFILE', 'WINDIR' ) {
  		next unless $ENV{$e};
  		my $desktop = File::Spec->catdir($ENV{$e}, 'Desktop');
  		return $desktop if $desktop and $class->_d($desktop);
  	}
  
  	# As a last resort, try some hard-wired values
  	foreach my $fixed (
  		# The reason there are both types of slash here is because
  		# this set of paths has been kept from thethe original version
  		# of File::HomeDir::Win32 (before it was rewritten).
  		# I can only assume this is Cygwin-related stuff.
  		"C:\\windows\\desktop",
  		"C:\\win95\\desktop",
  		"C:/win95/desktop",
  		"C:/windows/desktop",
  	) {
  		return $fixed if $class->_d($fixed);
  	}
  
  	return undef;
  }
  
  sub my_documents {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_PERSONAL(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_data {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_music {
  	my $class = shift;
  
  	# The most correct way to find my music
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	# The most correct way to find my pictures
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_videos {
  	my $class = shift;
  
  	# The most correct way to find my videos
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  # Special case version of -d
  sub _d {
  	my $self = shift;
  	my $path = shift;
  
  	# Window can legally return a UNC path from GetFolderPath.
  	# Not only is the meaning of -d complicated in this situation,
  	# but even on a local network calling -d "\\\\cifs\\path" can
  	# take several seconds. UNC can also do even weirder things,
  	# like launching processes and such.
  	# To avoid various crazy bugs caused by this, we do NOT attempt
  	# to validate UNC paths at all so that the code that is calling
  	# us has an opportunity to take special actions without our 
  	# blundering getting in the way.
  	if ( $path =~ /\\\\/ ) {
  		return 1;
  	}
  
  	# Otherwise do a stat as normal
  	return -d $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Windows - Find your home and other directories on Windows
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user (eg. using Windows XP Professional)
    $home    = File::HomeDir->my_home;        # C:\Documents and Settings\mylogin
    $desktop = File::HomeDir->my_desktop;     # C:\Documents and Settings\mylogin\Desktop
    $docs    = File::HomeDir->my_documents;   # C:\Documents and Settings\mylogin\My Documents
    $music   = File::HomeDir->my_music;       # C:\Documents and Settings\mylogin\My Documents\My Music
    $pics    = File::HomeDir->my_pictures;    # C:\Documents and Settings\mylogin\My Documents\My Pictures
    $videos  = File::HomeDir->my_videos;      # C:\Documents and Settings\mylogin\My Documents\My Video
    $data    = File::HomeDir->my_data;        # C:\Documents and Settings\mylogin\Local Settings\Application Data
  
  =head1 DESCRIPTION
  
  This module provides Windows-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Internally this module will use L<Win32>::GetFolderPath to fetch the location
  of your directories. As a result of this, in certain unusual situations
  (usually found inside large organisations) the methods may return UNC paths
  such as C<\\cifs.local\home$>.
  
  If your application runs on Windows and you want to have it work comprehensively
  everywhere, you may need to implement your own handling for these paths as they
  can cause strange behaviour.
  
  For example, stat calls to UNC paths may work but block for several seconds, but
  opendir() may not be able to read any files (creating the appearance of an existing
  but empty directory).
  
  To avoid complicating the problem any further, in the rare situation that a UNC path
  is returned by C<GetFolderPath> the usual -d validation checks will B<not> be done.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_WINDOWS

$fatpacked{"IO/Socket/SSL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL';
  #vim: set sts=4 sw=4 ts=8 ai:
  #
  # IO::Socket::SSL:
  # provide an interface to SSL connections similar to IO::Socket modules
  #
  # Current Code Shepherd: Steffen Ullrich <sullr at cpan.org>
  # Code Shepherd before: Peter Behroozi, <behrooz at fas.harvard.edu>
  #
  # The original version of this module was written by
  # Marko Asplund, <marko.asplund at kronodoc.fi>, who drew from
  # Crypt::SSLeay (Net::SSL) by Gisle Aas.
  #
  
  package IO::Socket::SSL;
  
  our $VERSION = '2.027';
  
  use IO::Socket;
  use Net::SSLeay 1.46;
  use IO::Socket::SSL::PublicSuffix;
  use Exporter ();
  use Errno qw( EWOULDBLOCK EAGAIN ETIMEDOUT EINTR );
  use Carp;
  use strict;
  
  BEGIN {
      eval { require Scalar::Util; Scalar::Util->import("weaken"); 1 }
  	|| eval { require WeakRef; WeakRef->import("weaken"); 1 }
  	|| die "no support for weaken - please install Scalar::Util";
  }
  
  
  
  use constant SSL_VERIFY_NONE => Net::SSLeay::VERIFY_NONE();
  use constant SSL_VERIFY_PEER => Net::SSLeay::VERIFY_PEER();
  use constant SSL_VERIFY_FAIL_IF_NO_PEER_CERT => Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT();
  use constant SSL_VERIFY_CLIENT_ONCE => Net::SSLeay::VERIFY_CLIENT_ONCE();
  
  # from openssl/ssl.h; should be better in Net::SSLeay
  use constant SSL_SENT_SHUTDOWN => 1;
  use constant SSL_RECEIVED_SHUTDOWN => 2;
  
  use constant SSL_OCSP_NO_STAPLE   => 0b00001;
  use constant SSL_OCSP_MUST_STAPLE => 0b00010;
  use constant SSL_OCSP_FAIL_HARD   => 0b00100;
  use constant SSL_OCSP_FULL_CHAIN  => 0b01000;
  use constant SSL_OCSP_TRY_STAPLE  => 0b10000;
  
  # capabilities of underlying Net::SSLeay/openssl
  my $can_client_sni;  # do we support SNI on the client side
  my $can_server_sni;  # do we support SNI on the server side
  my $can_npn;         # do we support NPN (obsolete)
  my $can_alpn;        # do we support ALPN
  my $can_ecdh;        # do we support ECDH key exchange
  my $can_ocsp;        # do we support OCSP
  my $can_ocsp_staple; # do we support OCSP stapling
  BEGIN {
      $can_client_sni = Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000;
      $can_server_sni = defined &Net::SSLeay::get_servername;
      $can_npn        = defined &Net::SSLeay::P_next_proto_negotiated;
      $can_alpn       = defined &Net::SSLeay::CTX_set_alpn_protos;
      $can_ecdh       = defined &Net::SSLeay::CTX_set_tmp_ecdh &&
  	# There is a regression with elliptic curves on 1.0.1d with 64bit
  	# http://rt.openssl.org/Ticket/Display.html?id=2975
  	( Net::SSLeay::OPENSSL_VERSION_NUMBER() != 0x1000104f
  	|| length(pack("P",0)) == 4 );
      $can_ocsp        = defined &Net::SSLeay::OCSP_cert2ids;
      $can_ocsp_staple = $can_ocsp
  	&& defined &Net::SSLeay::set_tlsext_status_type;
  }
  
  my $algo2digest = do {
      my %digest;
      sub {
  	my $digest_name = shift;
  	return $digest{$digest_name} ||= do {
  	    Net::SSLeay::SSLeay_add_ssl_algorithms();
  	    Net::SSLeay::EVP_get_digestbyname($digest_name)
  		or die "Digest algorithm $digest_name is not available";
  	};
      }
  };
  
  
  # global defaults
  my %DEFAULT_SSL_ARGS = (
      SSL_check_crl => 0,
      SSL_version => 'SSLv23:!SSLv3:!SSLv2', # consider both SSL3.0 and SSL2.0 as broken
      SSL_verify_callback => undef,
      SSL_verifycn_scheme => undef,  # fallback cn verification
      SSL_verifycn_publicsuffix => undef,  # fallback default list verification
      #SSL_verifycn_name => undef,   # use from PeerAddr/PeerHost - do not override in set_args_filter_hack 'use_defaults'
      SSL_npn_protocols => undef,    # meaning depends whether on server or client side
      SSL_alpn_protocols => undef,   # list of protocols we'll accept/send, for example ['http/1.1','spdy/3.1']
  
      # https://wiki.mozilla.org/Security/Server_Side_TLS, 2016/04/20
      # "Old backward compatibility" for best compatibility
      # .. "Most ciphers that are not clearly broken and dangerous to use are supported"
      SSL_cipher_list => 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP',
  );
  
  my %DEFAULT_SSL_CLIENT_ARGS = (
      %DEFAULT_SSL_ARGS,
      SSL_verify_mode => SSL_VERIFY_PEER,
  
      SSL_ca_file => undef,
      SSL_ca_path => undef,
  
      # older versions of F5 BIG-IP hang when getting SSL client hello >255 bytes
      # http://support.f5.com/kb/en-us/solutions/public/13000/000/sol13037.html
      # http://guest:guest@rt.openssl.org/Ticket/Display.html?id=2771
      # Ubuntu worked around this by disabling TLSv1_2 on the client side for
      # a while. Later a padding extension was added to OpenSSL to work around
      # broken F5 but then IronPort croaked because it did not understand this
      # extension so it was disabled again :(
      # Firefox, Chrome and IE11 use TLSv1_2 but use only a few ciphers, so
      # that packet stays small enough. We try the same here.
  
      SSL_cipher_list => join(" ",
  
  	# SSLabs report for Chrome 48/OSX. 
  	# This also includes the fewer ciphers Firefox uses.
  	'ECDHE-ECDSA-AES128-GCM-SHA256',
  	'ECDHE-RSA-AES128-GCM-SHA256',
  	'DHE-RSA-AES128-GCM-SHA256',
  	'ECDHE-ECDSA-CHACHA20-POLY1305',
  	'ECDHE-RSA-CHACHA20-POLY1305',
  	'ECDHE-ECDSA-AES256-SHA',
  	'ECDHE-RSA-AES256-SHA',
  	'DHE-RSA-AES256-SHA',
  	'ECDHE-ECDSA-AES128-SHA',
  	'ECDHE-RSA-AES128-SHA',
  	'DHE-RSA-AES128-SHA',
  	'AES128-GCM-SHA256',
  	'AES256-SHA',
  	'AES128-SHA',
  	'DES-CBC3-SHA',
  
  	# IE11/Edge has some more ciphers, notably SHA384 and DSS
  	# we don't offer the *-AES128-SHA256 and *-AES256-SHA384 non-GCM
  	# ciphers IE/Edge offers because they look like a large mismatch
  	# between a very strong HMAC and a comparably weak (but sufficient)
  	# encryption. Similar all browsers which do SHA384 can do ECDHE
  	# so skip the DHE*SHA384 ciphers.
  	'ECDHE-RSA-AES256-GCM-SHA384',
  	'ECDHE-ECDSA-AES256-GCM-SHA384',
  	# 'ECDHE-RSA-AES256-SHA384',
  	# 'ECDHE-ECDSA-AES256-SHA384',
  	# 'ECDHE-RSA-AES128-SHA256',
  	# 'ECDHE-ECDSA-AES128-SHA256',
  	# 'DHE-RSA-AES256-GCM-SHA384',
  	# 'AES256-GCM-SHA384',
  	'AES256-SHA256',
  	# 'AES128-SHA256',
  	'DHE-DSS-AES256-SHA256',
  	# 'DHE-DSS-AES128-SHA256',
  	'DHE-DSS-AES256-SHA',
  	'DHE-DSS-AES128-SHA',
  	'EDH-DSS-DES-CBC3-SHA',
  
  	# Just to make sure, that we don't accidentally add bad ciphers above.
  	# This includes dropping RC4 which is no longer supported by modern
  	# browsers and also excluded in the SSL libraries of Python and Ruby.
  	"!EXP !MEDIUM !LOW !eNULL !aNULL !RC4 !DES !MD5 !PSK !SRP"
      )
  );
  
  # set values inside _init to work with perlcc, RT#95452
  my %DEFAULT_SSL_SERVER_ARGS;
  
  # Initialization of OpenSSL internals
  # This will be called once during compilation - perlcc users might need to
  # call it again by hand, see RT#95452
  {
      sub init {
  	# library_init returns false if the library was already initialized.
  	# This way we can find out if the library needs to be re-initialized
  	# inside code compiled with perlcc
  	Net::SSLeay::library_init() or return; 
  
  	Net::SSLeay::load_error_strings();
  	Net::SSLeay::OpenSSL_add_all_digests();
  	Net::SSLeay::randomize();
  
  	%DEFAULT_SSL_SERVER_ARGS = (
  	    %DEFAULT_SSL_ARGS,
  	    SSL_verify_mode => SSL_VERIFY_NONE,
  	    SSL_honor_cipher_order => 1,  # trust server to know the best cipher
  	    SSL_dh => do {
  		my $bio = Net::SSLeay::BIO_new(Net::SSLeay::BIO_s_mem());
  		# generated with: openssl dhparam 2048
  		Net::SSLeay::BIO_write($bio,<<'DH');
  -----BEGIN DH PARAMETERS-----
  MIIBCAKCAQEAr8wskArj5+1VCVsnWt/RUR7tXkHJ7mGW7XxrLSPOaFyKyWf8lZht
  iSY2Lc4oa4Zw8wibGQ3faeQu/s8fvPq/aqTxYmyHPKCMoze77QJHtrYtJAosB9SY
  CN7s5Hexxb5/vQ4qlQuOkVrZDiZO9GC4KaH9mJYnCoAsXDhDft6JT0oRVSgtZQnU
  gWFKShIm+JVjN94kGs0TcBEesPTK2g8XVHK9H8AtSUb9BwW2qD/T5RmgNABysApO
  Ps2vlkxjAHjJcqc3O+OiImKik/X2rtBTZjpKmzN3WWTB0RJZCOWaLlDO81D01o1E
  aZecz3Np9KIYey900f+X7zC2bJxEHp95ywIBAg==
  -----END DH PARAMETERS-----
  DH
  		my $dh = Net::SSLeay::PEM_read_bio_DHparams($bio);
  		Net::SSLeay::BIO_free($bio);
  		$dh or die "no DH";
  		$dh;
  	    },
  	    $can_ecdh ? ( SSL_ecdh_curve => 'prime256v1' ):(),
  	);
      }
      # Call it once at compile time and try it at INIT.
      # This should catch all cases of including the module, e.g 'use' (INIT) or
      # 'require' (compile time) and works also with perlcc
      {
  	no warnings;
  	INIT { init() }
  	init();
      }
  }
  
  # global defaults which can be changed using set_defaults
  # either key/value can be set or it can just be set to an external hash
  my $GLOBAL_SSL_ARGS = {};
  my $GLOBAL_SSL_CLIENT_ARGS = {};
  my $GLOBAL_SSL_SERVER_ARGS = {};
  
  # hack which is used to filter bad settings from used modules
  my $FILTER_SSL_ARGS = undef;
  
  # non-XS Versions of Scalar::Util will fail
  BEGIN{
      local $SIG{__DIE__}; local $SIG{__WARN__}; # be silent
      eval { use Scalar::Util 'dualvar'; dualvar(0,'') };
      die "You need the XS Version of Scalar::Util for dualvar() support"
  	if $@;
  }
  
  # get constants for SSL_OP_NO_* now, instead calling the related functions
  # every time we setup a connection
  my %SSL_OP_NO;
  for(qw( SSLv2 SSLv3 TLSv1 TLSv1_1 TLSv11:TLSv1_1 TLSv1_2 TLSv12:TLSv1_2 )) {
      my ($k,$op) = m{:} ? split(m{:},$_,2) : ($_,$_);
      my $sub = "Net::SSLeay::OP_NO_$op";
      $SSL_OP_NO{$k} = eval { no strict 'refs'; &$sub } || 0;
  }
  
  # Make SSL_CTX_clear_options accessible through SSL_CTX_ctrl unless it is
  # already implemented in Net::SSLeay
  if (!defined &Net::SSLeay::CTX_clear_options) {
      *Net::SSLeay::CTX_clear_options = sub {
  	my ($ctx,$opt) = @_;
  	# 77 = SSL_CTRL_CLEAR_OPTIONS
  	Net::SSLeay::CTX_ctrl($ctx,77,$opt,0);
      };
  }
  
  # Try to work around problems with alternative trust path by default, RT#104759
  my $DEFAULT_X509_STORE_flags = 0;
  eval { $DEFAULT_X509_STORE_flags |= Net::SSLeay::X509_V_FLAG_TRUSTED_FIRST() };
  
  our $DEBUG;
  use vars qw(@ISA $SSL_ERROR @EXPORT);
  
  {
      # These constants will be used in $! at return from SSL_connect,
      # SSL_accept, _generic_(read|write), thus notifying the caller
      # the usual way of problems. Like with EWOULDBLOCK, EINPROGRESS..
      # these are especially important for non-blocking sockets
  
      my $x = Net::SSLeay::ERROR_WANT_READ();
      use constant SSL_WANT_READ  => dualvar( \$x, 'SSL wants a read first' );
      my $y = Net::SSLeay::ERROR_WANT_WRITE();
      use constant SSL_WANT_WRITE => dualvar( \$y, 'SSL wants a write first' );
  
      @EXPORT = qw(
  	SSL_WANT_READ SSL_WANT_WRITE SSL_VERIFY_NONE SSL_VERIFY_PEER
  	SSL_VERIFY_FAIL_IF_NO_PEER_CERT SSL_VERIFY_CLIENT_ONCE
  	SSL_OCSP_NO_STAPLE SSL_OCSP_TRY_STAPLE SSL_OCSP_MUST_STAPLE
  	SSL_OCSP_FAIL_HARD SSL_OCSP_FULL_CHAIN
  	$SSL_ERROR GEN_DNS GEN_IPADD
      );
  }
  
  my @caller_force_inet4; # in case inet4 gets forced we store here who forced it
  
  my $IOCLASS;
  my $family_key; # 'Domain'||'Family'
  BEGIN {
      # declare @ISA depending of the installed socket class
  
      # try to load inet_pton from Socket or Socket6 and make sure it is usable
      local $SIG{__DIE__}; local $SIG{__WARN__}; # be silent
      my $ip6 = eval {
  	require Socket;
  	Socket->VERSION(1.95);
  	my $ok = Socket::inet_pton( AF_INET6(),'::1') && AF_INET6();
  	$ok && Socket->import( qw/inet_pton NI_NUMERICHOST NI_NUMERICSERV/ );
  	# behavior different to Socket6::getnameinfo - wrap
  	*_getnameinfo = sub { 
  	    my ($err,$host,$port) = Socket::getnameinfo(@_) or return; 
  	    return if $err;
  	    return ($host,$port);
  	};
  	$ok;
      } || eval {
  	require Socket6;
  	my $ok = Socket6::inet_pton( AF_INET6(),'::1') && AF_INET6();
  	$ok && Socket6->import( qw/inet_pton NI_NUMERICHOST NI_NUMERICSERV/ );
  	# behavior different to Socket::getnameinfo - wrap
  	*_getnameinfo = sub { return Socket6::getnameinfo(@_); };
  	$ok;
      };
  
      # try IO::Socket::IP or IO::Socket::INET6 for IPv6 support
      $family_key = 'Domain'; # traditional
      if ( $ip6 ) {
  	# if we have IO::Socket::IP >= 0.31 we will use this in preference
  	# because it can handle both IPv4 and IPv6
  	if ( eval { 
  	    require IO::Socket::IP; 
  	    IO::Socket::IP->VERSION(0.31)
  	}) {
  	    @ISA = qw(IO::Socket::IP);
  	    constant->import( CAN_IPV6 => "IO::Socket::IP" );
  	    $family_key = 'Family';
  	    $IOCLASS = "IO::Socket::IP";
  
  	# if we have IO::Socket::INET6 we will use this not IO::Socket::INET
  	# because it can handle both IPv4 and IPv6
  	# require at least 2.62 because of several problems before that version
  	} elsif( eval { require IO::Socket::INET6; IO::Socket::INET6->VERSION(2.62) } ) {
  	    @ISA = qw(IO::Socket::INET6);
  	    constant->import( CAN_IPV6 => "IO::Socket::INET6" );
  	    $IOCLASS = "IO::Socket::INET6";
  	} else {
  	    $ip6 = 0;
  	}
      }
  
      # fall back to IO::Socket::INET for IPv4 only
      if ( ! $ip6 ) {
  	@ISA = qw(IO::Socket::INET);
  	$IOCLASS = "IO::Socket::INET";
  	constant->import( CAN_IPV6 => '' );
      }
  
      #Make $DEBUG another name for $Net::SSLeay::trace
      *DEBUG = \$Net::SSLeay::trace;
  
      #Compatibility
      *ERROR = \$SSL_ERROR;
  }
  
  
  sub DEBUG {
      $DEBUG or return;
      my (undef,$file,$line,$sub) = caller(1);
      if ($sub =~m{^IO::Socket::SSL::(?:error|(_internal_error))$}) {
  	(undef,$file,$line) = caller(2) if $1;
      } else {
  	(undef,$file,$line) = caller;
      }
      my $msg = shift;
      $file = '...'.substr( $file,-17 ) if length($file)>20;
      $msg = sprintf $msg,@_ if @_;
      print STDERR "DEBUG: $file:$line: $msg\n";
  }
  
  BEGIN {
      # import some constants from Net::SSLeay or use hard-coded defaults
      # if Net::SSLeay isn't recent enough to provide the constants
      my %const = (
  	NID_CommonName => 13,
  	GEN_DNS => 2,
  	GEN_IPADD => 7,
      );
      while ( my ($name,$value) = each %const ) {
  	no strict 'refs';
  	*{$name} = UNIVERSAL::can( 'Net::SSLeay', $name ) || sub { $value };
      }
  
      *idn_to_ascii = \&IO::Socket::SSL::PublicSuffix::idn_to_ascii;
      *idn_to_unicode = \&IO::Socket::SSL::PublicSuffix::idn_to_unicode;
  }
  
  my $OPENSSL_LIST_SEPARATOR = $^O =~m{^(?:(dos|os2|mswin32|netware)|vms)$}i
      ? $1 ? ';' : ',' : ':';
  my $CHECK_SSL_PATH = sub {
      my %args = (@_ == 1) ? ('',@_) : @_;
      for my $type (keys %args) {
  	my $path = $args{$type};
  	if (!$type) {
  	    delete $args{$type};
  	    $type = (ref($path) || -d $path) ? 'SSL_ca_path' : 'SSL_ca_file';
  	    $args{$type} = $path;
  	}
  
  	next if ref($path) eq 'SCALAR' && ! $$path;
  	if ($type eq 'SSL_ca_file') {
  	    die "SSL_ca_file $path does not exist" if ! -f $path;
  	    die "SSL_ca_file $path is not accessible: $!"
  		if ! open(my $fh,'<',$path);
  	} elsif ($type eq 'SSL_ca_path') {
  	    $path = [ split($OPENSSL_LIST_SEPARATOR,$path) ] if !ref($path);
  	    my @err;
  	    for my $d (ref($path) ? @$path : $path) {
  		if (! -d $d) {
  		    push @err, "SSL_ca_path $d does not exist";
  		} elsif (! opendir(my $dh,$d)) {
  		    push @err, "SSL_ca_path $d is not accessible: $!"
  		} else {
  		    @err = ();
  		    last
  		}
  	    }
  	    die "@err" if @err;
  	}
      }
      return %args;
  };
  
  
  {
      my %default_ca;
      my $ca_detected; # 0: never detect, undef: need to (re)detect
      my $openssldir;
  
      sub default_ca {
  	if (@_) {
  	    # user defined default CA or reset
  	    if ( @_ > 1 ) {
  		%default_ca = @_;
  		$ca_detected  = 0;
  	    } elsif ( my $path = shift ) {
  		%default_ca = $CHECK_SSL_PATH->($path);
  		$ca_detected  = 0;
  	    } else {
  		$ca_detected = undef;
  	    }
  	}
  	return %default_ca if defined $ca_detected;
  
  	$openssldir ||= Net::SSLeay::SSLeay_version(5)
  	    =~m{^OPENSSLDIR: "(.+)"$} && $1 || '';
  
  	# (re)detect according to openssl crypto/cryptlib.h
  	my $dir = $ENV{SSL_CERT_DIR}
  	    || ( $^O =~m{vms}i ? "SSLCERTS:":"$openssldir/certs" );
  	if ( opendir(my $dh,$dir)) {
  	    FILES: for my $f (  grep { m{^[a-f\d]{8}(\.\d+)?$} } readdir($dh) ) {
  		open( my $fh,'<',"$dir/$f") or next;
  		while (my $line = <$fh>) {
  		    $line =~m{^-+BEGIN (X509 |TRUSTED |)CERTIFICATE-} or next;
  		    $default_ca{SSL_ca_path} = $dir;
  		    last FILES;
  		}
  	    }
  	}
  	my $file = $ENV{SSL_CERT_FILE}
  	    || ( $^O =~m{vms}i ? "SSLCERTS:cert.pem":"$openssldir/cert.pem" );
  	if ( open(my $fh,'<',$file)) {
  	    while (my $line = <$fh>) {
  		$line =~m{^-+BEGIN (X509 |TRUSTED |)CERTIFICATE-} or next;
  		$default_ca{SSL_ca_file} = $file;
  		last;
  	    }
  	}
  
  	$default_ca{SSL_ca_file} = Mozilla::CA::SSL_ca_file()
  	    if ! %default_ca && eval { require Mozilla::CA };
  
  	$ca_detected = 1;
  	return %default_ca;
      }
  }
  
  
  # Export some stuff
  # inet4|inet6|debug will be handled by myself, everything
  # else will be handled the Exporter way
  sub import {
      my $class = shift;
  
      my @export;
      foreach (@_) {
  	if ( /^inet4$/i ) {
  	    # explicitly fall back to inet4
  	    @ISA = 'IO::Socket::INET';
  	    @caller_force_inet4 = caller(); # save for warnings for 'inet6' case
  	} elsif ( /^inet6$/i ) {
  	    # check if we have already ipv6 as base
  	    if ( ! UNIVERSAL::isa( $class, 'IO::Socket::INET6')
  		and ! UNIVERSAL::isa( $class, 'IO::Socket::IP' )) {
  		# either we don't support it or we disabled it by explicitly
  		# loading it with 'inet4'. In this case re-enable but warn
  		# because this is probably an error
  		if ( CAN_IPV6 ) {
  		    @ISA = ( CAN_IPV6 );
  		    warn "IPv6 support re-enabled in __PACKAGE__, got disabled in file $caller_force_inet4[1] line $caller_force_inet4[2]";
  		} else {
  		    die "INET6 is not supported, install IO::Socket::IP";
  		}
  	    }
  	} elsif ( /^:?debug(\d+)/ ) {
  	    $DEBUG=$1;
  	} else {
  	    push @export,$_
  	}
      }
  
      @_ = ( $class,@export );
      goto &Exporter::import;
  }
  
  my %SSL_OBJECT;
  my %CREATED_IN_THIS_THREAD;
  sub CLONE { %CREATED_IN_THIS_THREAD = (); }
  
  
  # we have callbacks associated with contexts, but have no way to access the
  # current SSL object from these callbacks. To work around this
  # CURRENT_SSL_OBJECT will be set before calling Net::SSLeay::{connect,accept}
  # and reset afterwards, so we have access to it inside _internal_error.
  my $CURRENT_SSL_OBJECT;
  
  # You might be expecting to find a new() subroutine here, but that is
  # not how IO::Socket::INET works.  All configuration gets performed in
  # the calls to configure() and either connect() or accept().
  
  #Call to configure occurs when a new socket is made using
  #IO::Socket::INET.  Returns false (empty list) on failure.
  sub configure {
      my ($self, $arg_hash) = @_;
      return _invalid_object() unless($self);
  
      # force initial blocking
      # otherwise IO::Socket::SSL->new might return undef if the
      # socket is nonblocking and it fails to connect immediately
      # for real nonblocking behavior one should create a nonblocking
      # socket and later call connect explicitly
      my $blocking = delete $arg_hash->{Blocking};
  
      # because Net::HTTPS simple redefines blocking() to {} (e.g
      # return undef) and IO::Socket::INET does not like this we
      # set Blocking only explicitly if it was set
      $arg_hash->{Blocking} = 1 if defined ($blocking);
  
      $self->configure_SSL($arg_hash) || return;
  
      if ($arg_hash->{$family_key} ||= $arg_hash->{Domain} || $arg_hash->{Family}) {
  	# Hack to work around the problem that IO::Socket::IP defaults to
  	# AI_ADDRCONFIG which creates problems if we have only the loopback
  	# interface. If we already know the family this flag is more harmful
  	# then useful.
  	$arg_hash->{GetAddrInfoFlags} = 0 if $IOCLASS eq 'IO::Socket::IP'
  		&& ! defined $arg_hash->{GetAddrInfoFlags};
      }
      return $self->_internal_error("@ISA configuration failed",0)
  	if ! $self->SUPER::configure($arg_hash);
  
      $self->blocking(0) if defined $blocking && !$blocking;
      return $self;
  }
  
  sub configure_SSL {
      my ($self, $arg_hash) = @_;
  
      $arg_hash->{Proto} ||= 'tcp';
      my $is_server = $arg_hash->{SSL_server};
      if ( ! defined $is_server ) {
  	$is_server = $arg_hash->{SSL_server} = $arg_hash->{Listen} || 0;
      }
  
      # add user defined defaults, maybe after filtering
      $FILTER_SSL_ARGS->($is_server,$arg_hash) if $FILTER_SSL_ARGS;
      my %defaults = (
  	%$GLOBAL_SSL_ARGS,
  	$is_server ? %$GLOBAL_SSL_SERVER_ARGS : %$GLOBAL_SSL_CLIENT_ARGS,
      );
      if ( $defaults{SSL_reuse_ctx} ) {
  	# ignore default context if there are args to override it
  	delete $defaults{SSL_reuse_ctx}
  	    if grep { m{^SSL_(?!verifycn_name|hostname)$} } keys %$arg_hash;
      }
      %$arg_hash = ( %defaults, %$arg_hash ) if %defaults;
  
      my $ctx = $arg_hash->{'SSL_reuse_ctx'};
      if ($ctx) {
  	if ($ctx->isa('IO::Socket::SSL::SSL_Context') and
  	    $ctx->{context}) {
  	    # valid context
  	} elsif ( $ctx = ${*$ctx}{_SSL_ctx} ) {
  	    # reuse context from existing SSL object
  	}
      }
  
      # create context
      # this will fill in defaults in $arg_hash
      $ctx ||= IO::Socket::SSL::SSL_Context->new($arg_hash) || return;
  
      ${*$self}{'_SSL_arguments'} = $arg_hash;
      ${*$self}{'_SSL_ctx'} = $ctx;
      ${*$self}{'_SSL_opened'} = 1 if $is_server;
  
      return $self;
  }
  
  
  sub _skip_rw_error {
      my ($self,$ssl,$rv) = @_;
      my $err = Net::SSLeay::get_error($ssl,$rv);
      if ( $err == Net::SSLeay::ERROR_WANT_READ()) {
  	$SSL_ERROR = SSL_WANT_READ;
      } elsif ( $err == Net::SSLeay::ERROR_WANT_WRITE()) {
  	$SSL_ERROR = SSL_WANT_WRITE;
      } else {
  	return $err;
      }
      $! ||= EWOULDBLOCK;
      ${*$self}{_SSL_last_err} = [$SSL_ERROR,4] if ref($self);
      Net::SSLeay::ERR_clear_error();
      return 0;
  }
  
  
  # Call to connect occurs when a new client socket is made using IO::Socket::*
  sub connect {
      my $self = shift || return _invalid_object();
      return $self if ${*$self}{'_SSL_opened'};  # already connected
  
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	# call SUPER::connect if the underlying socket is not connected
  	# if this fails this might not be an error (e.g. if $! = EINPROGRESS
  	# and socket is nonblocking this is normal), so keep any error
  	# handling to the client
  	$DEBUG>=2 && DEBUG('socket not yet connected' );
  	$self->SUPER::connect(@_) || return;
  	$DEBUG>=2 && DEBUG('socket connected' );
  
  	# IO::Socket works around systems, which return EISCONN or similar
  	# on non-blocking re-connect by returning true, even if $! is set
  	# but it does not clear $!, so do it here
  	$! = undef;
  
  	# don't continue with connect_SSL if SSL_startHandshake is set to 0
  	my $sh = ${*$self}{_SSL_arguments}{SSL_startHandshake};
  	return $self if defined $sh && ! $sh;
      }
      return $self->connect_SSL;
  }
  
  
  sub connect_SSL {
      my $self = shift;
      my $args = @_>1 ? {@_}: $_[0]||{};
  
      my ($ssl,$ctx);
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	# start ssl connection
  	$DEBUG>=2 && DEBUG('ssl handshake not started' );
  	${*$self}{'_SSL_opening'} = 1;
  	my $arg_hash = ${*$self}{'_SSL_arguments'};
  
  	my $fileno = ${*$self}{'_SSL_fileno'} = fileno($self);
  	return $self->_internal_error("Socket has no fileno",9)
  	    if ! defined $fileno;
  
  	$ctx = ${*$self}{'_SSL_ctx'};  # Reference to real context
  	$ssl = ${*$self}{'_SSL_object'} = Net::SSLeay::new($ctx->{context})
  	    || return $self->error("SSL structure creation failed");
  	$CREATED_IN_THIS_THREAD{$ssl} = 1;
  	$SSL_OBJECT{$ssl} = [$self,0];
  	weaken($SSL_OBJECT{$ssl}[0]);
  
  	Net::SSLeay::set_fd($ssl, $fileno)
  	    || return $self->error("SSL filehandle association failed");
  
  	if ( $can_client_sni ) {
  	    my $host;
  	    if ( exists $arg_hash->{SSL_hostname} ) {
  		# explicitly given
  		# can be set to undef/'' to not use extension
  		$host = $arg_hash->{SSL_hostname}
  	    } elsif ( $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost} ) {
  		# implicitly given
  		$host =~s{:[a-zA-Z0-9_\-]+$}{};
  		# should be hostname, not IPv4/6
  		$host = undef if $host !~m{[a-z_]} or $host =~m{:};
  	    }
  	    # define SSL_CTRL_SET_TLSEXT_HOSTNAME 55
  	    # define TLSEXT_NAMETYPE_host_name 0
  	    if ($host) {
  		$DEBUG>=2 && DEBUG("using SNI with hostname $host");
  		Net::SSLeay::ctrl($ssl,55,0,$host);
  	    } else {
  		$DEBUG>=2 && DEBUG("not using SNI because hostname is unknown");
  	    }
  	} elsif ( $arg_hash->{SSL_hostname} ) {
  	    return $self->_internal_error(
  		"Client side SNI not supported for this openssl",9);
  	} else {
  	    $DEBUG>=2 && DEBUG("not using SNI because openssl is too old");
  	}
  
  	$arg_hash->{PeerAddr} || $arg_hash->{PeerHost} || $self->_update_peer;
  	if ( $ctx->{verify_name_ref} ) {
  	    # need target name for update
  	    my $host = $arg_hash->{SSL_verifycn_name}
  		|| $arg_hash->{SSL_hostname};
  	    if ( ! defined $host ) {
  		if ( $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost} ) {
  		    $host =~s{:[a-zA-Z0-9_\-]+$}{};
  		}
  	    }
  	    ${$ctx->{verify_name_ref}} = $host;
  	}
  
  	my $ocsp = $ctx->{ocsp_mode};
  	if ( $ocsp & SSL_OCSP_NO_STAPLE ) {
  	    # don't try stapling
  	} elsif ( ! $can_ocsp_staple ) {
  	    croak("OCSP stapling not support") if $ocsp & SSL_OCSP_MUST_STAPLE;
  	} elsif ( $ocsp & (SSL_OCSP_TRY_STAPLE|SSL_OCSP_MUST_STAPLE)) {
  	    # staple by default if verification enabled
  	    ${*$self}{_SSL_ocsp_verify} = undef;
  	    Net::SSLeay::set_tlsext_status_type($ssl,
  		Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());
  	    $DEBUG>=2 && DEBUG("request OCSP stapling");
  	}
  
  	my $session = $ctx->session_cache( $arg_hash->{SSL_session_key} ?
  	    ( $arg_hash->{SSL_session_key},1 ) :
  	    ( 
  		$arg_hash->{PeerAddr} || $arg_hash->{PeerHost}, 
  		$arg_hash->{PeerPort} || $arg_hash->{PeerService}
  	    )
  	);
  	Net::SSLeay::set_session($ssl, $session) if ($session);
      }
  
      $ssl ||= ${*$self}{'_SSL_object'};
  
      $SSL_ERROR = $! = undef;
      my $timeout = exists $args->{Timeout}
  	? $args->{Timeout}
  	: ${*$self}{io_socket_timeout}; # from IO::Socket
      if ( defined($timeout) && $timeout>0 && $self->blocking(0) ) {
  	$DEBUG>=2 && DEBUG( "set socket to non-blocking to enforce timeout=$timeout" );
  	# timeout was given and socket was blocking
  	# enforce timeout with now non-blocking socket
      } else {
  	# timeout does not apply because invalid or socket non-blocking
  	$timeout = undef;
      }
  
      my $start = defined($timeout) && time();
      {
  	$SSL_ERROR = undef;
  	$CURRENT_SSL_OBJECT = $self;
  	$DEBUG>=3 && DEBUG("call Net::SSLeay::connect" );
  	my $rv = Net::SSLeay::connect($ssl);
  	$CURRENT_SSL_OBJECT = undef;
  	$DEBUG>=3 && DEBUG("done Net::SSLeay::connect -> $rv" );
  	if ( $rv < 0 ) {
  	    if ( my $err = $self->_skip_rw_error( $ssl,$rv )) {
  		$self->error("SSL connect attempt failed");
  		delete ${*$self}{'_SSL_opening'};
  		${*$self}{'_SSL_opened'} = -1;
  		$DEBUG>=1 && DEBUG( "fatal SSL error: $SSL_ERROR" );
  		return $self->fatal_ssl_error();
  	    }
  
  	    $DEBUG>=2 && DEBUG('ssl handshake in progress' );
  	    # connect failed because handshake needs to be completed
  	    # if socket was non-blocking or no timeout was given return with this error
  	    return if ! defined($timeout);
  
  	    # wait until socket is readable or writable
  	    my $rv;
  	    if ( $timeout>0 ) {
  		my $vec = '';
  		vec($vec,$self->fileno,1) = 1;
  		$DEBUG>=2 && DEBUG( "waiting for fd to become ready: $SSL_ERROR" );
  		$rv =
  		    $SSL_ERROR == SSL_WANT_READ ? select( $vec,undef,undef,$timeout) :
  		    $SSL_ERROR == SSL_WANT_WRITE ? select( undef,$vec,undef,$timeout) :
  		    undef;
  	    } else {
  		$DEBUG>=2 && DEBUG("handshake failed because no more time" );
  		$! = ETIMEDOUT
  	    }
  	    if ( ! $rv ) {
  		$DEBUG>=2 && DEBUG("handshake failed because socket did not became ready" );
  		# failed because of timeout, return
  		$! ||= ETIMEDOUT;
  		delete ${*$self}{'_SSL_opening'};
  		${*$self}{'_SSL_opened'} = -1;
  		$self->blocking(1); # was blocking before
  		return
  	    }
  
  	    # socket is ready, try non-blocking connect again after recomputing timeout
  	    $DEBUG>=2 && DEBUG("socket ready, retrying connect" );
  	    my $now = time();
  	    $timeout -= $now - $start;
  	    $start = $now;
  	    redo;
  
  	} elsif ( $rv == 0 ) {
  	    delete ${*$self}{'_SSL_opening'};
  	    $DEBUG>=2 && DEBUG("connection failed - connect returned 0" );
  	    $self->error("SSL connect attempt failed because of handshake problems" );
  	    ${*$self}{'_SSL_opened'} = -1;
  	    return $self->fatal_ssl_error();
  	}
      }
  
      $DEBUG>=2 && DEBUG('ssl handshake done' );
      # ssl connect successful
      delete ${*$self}{'_SSL_opening'};
      ${*$self}{'_SSL_opened'}=1;
      if (defined($timeout)) {
  	$self->blocking(1); # reset back to blocking
  	$! = undef; # reset errors from non-blocking
      }
  
      $ctx ||= ${*$self}{'_SSL_ctx'};
  
      if ( my $ocsp_result = ${*$self}{_SSL_ocsp_verify} ) {
  	# got result from OCSP stapling
  	if ( $ocsp_result->[0] > 0 ) {
  	    $DEBUG>=3 && DEBUG("got OCSP success with stapling");
  	    # successful validated
  	} elsif ( $ocsp_result->[0] < 0 ) {
  	    # Permanent problem with validation because certificate
  	    # is either self-signed or the issuer cannot be found.
  	    # Ignore here, because this will cause other errors too.
  	    $DEBUG>=3 && DEBUG("got OCSP failure with stapling: %s",
  		$ocsp_result->[1]);
  	} else {
  	    # definitely revoked
  	    $DEBUG>=3 && DEBUG("got OCSP revocation with stapling: %s",
  		$ocsp_result->[1]);
  	    $self->_internal_error($ocsp_result->[1],5);
  	    return $self->fatal_ssl_error();
  	}
      } elsif ( $ctx->{ocsp_mode} & SSL_OCSP_MUST_STAPLE ) {
  	$self->_internal_error("did not receive the required stapled OCSP response",5);
  	return $self->fatal_ssl_error();
      }
  
      if ( $ctx->has_session_cache
  	and my $session = Net::SSLeay::get1_session($ssl)) {
  	my $arg_hash = ${*$self}{'_SSL_arguments'};
  	$arg_hash->{PeerAddr} || $arg_hash->{PeerHost} || $self->_update_peer;
  	$ctx->session_cache( $arg_hash->{SSL_session_key} ?
  	    ( $arg_hash->{SSL_session_key},1 ) :
  	    ( 
  		$arg_hash->{PeerAddr} || $arg_hash->{PeerHost},
  		$arg_hash->{PeerPort} || $arg_hash->{PeerService}
  	    ),
  	    $session
  	);
      }
  
      tie *{$self}, "IO::Socket::SSL::SSL_HANDLE", $self;
  
      return $self;
  }
  
  # called if PeerAddr is not set in ${*$self}{'_SSL_arguments'}
  # this can be the case if start_SSL is called with a normal IO::Socket::INET
  # so that PeerAddr|PeerPort are not set from args
  sub _update_peer {
      my $self = shift;
      my $arg_hash = ${*$self}{'_SSL_arguments'};
      eval {
  	my $sockaddr = getpeername( $self );
  	my $af = sockaddr_family($sockaddr);
  	if( CAN_IPV6 && $af == AF_INET6 ) {
  	    my (undef, $host, $port) = _getnameinfo($sockaddr,
  		NI_NUMERICHOST | NI_NUMERICSERV);
  	    $arg_hash->{PeerAddr} = $host;
  	    $arg_hash->{PeerPort} = $port;
  	} else {
  	    my ($port,$addr) = sockaddr_in( $sockaddr);
  	    $arg_hash->{PeerAddr} = inet_ntoa( $addr );
  	    $arg_hash->{PeerPort} = $port;
  	}
      }
  }
  
  #Call to accept occurs when a new client connects to a server using
  #IO::Socket::SSL
  sub accept {
      my $self = shift || return _invalid_object();
      my $class = shift || 'IO::Socket::SSL';
  
      my $socket = ${*$self}{'_SSL_opening'};
      if ( ! $socket ) {
  	# underlying socket not done
  	$DEBUG>=2 && DEBUG('no socket yet' );
  	$socket = $self->SUPER::accept($class) || return;
  	$DEBUG>=2 && DEBUG('accept created normal socket '.$socket );
  
  	# don't continue with accept_SSL if SSL_startHandshake is set to 0
  	my $sh = ${*$self}{_SSL_arguments}{SSL_startHandshake};
  	if (defined $sh && ! $sh) {
  	    ${*$socket}{_SSL_ctx} = ${*$self}{_SSL_ctx};
  	    ${*$socket}{_SSL_arguments} = {
  		%{${*$self}{_SSL_arguments}},
  		SSL_server => 0,
  	    };
  	    $DEBUG>=2 && DEBUG('will not start SSL handshake yet');
  	    return wantarray ? ($socket, getpeername($socket) ) : $socket
  	}
      }
  
      $self->accept_SSL($socket) || return;
      $DEBUG>=2 && DEBUG('accept_SSL ok' );
  
      return wantarray ? ($socket, getpeername($socket) ) : $socket;
  }
  
  sub accept_SSL {
      my $self = shift;
      my $socket = ( @_ && UNIVERSAL::isa( $_[0], 'IO::Handle' )) ? shift : $self;
      my $args = @_>1 ? {@_}: $_[0]||{};
  
      my $ssl;
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	$DEBUG>=2 && DEBUG('starting sslifying' );
  	${*$self}{'_SSL_opening'} = $socket;
  	if ($socket != $self) {
  	    ${*$socket}{_SSL_ctx} = ${*$self}{_SSL_ctx};
  	    ${*$socket}{_SSL_arguments} = {
  		%{${*$self}{_SSL_arguments}},
  		SSL_server => 0
  	    };
  	}
  
  	my $fileno = ${*$socket}{'_SSL_fileno'} = fileno($socket);
  	return $socket->_internal_error("Socket has no fileno",9)
  	    if ! defined $fileno;
  
  	$ssl = ${*$socket}{_SSL_object} =
  	    Net::SSLeay::new(${*$socket}{_SSL_ctx}{context})
  	    || return $socket->error("SSL structure creation failed");
  	$CREATED_IN_THIS_THREAD{$ssl} = 1;
  	$SSL_OBJECT{$ssl} = [$socket,1];
  	weaken($SSL_OBJECT{$ssl}[0]);
  
  	Net::SSLeay::set_fd($ssl, $fileno)
  	    || return $socket->error("SSL filehandle association failed");
      }
  
      $ssl ||= ${*$socket}{'_SSL_object'};
  
      $SSL_ERROR = $! = undef;
      #$DEBUG>=2 && DEBUG('calling ssleay::accept' );
  
      my $timeout = exists $args->{Timeout}
  	? $args->{Timeout}
  	: ${*$self}{io_socket_timeout}; # from IO::Socket
      if ( defined($timeout) && $timeout>0 && $socket->blocking(0) ) {
  	# timeout was given and socket was blocking
  	# enforce timeout with now non-blocking socket
      } else {
  	# timeout does not apply because invalid or socket non-blocking
  	$timeout = undef;
      }
  
      my $start = defined($timeout) && time();
      {
  	$SSL_ERROR = undef;
  	$CURRENT_SSL_OBJECT = $self;
  	my $rv = Net::SSLeay::accept($ssl);
  	$CURRENT_SSL_OBJECT = undef;
  	$DEBUG>=3 && DEBUG( "Net::SSLeay::accept -> $rv" );
  	if ( $rv < 0 ) {
  	    if ( my $err = $socket->_skip_rw_error( $ssl,$rv )) {
  		$socket->error("SSL accept attempt failed");
  		delete ${*$self}{'_SSL_opening'};
  		${*$socket}{'_SSL_opened'} = -1;
  		return $socket->fatal_ssl_error();
  	    }
  
  	    # accept failed because handshake needs to be completed
  	    # if socket was non-blocking or no timeout was given return with this error
  	    return if ! defined($timeout);
  
  	    # wait until socket is readable or writable
  	    my $rv;
  	    if ( $timeout>0 ) {
  		my $vec = '';
  		vec($vec,$socket->fileno,1) = 1;
  		$rv =
  		    $SSL_ERROR == SSL_WANT_READ  ? select( $vec,undef,undef,$timeout) :
  		    $SSL_ERROR == SSL_WANT_WRITE ? select( undef,$vec,undef,$timeout) :
  		    undef;
  	    } else {
  		$! = ETIMEDOUT
  	    }
  	    if ( ! $rv ) {
  		# failed because of timeout, return
  		$! ||= ETIMEDOUT;
  		delete ${*$self}{'_SSL_opening'};
  		${*$socket}{'_SSL_opened'} = -1;
  		$socket->blocking(1); # was blocking before
  		return
  	    }
  
  	    # socket is ready, try non-blocking accept again after recomputing timeout
  	    my $now = time();
  	    $timeout -= $now - $start;
  	    $start = $now;
  	    redo;
  
  	} elsif ( $rv == 0 ) {
  	    $socket->error("SSL accept attempt failed because of handshake problems" );
  	    delete ${*$self}{'_SSL_opening'};
  	    ${*$socket}{'_SSL_opened'} = -1;
  	    return $socket->fatal_ssl_error();
  	}
      }
  
      $DEBUG>=2 && DEBUG('handshake done, socket ready' );
      # socket opened
      delete ${*$self}{'_SSL_opening'};
      ${*$socket}{'_SSL_opened'} = 1;
      if (defined($timeout)) {
  	$socket->blocking(1); # reset back to blocking
  	$! = undef; # reset errors from non-blocking
      }
  
      tie *{$socket}, "IO::Socket::SSL::SSL_HANDLE", $socket;
  
      return $socket;
  }
  
  
  ####### I/O subroutines ########################
  
  sub _generic_read {
      my ($self, $read_func, undef, $length, $offset) = @_;
      my $ssl = $self->_get_ssl_object || return;
      my $buffer=\$_[2];
  
      $SSL_ERROR = $! = undef;
      my ($data,$rwerr) = $read_func->($ssl, $length);
      if ( !defined($data)) {
  	if ( my $err = $self->_skip_rw_error( $ssl, defined($rwerr) ? $rwerr:-1 )) {
  	    $self->error("SSL read error");
  	}
  	return;
      }
  
      $length = length($data);
      $$buffer = '' if !defined $$buffer;
      $offset ||= 0;
      if ($offset>length($$buffer)) {
  	$$buffer.="\0" x ($offset-length($$buffer));  #mimic behavior of read
      }
  
      substr($$buffer, $offset, length($$buffer), $data);
      return $length;
  }
  
  sub read {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read($self,
  	$self->blocking ? \&Net::SSLeay::ssl_read_all : \&Net::SSLeay::read,
  	@_
      );
  
      # fall back to plain read if we are not required to use SSL yet
      return $self->SUPER::read(@_);
  }
  
  # contrary to the behavior of read sysread can read partial data
  sub sysread {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read( $self,
  	\&Net::SSLeay::read, @_ );
  
      # fall back to plain sysread if we are not required to use SSL yet
      my $rv = $self->SUPER::sysread(@_);
      return $rv;
  }
  
  sub peek {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read( $self,
  	\&Net::SSLeay::peek, @_ );
  
      # fall back to plain peek if we are not required to use SSL yet
      # emulate peek with recv(...,MS_PEEK) - peek(buf,len,offset)
      return if ! defined recv($self,my $buf,$_[1],MSG_PEEK);
      $_[0] = $_[2] ? substr($_[0],0,$_[2]).$buf : $buf;
      return length($buf);
  }
  
  
  sub _generic_write {
      my ($self, $write_all, undef, $length, $offset) = @_;
  
      my $ssl = $self->_get_ssl_object || return;
      my $buffer = \$_[2];
  
      my $buf_len = length($$buffer);
      $length ||= $buf_len;
      $offset ||= 0;
      return $self->_internal_error("Invalid offset for SSL write",9)
  	if $offset>$buf_len;
      return 0 if ($offset == $buf_len);
  
      $SSL_ERROR = $! = undef;
      my $written;
      if ( $write_all ) {
  	my $data = $length < $buf_len-$offset ? substr($$buffer, $offset, $length) : $$buffer;
  	($written, my $errs) = Net::SSLeay::ssl_write_all($ssl, $data);
  	# ssl_write_all returns number of bytes written
  	$written = undef if ! $written && $errs;
      } else {
  	$written = Net::SSLeay::write_partial( $ssl,$offset,$length,$$buffer );
  	# write_partial does SSL_write which returns -1 on error
  	$written = undef if $written < 0;
      }
      if ( !defined($written) ) {
  	if ( my $err = $self->_skip_rw_error( $ssl,-1 )) {
  	    $self->error("SSL write error ($err)");
  	}
  	return;
      }
  
      return $written;
  }
  
  # if socket is blocking write() should return only on error or
  # if all data are written
  sub write {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_write( $self,
  	scalar($self->blocking),@_ );
  
      # fall back to plain write if we are not required to use SSL yet
      return $self->SUPER::write(@_);
  }
  
  # contrary to write syswrite() returns already if only
  # a part of the data is written
  sub syswrite {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_write($self,0,@_);
  
      # fall back to plain syswrite if we are not required to use SSL yet
      return $self->SUPER::syswrite(@_);
  }
  
  sub print {
      my $self = shift;
      my $string = join(($, or ''), @_, ($\ or ''));
      return $self->write( $string );
  }
  
  sub printf {
      my ($self,$format) = (shift,shift);
      return $self->write(sprintf($format, @_));
  }
  
  sub getc {
      my ($self, $buffer) = (shift, undef);
      return $buffer if $self->read($buffer, 1, 0);
  }
  
  sub readline {
      my $self = shift;
      ${*$self}{_SSL_object} or return $self->SUPER::getline;
  
      if ( not defined $/ or wantarray) {
  	# read all and split
  
  	my $buf = '';
  	while (1) {
  	    my $rv = $self->sysread($buf,2**16,length($buf));
  	    if ( ! defined $rv ) {
  		next if $! == EINTR;       # retry
  		last if $! == EWOULDBLOCK || $! == EAGAIN; # use everything so far
  		return;                    # return error
  	    } elsif ( ! $rv ) {
  		last
  	    }
  	}
  
  	if ( ! defined $/ ) {
  	    return $buf
  	} elsif ( ref($/)) {
  	    my $size = ${$/};
  	    die "bad value in ref \$/: $size" unless $size>0;
  	    return $buf=~m{\G(.{1,$size})}g;
  	} elsif ( $/ eq '' ) {
  	    return $buf =~m{\G(.*\n\n+|.+)}g;
  	} else {
  	    return $buf =~m{\G(.*$/|.+)}g;
  	}
      }
  
      # read only one line
      if ( ref($/) ) {
  	my $size = ${$/};
  	# read record of $size bytes
  	die "bad value in ref \$/: $size" unless $size>0;
  	my $buf = '';
  	while ( $size>length($buf)) {
  	    my $rv = $self->sysread($buf,$size-length($buf),length($buf));
  	    if ( ! defined $rv ) {
  		next if $! == EINTR;       # retry
  		last if $! == EWOULDBLOCK || $! == EAGAIN; # use everything so far
  		return;                    # return error
  	    } elsif ( ! $rv ) {
  		last
  	    }
  	}
  	return $buf;
      }
  
      my ($delim0,$delim1) = $/ eq '' ? ("\n\n","\n"):($/,'');
  
      # find first occurrence of $delim0 followed by as much as possible $delim1
      my $buf = '';
      my $eod = 0;  # pointer into $buf after $delim0 $delim1*
      my $ssl = $self->_get_ssl_object or return;
      while (1) {
  
  	# wait until we have more data or eof
  	my $poke = Net::SSLeay::peek($ssl,1);
  	if ( ! defined $poke or $poke eq '' ) {
  	    next if $! == EINTR;
  	}
  
  	my $skip = 0;
  
  	# peek into available data w/o reading
  	my $pending = Net::SSLeay::pending($ssl);
  	if ( $pending and
  	    ( my $pb = Net::SSLeay::peek( $ssl,$pending )) ne '' ) {
  	    $buf .= $pb
  	} else {
  	    return $buf eq '' ? ():$buf;
  	}
  	if ( !$eod ) {
  	    my $pos = index( $buf,$delim0 );
  	    if ( $pos<0 ) {
  		$skip = $pending
  	    } else {
  		$eod = $pos + length($delim0); # pos after delim0
  	    }
  	}
  
  	if ( $eod ) {
  	    if ( $delim1 ne '' ) {
  		# delim0 found, check for as much delim1 as possible
  		while ( index( $buf,$delim1,$eod ) == $eod ) {
  		    $eod+= length($delim1);
  		}
  	    }
  	    $skip = $pending - ( length($buf) - $eod );
  	}
  
  	# remove data from $self which I already have in buf
  	while ( $skip>0 ) {
  	    if ($self->sysread(my $p,$skip,0)) {
  		$skip -= length($p);
  		next;
  	    }
  	    $! == EINTR or last;
  	}
  
  	if ( $eod and ( $delim1 eq '' or $eod < length($buf))) {
  	    # delim0 found and there can be no more delim1 pending
  	    last
  	}
      }
      return substr($buf,0,$eod);
  }
  
  sub close {
      my $self = shift || return _invalid_object();
      my $close_args = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  
      return if ! $self->stop_SSL(
  	SSL_fast_shutdown => 1,
  	%$close_args,
  	_SSL_ioclass_downgrade => 0,
      );
  
      if ( ! $close_args->{_SSL_in_DESTROY} ) {
  	untie( *$self );
  	undef ${*$self}{_SSL_fileno};
  	return $self->SUPER::close;
      }
      return 1;
  }
  
  sub is_SSL {
      my $self = pop;
      return ${*$self}{_SSL_object} && 1
  }
  
  sub stop_SSL {
      my $self = shift || return _invalid_object();
      my $stop_args = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
      $stop_args->{SSL_no_shutdown} = 1 if ! ${*$self}{_SSL_opened};
  
      if (my $ssl = ${*$self}{'_SSL_object'}) {
  	if ( ! $stop_args->{SSL_no_shutdown} ) {
  	    my $status = Net::SSLeay::get_shutdown($ssl);
  
  	    my $timeout =
  		not($self->blocking) ? undef :
  		exists $stop_args->{Timeout} ? $stop_args->{Timeout} :
  		${*$self}{io_socket_timeout}; # from IO::Socket
  	    if ($timeout) {
  		$self->blocking(0);
  		$timeout += time();
  	    }
  
  	    while (1) {
  		if ( $status & SSL_SENT_SHUTDOWN and
  		    # don't care for received if fast shutdown
  		    $status & SSL_RECEIVED_SHUTDOWN
  			|| $stop_args->{SSL_fast_shutdown}) {
  		    # shutdown complete
  		    last;
  		}
  		if ((${*$self}{'_SSL_opened'}||0) <= 0) {
  		    # not really open, thus don't expect shutdown to return
  		    # something meaningful
  		    last;
  		}
  
  		# initiate or complete shutdown
  		local $SIG{PIPE} = 'IGNORE';
  		my $rv = Net::SSLeay::shutdown($ssl);
  		if ( $rv < 0 ) {
  		    # non-blocking socket?
  		    if ( ! $timeout ) {
  			$self->_skip_rw_error( $ssl,$rv );
  			# need to try again
  			return;
  		    }
  
  		    # don't use _skip_rw_error so that existing error does
  		    # not get cleared
  		    my $wait = $timeout - time();
  		    last if $wait<=0;
  		    vec(my $vec = '',fileno($self),1) = 1;
  		    my $err = Net::SSLeay::get_error($ssl,$rv);
  		    if ( $err == Net::SSLeay::ERROR_WANT_READ()) {
  			select($vec,undef,undef,$wait)
  		    } elsif ( $err == Net::SSLeay::ERROR_WANT_READ()) {
  			select(undef,$vec,undef,$wait)
  		    } else {
  			last;
  		    }
  		}
  
  		$status |= SSL_SENT_SHUTDOWN;
  		$status |= SSL_RECEIVED_SHUTDOWN if $rv>0;
  	    }
  	    $self->blocking(1) if $timeout;
  	}
  
  	# destroy allocated objects for SSL and untie
  	# do not destroy CTX unless explicitly specified
  	Net::SSLeay::free($ssl);
  	delete ${*$self}{_SSL_object};
  	if (my $cert = delete ${*$self}{'_SSL_certificate'}) {
  	    Net::SSLeay::X509_free($cert);
  	}
  	${*$self}{'_SSL_opened'} = 0;
  	untie(*$self);
      }
  
      if ($stop_args->{'SSL_ctx_free'}) {
  	my $ctx = delete ${*$self}{'_SSL_ctx'};
  	$ctx && $ctx->DESTROY();
      }
  
  
      if ( ! $stop_args->{_SSL_in_DESTROY} ) {
  
  	my $downgrade = $stop_args->{_SSL_ioclass_downgrade};
  	if ( $downgrade || ! defined $downgrade ) {
  	    # rebless to original class from start_SSL
  	    if ( my $orig_class = delete ${*$self}{'_SSL_ioclass_upgraded'} ) {
  		bless $self,$orig_class;
  		# FIXME: if original class was tied too we need to restore the tie
  		# remove all _SSL related from *$self
  		my @sslkeys = grep { m{^_?SSL_} } keys %{*$self};
  		delete @{*$self}{@sslkeys} if @sslkeys;
  	    }
  	}
      }
      return 1;
  }
  
  
  sub fileno {
      my $self = shift;
      my $fn = ${*$self}{'_SSL_fileno'};
  	return defined($fn) ? $fn : $self->SUPER::fileno();
  }
  
  
  ####### IO::Socket::SSL specific functions #######
  # _get_ssl_object is for internal use ONLY!
  sub _get_ssl_object {
      my $self = shift;
      return ${*$self}{'_SSL_object'} ||
  	IO::Socket::SSL->_internal_error("Undefined SSL object",9);
  }
  
  # _get_ctx_object is for internal use ONLY!
  sub _get_ctx_object {
      my $self = shift;
      my $ctx_object = ${*$self}{_SSL_ctx};
      return $ctx_object && $ctx_object->{context};
  }
  
  # default error for undefined arguments
  sub _invalid_object {
      return IO::Socket::SSL->_internal_error("Undefined IO::Socket::SSL object",9);
  }
  
  
  sub pending {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::pending($ssl);
  }
  
  sub start_SSL {
      my ($class,$socket) = (shift,shift);
      return $class->_internal_error("Not a socket",9) if ! ref($socket);
      my $arg_hash = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
      my %to = exists $arg_hash->{Timeout} ? ( Timeout => delete $arg_hash->{Timeout} ) :();
      my $original_class = ref($socket);
      if ( ! $original_class ) {
  	$socket = ($original_class = $ISA[0])->new_from_fd($socket,'<+')
  	    or return $class->_internal_error(
  	    "creating $original_class from file handle failed",9);
      }
      my $original_fileno = (UNIVERSAL::can($socket, "fileno"))
  	? $socket->fileno : CORE::fileno($socket);
      return $class->_internal_error("Socket has no fileno",9)
  	if ! defined $original_fileno;
  
      bless $socket, $class;
      $socket->configure_SSL($arg_hash) or bless($socket, $original_class) && return;
  
      ${*$socket}{'_SSL_fileno'} = $original_fileno;
      ${*$socket}{'_SSL_ioclass_upgraded'} = $original_class
  	if $class ne $original_class;
  
      my $start_handshake = $arg_hash->{SSL_startHandshake};
      if ( ! defined($start_handshake) || $start_handshake ) {
  	# if we have no callback force blocking mode
  	$DEBUG>=2 && DEBUG( "start handshake" );
  	my $was_blocking = $socket->blocking(1);
  	my $result = ${*$socket}{'_SSL_arguments'}{SSL_server}
  	    ? $socket->accept_SSL(%to)
  	    : $socket->connect_SSL(%to);
  	if ( $result ) {
  	    $socket->blocking(0) if ! $was_blocking;
  	    return $socket;
  	} else {
  	    # upgrade to SSL failed, downgrade socket to original class
  	    if ( $original_class ) {
  		bless($socket,$original_class);
  		$socket->blocking(0) if ! $was_blocking
  		    && $socket->can('blocking');
  	    }
  	    return;
  	}
      } else {
  	$DEBUG>=2 && DEBUG( "don't start handshake: $socket" );
  	return $socket; # just return upgraded socket
      }
  
  }
  
  sub new_from_fd {
      my ($class, $fd) = (shift,shift);
      # Check for accidental inclusion of MODE in the argument list
      if (length($_[0]) < 4) {
  	(my $mode = $_[0]) =~ tr/+<>//d;
  	shift unless length($mode);
      }
      my $handle = $ISA[0]->new_from_fd($fd, '+<')
  	|| return($class->error("Could not create socket from file descriptor."));
  
      # Annoying workaround for Perl 5.6.1 and below:
      $handle = $ISA[0]->new_from_fd($handle, '+<');
  
      return $class->start_SSL($handle, @_);
  }
  
  
  sub dump_peer_certificate {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::dump_peer_certificate($ssl);
  }
  
  if ( defined &Net::SSLeay::get_peer_cert_chain
      && $Net::SSLeay::VERSION >= 1.58 ) {
      *peer_certificates = sub {
  	my $self = shift;
  	my $ssl = $self->_get_ssl_object || return;
  	my @chain = Net::SSLeay::get_peer_cert_chain($ssl);
  	@chain = () if @chain && !$self->peer_certificate; # work around #96013
  	if ( ${*$self}{_SSL_arguments}{SSL_server} ) {
  	    # in the client case the chain contains the peer certificate,
  	    # in the server case not
  	    # this one has an increased reference counter, the other not
  	    if ( my $peer = Net::SSLeay::get_peer_certificate($ssl)) {
  		Net::SSLeay::X509_free($peer);
  		unshift @chain, $peer;
  	    }
  	}
  	return @chain;
  
      }
  } else {
      *peer_certificates = sub {
  	die "peer_certificates needs Net::SSLeay>=1.58";
      }
  }
  
  {
      my %dispatcher = (
  	issuer =>  sub { Net::SSLeay::X509_NAME_oneline( Net::SSLeay::X509_get_issuer_name( shift )) },
  	subject => sub { Net::SSLeay::X509_NAME_oneline( Net::SSLeay::X509_get_subject_name( shift )) },
  	commonName => sub {
  	    my $cn = Net::SSLeay::X509_NAME_get_text_by_NID(
  		Net::SSLeay::X509_get_subject_name( shift ), NID_CommonName);
  	    $cn;
  	},
  	subjectAltNames => sub { Net::SSLeay::X509_get_subjectAltNames( shift ) },
      );
  
      # alternative names
      $dispatcher{authority} = $dispatcher{issuer};
      $dispatcher{owner}     = $dispatcher{subject};
      $dispatcher{cn}        = $dispatcher{commonName};
  
      sub peer_certificate {
  	my ($self,$field,$reload) = @_;
  	my $ssl = $self->_get_ssl_object or return;
  
  	Net::SSLeay::X509_free(delete ${*$self}{_SSL_certificate})
  	    if $reload && ${*$self}{_SSL_certificate};
  	my $cert = ${*$self}{_SSL_certificate}
  	    ||= Net::SSLeay::get_peer_certificate($ssl)
  	    or return $self->error("Could not retrieve peer certificate");
  
  	if ($field) {
  	    my $sub = $dispatcher{$field} or croak
  		"invalid argument for peer_certificate, valid are: ".join( " ",keys %dispatcher ).
  		"\nMaybe you need to upgrade your Net::SSLeay";
  	    return $sub->($cert);
  	} else {
  	    return $cert
  	}
      }
  
      sub sock_certificate {
  	my ($self,$field) = @_;
  	my $ssl = $self->_get_ssl_object || return;
  	my $cert = Net::SSLeay::get_certificate( $ssl ) || return;
  	if ($field) {
  	    my $sub = $dispatcher{$field} or croak
  		"invalid argument for sock_certificate, valid are: ".join( " ",keys %dispatcher ).
  		"\nMaybe you need to upgrade your Net::SSLeay";
  	    return $sub->($cert);
  	} else {
  	    return $cert
  	}
      }
  
  
      # known schemes, possible attributes are:
      #  - wildcards_in_alt (0, 'full_label', 'anywhere')
      #  - wildcards_in_cn (0, 'full_label', 'anywhere')
      #  - check_cn (0, 'always', 'when_only')
      # unfortunately there are a lot of different schemes used, see RFC 6125 for a
      # summary, which references all of the following except RFC4217/ftp
  
      my %scheme = (
  	none => {}, # do not check
  	# default set is a superset of all the others and thus worse than a more
  	# specific set, but much better than not verifying name at all
  	default => {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'always',
  	    ip_in_cn         => 1,
  	},
      );
  
      for(qw(
  	rfc2818
  	rfc3920 xmpp
  	rfc4217 ftp
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'when_only',
  	}
      }
  
      for(qw(www http)) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'when_only',
  	    ip_in_cn         => 4,
  	}
      }
  
      for(qw(
  	rfc4513 ldap
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 0,
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'always',
  	};
      }
  
      for(qw(
  	rfc2595 smtp
  	rfc4642 imap pop3 acap
  	rfc5539 nntp
  	rfc5538 netconf
  	rfc5425 syslog
  	rfc5953 snmp
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'full_label',
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'always'
  	};
      }
      for(qw(
  	rfc5971 gist
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'full_label',
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'when_only',
  	};
      }
  
      for(qw(
  	rfc5922 sip
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 0,
  	    wildcards_in_alt => 0,
  	    check_cn         => 'always',
  	};
      }
  
  
      # function to verify the hostname
      #
      # as every application protocol has its own rules to do this
      # we provide some default rules as well as a user-defined
      # callback
  
      sub verify_hostname_of_cert {
  	my $identity = shift;
  	my $cert = shift;
  	my $scheme = shift || 'default';
  	my $publicsuffix = shift;
  	if ( ! ref($scheme) ) {
  	    $DEBUG>=3 && DEBUG( "scheme=$scheme cert=$cert" );
  	    $scheme = $scheme{$scheme} || croak("scheme $scheme not defined");
  	}
  
  	return 1 if ! %$scheme; # 'none'
  	$identity =~s{\.+$}{}; # ignore absolutism
  
  	# get data from certificate
  	my $commonName = $dispatcher{cn}->($cert);
  	my @altNames = $dispatcher{subjectAltNames}->($cert);
  	$DEBUG>=3 && DEBUG("identity=$identity cn=$commonName alt=@altNames" );
  
  	if ( my $sub = $scheme->{callback} ) {
  	    # use custom callback
  	    return $sub->($identity,$commonName,@altNames);
  	}
  
  	# is the given hostname an IP address? Then we have to convert to network byte order [RFC791][RFC2460]
  
  	my $ipn;
  	if ( CAN_IPV6 and $identity =~m{:} ) {
  	    # no IPv4 or hostname have ':'  in it, try IPv6.
  	    $identity =~m{[^\da-fA-F:\.]} and return; # invalid characters in name
  	    $ipn = inet_pton(AF_INET6,$identity) or return; # invalid name
  	} elsif ( my @ip = $identity =~m{^(\d+)(?:\.(\d+)\.(\d+)\.(\d+)|[\d\.]*)$} ) {
  	    # check for invalid IP/hostname
  	    return if 4 != @ip or 4 != grep { defined($_) && $_<256 } @ip; 
  	    $ipn = pack("CCCC",@ip);
  	} else {
  	    # assume hostname, check for umlauts etc
  	    if ( $identity =~m{[^a-zA-Z0-9_.\-]} ) {
  		$identity =~m{\0} and return; # $identity has \\0 byte
  		$identity = idn_to_ascii($identity)
  		    or return; # conversation to IDNA failed
  		$identity =~m{[^a-zA-Z0-9_.\-]}
  		    and return; # still junk inside
  	    }
  	}
  
  	# do the actual verification
  	my $check_name = sub {
  	    my ($name,$identity,$wtyp,$publicsuffix) = @_;
  	    $name =~s{\.+$}{}; # ignore absolutism
  	    $name eq '' and return;
  	    $wtyp ||= '';
  	    my $pattern;
  	    ### IMPORTANT!
  	    # We accept only a single wildcard and only for a single part of the FQDN
  	    # e.g *.example.org does match www.example.org but not bla.www.example.org
  	    # The RFCs are in this regard unspecific but we don't want to have to
  	    # deal with certificates like *.com, *.co.uk or even *
  	    # see also http://nils.toedtmann.net/pub/subjectAltName.txt .
  	    # Also, we fall back to full_label matches if the identity is an IDNA
  	    # name, see RFC6125 and the discussion at
  	    # http://bugs.python.org/issue17997#msg194950
  	    if ( $wtyp eq 'anywhere' and $name =~m{^([a-zA-Z0-9_\-]*)\*(.+)} ) {
  		return if $1 ne '' and substr($identity,0,4) eq 'xn--'; # IDNA
  		$pattern = qr{^\Q$1\E[a-zA-Z0-9_\-]+\Q$2\E$}i;
  	    } elsif ( $wtyp =~ m{^(?:full_label|leftmost)$}
  		and $name =~m{^\*(\..+)$} ) {
  		$pattern = qr{^[a-zA-Z0-9_\-]+\Q$1\E$}i;
  	    } else {
  		return lc($identity) eq lc($name);
  	    }
  	    if ( $identity =~ $pattern ) {
  		$publicsuffix = IO::Socket::SSL::PublicSuffix->default
  		    if ! defined $publicsuffix;
  		return 1 if $publicsuffix eq '';
  		my @labels = split( m{\.+}, $identity );
  		my $tld = $publicsuffix->public_suffix(\@labels,+1);
  		return 1 if @labels > ( $tld ? 0+@$tld : 1 );
  	    }
  	    return;
  	};
  
  
  	my $alt_dnsNames = 0;
  	while (@altNames) {
  	    my ($type, $name) = splice (@altNames, 0, 2);
  	    if ( $ipn and $type == GEN_IPADD ) {
  		# exact match needed for IP
  		# $name is already packed format (inet_xton)
  		return 1 if $ipn eq $name;
  
  	    } elsif ( ! $ipn and $type == GEN_DNS ) {
  		$name =~s/\s+$//; $name =~s/^\s+//;
  		$alt_dnsNames++;
  		$check_name->($name,$identity,$scheme->{wildcards_in_alt},$publicsuffix)
  		    and return 1;
  	    }
  	}
  
  	if ( $scheme->{check_cn} eq 'always' or
  	    $scheme->{check_cn} eq 'when_only' and !$alt_dnsNames ) {
  	    if ( ! $ipn ) {
  		$check_name->($commonName,$identity,$scheme->{wildcards_in_cn},$publicsuffix)
  		    and return 1;
  	    } elsif ( $scheme->{ip_in_cn} ) {
  		if ( $identity eq $commonName ) {
  		    return 1 if
  			$scheme->{ip_in_cn} == 4 ? length($ipn) == 4 :
  			$scheme->{ip_in_cn} == 6 ? length($ipn) == 8 :
  			1;
  		}
  	    }
  	}
  
  	return 0; # no match
      }
  }
  
  sub verify_hostname {
      my $self = shift;
      my $host = shift;
      my $cert = $self->peer_certificate;
      return verify_hostname_of_cert( $host,$cert,@_ );
  }
  
  
  sub get_servername {
      my $self = shift;
      return ${*$self}{_SSL_servername} ||= do {
  	my $ssl = $self->_get_ssl_object or return;
  	Net::SSLeay::get_servername($ssl);
      };
  }
  
  sub get_fingerprint_bin {
      my ($self,$algo,$cert) = @_;
      $cert ||= $self->peer_certificate;
      return Net::SSLeay::X509_digest($cert, $algo2digest->($algo || 'sha256'));
  }
  
  sub get_fingerprint {
      my ($self,$algo,$cert) = @_;
      $algo ||= 'sha256';
      my $fp = get_fingerprint_bin($self,$algo,$cert) or return;
      return $algo.'$'.unpack('H*',$fp);
  }
  
  sub get_cipher {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::get_cipher($ssl);
  }
  
  sub get_sslversion {
      my $ssl = shift()->_get_ssl_object || return;
      my $version = Net::SSLeay::version($ssl) or return;
      return
  	$version == 0x0303 ? 'TLSv1_2' :
  	$version == 0x0302 ? 'TLSv1_1' :
  	$version == 0x0301 ? 'TLSv1'   :
  	$version == 0x0300 ? 'SSLv3'   :
  	$version == 0x0002 ? 'SSLv2'   :
  	$version == 0xfeff ? 'DTLS1'   :
  	undef;
  }
  
  sub get_sslversion_int {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::version($ssl);
  }
  
  if ($can_ocsp) {
      no warnings 'once';
      *ocsp_resolver = sub {
  	my $self = shift;
  	my $ssl = $self->_get_ssl_object || return;
  	my $ctx = ${*$self}{_SSL_ctx};
  	return IO::Socket::SSL::OCSP_Resolver->new(
  	    $ssl,
  	    $ctx->{ocsp_cache} ||= IO::Socket::SSL::OCSP_Cache->new,
  	    $ctx->{ocsp_mode} & SSL_OCSP_FAIL_HARD,
  	    @_ ? \@_ :
  		$ctx->{ocsp_mode} & SSL_OCSP_FULL_CHAIN ? [ $self->peer_certificates ]:
  		[ $self->peer_certificate ]
  	);
      };
  }
  
  sub errstr {
      my $self = shift;
      my $oe = ref($self) && ${*$self}{_SSL_last_err};
      return $oe ? $oe->[0] : $SSL_ERROR || '';
  }
  
  sub fatal_ssl_error {
      my $self = shift;
      my $error_trap = ${*$self}{'_SSL_arguments'}->{'SSL_error_trap'};
      $@ = $self->errstr;
      if (defined $error_trap and ref($error_trap) eq 'CODE') {
  	$error_trap->($self, $self->errstr()."\n".$self->get_ssleay_error());
      } elsif ( ${*$self}{'_SSL_ioclass_upgraded'} ) {
  	# downgrade only
  	$self->stop_SSL;
      } else {
  	# kill socket
  	$self->close
      }
      return;
  }
  
  sub get_ssleay_error {
      #Net::SSLeay will print out the errors itself unless we explicitly
      #undefine $Net::SSLeay::trace while running print_errs()
      local $Net::SSLeay::trace;
      return Net::SSLeay::print_errs('SSL error: ') || '';
  }
  
  # internal errors, e.g unsupported features, hostname check failed etc
  # _SSL_last_err contains severity so that on error chains we can decide if one
  # error should replace the previous one or if this is just a less specific
  # follow-up error, e.g. configuration failed because certificate failed because
  # hostname check went wrong:
  # 0 - fallback errors
  # 4 - errors bubbled up from OpenSSL (sub error, r/w error)
  # 5 - hostname or OCSP verification failed
  # 9 - fatal problems, e.g. missing feature, no fileno...
  # _SSL_last_err and SSL_ERROR are only replaced if the error has a higher
  # severity than the previous one
  
  sub _internal_error {
      my ($self, $error, $severity) = @_;
      $error = dualvar( -1, $error );
      $self = $CURRENT_SSL_OBJECT if !ref($self) && $CURRENT_SSL_OBJECT;
      if (ref($self)) {
  	my $oe = ${*$self}{_SSL_last_err};
  	if (!$oe || $oe->[1] <= $severity) {
  	    ${*$self}{_SSL_last_err} = [$error,$severity];
  	    $SSL_ERROR = $error;
  	    $DEBUG && DEBUG("local error: $error");
  	} else {
  	    $DEBUG && DEBUG("ignoring less severe local error '$error', keep '$oe->[0]'");
  	}
      } else {
  	$SSL_ERROR = $error;
  	$DEBUG && DEBUG("global error: $error");
      }
      return;
  }
  
  # OpenSSL errors
  sub error {
      my ($self, $error) = @_;
      my @err;
      while ( my $err = Net::SSLeay::ERR_get_error()) {
  	push @err, Net::SSLeay::ERR_error_string($err);
  	$DEBUG>=2 && DEBUG( $error."\n".$self->get_ssleay_error());
      }
      $error .= ' '.join(' ',@err) if @err;
      return $self->_internal_error($error,4) if $error;
      return;
  }
  
  sub can_client_sni { return $can_client_sni }
  sub can_server_sni { return $can_server_sni }
  sub can_npn        { return $can_npn }
  sub can_alpn       { return $can_alpn }
  sub can_ecdh       { return $can_ecdh }
  sub can_ipv6       { return CAN_IPV6 }
  sub can_ocsp       { return $can_ocsp }
  
  sub DESTROY {
      my $self = shift or return;
      my $ssl = ${*$self}{_SSL_object} or return;
      delete $SSL_OBJECT{$ssl};
      if ($CREATED_IN_THIS_THREAD{$ssl}) {
  	$self->close(_SSL_in_DESTROY => 1, SSL_no_shutdown => 1)
  	    if ${*$self}{'_SSL_opened'};
  	delete(${*$self}{'_SSL_ctx'});
      }
  }
  
  
  #######Extra Backwards Compatibility Functionality#######
  sub socket_to_SSL { IO::Socket::SSL->start_SSL(@_); }
  sub socketToSSL { IO::Socket::SSL->start_SSL(@_); }
  sub kill_socket { shift->close }
  
  sub issuer_name { return(shift()->peer_certificate("issuer")) }
  sub subject_name { return(shift()->peer_certificate("subject")) }
  sub get_peer_certificate { return shift() }
  
  sub context_init {
      return($GLOBAL_SSL_ARGS = (ref($_[0]) eq 'HASH') ? $_[0] : {@_});
  }
  
  sub set_default_context {
      $GLOBAL_SSL_ARGS->{'SSL_reuse_ctx'} = shift;
  }
  
  sub set_default_session_cache {
      $GLOBAL_SSL_ARGS->{SSL_session_cache} = shift;
  }
  
  
  {
      my $set_defaults = sub {
  	my $args = shift;
  	for(my $i=0;$i<@$args;$i+=2 ) {
  	    my ($k,$v) = @{$args}[$i,$i+1];
  	    if ( $k =~m{^SSL_} ) {
  		$_->{$k} = $v for(@_);
  	    } elsif ( $k =~m{^(name|scheme)$} ) {
  		$_->{"SSL_verifycn_$k"} = $v for (@_);
  	    } elsif ( $k =~m{^(callback|mode)$} ) {
  		$_->{"SSL_verify_$k"} = $v for(@_);
  	    } else {
  		$_->{"SSL_$k"} = $v for(@_);
  	    }
  	}
      };
      sub set_defaults {
  	my %args = @_;
  	$set_defaults->(\@_,
  	    $GLOBAL_SSL_ARGS,
  	    $GLOBAL_SSL_CLIENT_ARGS,
  	    $GLOBAL_SSL_SERVER_ARGS
  	);
      }
      { # deprecated API
  	no warnings;
  	*set_ctx_defaults = \&set_defaults;
      }
      sub set_client_defaults {
  	my %args = @_;
  	$set_defaults->(\@_, $GLOBAL_SSL_CLIENT_ARGS );
      }
      sub set_server_defaults {
  	my %args = @_;
  	$set_defaults->(\@_, $GLOBAL_SSL_SERVER_ARGS );
      }
  }
  
  sub set_args_filter_hack {
      my $sub = shift;
      if ( ref $sub ) {
  	$FILTER_SSL_ARGS = $sub;
      } elsif ( $sub eq 'use_defaults' ) {
  	# override args with defaults
  	$FILTER_SSL_ARGS = sub {
  	    my ($is_server,$args) = @_;
  	    %$args = ( %$args, $is_server
  		? ( %DEFAULT_SSL_SERVER_ARGS, %$GLOBAL_SSL_SERVER_ARGS )
  		: ( %DEFAULT_SSL_CLIENT_ARGS, %$GLOBAL_SSL_CLIENT_ARGS )
  	    );
  	}
      }
  }
  
  sub next_proto_negotiated {
      my $self = shift;
      return $self->_internal_error("NPN not supported in Net::SSLeay",9) if ! $can_npn;
      my $ssl = $self->_get_ssl_object || return;
      return Net::SSLeay::P_next_proto_negotiated($ssl);
  }
  
  sub alpn_selected {
      my $self = shift;
      return $self->_internal_error("ALPN not supported in Net::SSLeay",9) if ! $can_alpn;
      my $ssl = $self->_get_ssl_object || return;
      return Net::SSLeay::P_alpn_selected($ssl);
  }
  
  sub opened {
      my $self = shift;
      return IO::Handle::opened($self) && ${*$self}{'_SSL_opened'};
  }
  
  sub opening {
      my $self = shift;
      return ${*$self}{'_SSL_opening'};
  }
  
  sub want_read  { shift->errstr == SSL_WANT_READ }
  sub want_write { shift->errstr == SSL_WANT_WRITE }
  
  
  #Redundant IO::Handle functionality
  sub getline { return(scalar shift->readline()) }
  sub getlines {
      return(shift->readline()) if wantarray();
      croak("Use of getlines() not allowed in scalar context");
  }
  
  #Useless IO::Handle functionality
  sub truncate { croak("Use of truncate() not allowed with SSL") }
  sub stat     { croak("Use of stat() not allowed with SSL" ) }
  sub setbuf   { croak("Use of setbuf() not allowed with SSL" ) }
  sub setvbuf  { croak("Use of setvbuf() not allowed with SSL" ) }
  sub fdopen   { croak("Use of fdopen() not allowed with SSL" ) }
  
  #Unsupported socket functionality
  sub ungetc { croak("Use of ungetc() not implemented in IO::Socket::SSL") }
  sub send   { croak("Use of send() not implemented in IO::Socket::SSL; use print/printf/syswrite instead") }
  sub recv   { croak("Use of recv() not implemented in IO::Socket::SSL; use read/sysread instead") }
  
  package IO::Socket::SSL::SSL_HANDLE;
  use strict;
  use Errno 'EBADF';
  *weaken = *IO::Socket::SSL::weaken;
  
  sub TIEHANDLE {
      my ($class, $handle) = @_;
      weaken($handle);
      bless \$handle, $class;
  }
  
  sub READ     { ${shift()}->sysread(@_) }
  sub READLINE { ${shift()}->readline(@_) }
  sub GETC     { ${shift()}->getc(@_) }
  
  sub PRINT    { ${shift()}->print(@_) }
  sub PRINTF   { ${shift()}->printf(@_) }
  sub WRITE    { ${shift()}->syswrite(@_) }
  
  sub FILENO   { ${shift()}->fileno(@_) }
  
  sub TELL     { $! = EBADF; return -1 }
  sub BINMODE  { return 0 }  # not perfect, but better than not implementing the method
  
  sub CLOSE {                          #<---- Do not change this function!
      my $ssl = ${$_[0]};
      local @_;
      $ssl->close();
  }
  
  
  package IO::Socket::SSL::SSL_Context;
  use Carp;
  use strict;
  
  my %CTX_CREATED_IN_THIS_THREAD;
  *DEBUG = *IO::Socket::SSL::DEBUG;
  
  use constant SSL_MODE_ENABLE_PARTIAL_WRITE => 1;
  use constant SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER => 2;
  
  use constant FILETYPE_PEM => Net::SSLeay::FILETYPE_PEM();
  use constant FILETYPE_ASN1 => Net::SSLeay::FILETYPE_ASN1();
  
  # Note that the final object will actually be a reference to the scalar
  # (C-style pointer) returned by Net::SSLeay::CTX_*_new() so that
  # it can be blessed.
  sub new {
      my $class = shift;
      #DEBUG( "$class @_" );
      my $arg_hash = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  
      # common problem forgetting to set SSL_use_cert
      # if client cert is given by user but SSL_use_cert is undef, assume that it
      # should be set
      my $is_server = $arg_hash->{SSL_server};
      if ( ! $is_server && ! defined $arg_hash->{SSL_use_cert}
  	&& ( grep { $arg_hash->{$_} } qw(SSL_cert SSL_cert_file))
  	&& ( grep { $arg_hash->{$_} } qw(SSL_key SSL_key_file)) ) {
  	$arg_hash->{SSL_use_cert} = 1
      }
  
      # if any of SSL_ca* is set don't set the other SSL_ca*
      # from defaults
      if ( $arg_hash->{SSL_ca} ) {
  	$arg_hash->{SSL_ca_file} ||= undef
  	$arg_hash->{SSL_ca_path} ||= undef
      } elsif ( $arg_hash->{SSL_ca_path} ) {
  	$arg_hash->{SSL_ca_file} ||= undef
      } elsif ( $arg_hash->{SSL_ca_file} ) {
  	$arg_hash->{SSL_ca_path} ||= undef;
      }
  
      # add library defaults
      %$arg_hash = (
  	SSL_use_cert => $is_server,
  	$is_server ? %DEFAULT_SSL_SERVER_ARGS : %DEFAULT_SSL_CLIENT_ARGS,
  	%$arg_hash
      );
  
      # Avoid passing undef arguments to Net::SSLeay
      defined($arg_hash->{$_}) or delete($arg_hash->{$_}) for(keys %$arg_hash);
  
      # check SSL CA, cert etc arguments
      # some apps set keys '' to signal that it is not set, replace with undef
      for (qw( SSL_cert SSL_cert_file SSL_key SSL_key_file
  	SSL_ca SSL_ca_file SSL_ca_path
  	SSL_fingerprint )) {
  	$arg_hash->{$_} = undef if defined $arg_hash->{$_}
  	    and $arg_hash->{$_} eq '';
      }
      for(qw(SSL_cert_file SSL_key_file)) {
  	 defined( my $file = $arg_hash->{$_} ) or next;
  	for my $f (ref($file) eq 'HASH' ? values(%$file):$file ) {
  	    die "$_ $f does not exist" if ! -f $f;
  	}
      }
  
      my $verify_mode = $arg_hash->{SSL_verify_mode} || 0;
      if ( $verify_mode != Net::SSLeay::VERIFY_NONE()) {
  	for (qw(SSL_ca_file SSL_ca_path)) {
  	    $CHECK_SSL_PATH->($_ => $arg_hash->{$_} || next);
  	}
      } elsif ( $verify_mode ne '0' ) {
  	# some users use the string 'SSL_VERIFY_PEER' instead of the constant
  	die "SSL_verify_mode must be a number and not a string";
      }
  
      my $self = bless {},$class;
  
      my $vcn_scheme = delete $arg_hash->{SSL_verifycn_scheme};
      my $vcn_publicsuffix = delete $arg_hash->{SSL_verifycn_publicsuffix};
      if ( ! $is_server and $verify_mode & 0x01 and
  	! $vcn_scheme || $vcn_scheme ne 'none' ) {
  
  	# gets updated during configure_SSL
  	my $verify_name;
  	$self->{verify_name_ref} = \$verify_name;
  
  	my $vcb = $arg_hash->{SSL_verify_callback};
  	$arg_hash->{SSL_verify_callback} = sub {
  	    my ($ok,$ctx_store,$certname,$error,$cert,$depth) = @_;
  	    $ok = $vcb->($ok,$ctx_store,$certname,$error,$cert,$depth) if $vcb;
  	    $ok or return 0;
  
  	    return $ok if $depth != 0;
  
  	    my $host = $verify_name || ref($vcn_scheme) && $vcn_scheme->{callback} && 'unknown';
  	    if ( ! $host ) {
  		if ( $vcn_scheme ) {
  		    IO::Socket::SSL->_internal_error(
  			"Cannot determine peer hostname for verification",8);
  		    return 0;
  		}
  		warn "Cannot determine hostname of peer for verification. ".
  		    "Disabling default hostname verification for now. ".
  		    "Please specify hostname with SSL_verifycn_name and better set SSL_verifycn_scheme too.\n";
  		return $ok;
  	    } elsif ( ! $vcn_scheme && $host =~m{^[\d.]+$|:} ) {
  		# don't try to verify IP by default
  		return $ok;
  	    }
  
  
  	    # verify name
  	    my $rv = IO::Socket::SSL::verify_hostname_of_cert(
  		$host,$cert,$vcn_scheme,$vcn_publicsuffix );
  	    if ( ! $rv ) {
  		IO::Socket::SSL->_internal_error(
  		    "hostname verification failed",5);
  	    }
  	    return $rv;
  	};
      }
  
      my $ssl_op = Net::SSLeay::OP_ALL();
      $ssl_op |= &Net::SSLeay::OP_SINGLE_DH_USE;
      $ssl_op |= &Net::SSLeay::OP_SINGLE_ECDH_USE if $can_ecdh;
  
      my $ver;
      for (split(/\s*:\s*/,$arg_hash->{SSL_version})) {
  	m{^(!?)(?:(SSL(?:v2|v3|v23|v2/3))|(TLSv1(?:_?[12])?))$}i
  	or croak("invalid SSL_version specified");
  	my $not = $1;
  	( my $v = lc($2||$3) ) =~s{^(...)}{\U$1};
  	if ( $not ) {
  	    $ssl_op |= $SSL_OP_NO{$v};
  	} else {
  	    croak("cannot set multiple SSL protocols in SSL_version")
  		if $ver && $v ne $ver;
  	    $ver = $v;
  	    $ver =~s{/}{}; # interpret SSLv2/3 as SSLv23
  	    $ver =~s{(TLSv1)(\d)}{$1\_$2}; # TLSv1_1
  	}
      }
  
      my $ctx_new_sub =  UNIVERSAL::can( 'Net::SSLeay',
  	$ver eq 'SSLv2'   ? 'CTX_v2_new' :
  	$ver eq 'SSLv3'   ? 'CTX_v3_new' :
  	$ver eq 'TLSv1'   ? 'CTX_tlsv1_new' :
  	$ver eq 'TLSv1_1' ? 'CTX_tlsv1_1_new' :
  	$ver eq 'TLSv1_2' ? 'CTX_tlsv1_2_new' :
  	'CTX_new'
      ) or return IO::Socket::SSL->_internal_error("SSL Version $ver not supported",9);
  
      # For SNI in server mode we need a separate context for each certificate.
      my %ctx;
      if ($arg_hash->{'SSL_server'}) {
  	my %sni;
  	for my $opt (qw(SSL_key SSL_key_file SSL_cert SSL_cert_file)) {
  	    my $val  = $arg_hash->{$opt} or next;
  	    if ( ref($val) eq 'HASH' ) {
  		while ( my ($host,$v) = each %$val ) {
  		    $sni{lc($host)}{$opt} = $v;
  		}
  	    }
  	}
  	while (my ($host,$v) = each %sni) {
  	    $ctx{$host} = { %$arg_hash, %$v };
  	}
      }
      $ctx{''} = $arg_hash if ! %ctx;
  
      while (my ($host,$arg_hash) = each %ctx) {
  	# replace value in %ctx with real context
  	my $ctx = $ctx_new_sub->() or return
  	    IO::Socket::SSL->error("SSL Context init failed");
  	$CTX_CREATED_IN_THIS_THREAD{$ctx} = 1;
  
  	# SSL_OP_CIPHER_SERVER_PREFERENCE
  	$ssl_op |= 0x00400000 if $arg_hash->{SSL_honor_cipher_order};
  
  	if ($ver eq 'SSLv23' && !($ssl_op & $SSL_OP_NO{SSLv3})) {
  	    # At least LibreSSL disables SSLv3 by default in SSL_CTX_new.
  	    # If we really want SSL3.0 we need to explicitly allow it with
  	    # SSL_CTX_clear_options.
  	    Net::SSLeay::CTX_clear_options($ctx,$SSL_OP_NO{SSLv3});
  	}
  
  	Net::SSLeay::CTX_set_options($ctx,$ssl_op);
  
  	# if we don't set session_id_context if client certificate is expected
  	# client session caching will fail
  	# if user does not provide explicit id just use the stringification
  	# of the context
  	if ( my $id = $arg_hash->{SSL_session_id_context}
  	    || ( $arg_hash->{SSL_verify_mode} & 0x01 ) && "$ctx" ) {
  	    Net::SSLeay::CTX_set_session_id_context($ctx,$id,length($id));
  	}
  
  	# SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER makes syswrite return if at least one
  	# buffer was written and not block for the rest
  	# SSL_MODE_ENABLE_PARTIAL_WRITE can be necessary for non-blocking because we
  	# cannot guarantee, that the location of the buffer stays constant
  	Net::SSLeay::CTX_set_mode( $ctx,
  	    SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER|SSL_MODE_ENABLE_PARTIAL_WRITE);
  
  	if ( my $proto_list = $arg_hash->{SSL_npn_protocols} ) {
  	    return IO::Socket::SSL->_internal_error("NPN not supported in Net::SSLeay",9)
  		if ! $can_npn;
  	    if($arg_hash->{SSL_server}) {
  		# on server side SSL_npn_protocols means a list of advertised protocols
  		Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, $proto_list);
  	    } else {
  		# on client side SSL_npn_protocols means a list of preferred protocols
  		# negotiation algorithm used is "as-openssl-implements-it"
  		Net::SSLeay::CTX_set_next_proto_select_cb($ctx, $proto_list);
  	    }
  	}
  
  	if ( my $proto_list = $arg_hash->{SSL_alpn_protocols} ) {
  	    return IO::Socket::SSL->_internal_error("ALPN not supported in Net::SSLeay",9)
  		if ! $can_alpn;
  	    if($arg_hash->{SSL_server}) {
  		Net::SSLeay::CTX_set_alpn_select_cb($ctx, $proto_list);
  	    } else {
  		Net::SSLeay::CTX_set_alpn_protos($ctx, $proto_list);
  	    }
  	}
  
  	# Try to apply SSL_ca even if SSL_verify_mode is 0, so that they can be
  	# used to verify OCSP responses.
  	# If applying fails complain only if verify_mode != VERIFY_NONE.
  	if ( $arg_hash->{SSL_ca}
  	    || defined $arg_hash->{SSL_ca_file}
  	    || defined $arg_hash->{SSL_ca_path} ) {
  	    my $file = $arg_hash->{SSL_ca_file};
  	    $file = undef if ref($file) eq 'SCALAR' && ! $$file;
  	    my $dir = $arg_hash->{SSL_ca_path};
  	    $dir = undef if ref($dir) eq 'SCALAR' && ! $$dir;
  	    if ( $arg_hash->{SSL_ca} ) {
  		my $store = Net::SSLeay::CTX_get_cert_store($ctx);
  		for (@{$arg_hash->{SSL_ca}}) {
  		    Net::SSLeay::X509_STORE_add_cert($store,$_) or
  			return IO::Socket::SSL->error(
  			    "Failed to add certificate to CA store");
  		}
  	    }
  	    $dir = join($OPENSSL_LIST_SEPARATOR,@$dir) if ref($dir);
  	    if ( $file || $dir and ! Net::SSLeay::CTX_load_verify_locations(
  		$ctx, $file || '', $dir || '')) {
  		return IO::Socket::SSL->error(
  		    "Invalid certificate authority locations")
  		    if $verify_mode != Net::SSLeay::VERIFY_NONE();
  	    }
  	} elsif ( my %ca = IO::Socket::SSL::default_ca()) {
  	    # no CA path given, continue with system defaults
  	    my $dir = $ca{SSL_ca_path};
  	    $dir = join($OPENSSL_LIST_SEPARATOR,@$dir) if ref($dir);
  	    if (! Net::SSLeay::CTX_load_verify_locations( $ctx,
  		$ca{SSL_ca_file} || '',$dir || '')
  		&& $verify_mode != Net::SSLeay::VERIFY_NONE()) {
  		return IO::Socket::SSL->error(
  		    "Invalid default certificate authority locations")
  	    }
  	}
  
  	if ($arg_hash->{SSL_server}
  	    && ($verify_mode & Net::SSLeay::VERIFY_PEER())) {
  	    if ($arg_hash->{SSL_client_ca}) {
  		for (@{$arg_hash->{SSL_client_ca}}) {
  		    return IO::Socket::SSL->error(
  			"Failed to add certificate to client CA list") if
  			! Net::SSLeay::CTX_add_client_CA($ctx,$_);
  		}
  	    }
  	    if ($arg_hash->{SSL_client_ca_file}) {
  		my $list = Net::SSLeay::load_client_CA_file(
  		    $arg_hash->{SSL_client_ca_file}) or
  		    return IO::Socket::SSL->error(
  		    "Failed to load certificate to client CA list");
  		Net::SSLeay::CTX_set_client_CA_list($ctx,$list);
  	    }
  	}
  
  	my $X509_STORE_flags = $DEFAULT_X509_STORE_flags;
  	if ($arg_hash->{'SSL_check_crl'}) {
  	    $X509_STORE_flags |= Net::SSLeay::X509_V_FLAG_CRL_CHECK();
  	    if ($arg_hash->{'SSL_crl_file'}) {
  		my $bio = Net::SSLeay::BIO_new_file($arg_hash->{'SSL_crl_file'}, 'r');
  		my $crl = Net::SSLeay::PEM_read_bio_X509_CRL($bio);
  		Net::SSLeay::BIO_free($bio);
  		if ( $crl ) {
  		    Net::SSLeay::X509_STORE_add_crl(Net::SSLeay::CTX_get_cert_store($ctx), $crl);
  		} else {
  		    return IO::Socket::SSL->error("Invalid certificate revocation list");
  		}
  	    }
  	}
  
  	Net::SSLeay::X509_STORE_set_flags(
  	    Net::SSLeay::CTX_get_cert_store($ctx),
  	    $X509_STORE_flags
  	) if $X509_STORE_flags;
  
  	Net::SSLeay::CTX_set_default_passwd_cb($ctx,$arg_hash->{SSL_passwd_cb})
  	    if $arg_hash->{SSL_passwd_cb};
  
  	my ($havekey,$havecert);
  	if ( my $x509 = $arg_hash->{SSL_cert} ) {
  	    # binary, e.g. X509*
  	    # we have either a single certificate or a list with
  	    # a chain of certificates
  	    my @x509 = ref($x509) eq 'ARRAY' ? @$x509: ($x509);
  	    my $cert = shift @x509;
  	    Net::SSLeay::CTX_use_certificate( $ctx,$cert )
  		|| return IO::Socket::SSL->error("Failed to use Certificate");
  	    foreach my $ca (@x509) {
  		Net::SSLeay::CTX_add_extra_chain_cert( $ctx,$ca )
  		    || return IO::Socket::SSL->error("Failed to use Certificate");
  	    }
  	    $havecert = 'OBJ';
  	} elsif ( my $f = $arg_hash->{SSL_cert_file} ) {
  	    # try to load chain from PEM or certificate from ASN1
  	    if (Net::SSLeay::CTX_use_certificate_chain_file($ctx,$f)) {
  		$havecert = 'PEM';
  	    } elsif (Net::SSLeay::CTX_use_certificate_file($ctx,$f,FILETYPE_ASN1)) {
  		$havecert = 'DER';
  	    } else {
  		# try to load certificate, key and chain from PKCS12 file
  		my ($key,$cert,@chain) = Net::SSLeay::P_PKCS12_load_file($f,1);
  		if (!$cert and $arg_hash->{SSL_passwd_cb}
  		    and defined( my $pw = $arg_hash->{SSL_passwd_cb}->(0))) {
  		    ($key,$cert,@chain) = Net::SSLeay::P_PKCS12_load_file($f,1,$pw);
  		}
  		PKCS12: while ($cert) {
  		    Net::SSLeay::CTX_use_certificate($ctx,$cert) or last;
  		    for my $ca (@chain) {
  			Net::SSLeay::CTX_add_extra_chain_cert($ctx,$ca)
  			    or last PKCS12;
  		    }
  		    last if $key && ! Net::SSLeay::CTX_use_PrivateKey($ctx,$key);
  		    $havecert = 'PKCS12';
  		    last;
  		}
  		$havekey = 'PKCS12' if $key;
  		Net::SSLeay::X509_free($cert) if $cert;
  		Net::SSLeay::EVP_PKEY_free($key) if $key;
  		# don't free @chain, because CTX_add_extra_chain_cert
  		# did not duplicate the certificates
  	    }
  	    $havecert or return IO::Socket::SSL->error(
  		"Failed to load certificate from file (no PEM, DER or PKCS12)");
  	}
  
  	if (!$havecert || $havekey) {
  	    # skip SSL_key_*
  	} elsif ( my $pkey = $arg_hash->{SSL_key} ) {
  	    # binary, e.g. EVP_PKEY*
  	    Net::SSLeay::CTX_use_PrivateKey($ctx, $pkey)
  		|| return IO::Socket::SSL->error("Failed to use Private Key");
  	    $havekey = 'MEM';
  	} elsif ( my $f = $arg_hash->{SSL_key_file}
  	    || (($havecert eq 'PEM') ? $arg_hash->{SSL_cert_file}:undef) ) {
  	    for my $ft ( FILETYPE_PEM, FILETYPE_ASN1 ) {
  		if (Net::SSLeay::CTX_use_PrivateKey_file($ctx,$f,$ft)) {
  		    $havekey = ($ft == FILETYPE_PEM) ? 'PEM':'DER';
  		    last;
  		}
  	    }
  	    $havekey or return IO::Socket::SSL->error(
  		"Failed to load key from file (no PEM or DER)");
  	}
  
  	# replace arg_hash with created context
  	$ctx{$host} = $ctx;
      }
  
      if ($arg_hash->{'SSL_server'} || $arg_hash->{'SSL_use_cert'}) {
  
  	if ( my $f = $arg_hash->{SSL_dh_file} ) {
  	    my $bio = Net::SSLeay::BIO_new_file( $f,'r' )
  		|| return IO::Socket::SSL->error( "Failed to open DH file $f" );
  	    my $dh = Net::SSLeay::PEM_read_bio_DHparams($bio);
  	    Net::SSLeay::BIO_free($bio);
  	    $dh || return IO::Socket::SSL->error( "Failed to read PEM for DH from $f - wrong format?" );
  	    my $rv;
  	    for (values (%ctx)) {
  		$rv = Net::SSLeay::CTX_set_tmp_dh( $_,$dh ) or last;
  	    }
  	    Net::SSLeay::DH_free( $dh );
  	    $rv || return IO::Socket::SSL->error( "Failed to set DH from $f" );
  	} elsif ( my $dh = $arg_hash->{SSL_dh} ) {
  	    # binary, e.g. DH*
  
  	    for( values %ctx ) {
  		Net::SSLeay::CTX_set_tmp_dh( $_,$dh ) || return 
  		    IO::Socket::SSL->error( "Failed to set DH from SSL_dh" );
  	    }
  	}
  
  	if ( my $curve = $arg_hash->{SSL_ecdh_curve} ) {
  	    return IO::Socket::SSL->_internal_error(
  		"ECDH curve needs Net::SSLeay>=1.56 and OpenSSL>=1.0",9)
  		if ! $can_ecdh;
  	    if ( $curve !~ /^\d+$/ ) {
  		# name of curve, find NID
  		$curve = Net::SSLeay::OBJ_txt2nid($curve)
  		    || return IO::Socket::SSL->error(
  		    "cannot find NID for curve name '$curve'");
  	    }
  	    my $ecdh = Net::SSLeay::EC_KEY_new_by_curve_name($curve) or
  		return IO::Socket::SSL->error(
  		"cannot create curve for NID $curve");
  	    for( values %ctx ) {
  		Net::SSLeay::CTX_set_tmp_ecdh($_,$ecdh) or
  		    return IO::Socket::SSL->error(
  		    "failed to set ECDH curve context");
  	    }
  	    Net::SSLeay::EC_KEY_free($ecdh);
  	}
      }
  
      my $verify_cb = $arg_hash->{SSL_verify_callback};
      my @accept_fp;
      if ( my $fp = $arg_hash->{SSL_fingerprint} ) {
  	for( ref($fp) ? @$fp : $fp) {
  	    my ($algo,$digest) = m{^([\w-]+)\$([a-f\d:]+)$}i;
  	    return IO::Socket::SSL->_internal_error("invalid fingerprint '$_'",9)
  		if ! $algo;
  	    $algo = lc($algo);
  	    ( $digest = lc($digest) ) =~s{:}{}g;
  	    push @accept_fp,[ $algo, pack('H*',$digest) ]
  	}
      }
      my $verify_fingerprint = @accept_fp && do {
  	my $fail;
  	sub {
  	    my ($ok,$cert,$depth) = @_;
  	    $fail = 1 if ! $ok;
  	    return 1 if $depth>0; # to let us continue with verification
  	    # Check fingerprint only from top certificate.
  	    my %fp;
  	    for(@accept_fp) {
  		my $fp = $fp{$_->[0]} ||=
  		    Net::SSLeay::X509_digest($cert,$algo2digest->($_->[0]));
  		next if $fp ne $_->[1];
  		return 1;
  	    }
  	    return ! $fail;
  	}
      };
      my $verify_callback = ( $verify_cb || @accept_fp ) && sub {
  	my ($ok, $ctx_store) = @_;
  	my ($certname,$cert,$error,$depth);
  	if ($ctx_store) {
  	    $cert  = Net::SSLeay::X509_STORE_CTX_get_current_cert($ctx_store);
  	    $error = Net::SSLeay::X509_STORE_CTX_get_error($ctx_store);
  	    $depth = Net::SSLeay::X509_STORE_CTX_get_error_depth($ctx_store);
  	    $certname =
  		Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_issuer_name($cert)).
  		Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_subject_name($cert));
  	    $error &&= Net::SSLeay::ERR_error_string($error);
  	}
  	$DEBUG>=3 && DEBUG( "ok=$ok [$depth] $certname" );
  	$ok = $verify_cb->($ok,$ctx_store,$certname,$error,$cert,$depth) if $verify_cb;
  	$ok = $verify_fingerprint->($ok,$cert,$depth) if $verify_fingerprint && $cert;
  	return $ok;
      };
  
      if ( $^O eq 'darwin' ) {
  	# explicitly set error code to disable use of apples TEA patch
  	# https://hynek.me/articles/apple-openssl-verification-surprises/
  	my $vcb = $verify_callback;
  	$verify_callback = sub {
  	    my $rv = $vcb ? &$vcb : $_[0];
  	    if ( $rv != 1 ) {
  		# 50 - X509_V_ERR_APPLICATION_VERIFICATION: application verification failure
  		Net::SSLeay::X509_STORE_CTX_set_error($_[1], 50);
  	    }
  	    return $rv;
  	};
      }
      Net::SSLeay::CTX_set_verify($_, $verify_mode, $verify_callback)
  	for (values %ctx);
  
      my $staple_callback = $arg_hash->{SSL_ocsp_staple_callback};
      if ( !$is_server && $can_ocsp_staple ) {
  	$self->{ocsp_cache} = $arg_hash->{SSL_ocsp_cache};
  	my $status_cb = sub {
  	    my ($ssl,$resp) = @_;
  	    my $iossl = $SSL_OBJECT{$ssl} or
  		die "no IO::Socket::SSL object found for SSL $ssl";
  	    $iossl->[1] and do {
  		# we must return with 1 or it will be called again
  		# and because we have no SSL object we must make the error global
  		Carp::cluck($IO::Socket::SSL::SSL_ERROR
  		    = "OCSP callback on server side");
  		return 1;
  	    };
  	    $iossl = $iossl->[0];
  
  	    # if we have a callback use this
  	    # callback must not free or copy $resp !!
  	    if ( $staple_callback ) {
  		$staple_callback->($iossl,$resp);
  		return 1;
  	    }
  
  	    # default callback does verification
  	    if ( ! $resp ) {
  		$DEBUG>=3 && DEBUG("did not get stapled OCSP response");
  		return 1;
  	    }
  	    $DEBUG>=3 && DEBUG("got stapled OCSP response");
  	    my $status = Net::SSLeay::OCSP_response_status($resp);
  	    if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
  		$DEBUG>=3 && DEBUG("bad status of stapled OCSP response: ".
  		    Net::SSLeay::OCSP_response_status_str($status));
  		return 1;
  	    }
  	    if (!eval { Net::SSLeay::OCSP_response_verify($ssl,$resp) }) {
  		$DEBUG>=3 && DEBUG("verify of stapled OCSP response failed");
  		return 1;
  	    }
  	    my (@results,$hard_error);
  	    my @chain = $iossl->peer_certificates;
  	    for my $cert (@chain) {
  		my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) };
  		if (!$certid) {
  		    $DEBUG>=3 && DEBUG("cannot create OCSP_CERTID: $@");
  		    push @results,[-1,$@];
  		    last;
  		}
  		($status) = Net::SSLeay::OCSP_response_results($resp,$certid);
  		if ($status && $status->[2]) {
  		    my $cache = ${*$iossl}{_SSL_ctx}{ocsp_cache};
  		    if (!$status->[1]) {
  			push @results,[1,$status->[2]{nextUpdate}];
  			$cache && $cache->put($certid,$status->[2]);
  		    } elsif ( $status->[2]{statusType} ==
  			Net::SSLeay::V_OCSP_CERTSTATUS_GOOD()) {
  			push @results,[1,$status->[2]{nextUpdate}];
  			$cache && $cache->put($certid,{
  			    %{$status->[2]},
  			    expire => time()+120,
  			    soft_error => $status->[1],
  			});
  		    } else {
  			push @results,($hard_error = [0,$status->[1]]);
  			$cache && $cache->put($certid,{
  			    %{$status->[2]},
  			    hard_error => $status->[1],
  			});
  		    }
  		}
  	    }
  	    # return result of lead certificate, this should be in chain[0] and
  	    # thus result[0], but we better check. But if we had any hard_error
  	    # return this instead
  	    if ($hard_error) {
  		${*$iossl}{_SSL_ocsp_verify} = $hard_error;
  	    } elsif (@results and $chain[0] == $iossl->peer_certificate) {
  		${*$iossl}{_SSL_ocsp_verify} = $results[0];
  	    }
  	    return 1;
  	};
  	Net::SSLeay::CTX_set_tlsext_status_cb($_,$status_cb) for (values %ctx);
      }
  
      if ( my $cl = $arg_hash->{SSL_cipher_list} ) {
  	for (keys %ctx) {
  	    Net::SSLeay::CTX_set_cipher_list($ctx{$_}, ref($cl) 
  		? $cl->{$_} || $cl->{''} || $DEFAULT_SSL_ARGS{SSL_cipher_list} || next 
  		: $cl
  	    ) || return IO::Socket::SSL->error("Failed to set SSL cipher list");
  	}
      }
  
      # Main context is default context or any other if no default context.
      my $ctx = $ctx{''} || (values %ctx)[0];
      if (keys(%ctx) > 1 || ! exists $ctx{''}) {
  	$can_server_sni or return IO::Socket::SSL->_internal_error(
  	    "Server side SNI not supported for this openssl/Net::SSLeay",9);
  
  	Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, sub {
  	    my $ssl = shift;
  	    my $host = Net::SSLeay::get_servername($ssl);
  	    $host = '' if ! defined $host;
  	    my $snictx = $ctx{lc($host)} || $ctx{''} or do {
  		$DEBUG>1 and DEBUG(
  		    "cannot get context from servername '$host'");
  		return 0;
  	    };
  	    $DEBUG>1 and DEBUG("set context from servername $host");
  	    Net::SSLeay::set_SSL_CTX($ssl,$snictx) if $snictx != $ctx;
  	    return 1;
  	});
      }
  
      if ( my $cb = $arg_hash->{SSL_create_ctx_callback} ) {
  	$cb->($_) for values (%ctx);
      }
  
      $self->{context} = $ctx;
      $self->{verify_mode} = $arg_hash->{SSL_verify_mode};
      $self->{ocsp_mode} =
  	defined($arg_hash->{SSL_ocsp_mode}) ? $arg_hash->{SSL_ocsp_mode} :
  	$self->{verify_mode} ? IO::Socket::SSL::SSL_OCSP_TRY_STAPLE() :
  	0;
      $DEBUG>=3 && DEBUG( "new ctx $ctx" );
  
      if ( my $cache = $arg_hash->{SSL_session_cache} ) {
  	# use predefined cache
  	$self->{session_cache} = $cache
      } elsif ( my $size = $arg_hash->{SSL_session_cache_size}) {
  	$self->{session_cache} = IO::Socket::SSL::Session_Cache->new( $size );
      }
  
      return $self;
  }
  
  
  sub session_cache {
      my $self = shift;
      my $cache = $self->{session_cache} || return;
      my ($addr,$port,$session) = @_;
      $port ||= $addr =~s{:(\w+)$}{} && $1; # host:port
      my $key = "$addr:$port";
      return defined($session)
  	? $cache->add_session($key, $session)
  	: $cache->get_session($key);
  }
  
  sub has_session_cache {
      return defined shift->{session_cache};
  }
  
  
  sub CLONE { %CTX_CREATED_IN_THIS_THREAD = (); }
  sub DESTROY {
      my $self = shift;
      if ( my $ctx = $self->{context} ) {
  	$DEBUG>=3 && DEBUG("free ctx $ctx open=".join( " ",keys %CTX_CREATED_IN_THIS_THREAD ));
  	if ( %CTX_CREATED_IN_THIS_THREAD and
  	    delete $CTX_CREATED_IN_THIS_THREAD{$ctx} ) {
  	    # remove any verify callback for this context
  	    if ( $self->{verify_mode}) {
  		$DEBUG>=3 && DEBUG("free ctx $ctx callback" );
  		Net::SSLeay::CTX_set_verify($ctx, 0,undef);
  	    }
  	    if ( $self->{ocsp_error_ref}) {
  		$DEBUG>=3 && DEBUG("free ctx $ctx tlsext_status_cb" );
  		Net::SSLeay::CTX_set_tlsext_status_cb($ctx,undef);
  	    }
  	    $DEBUG>=3 && DEBUG("OK free ctx $ctx" );
  	    Net::SSLeay::CTX_free($ctx);
  	}
      }
      delete(@{$self}{'context','session_cache'});
  }
  
  package IO::Socket::SSL::Session_Cache;
  use strict;
  
  sub new {
      my ($class, $size) = @_;
      $size>0 or return;
      return bless { _maxsize => $size }, $class;
  }
  
  
  sub get_session {
      my ($self, $key) = @_;
      my $session = $self->{$key} || return;
      return $session->{session} if ($self->{'_head'} eq $session);
      $session->{prev}->{next} = $session->{next};
      $session->{next}->{prev} = $session->{prev};
      $session->{next} = $self->{'_head'};
      $session->{prev} = $self->{'_head'}->{prev};
      $self->{'_head'}->{prev} = $self->{'_head'}->{prev}->{next} = $session;
      $self->{'_head'} = $session;
      return $session->{session};
  }
  
  sub add_session {
      my ($self, $key, $val) = @_;
      return if ($key eq '_maxsize' or $key eq '_head');
  
      if ( my $have = $self->{$key} ) {
  	Net::SSLeay::SESSION_free( $have->{session} );
  	$have->{session} = $val;
  	return get_session($self,$key); # will put key on front
      }
  
      my $session = $self->{$key} = { session => $val, key => $key };
  
      if ( keys(%$self) > $self->{_maxsize}+2) {
  	my $last = $self->{'_head'}->{prev};
  	Net::SSLeay::SESSION_free($last->{session});
  	delete($self->{$last->{key}});
  	$self->{'_head'}->{prev} = $self->{'_head'}->{prev}->{prev};
  	delete($self->{'_head'}) if ($self->{'_maxsize'} == 1);
      }
  
      if ($self->{'_head'}) {
  	$session->{next} = $self->{'_head'};
  	$session->{prev} = $self->{'_head'}->{prev};
  	$self->{'_head'}->{prev}->{next} = $session;
  	$self->{'_head'}->{prev} = $session;
      } else {
  	$session->{next} = $session->{prev} = $session;
      }
      $self->{'_head'} = $session;
      return $session;
  }
  
  sub DESTROY {
      my $self = shift;
      delete(@{$self}{'_head','_maxsize'});
      for (values %$self) {
  	Net::SSLeay::SESSION_free($_->{session} || next);
      }
  }
  
  
  
  package IO::Socket::SSL::OCSP_Cache;
  
  sub new {
      my ($class,$size) = @_;
      return bless {
  	'' => { _lru => 0, size => $size || 100 }
      },$class;
  }
  sub get {
      my ($self,$id) = @_;
      my $e = $self->{$id} or return;
      $e->{_lru} = $self->{''}{_lru}++;
      if ( $e->{expire} && time()<$e->{expire}) {
  	delete $self->{$id};
  	return;
      }
      if ( $e->{nextUpdate} && time()<$e->{nextUpdate} ) {
  	delete $self->{$id};
  	return;
      }
      return $e;
  }
  
  sub put {
      my ($self,$id,$e) = @_;
      $self->{$id} = $e;
      $e->{_lru} = $self->{''}{_lru}++;
      my $del = keys(%$self) - $self->{''}{size};
      if ($del>0) {
  	my @k = sort { $self->{$a}{_lru} <=> $self->{$b}{_lru} } keys %$self;
  	delete @{$self}{ splice(@k,0,$del) };
      }
      return $e;
  }
  
  package IO::Socket::SSL::OCSP_Resolver;
  *DEBUG = *IO::Socket::SSL::DEBUG;
  
  # create a new resolver
  # $ssl - the ssl object
  # $cache - OCSP_Cache object (put,get)
  # $failhard - flag if we should fail hard on OCSP problems
  # $certs - list of certs to verify
  sub new {
      my ($class,$ssl,$cache,$failhard,$certs) = @_;
      my (%todo,$done,$hard_error,@soft_error);
      for my $cert (@$certs) {
  	# skip entries which have no OCSP uri or where we cannot get a certid
  	# (e.g. self-signed or where we don't have the issuer)
  	my $subj = Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_subject_name($cert));
  	my $uri = Net::SSLeay::P_X509_get_ocsp_uri($cert) or do {
  	    $DEBUG>2 && DEBUG("no URI for certificate $subj");
  	    push @soft_error,"no ocsp_uri for $subj";
  	    next;
  	};
  	my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) } or do {
  	    $DEBUG>2 && DEBUG("no OCSP_CERTID for certificate $subj: $@");
  	    push @soft_error,"no certid for $subj: $@";
  	    next;
  	};
  	if (!($done = $cache->get($certid))) {
  	    push @{ $todo{$uri}{ids} }, $certid;
  	    push @{ $todo{$uri}{subj} }, $subj;
  	} elsif ( $done->{hard_error} ) {
  	    # one error is enough to fail validation
  	    $hard_error = $done->{hard_error};
  	    %todo = ();
  	    last;
  	} elsif ( $done->{soft_error} ) {
  	    push @soft_error,$done->{soft_error};
  	}
      }
      while ( my($uri,$v) = each %todo) {
  	my $ids = $v->{ids};
  	$v->{req} = Net::SSLeay::i2d_OCSP_REQUEST(
  	    Net::SSLeay::OCSP_ids2req(@$ids));
      }
      $hard_error ||= '' if ! %todo;
      return bless {
  	ssl => $ssl,
  	cache => $cache,
  	failhard => $failhard,
  	hard_error => $hard_error,
  	soft_error => @soft_error ? join("; ",@soft_error) : undef,
  	todo => \%todo,
      },$class;
  }
  
  # return current result, e.g. '' for no error, else error
  # if undef we have no final result yet
  sub hard_error { return shift->{hard_error} }
  sub soft_error { return shift->{soft_error} }
  
  # return hash with uri => ocsp_request_data for open requests
  sub requests {
      my $todo = shift()->{todo};
      return map { ($_,$todo->{$_}{req}) } keys %$todo;
  }
  
  # add new response
  sub add_response {
      my ($self,$uri,$resp) = @_;
      my $todo = delete $self->{todo}{$uri};
      return $self->{error} if ! $todo || $self->{error};
  
      my ($req,@soft_error,@hard_error);
  
      # do we have a response
      if (!$resp) {
  	@soft_error = "http request for OCSP failed; subject: ".
  	    join("; ",@{$todo->{subj}});
  
      # is it an valid OCSP_RESPONSE
      } elsif ( ! eval { $resp = Net::SSLeay::d2i_OCSP_RESPONSE($resp) }) {
  	@soft_error = "invalid response (no OCSP_RESPONSE); subject: ".
  	    join("; ",@{$todo->{subj}});
  	# hopefully short-time error
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+10,
  	}) for (@{$todo->{ids}});
      # is the OCSP response status success
      } elsif (
  	( my $status = Net::SSLeay::OCSP_response_status($resp))
  	    != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()
      ){
  	@soft_error = "OCSP response failed: ".
  	    Net::SSLeay::OCSP_response_status_str($status).
  	    "; subject: ".join("; ",@{$todo->{subj}});
  	# hopefully short-time error
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+10,
  	}) for (@{$todo->{ids}});
  
      # does nonce match the request and can the signature be verified
      } elsif ( ! eval {
  	$req = Net::SSLeay::d2i_OCSP_REQUEST($todo->{req});
  	Net::SSLeay::OCSP_response_verify($self->{ssl},$resp,$req);
      }) {
  	if ($@) {
  	    @soft_error = $@
  	} else {
  	    my @err;
  	    while ( my $err = Net::SSLeay::ERR_get_error()) {
  		push @soft_error, Net::SSLeay::ERR_error_string($err);
  	    }
  	    @soft_error = 'failed to verify OCSP response; subject: '.
  		join("; ",@{$todo->{subj}}) if ! @soft_error;
  	}
  	# configuration problem or we don't know the signer
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+120,
  	}) for (@{$todo->{ids}});
  
      # extract results from response
      } elsif ( my @result =
  	Net::SSLeay::OCSP_response_results($resp,@{$todo->{ids}})) {
  	my (@found,@miss);
  	for my $rv (@result) {
  	    if ($rv->[2]) {
  		push @found,$rv->[0];
  		if (!$rv->[1]) {
  		    # no error
  		    $self->{cache}->put($rv->[0],$rv->[2]);
  		} elsif ( $rv->[2]{statusType} ==
  		    Net::SSLeay::V_OCSP_CERTSTATUS_GOOD()) {
  		    # soft error, like response after nextUpdate
  		    push @soft_error,$rv->[1]."; subject: ".
  			join("; ",@{$todo->{subj}});
  		    $self->{cache}->put($rv->[0],{
  			%{$rv->[2]},
  			soft_error => "@soft_error",
  			expire => time()+120,
  		    });
  		} else {
  		    # hard error
  		    $self->{cache}->put($rv->[0],$rv->[2]);
  		    push @hard_error, $rv->[1]."; subject: ".
  			join("; ",@{$todo->{subj}});
  		}
  	    } else {
  		push @miss,$rv->[0];
  	    }
  	}
  	if (@miss && @found) {
  	    # we sent multiple responses, but server answered only to one
  	    # try again
  	    $self->{todo}{$uri} = $todo;
  	    $todo->{ids} = \@miss;
  	    $todo->{req} = Net::SSLeay::i2d_OCSP_REQUEST(
  		Net::SSLeay::OCSP_ids2req(@miss));
  	    $DEBUG>=2 && DEBUG("$uri just answered ".@found." of ".(@found+@miss)." requests");
  	}
      } else {
  	@soft_error = "no data in response; subject: ".
  	    join("; ",@{$todo->{subj}});
  	# probably configuration problem
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+120,
  	}) for (@{$todo->{ids}});
      }
  
      Net::SSLeay::OCSP_REQUEST_free($req) if $req;
      if ($self->{failhard}) {
  	push @hard_error,@soft_error;
  	@soft_error = ();
      }
      if (@soft_error) {
  	$self->{soft_error} .= "; " if $self->{soft_error};
  	$self->{soft_error} .= "$uri: ".join('; ',@soft_error);
      }
      if (@hard_error) {
  	$self->{hard_error} = "$uri: ".join('; ',@hard_error);
  	%{$self->{todo}} = ();
      } elsif ( ! %{$self->{todo}} ) {
  	$self->{hard_error} = ''
      }
      return $self->{hard_error};
  }
  
  # make all necessary requests to get OCSP responses blocking
  sub resolve_blocking {
      my ($self,%args) = @_;
      while ( my %todo = $self->requests ) {
  	eval { require HTTP::Tiny } or die "need HTTP::Tiny installed";
  	# OCSP responses have their own signature, so we don't need SSL verification
  	my $ua = HTTP::Tiny->new(verify_SSL => 0,%args);
  	while (my ($uri,$reqdata) = each %todo) {
  	    $DEBUG && DEBUG("sending OCSP request to $uri");
  	    my $resp = $ua->request('POST',$uri, {
  		headers => { 'Content-type' => 'application/ocsp-request' },
  		content => $reqdata
  	    });
  	    $DEBUG && DEBUG("got  OCSP response from $uri code=$resp->{status}");
  	    defined ($self->add_response($uri,
  		$resp->{success} && $resp->{content}))
  		&& last;
  	}
      }
      $DEBUG>=2 && DEBUG("no more open OCSP requests");
      return $self->{hard_error};
  }
  
  1;
  
  __END__
IO_SOCKET_SSL

$fatpacked{"IO/Socket/SSL/Intercept.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_INTERCEPT';
  
  package IO::Socket::SSL::Intercept;
  use strict;
  use warnings;
  use Carp 'croak';
  use IO::Socket::SSL::Utils;
  use Net::SSLeay;
  
  our $VERSION = '2.014';
  
  sub new {
      my ($class,%args) = @_;
  
      my $cacert = delete $args{proxy_cert};
      if ( ! $cacert ) {
  	if ( my $f = delete $args{proxy_cert_file} ) {
  	    $cacert = PEM_file2cert($f);
  	} else {
  	    croak "no proxy_cert or proxy_cert_file given";
  	}
      }
  
      my $cakey  = delete $args{proxy_key};
      if ( ! $cakey ) {
  	if ( my $f = delete $args{proxy_key_file} ) {
  	    $cakey = PEM_file2key($f);
  	} else {
  	    croak "no proxy_cert or proxy_cert_file given";
  	}
      }
  
      my $certkey = delete $args{cert_key};
      if ( ! $certkey ) {
  	if ( my $f = delete $args{cert_key_file} ) {
  	    $certkey = PEM_file2key($f);
  	}
      }
  
      my $cache = delete $args{cache} || {};
  
      my $self = bless {
  	cacert => $cacert,
  	cakey => $cakey,
  	certkey => $certkey,
  	serial => delete $args{serial} || 1,
  	cache => $cache,
      };
      return $self;
  }
  
  sub DESTROY {
      # call various ssl _free routines
      my $self = shift or return;
      for ( \$self->{cacert}, 
  	map { \$_->{cert} } ref($self->{cache}) ne 'CODE' ? values %{$self->{cache}} :()) {
  	$$_ or next;
  	CERT_free($$_);
  	$$_ = undef;
      }
      for ( \$self->{cakey}, \$self->{pubkey} ) {
  	$$_ or next;
  	KEY_free($$_);
  	$$_ = undef;
      }
  }
  
  sub clone_cert {
      my ($self,$old_cert,$clone_key) = @_;
  
      $clone_key ||= substr(unpack("H*",Net::SSLeay::X509_get_fingerprint($old_cert,'sha1')),0,16);
      if ( my ($clone,$key) = _get_cached($self,$clone_key)) {
  	return ($clone,$key);
      }
  
      # create new certificate based on original
      # copy most but not all extensions
      my $hash = CERT_asHash($old_cert);
      if (my $ext = $hash->{ext}) {
  	@$ext = grep {
  	    defined($_->{sn}) && $_->{sn} !~m{^(?:
  		authorityInfoAccess    |
  		subjectKeyIdentifier   |
  		authorityKeyIdentifier |
  		certificatePolicies    |
  		crlDistributionPoints
  	    )$}x
  	} @$ext;
      }
      my ($clone,$key) = CERT_create(
  	%$hash,
  	serial => $self->{serial}++,
  	issuer_cert => $self->{cacert},
  	issuer_key => $self->{cakey},
  	key => $self->{certkey},
      );
  
      # put into cache
      _set_cached($self,$clone_key,$clone,$key);
  
      return ($clone,$key);
  }
  
  sub _get_cached {
      my ($self,$clone_key) = @_;
      my $c = $self->{cache};
      return $c->($clone_key) if ref($c) eq 'CODE';
      my $e = $c->{$clone_key} or return;
      $e->{atime} = time();
      return ($e->{cert},$e->{key} || $self->{certkey});
  }
  
  sub _set_cached {
      my ($self,$clone_key,$cert,$key) = @_;
      my $c = $self->{cache};
      return $c->($clone_key,$cert,$key) if ref($c) eq 'CODE';
      $c->{$clone_key} = { 
  	cert => $cert, 
  	$self->{certkey} && $self->{certkey} == $key ? () : ( key => $key ),
  	atime => time() 
      };
  }
  
  
  sub STORABLE_freeze { my $self = shift; $self->serialize() }
  sub STORABLE_thaw   { my ($class,undef,$data) = @_; $class->unserialize($data) }
  
  sub serialize {
      my $self = shift;
      my $data = pack("N",2); # version
      $data .= pack("N/a", PEM_cert2string($self->{cacert}));
      $data .= pack("N/a", PEM_key2string($self->{cakey}));
      if ( $self->{certkey} ) {
  	$data .= pack("N/a", PEM_key2string($self->{certkey}));
      } else {
  	$data .= pack("N/a", '');
      }
      $data .= pack("N",$self->{serial});
      if ( ref($self->{cache}) eq 'HASH' ) {
  	while ( my($k,$v) = each %{ $self->{cache}} ) {
  	    $data .= pack("N/aN/aN/aN", $k,
  		PEM_cert2string($k->{cert}),
  		$k->{key} ? PEM_key2string($k->{key}) : '',
  		$k->{atime});
  	}
      }
      return $data;
  }
  
  sub unserialize {
      my ($class,$data) = @_;
      unpack("N",substr($data,0,4,'')) == 2 or 
  	croak("serialized with wrong version");
      ( my $cacert,my $cakey,my $certkey,my $serial,$data) 
  	= unpack("N/aN/aN/aNa*",$data);
      my $self = bless {
  	serial => $serial,
  	cacert => PEM_string2cert($cacert),
  	cakey => PEM_string2key($cakey),
  	$certkey ? ( certkey => PEM_string2key($certkey)):(),
      }, ref($class)||$class;
  
      $self->{cache} = {} if $data ne '';
      while ( $data ne '' ) {
  	(my $key,my $cert,my $certkey, my $atime,$data) = unpack("N/aN/aNa*",$data);
  	$self->{cache}{$key} = { 
  	    cert => PEM_string2cert($cert), 
  	    $key ? ( key => PEM_string2key($certkey)):(),
  	    atime => $atime 
  	};
      }
      return $self;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::SSL::Intercept -- SSL interception (man in the middle)
  
  =head1 SYNOPSIS
  
      use IO::Socket::SSL::Intercept;
      # create interceptor with proxy certificates
      my $mitm = IO::Socket::SSL::Intercept->new(
  	proxy_cert_file => 'proxy_cert.pem',
  	proxy_key_file  => 'proxy_key.pem',
  	...
      );
      my $listen = IO::Socket::INET->new( LocalAddr => .., Listen => .. );
      while (1) {
  	# TCP accept new client
  	my $client = $listen->accept or next;
  	# SSL connect to server
  	my $server = IO::Socket::SSL->new(
  	    PeerAddr => ..,
  	    SSL_verify_mode => ...,
  	    ...
  	) or die "ssl connect failed: $!,$SSL_ERROR";
  	# clone server certificate
  	my ($cert,$key) = $mitm->clone_cert( $server->peer_certificate );
  	# and upgrade client side to SSL with cloned certificate
  	IO::Socket::SSL->start_SSL($client,
  	    SSL_server => 1,
  	    SSL_cert => $cert,
  	    SSL_key => $key
  	) or die "upgrade failed: $SSL_ERROR";
  	# now transfer data between $client and $server and analyze
  	# the unencrypted data
  	...
      }
  
  
  =head1 DESCRIPTION
  
  This module provides functionality to clone certificates and sign them with a
  proxy certificate, thus making it easy to intercept SSL connections (man in the
  middle). It also manages a cache of the generated certificates.
  
  =head1 How Intercepting SSL Works
  
  Intercepting SSL connections is useful for analyzing encrypted traffic for
  security reasons or for testing. It does not break the end-to-end security of
  SSL, e.g. a properly written client will notice the interception unless you
  explicitly configure the client to trust your interceptor.
  Intercepting SSL works the following way:
  
  =over 4
  
  =item *
  
  Create a new CA certificate, which will be used to sign the cloned certificates.
  This proxy CA certificate should be trusted by the client, or (a properly
  written client) will throw error messages or deny the connections because it
  detected a man in the middle attack.
  Due to the way the interception works there no support for client side
  certificates is possible.
  
  Using openssl such a proxy CA certificate and private key can be created with:
  
    openssl genrsa -out proxy_key.pem 1024
    openssl req -new -x509 -extensions v3_ca -key proxy_key.pem -out proxy_cert.pem
    # export as PKCS12 for import into browser
    openssl pkcs12 -export -in proxy_cert.pem -inkey proxy_key.pem -out proxy_cert.p12
  
  =item * 
  
  Configure client to connect to use intercepting proxy or somehow redirect
  connections from client to the proxy (e.g. packet filter redirects, ARP or DNS
  spoofing etc).
  
  =item *
  
  Accept the TCP connection from the client, e.g. don't do any SSL handshakes with
  the client yet.
  
  =item *
  
  Establish the SSL connection to the server and verify the servers certificate as
  usually. Then create a new certificate based on the original servers
  certificate, but signed by your proxy CA.
  This is the step where IO::Socket::SSL::Intercept helps.
  
  =item *
  
  Upgrade the TCP connection to the client to SSL using the cloned certificate
  from the server. If the client trusts your proxy CA it will accept the upgrade
  to SSL.
  
  =item *
  
  Transfer data between client and server. While the connections to client and
  server are both encrypted with SSL you will read/write the unencrypted data in
  your proxy application.
  
  =back
  
  =head1 METHODS 
  
  IO::Socket::SSL::Intercept helps creating the cloned certificate with the
  following methods:
  
  =over 4
  
  =item B<< $mitm = IO::Socket::SSL::Intercept->new(%args) >>
  
  This creates a new interceptor object. C<%args> should be
  
  =over 8
  
  =item proxy_cert X509 | proxy_cert_file filename
  
  This is the proxy certificate.
  It can be either given by an X509 object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  
  =item proxy_key EVP_PKEY | proxy_key_file filename
  
  This is the key for the proxy certificate.
  It can be either given by an EVP_PKEY object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  The key should not have a passphrase.
  
  =item pubkey EVP_PKEY | pubkey_file filename
  
  This optional argument specifies the public key used for the cloned certificate.
  It can be either given by an EVP_PKEY object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  If not given it will create a new public key on each call of C<new>.
  
  =item serial INTEGER
  
  This optional argument gives the starting point for the serial numbers of the
  newly created certificates. Default to 1.
  
  =item cache HASH | SUBROUTINE
  
  This optional argument gives a way to cache created certificates, so that they
  don't get recreated on future accesses to the same host.
  If the argument ist not given an internal HASH ist used.
  
  If the argument is a hash it will store for each generated certificate a hash
  reference with C<cert> and C<atime> in the hash, where C<atime> is the time of
  last access (to expire unused entries) and C<cert> is the certificate. Please
  note, that the certificate is in L<Net::SSLeay>s internal X509 format and can
  thus not be simply dumped and restored.
  The key for the hash is an C<ident> either given to C<clone_cert> or generated
  from the original certificate.
  
  If the argument is a subroutine it will be called as C<< $cache->(ident) >>
  to get an existing (cert,key) and with C<< $cache->(ident,cert,key) >> to cache
  the newly created certificate.
  
  =back
  
  =item B<< ($clone_cert,$key) = $mitm->clone_cert($original_cert,[ $ident ]) >>
  
  This clones the given certificate.
  An ident as the key into the cache can be given (like C<host:port>), if not it
  will be created from the properties of the original certificate.
  It returns the cloned certificate and its key (which is the same for alle
  created certificates).
  
  =item B<< $string = $mitm->serialize >>
  
  This creates a serialized version of the object (e.g. a string) which can then
  be used to persistantly store created certificates over restarts of the
  application. The cache will only be serialized if it is a HASH.
  To work together with L<Storable> the C<STORABLE_freeze> function is defined to
  call C<serialize>.
  
  =item B<< $mitm = IO::Socket::SSL::Intercept->unserialize($string) >>
  
  This restores an Intercept object from a serialized string.
  To work together with L<Storable> the C<STORABLE_thaw> function is defined to
  call C<unserialize>.
  
  =back
  
  =head1 AUTHOR
  
  Steffen Ullrich
IO_SOCKET_SSL_INTERCEPT

$fatpacked{"IO/Socket/SSL/PublicSuffix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_PUBLICSUFFIX';
  
  use strict;
  use warnings;
  package IO::Socket::SSL::PublicSuffix;
  use Carp;
  
  # for updates
  use constant URL => 'http://publicsuffix.org/list/effective_tld_names.dat';
  
  =head1 NAME
  
  IO::Socket::SSL::PublicSuffix - provide access to Mozilla's list of effective TLD names
  
  =head1 SYNOPSIS
  
      # use builtin default
      use IO::Socket::SSL::PublicSuffix;
      $ps = IO::Socket::SSL::PublicSuffix->default;
  
      # load from string
      $ps = IO::Socket::SSL::PublicSuffix->from_string("*.uk\n*");
  
      # load from file or file handle
      $ps = IO::Socket::SSL::PublicSuffix->from_file($filename);
      $ps = IO::Socket::SSL::PublicSuffix->from_file(\*STDIN);
  
  
      # --- string in -> string out
      # $rest -> whatever.host
      # $tld  -> co.uk
      my ($rest,$tld) = $ps->public_suffix('whatever.host.co.uk');
      my $tld = $ps->public_suffix('whatever.host.co.uk');
  
      # $root_domain -> host.co.uk
      my $root_domain = $ps->public_suffix('whatever.host.co.uk', 1);
  
      # --- array in -> array out
      # $rest -> [qw(whatever host)]
      # $tld  -> [qw(co uk)]
      my ($rest,$tld) = $ps->public_suffix([qw(whatever host co uk)]);
  
   ----
  
      # To update this file with the current list:
      perl -MIO::Socket::SSL::PublicSuffix -e 'IO::Socket::SSL::PublicSuffix::update_self_from_url()'
  
  
  
  =head1 DESCRIPTION
  
  This module uses the list of effective top level domain names from the mozilla
  project to determine the public top level domain for a given hostname.
  
  =head2 Method
  
  =over 4
  
  =item class->default(%args)
  
  Returns object with builtin default.
  C<min_suffix> can be given in C<%args> to specify the minimal suffix, default
  is 1.
  
  =item class->from_string(string,%args)
  
  Returns object with configuration from string.
  See method C<default> for C<%args>.
  
  =item class->from_file( file name| file handle, %args )
  
  Returns object with configuration from file or file handle.
  See method C<default> for C<%args>.
  
  =item $self->public_suffix( $host|\@host, [ $add ] )
  
  In array context the function returns the non-tld part and the tld part of the
  given hostname, in scalar context only the tld part.
  It adds C<$add> parts of the non-tld part to the tld, e.g. with C<$add=1> it
  will return the root domain.
  
  If there were no explicit matches against the public suffix configuration it
  will fall back to a suffix of length 1.
  
  The function accepts a string or an array-ref (e.g. host split by C<.>). In the
  first case it will return string(s), in the latter case array-ref(s).
  
  International hostnames or labels can be in ASCII (IDNA form starting with
  C<xn-->) or unicode. In the latter case an IDNA handling library like
  L<Net::IDN:::Encode>, L<Net::LibIDN> or recent versions of L<URI> need to be
  installed.
  
  =item ($self|class)->can_idn
  
  Returns true if IDN support is available.
  
  =back
  
  =head1 FILES
  
  http://publicsuffix.org/list/effective_tld_names.dat
  
  =head1 SEE ALSO
  
  Domain::PublicSuffix, Mozilla::PublicSuffix
  
  =head1 BUGS
  
   Q: Why yet another module, we already have L<Domain::PublicSuffix> and
      L<Mozilla::PublicSuffix>.
   A: Because the public suffix data change more often than these modules do,
      IO::Socket::SSL needs this list and it is more easy this way to keep it
      up-to-date.
  
  
  =head1 AUTHOR
  
  Steffen Ullrich
  
  =cut
  
  
  BEGIN {
      if ( eval {
  	require URI::_idna;
  	defined &URI::_idna::encode && defined &URI::_idna::decode
      }) {
  	*idn_to_ascii   = \&URI::_idna::encode;
  	*idn_to_unicode = \&URI::_idna::decode;
  	*can_idn = sub { 1 };
      } elsif ( eval { require Net::IDN::Encode } ) {
  	*idn_to_ascii   = \&Net::IDN::Encode::domain_to_ascii;
  	*idn_to_unicode = \&Net::IDN::Encode::domain_to_unicode;
  	*can_idn = sub { 1 };
      } elsif ( eval { require Net::LibIDN; require Encode } ) {
  	# Net::LibIDN does not use utf-8 flag and expects raw data
  	*idn_to_ascii   = sub { 
  	    Net::LibIDN::idn_to_ascii(Encode::encode('utf-8',$_[0]),'utf-8');
  	},
  	*idn_to_unicode = sub { 
  	    Encode::decode('utf-8',Net::LibIDN::idn_to_unicode($_[0],'utf-8'));
  	},
  	*can_idn = sub { 1 };
      } else {
  	*idn_to_ascii   = sub { croak "idn_to_ascii(@_) - no IDNA library installed" };
  	*idn_to_unicode = sub { croak "idn_to_unicode(@_) - no IDNA library installed" };
  	*can_idn = sub { 0 };
      }
  }
  
  {
      my %default;
      sub default {
  	my (undef,%args) = @_;
  	my $min_suffix = delete $args{min_suffix};
  	$min_suffix = 1 if ! defined $min_suffix;
  	%args and die "unknown args: ".join(" ",sort keys %args);
  	return $default{$min_suffix} ||= shift->from_string(_default_data(),
  	    min_suffix => $min_suffix);
      }
  }
  
  sub from_string {
      my $class = shift;
      my $data  = shift;
      open( my $fh,'<', \$data );
      return $class->from_file($fh,@_);
  }
  
  sub from_file {
      my ($class,$file,%args) = @_;
      my $min_suffix = delete $args{min_suffix};
      $min_suffix = 1 if ! defined $min_suffix;
      %args and die "unknown args: ".join(" ",sort keys %args);
  
      my $fh;
      if ( ref($file)) {
  	$fh = $file
      } elsif ( ! open($fh,'<',$file)) {
  	die "failed to open $file: $!";
      }
      my %tree;
      local $/ = "\n";
      while ( my $line = <$fh>) {
  	$line =~s{//.*}{};
  	$line =~s{\s+$}{};
  	$line eq '' and next;
  	my $p = \%tree;
  	$line = idn_to_ascii($line) if $line !~m{\A[\x00-\x7f]*\Z};
  	my $not = $line =~s{^!}{};
  	my @path = split(m{\.},$line);
  	for(reverse @path) {
  	    $p = $p->{$_} ||= {}
  	}
  	$p->{'\0'} = $not ? -1:1;
      }
      return bless { 
  	tree => \%tree, 
  	min_suffix => $min_suffix 
      },$class;
  }
  
  
  sub public_suffix {
      my ($self,$name,$add) = @_;
      my $want; # [a]rray, [s]tring, [u]nicode-string
      if ( ref($name)) {
  	$want = 'a';
  	$name = [ @$name ]; # don't change input
      } else {
  	return if ! defined $name;
  	if ( $name !~m{\A[\x00-\x7f]*\Z} ) {
  	    $name = idn_to_ascii($name);
  	    $want = 'u';
  	} else {
  	    $want = 's';
  	}
  	$name = lc($name);
  	$name =~s{\.$}{};
  	$name = [ $name =~m{([^.]+)}g ];
      }
      @$name or return;
      $_ = lc($_) for(@$name);
  
      my (%wild,%host,%xcept,@stack,$choices);
      my $p = $self->{tree};
      for( my $i=0; $i<@$name; $i++ ) {
  	$choices = [];
  	if ( my $px = $p->{ $name->[$#$name-$i] } ) {
  	    # name match, continue with next path element
  	    push @$choices,$px;
  	    if ( my $end = $px->{'\0'} ) {
  		( $end>0 ? \%host : \%xcept )->{$i+1} = $end;
  	    }
  	}
  	if ( my $px = $p->{'*'} ) {
  	    # wildcard match, continue with next path element
  	    push @$choices,$px;
  	    if ( my $end = $px->{'\0'} ) {
  		( $end>0 ? \%wild : \%xcept )->{$i+1} = $end;
  	    }
  	}
  
  
  	next_choice:
  	if ( @$choices ) {
  	    $p = shift(@$choices);
  	    push @stack, [ $choices, $i ] if @$choices;
  	    next; # go deeper
  	}
  
  	# backtrack
  	@stack or last;
  	($choices,$i) = @{ pop(@stack) };
  	goto next_choice;
      }
  
      #warn Dumper([\%wild,\%host,\%xcept]); use Data::Dumper;
  
  
      # remove all exceptions from wildcards
      delete @wild{ keys %xcept } if %xcept;
      # get longest match
      my ($len) = sort { $b <=> $a } (
  	keys(%wild), keys(%host), map { $_-1 } keys(%xcept));
      # if we have no matches use a minimum of min_suffix
      $len = $self->{min_suffix} if ! defined $len;
      $len += $add if $add;
      my $suffix;
      if ( $len < @$name ) {
  	$suffix = [ splice( @$name, -$len, $len ) ];
      } elsif ( $len > 0 ) {
  	$suffix = $name;
  	$name = []
      } else {
  	$suffix = []
      }
  
      if ( $want ne 'a' ) {
  	$suffix = join('.',@$suffix);
  	$name = join('.',@$name);
  	if ( $want eq 'u' ) {
  	    $suffix = idn_to_unicode($suffix);
  	    $name   = idn_to_unicode($name);
  	}
      }
  
      return wantarray ? ($name,$suffix):$suffix;
  }
  
  
  {
      my $data;
      sub _default_data {
  	if ( ! defined $data ) {
  	    $data = _builtin_data();
  	    $data =~s{^// ===END ICANN DOMAINS.*}{}ms
  		or die "cannot find END ICANN DOMAINS";
  	}
  	return $data;
      }
  }
  
  sub update_self_from_url {
      my $url = shift || URL();
      my $dst = __FILE__;
      -w $dst or die "cannot write $dst";
      open( my $fh,'<',$dst ) or die "open $dst: $!";
      my $code = '';
      local $/ = "\n";
      while (<$fh>) {
  	$code .= $_;
  	m{<<\'END_BUILTIN_DATA\'} and last;
      }
      my $tail;
      while (<$fh>) {
  	m{\AEND_BUILTIN_DATA\r?\n} or next;
  	$tail = $_;
  	last;
      }
      $tail .= do { local $/; <$fh> };
      close($fh);
  
      require LWP::UserAgent;
      my $resp = LWP::UserAgent->new->get($url)
  	or die "no response from $url";
      die "no success url=$url code=".$resp->code." ".$resp->message 
  	if ! $resp->is_success;
      my $content = $resp->decoded_content;
      while ( $content =~m{(.*\n)}g ) {
  	my $line = $1;
  	if ( $line =~m{\S} && $line !~m{\A\s*//} ) {
  	    $line =~s{//.*}{};
  	    $line =~s{\s+$}{};
  	    $line eq '' and next;
  	    if ( $line !~m{\A[\x00-\x7f]+\Z} ) {
  		$line = idn_to_ascii($line);
  	    }
  	    $code .= "$line\n";
  	} else {
  	    $code .= "$line";
  	}
      }
  
      open( $fh,'>:utf8',$dst ) or die "open $dst: $!";
      print $fh $code.$tail;
  }
  
  sub _builtin_data { return <<'END_BUILTIN_DATA' }
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at http://mozilla.org/MPL/2.0/.
  
  // ===BEGIN ICANN DOMAINS===
  
  // ac : http://en.wikipedia.org/wiki/.ac
  ac
  com.ac
  edu.ac
  gov.ac
  net.ac
  mil.ac
  org.ac
  
  // ad : http://en.wikipedia.org/wiki/.ad
  ad
  nom.ad
  
  // ae : http://en.wikipedia.org/wiki/.ae
  // see also: "Domain Name Eligibility Policy" at http://www.aeda.ae/eng/aepolicy.php
  ae
  co.ae
  net.ae
  org.ae
  sch.ae
  ac.ae
  gov.ae
  mil.ae
  
  // aero : see http://www.information.aero/index.php?id=66
  aero
  accident-investigation.aero
  accident-prevention.aero
  aerobatic.aero
  aeroclub.aero
  aerodrome.aero
  agents.aero
  aircraft.aero
  airline.aero
  airport.aero
  air-surveillance.aero
  airtraffic.aero
  air-traffic-control.aero
  ambulance.aero
  amusement.aero
  association.aero
  author.aero
  ballooning.aero
  broker.aero
  caa.aero
  cargo.aero
  catering.aero
  certification.aero
  championship.aero
  charter.aero
  civilaviation.aero
  club.aero
  conference.aero
  consultant.aero
  consulting.aero
  control.aero
  council.aero
  crew.aero
  design.aero
  dgca.aero
  educator.aero
  emergency.aero
  engine.aero
  engineer.aero
  entertainment.aero
  equipment.aero
  exchange.aero
  express.aero
  federation.aero
  flight.aero
  freight.aero
  fuel.aero
  gliding.aero
  government.aero
  groundhandling.aero
  group.aero
  hanggliding.aero
  homebuilt.aero
  insurance.aero
  journal.aero
  journalist.aero
  leasing.aero
  logistics.aero
  magazine.aero
  maintenance.aero
  media.aero
  microlight.aero
  modelling.aero
  navigation.aero
  parachuting.aero
  paragliding.aero
  passenger-association.aero
  pilot.aero
  press.aero
  production.aero
  recreation.aero
  repbody.aero
  res.aero
  research.aero
  rotorcraft.aero
  safety.aero
  scientist.aero
  services.aero
  show.aero
  skydiving.aero
  software.aero
  student.aero
  trader.aero
  trading.aero
  trainer.aero
  union.aero
  workinggroup.aero
  works.aero
  
  // af : http://www.nic.af/help.jsp
  af
  gov.af
  com.af
  org.af
  net.af
  edu.af
  
  // ag : http://www.nic.ag/prices.htm
  ag
  com.ag
  org.ag
  net.ag
  co.ag
  nom.ag
  
  // ai : http://nic.com.ai/
  ai
  off.ai
  com.ai
  net.ai
  org.ai
  
  // al : http://www.ert.gov.al/ert_alb/faq_det.html?Id=31
  al
  com.al
  edu.al
  gov.al
  mil.al
  net.al
  org.al
  
  // am : http://en.wikipedia.org/wiki/.am
  am
  
  // ao : http://en.wikipedia.org/wiki/.ao
  // http://www.dns.ao/REGISTR.DOC
  ao
  ed.ao
  gv.ao
  og.ao
  co.ao
  pb.ao
  it.ao
  
  // aq : http://en.wikipedia.org/wiki/.aq
  aq
  
  // ar : https://nic.ar/normativa-vigente.xhtml
  ar
  com.ar
  edu.ar
  gob.ar
  gov.ar
  int.ar
  mil.ar
  net.ar
  org.ar
  tur.ar
  
  // arpa : http://en.wikipedia.org/wiki/.arpa
  // Confirmed by registry <iana-questions@icann.org> 2008-06-18
  arpa
  e164.arpa
  in-addr.arpa
  ip6.arpa
  iris.arpa
  uri.arpa
  urn.arpa
  
  // as : http://en.wikipedia.org/wiki/.as
  as
  gov.as
  
  // asia : http://en.wikipedia.org/wiki/.asia
  asia
  
  // at : http://en.wikipedia.org/wiki/.at
  // Confirmed by registry <it@nic.at> 2008-06-17
  at
  ac.at
  co.at
  gv.at
  or.at
  
  // au : http://en.wikipedia.org/wiki/.au
  // http://www.auda.org.au/
  au
  // 2LDs
  com.au
  net.au
  org.au
  edu.au
  gov.au
  asn.au
  id.au
  // Historic 2LDs (closed to new registration, but sites still exist)
  info.au
  conf.au
  oz.au
  // CGDNs - http://www.cgdn.org.au/
  act.au
  nsw.au
  nt.au
  qld.au
  sa.au
  tas.au
  vic.au
  wa.au
  // 3LDs
  act.edu.au
  nsw.edu.au
  nt.edu.au
  qld.edu.au
  sa.edu.au
  tas.edu.au
  vic.edu.au
  wa.edu.au
  // act.gov.au  Bug 984824 - Removed at request of Greg Tankard
  // nsw.gov.au  Bug 547985 - Removed at request of <Shae.Donelan@services.nsw.gov.au>
  // nt.gov.au  Bug 940478 - Removed at request of Greg Connors <Greg.Connors@nt.gov.au>
  qld.gov.au
  sa.gov.au
  tas.gov.au
  vic.gov.au
  wa.gov.au
  
  // aw : http://en.wikipedia.org/wiki/.aw
  aw
  com.aw
  
  // ax : http://en.wikipedia.org/wiki/.ax
  ax
  
  // az : http://en.wikipedia.org/wiki/.az
  az
  com.az
  net.az
  int.az
  gov.az
  org.az
  edu.az
  info.az
  pp.az
  mil.az
  name.az
  pro.az
  biz.az
  
  // ba : http://en.wikipedia.org/wiki/.ba
  ba
  org.ba
  net.ba
  edu.ba
  gov.ba
  mil.ba
  unsa.ba
  unbi.ba
  co.ba
  com.ba
  rs.ba
  
  // bb : http://en.wikipedia.org/wiki/.bb
  bb
  biz.bb
  co.bb
  com.bb
  edu.bb
  gov.bb
  info.bb
  net.bb
  org.bb
  store.bb
  tv.bb
  
  // bd : http://en.wikipedia.org/wiki/.bd
  *.bd
  
  // be : http://en.wikipedia.org/wiki/.be
  // Confirmed by registry <tech@dns.be> 2008-06-08
  be
  ac.be
  
  // bf : http://en.wikipedia.org/wiki/.bf
  bf
  gov.bf
  
  // bg : http://en.wikipedia.org/wiki/.bg
  // https://www.register.bg/user/static/rules/en/index.html
  bg
  a.bg
  b.bg
  c.bg
  d.bg
  e.bg
  f.bg
  g.bg
  h.bg
  i.bg
  j.bg
  k.bg
  l.bg
  m.bg
  n.bg
  o.bg
  p.bg
  q.bg
  r.bg
  s.bg
  t.bg
  u.bg
  v.bg
  w.bg
  x.bg
  y.bg
  z.bg
  0.bg
  1.bg
  2.bg
  3.bg
  4.bg
  5.bg
  6.bg
  7.bg
  8.bg
  9.bg
  
  // bh : http://en.wikipedia.org/wiki/.bh
  bh
  com.bh
  edu.bh
  net.bh
  org.bh
  gov.bh
  
  // bi : http://en.wikipedia.org/wiki/.bi
  // http://whois.nic.bi/
  bi
  co.bi
  com.bi
  edu.bi
  or.bi
  org.bi
  
  // biz : http://en.wikipedia.org/wiki/.biz
  biz
  
  // bj : http://en.wikipedia.org/wiki/.bj
  bj
  asso.bj
  barreau.bj
  gouv.bj
  
  // bm : http://www.bermudanic.bm/dnr-text.txt
  bm
  com.bm
  edu.bm
  gov.bm
  net.bm
  org.bm
  
  // bn : http://en.wikipedia.org/wiki/.bn
  *.bn
  
  // bo : http://www.nic.bo/
  bo
  com.bo
  edu.bo
  gov.bo
  gob.bo
  int.bo
  org.bo
  net.bo
  mil.bo
  tv.bo
  
  // br : http://registro.br/dominio/categoria.html
  // Submitted by registry <fneves@registro.br> 2014-08-11
  br
  adm.br
  adv.br
  agr.br
  am.br
  arq.br
  art.br
  ato.br
  b.br
  bio.br
  blog.br
  bmd.br
  cim.br
  cng.br
  cnt.br
  com.br
  coop.br
  ecn.br
  eco.br
  edu.br
  emp.br
  eng.br
  esp.br
  etc.br
  eti.br
  far.br
  flog.br
  fm.br
  fnd.br
  fot.br
  fst.br
  g12.br
  ggf.br
  gov.br
  imb.br
  ind.br
  inf.br
  jor.br
  jus.br
  leg.br
  lel.br
  mat.br
  med.br
  mil.br
  mp.br
  mus.br
  net.br
  *.nom.br
  not.br
  ntr.br
  odo.br
  org.br
  ppg.br
  pro.br
  psc.br
  psi.br
  qsl.br
  radio.br
  rec.br
  slg.br
  srv.br
  taxi.br
  teo.br
  tmp.br
  trd.br
  tur.br
  tv.br
  vet.br
  vlog.br
  wiki.br
  zlg.br
  
  // bs : http://www.nic.bs/rules.html
  bs
  com.bs
  net.bs
  org.bs
  edu.bs
  gov.bs
  
  // bt : http://en.wikipedia.org/wiki/.bt
  bt
  com.bt
  edu.bt
  gov.bt
  net.bt
  org.bt
  
  // bv : No registrations at this time.
  // Submitted by registry <jarle@uninett.no> 2006-06-16
  bv
  
  // bw : http://en.wikipedia.org/wiki/.bw
  // http://www.gobin.info/domainname/bw.doc
  // list of other 2nd level tlds ?
  bw
  co.bw
  org.bw
  
  // by : http://en.wikipedia.org/wiki/.by
  // http://tld.by/rules_2006_en.html
  // list of other 2nd level tlds ?
  by
  gov.by
  mil.by
  // Official information does not indicate that com.by is a reserved
  // second-level domain, but it's being used as one (see www.google.com.by and
  // www.yahoo.com.by, for example), so we list it here for safety's sake.
  com.by
  
  // http://hoster.by/
  of.by
  
  // bz : http://en.wikipedia.org/wiki/.bz
  // http://www.belizenic.bz/
  bz
  com.bz
  net.bz
  org.bz
  edu.bz
  gov.bz
  
  // ca : http://en.wikipedia.org/wiki/.ca
  ca
  // ca geographical names
  ab.ca
  bc.ca
  mb.ca
  nb.ca
  nf.ca
  nl.ca
  ns.ca
  nt.ca
  nu.ca
  on.ca
  pe.ca
  qc.ca
  sk.ca
  yk.ca
  // gc.ca: http://en.wikipedia.org/wiki/.gc.ca
  // see also: http://registry.gc.ca/en/SubdomainFAQ
  gc.ca
  
  // cat : http://en.wikipedia.org/wiki/.cat
  cat
  
  // cc : http://en.wikipedia.org/wiki/.cc
  cc
  
  // cd : http://en.wikipedia.org/wiki/.cd
  // see also: https://www.nic.cd/domain/insertDomain_2.jsp?act=1
  cd
  gov.cd
  
  // cf : http://en.wikipedia.org/wiki/.cf
  cf
  
  // cg : http://en.wikipedia.org/wiki/.cg
  cg
  
  // ch : http://en.wikipedia.org/wiki/.ch
  ch
  
  // ci : http://en.wikipedia.org/wiki/.ci
  // http://www.nic.ci/index.php?page=charte
  ci
  org.ci
  or.ci
  com.ci
  co.ci
  edu.ci
  ed.ci
  ac.ci
  net.ci
  go.ci
  asso.ci
  xn--aroport-bya.ci
  int.ci
  presse.ci
  md.ci
  gouv.ci
  
  // ck : http://en.wikipedia.org/wiki/.ck
  *.ck
  !www.ck
  
  // cl : http://en.wikipedia.org/wiki/.cl
  cl
  gov.cl
  gob.cl
  co.cl
  mil.cl
  
  // cm : http://en.wikipedia.org/wiki/.cm plus bug 981927
  cm
  co.cm
  com.cm
  gov.cm
  net.cm
  
  // cn : http://en.wikipedia.org/wiki/.cn
  // Submitted by registry <tanyaling@cnnic.cn> 2008-06-11
  cn
  ac.cn
  com.cn
  edu.cn
  gov.cn
  net.cn
  org.cn
  mil.cn
  xn--55qx5d.cn
  xn--io0a7i.cn
  xn--od0alg.cn
  // cn geographic names
  ah.cn
  bj.cn
  cq.cn
  fj.cn
  gd.cn
  gs.cn
  gz.cn
  gx.cn
  ha.cn
  hb.cn
  he.cn
  hi.cn
  hl.cn
  hn.cn
  jl.cn
  js.cn
  jx.cn
  ln.cn
  nm.cn
  nx.cn
  qh.cn
  sc.cn
  sd.cn
  sh.cn
  sn.cn
  sx.cn
  tj.cn
  xj.cn
  xz.cn
  yn.cn
  zj.cn
  hk.cn
  mo.cn
  tw.cn
  
  // co : http://en.wikipedia.org/wiki/.co
  // Submitted by registry <tecnico@uniandes.edu.co> 2008-06-11
  co
  arts.co
  com.co
  edu.co
  firm.co
  gov.co
  info.co
  int.co
  mil.co
  net.co
  nom.co
  org.co
  rec.co
  web.co
  
  // com : http://en.wikipedia.org/wiki/.com
  com
  
  // coop : http://en.wikipedia.org/wiki/.coop
  coop
  
  // cr : http://www.nic.cr/niccr_publico/showRegistroDominiosScreen.do
  cr
  ac.cr
  co.cr
  ed.cr
  fi.cr
  go.cr
  or.cr
  sa.cr
  
  // cu : http://en.wikipedia.org/wiki/.cu
  cu
  com.cu
  edu.cu
  org.cu
  net.cu
  gov.cu
  inf.cu
  
  // cv : http://en.wikipedia.org/wiki/.cv
  cv
  
  // cw : http://www.una.cw/cw_registry/
  // Confirmed by registry <registry@una.net> 2013-03-26
  cw
  com.cw
  edu.cw
  net.cw
  org.cw
  
  // cx : http://en.wikipedia.org/wiki/.cx
  // list of other 2nd level tlds ?
  cx
  gov.cx
  
  // cy : http://en.wikipedia.org/wiki/.cy
  ac.cy
  biz.cy
  com.cy
  ekloges.cy
  gov.cy
  ltd.cy
  name.cy
  net.cy
  org.cy
  parliament.cy
  press.cy
  pro.cy
  tm.cy
  
  // cz : http://en.wikipedia.org/wiki/.cz
  cz
  
  // de : http://en.wikipedia.org/wiki/.de
  // Confirmed by registry <ops@denic.de> (with technical
  // reservations) 2008-07-01
  de
  
  // dj : http://en.wikipedia.org/wiki/.dj
  dj
  
  // dk : http://en.wikipedia.org/wiki/.dk
  // Confirmed by registry <robert@dk-hostmaster.dk> 2008-06-17
  dk
  
  // dm : http://en.wikipedia.org/wiki/.dm
  dm
  com.dm
  net.dm
  org.dm
  edu.dm
  gov.dm
  
  // do : http://en.wikipedia.org/wiki/.do
  do
  art.do
  com.do
  edu.do
  gob.do
  gov.do
  mil.do
  net.do
  org.do
  sld.do
  web.do
  
  // dz : http://en.wikipedia.org/wiki/.dz
  dz
  com.dz
  org.dz
  net.dz
  gov.dz
  edu.dz
  asso.dz
  pol.dz
  art.dz
  
  // ec : http://www.nic.ec/reg/paso1.asp
  // Submitted by registry <vabboud@nic.ec> 2008-07-04
  ec
  com.ec
  info.ec
  net.ec
  fin.ec
  k12.ec
  med.ec
  pro.ec
  org.ec
  edu.ec
  gov.ec
  gob.ec
  mil.ec
  
  // edu : http://en.wikipedia.org/wiki/.edu
  edu
  
  // ee : http://www.eenet.ee/EENet/dom_reeglid.html#lisa_B
  ee
  edu.ee
  gov.ee
  riik.ee
  lib.ee
  med.ee
  com.ee
  pri.ee
  aip.ee
  org.ee
  fie.ee
  
  // eg : http://en.wikipedia.org/wiki/.eg
  eg
  com.eg
  edu.eg
  eun.eg
  gov.eg
  mil.eg
  name.eg
  net.eg
  org.eg
  sci.eg
  
  // er : http://en.wikipedia.org/wiki/.er
  *.er
  
  // es : https://www.nic.es/site_ingles/ingles/dominios/index.html
  es
  com.es
  nom.es
  org.es
  gob.es
  edu.es
  
  // et : http://en.wikipedia.org/wiki/.et
  et
  com.et
  gov.et
  org.et
  edu.et
  biz.et
  name.et
  info.et
  net.et
  
  // eu : http://en.wikipedia.org/wiki/.eu
  eu
  
  // fi : http://en.wikipedia.org/wiki/.fi
  fi
  // aland.fi : http://en.wikipedia.org/wiki/.ax
  // This domain is being phased out in favor of .ax. As there are still many
  // domains under aland.fi, we still keep it on the list until aland.fi is
  // completely removed.
  // TODO: Check for updates (expected to be phased out around Q1/2009)
  aland.fi
  
  // fj : http://en.wikipedia.org/wiki/.fj
  *.fj
  
  // fk : http://en.wikipedia.org/wiki/.fk
  *.fk
  
  // fm : http://en.wikipedia.org/wiki/.fm
  fm
  
  // fo : http://en.wikipedia.org/wiki/.fo
  fo
  
  // fr : http://www.afnic.fr/
  // domaines descriptifs : http://www.afnic.fr/obtenir/chartes/nommage-fr/annexe-descriptifs
  fr
  com.fr
  asso.fr
  nom.fr
  prd.fr
  presse.fr
  tm.fr
  // domaines sectoriels : http://www.afnic.fr/obtenir/chartes/nommage-fr/annexe-sectoriels
  aeroport.fr
  assedic.fr
  avocat.fr
  avoues.fr
  cci.fr
  chambagri.fr
  chirurgiens-dentistes.fr
  experts-comptables.fr
  geometre-expert.fr
  gouv.fr
  greta.fr
  huissier-justice.fr
  medecin.fr
  notaires.fr
  pharmacien.fr
  port.fr
  veterinaire.fr
  
  // ga : http://en.wikipedia.org/wiki/.ga
  ga
  
  // gb : This registry is effectively dormant
  // Submitted by registry <Damien.Shaw@ja.net> 2008-06-12
  gb
  
  // gd : http://en.wikipedia.org/wiki/.gd
  gd
  
  // ge : http://www.nic.net.ge/policy_en.pdf
  ge
  com.ge
  edu.ge
  gov.ge
  org.ge
  mil.ge
  net.ge
  pvt.ge
  
  // gf : http://en.wikipedia.org/wiki/.gf
  gf
  
  // gg : http://www.channelisles.net/register-domains/
  // Confirmed by registry <nigel@channelisles.net> 2013-11-28
  gg
  co.gg
  net.gg
  org.gg
  
  // gh : http://en.wikipedia.org/wiki/.gh
  // see also: http://www.nic.gh/reg_now.php
  // Although domains directly at second level are not possible at the moment,
  // they have been possible for some time and may come back.
  gh
  com.gh
  edu.gh
  gov.gh
  org.gh
  mil.gh
  
  // gi : http://www.nic.gi/rules.html
  gi
  com.gi
  ltd.gi
  gov.gi
  mod.gi
  edu.gi
  org.gi
  
  // gl : http://en.wikipedia.org/wiki/.gl
  // http://nic.gl
  gl
  co.gl
  com.gl
  edu.gl
  net.gl
  org.gl
  
  // gm : http://www.nic.gm/htmlpages%5Cgm-policy.htm
  gm
  
  // gn : http://psg.com/dns/gn/gn.txt
  // Submitted by registry <randy@psg.com> 2008-06-17
  gn
  ac.gn
  com.gn
  edu.gn
  gov.gn
  org.gn
  net.gn
  
  // gov : http://en.wikipedia.org/wiki/.gov
  gov
  
  // gp : http://www.nic.gp/index.php?lang=en
  gp
  com.gp
  net.gp
  mobi.gp
  edu.gp
  org.gp
  asso.gp
  
  // gq : http://en.wikipedia.org/wiki/.gq
  gq
  
  // gr : https://grweb.ics.forth.gr/english/1617-B-2005.html
  // Submitted by registry <segred@ics.forth.gr> 2008-06-09
  gr
  com.gr
  edu.gr
  net.gr
  org.gr
  gov.gr
  
  // gs : http://en.wikipedia.org/wiki/.gs
  gs
  
  // gt : http://www.gt/politicas_de_registro.html
  gt
  com.gt
  edu.gt
  gob.gt
  ind.gt
  mil.gt
  net.gt
  org.gt
  
  // gu : http://gadao.gov.gu/registration.txt
  *.gu
  
  // gw : http://en.wikipedia.org/wiki/.gw
  gw
  
  // gy : http://en.wikipedia.org/wiki/.gy
  // http://registry.gy/
  gy
  co.gy
  com.gy
  net.gy
  
  // hk : https://www.hkdnr.hk
  // Submitted by registry <hk.tech@hkirc.hk> 2008-06-11
  hk
  com.hk
  edu.hk
  gov.hk
  idv.hk
  net.hk
  org.hk
  xn--55qx5d.hk
  xn--wcvs22d.hk
  xn--lcvr32d.hk
  xn--mxtq1m.hk
  xn--gmqw5a.hk
  xn--ciqpn.hk
  xn--gmq050i.hk
  xn--zf0avx.hk
  xn--io0a7i.hk
  xn--mk0axi.hk
  xn--od0alg.hk
  xn--od0aq3b.hk
  xn--tn0ag.hk
  xn--uc0atv.hk
  xn--uc0ay4a.hk
  
  // hm : http://en.wikipedia.org/wiki/.hm
  hm
  
  // hn : http://www.nic.hn/politicas/ps02,,05.html
  hn
  com.hn
  edu.hn
  org.hn
  net.hn
  mil.hn
  gob.hn
  
  // hr : http://www.dns.hr/documents/pdf/HRTLD-regulations.pdf
  hr
  iz.hr
  from.hr
  name.hr
  com.hr
  
  // ht : http://www.nic.ht/info/charte.cfm
  ht
  com.ht
  shop.ht
  firm.ht
  info.ht
  adult.ht
  net.ht
  pro.ht
  org.ht
  med.ht
  art.ht
  coop.ht
  pol.ht
  asso.ht
  edu.ht
  rel.ht
  gouv.ht
  perso.ht
  
  // hu : http://www.domain.hu/domain/English/sld.html
  // Confirmed by registry <pasztor@iszt.hu> 2008-06-12
  hu
  co.hu
  info.hu
  org.hu
  priv.hu
  sport.hu
  tm.hu
  2000.hu
  agrar.hu
  bolt.hu
  casino.hu
  city.hu
  erotica.hu
  erotika.hu
  film.hu
  forum.hu
  games.hu
  hotel.hu
  ingatlan.hu
  jogasz.hu
  konyvelo.hu
  lakas.hu
  media.hu
  news.hu
  reklam.hu
  sex.hu
  shop.hu
  suli.hu
  szex.hu
  tozsde.hu
  utazas.hu
  video.hu
  
  // id : https://register.pandi.or.id/
  id
  ac.id
  biz.id
  co.id
  desa.id
  go.id
  mil.id
  my.id
  net.id
  or.id
  sch.id
  web.id
  
  // ie : http://en.wikipedia.org/wiki/.ie
  ie
  gov.ie
  
  // il : http://www.isoc.org.il/domains/
  il
  ac.il
  co.il
  gov.il
  idf.il
  k12.il
  muni.il
  net.il
  org.il
  
  // im : https://www.nic.im/
  // Submitted by registry <info@nic.im> 2013-11-15
  im
  ac.im
  co.im
  com.im
  ltd.co.im
  net.im
  org.im
  plc.co.im
  tt.im
  tv.im
  
  // in : http://en.wikipedia.org/wiki/.in
  // see also: https://registry.in/Policies
  // Please note, that nic.in is not an offical eTLD, but used by most
  // government institutions.
  in
  co.in
  firm.in
  net.in
  org.in
  gen.in
  ind.in
  nic.in
  ac.in
  edu.in
  res.in
  gov.in
  mil.in
  
  // info : http://en.wikipedia.org/wiki/.info
  info
  
  // int : http://en.wikipedia.org/wiki/.int
  // Confirmed by registry <iana-questions@icann.org> 2008-06-18
  int
  eu.int
  
  // io : http://www.nic.io/rules.html
  // list of other 2nd level tlds ?
  io
  com.io
  
  // iq : http://www.cmc.iq/english/iq/iqregister1.htm
  iq
  gov.iq
  edu.iq
  mil.iq
  com.iq
  org.iq
  net.iq
  
  // ir : http://www.nic.ir/Terms_and_Conditions_ir,_Appendix_1_Domain_Rules
  // Also see http://www.nic.ir/Internationalized_Domain_Names
  // Two <iran>.ir entries added at request of <tech-team@nic.ir>, 2010-04-16
  ir
  ac.ir
  co.ir
  gov.ir
  id.ir
  net.ir
  org.ir
  sch.ir
  // xn--mgba3a4f16a.ir (<iran>.ir, Persian YEH)
  xn--mgba3a4f16a.ir
  // xn--mgba3a4fra.ir (<iran>.ir, Arabic YEH)
  xn--mgba3a4fra.ir
  
  // is : http://www.isnic.is/domain/rules.php
  // Confirmed by registry <marius@isgate.is> 2008-12-06
  is
  net.is
  com.is
  edu.is
  gov.is
  org.is
  int.is
  
  // it : http://en.wikipedia.org/wiki/.it
  it
  gov.it
  edu.it
  // Reserved geo-names:
  // http://www.nic.it/documenti/regolamenti-e-linee-guida/regolamento-assegnazione-versione-6.0.pdf
  // There is also a list of reserved geo-names corresponding to Italian municipalities
  // http://www.nic.it/documenti/appendice-c.pdf, but it is not included here.
  // Regions
  abr.it
  abruzzo.it
  aosta-valley.it
  aostavalley.it
  bas.it
  basilicata.it
  cal.it
  calabria.it
  cam.it
  campania.it
  emilia-romagna.it
  emiliaromagna.it
  emr.it
  friuli-v-giulia.it
  friuli-ve-giulia.it
  friuli-vegiulia.it
  friuli-venezia-giulia.it
  friuli-veneziagiulia.it
  friuli-vgiulia.it
  friuliv-giulia.it
  friulive-giulia.it
  friulivegiulia.it
  friulivenezia-giulia.it
  friuliveneziagiulia.it
  friulivgiulia.it
  fvg.it
  laz.it
  lazio.it
  lig.it
  liguria.it
  lom.it
  lombardia.it
  lombardy.it
  lucania.it
  mar.it
  marche.it
  mol.it
  molise.it
  piedmont.it
  piemonte.it
  pmn.it
  pug.it
  puglia.it
  sar.it
  sardegna.it
  sardinia.it
  sic.it
  sicilia.it
  sicily.it
  taa.it
  tos.it
  toscana.it
  trentino-a-adige.it
  trentino-aadige.it
  trentino-alto-adige.it
  trentino-altoadige.it
  trentino-s-tirol.it
  trentino-stirol.it
  trentino-sud-tirol.it
  trentino-sudtirol.it
  trentino-sued-tirol.it
  trentino-suedtirol.it
  trentinoa-adige.it
  trentinoaadige.it
  trentinoalto-adige.it
  trentinoaltoadige.it
  trentinos-tirol.it
  trentinostirol.it
  trentinosud-tirol.it
  trentinosudtirol.it
  trentinosued-tirol.it
  trentinosuedtirol.it
  tuscany.it
  umb.it
  umbria.it
  val-d-aosta.it
  val-daosta.it
  vald-aosta.it
  valdaosta.it
  valle-aosta.it
  valle-d-aosta.it
  valle-daosta.it
  valleaosta.it
  valled-aosta.it
  valledaosta.it
  vallee-aoste.it
  valleeaoste.it
  vao.it
  vda.it
  ven.it
  veneto.it
  // Provinces
  ag.it
  agrigento.it
  al.it
  alessandria.it
  alto-adige.it
  altoadige.it
  an.it
  ancona.it
  andria-barletta-trani.it
  andria-trani-barletta.it
  andriabarlettatrani.it
  andriatranibarletta.it
  ao.it
  aosta.it
  aoste.it
  ap.it
  aq.it
  aquila.it
  ar.it
  arezzo.it
  ascoli-piceno.it
  ascolipiceno.it
  asti.it
  at.it
  av.it
  avellino.it
  ba.it
  balsan.it
  bari.it
  barletta-trani-andria.it
  barlettatraniandria.it
  belluno.it
  benevento.it
  bergamo.it
  bg.it
  bi.it
  biella.it
  bl.it
  bn.it
  bo.it
  bologna.it
  bolzano.it
  bozen.it
  br.it
  brescia.it
  brindisi.it
  bs.it
  bt.it
  bz.it
  ca.it
  cagliari.it
  caltanissetta.it
  campidano-medio.it
  campidanomedio.it
  campobasso.it
  carbonia-iglesias.it
  carboniaiglesias.it
  carrara-massa.it
  carraramassa.it
  caserta.it
  catania.it
  catanzaro.it
  cb.it
  ce.it
  cesena-forli.it
  cesenaforli.it
  ch.it
  chieti.it
  ci.it
  cl.it
  cn.it
  co.it
  como.it
  cosenza.it
  cr.it
  cremona.it
  crotone.it
  cs.it
  ct.it
  cuneo.it
  cz.it
  dell-ogliastra.it
  dellogliastra.it
  en.it
  enna.it
  fc.it
  fe.it
  fermo.it
  ferrara.it
  fg.it
  fi.it
  firenze.it
  florence.it
  fm.it
  foggia.it
  forli-cesena.it
  forlicesena.it
  fr.it
  frosinone.it
  ge.it
  genoa.it
  genova.it
  go.it
  gorizia.it
  gr.it
  grosseto.it
  iglesias-carbonia.it
  iglesiascarbonia.it
  im.it
  imperia.it
  is.it
  isernia.it
  kr.it
  la-spezia.it
  laquila.it
  laspezia.it
  latina.it
  lc.it
  le.it
  lecce.it
  lecco.it
  li.it
  livorno.it
  lo.it
  lodi.it
  lt.it
  lu.it
  lucca.it
  macerata.it
  mantova.it
  massa-carrara.it
  massacarrara.it
  matera.it
  mb.it
  mc.it
  me.it
  medio-campidano.it
  mediocampidano.it
  messina.it
  mi.it
  milan.it
  milano.it
  mn.it
  mo.it
  modena.it
  monza-brianza.it
  monza-e-della-brianza.it
  monza.it
  monzabrianza.it
  monzaebrianza.it
  monzaedellabrianza.it
  ms.it
  mt.it
  na.it
  naples.it
  napoli.it
  no.it
  novara.it
  nu.it
  nuoro.it
  og.it
  ogliastra.it
  olbia-tempio.it
  olbiatempio.it
  or.it
  oristano.it
  ot.it
  pa.it
  padova.it
  padua.it
  palermo.it
  parma.it
  pavia.it
  pc.it
  pd.it
  pe.it
  perugia.it
  pesaro-urbino.it
  pesarourbino.it
  pescara.it
  pg.it
  pi.it
  piacenza.it
  pisa.it
  pistoia.it
  pn.it
  po.it
  pordenone.it
  potenza.it
  pr.it
  prato.it
  pt.it
  pu.it
  pv.it
  pz.it
  ra.it
  ragusa.it
  ravenna.it
  rc.it
  re.it
  reggio-calabria.it
  reggio-emilia.it
  reggiocalabria.it
  reggioemilia.it
  rg.it
  ri.it
  rieti.it
  rimini.it
  rm.it
  rn.it
  ro.it
  roma.it
  rome.it
  rovigo.it
  sa.it
  salerno.it
  sassari.it
  savona.it
  si.it
  siena.it
  siracusa.it
  so.it
  sondrio.it
  sp.it
  sr.it
  ss.it
  suedtirol.it
  sv.it
  ta.it
  taranto.it
  te.it
  tempio-olbia.it
  tempioolbia.it
  teramo.it
  terni.it
  tn.it
  to.it
  torino.it
  tp.it
  tr.it
  trani-andria-barletta.it
  trani-barletta-andria.it
  traniandriabarletta.it
  tranibarlettaandria.it
  trapani.it
  trentino.it
  trento.it
  treviso.it
  trieste.it
  ts.it
  turin.it
  tv.it
  ud.it
  udine.it
  urbino-pesaro.it
  urbinopesaro.it
  va.it
  varese.it
  vb.it
  vc.it
  ve.it
  venezia.it
  venice.it
  verbania.it
  vercelli.it
  verona.it
  vi.it
  vibo-valentia.it
  vibovalentia.it
  vicenza.it
  viterbo.it
  vr.it
  vs.it
  vt.it
  vv.it
  
  // je : http://www.channelisles.net/register-domains/
  // Confirmed by registry <nigel@channelisles.net> 2013-11-28
  je
  co.je
  net.je
  org.je
  
  // jm : http://www.com.jm/register.html
  *.jm
  
  // jo : http://www.dns.jo/Registration_policy.aspx
  jo
  com.jo
  org.jo
  net.jo
  edu.jo
  sch.jo
  gov.jo
  mil.jo
  name.jo
  
  // jobs : http://en.wikipedia.org/wiki/.jobs
  jobs
  
  // jp : http://en.wikipedia.org/wiki/.jp
  // http://jprs.co.jp/en/jpdomain.html
  // Submitted by registry <info@jprs.jp> 2014-10-30
  jp
  // jp organizational type names
  ac.jp
  ad.jp
  co.jp
  ed.jp
  go.jp
  gr.jp
  lg.jp
  ne.jp
  or.jp
  // jp prefecture type names
  aichi.jp
  akita.jp
  aomori.jp
  chiba.jp
  ehime.jp
  fukui.jp
  fukuoka.jp
  fukushima.jp
  gifu.jp
  gunma.jp
  hiroshima.jp
  hokkaido.jp
  hyogo.jp
  ibaraki.jp
  ishikawa.jp
  iwate.jp
  kagawa.jp
  kagoshima.jp
  kanagawa.jp
  kochi.jp
  kumamoto.jp
  kyoto.jp
  mie.jp
  miyagi.jp
  miyazaki.jp
  nagano.jp
  nagasaki.jp
  nara.jp
  niigata.jp
  oita.jp
  okayama.jp
  okinawa.jp
  osaka.jp
  saga.jp
  saitama.jp
  shiga.jp
  shimane.jp
  shizuoka.jp
  tochigi.jp
  tokushima.jp
  tokyo.jp
  tottori.jp
  toyama.jp
  wakayama.jp
  yamagata.jp
  yamaguchi.jp
  yamanashi.jp
  xn--4pvxs.jp
  xn--vgu402c.jp
  xn--c3s14m.jp
  xn--f6qx53a.jp
  xn--8pvr4u.jp
  xn--uist22h.jp
  xn--djrs72d6uy.jp
  xn--mkru45i.jp
  xn--0trq7p7nn.jp
  xn--8ltr62k.jp
  xn--2m4a15e.jp
  xn--efvn9s.jp
  xn--32vp30h.jp
  xn--4it797k.jp
  xn--1lqs71d.jp
  xn--5rtp49c.jp
  xn--5js045d.jp
  xn--ehqz56n.jp
  xn--1lqs03n.jp
  xn--qqqt11m.jp
  xn--kbrq7o.jp
  xn--pssu33l.jp
  xn--ntsq17g.jp
  xn--uisz3g.jp
  xn--6btw5a.jp
  xn--1ctwo.jp
  xn--6orx2r.jp
  xn--rht61e.jp
  xn--rht27z.jp
  xn--djty4k.jp
  xn--nit225k.jp
  xn--rht3d.jp
  xn--klty5x.jp
  xn--kltx9a.jp
  xn--kltp7d.jp
  xn--uuwu58a.jp
  xn--zbx025d.jp
  xn--ntso0iqx3a.jp
  xn--elqq16h.jp
  xn--4it168d.jp
  xn--klt787d.jp
  xn--rny31h.jp
  xn--7t0a264c.jp
  xn--5rtq34k.jp
  xn--k7yn95e.jp
  xn--tor131o.jp
  xn--d5qv7z876c.jp
  // jp geographic type names
  // http://jprs.jp/doc/rule/saisoku-1.html
  *.kawasaki.jp
  *.kitakyushu.jp
  *.kobe.jp
  *.nagoya.jp
  *.sapporo.jp
  *.sendai.jp
  *.yokohama.jp
  !city.kawasaki.jp
  !city.kitakyushu.jp
  !city.kobe.jp
  !city.nagoya.jp
  !city.sapporo.jp
  !city.sendai.jp
  !city.yokohama.jp
  // 4th level registration
  aisai.aichi.jp
  ama.aichi.jp
  anjo.aichi.jp
  asuke.aichi.jp
  chiryu.aichi.jp
  chita.aichi.jp
  fuso.aichi.jp
  gamagori.aichi.jp
  handa.aichi.jp
  hazu.aichi.jp
  hekinan.aichi.jp
  higashiura.aichi.jp
  ichinomiya.aichi.jp
  inazawa.aichi.jp
  inuyama.aichi.jp
  isshiki.aichi.jp
  iwakura.aichi.jp
  kanie.aichi.jp
  kariya.aichi.jp
  kasugai.aichi.jp
  kira.aichi.jp
  kiyosu.aichi.jp
  komaki.aichi.jp
  konan.aichi.jp
  kota.aichi.jp
  mihama.aichi.jp
  miyoshi.aichi.jp
  nishio.aichi.jp
  nisshin.aichi.jp
  obu.aichi.jp
  oguchi.aichi.jp
  oharu.aichi.jp
  okazaki.aichi.jp
  owariasahi.aichi.jp
  seto.aichi.jp
  shikatsu.aichi.jp
  shinshiro.aichi.jp
  shitara.aichi.jp
  tahara.aichi.jp
  takahama.aichi.jp
  tobishima.aichi.jp
  toei.aichi.jp
  togo.aichi.jp
  tokai.aichi.jp
  tokoname.aichi.jp
  toyoake.aichi.jp
  toyohashi.aichi.jp
  toyokawa.aichi.jp
  toyone.aichi.jp
  toyota.aichi.jp
  tsushima.aichi.jp
  yatomi.aichi.jp
  akita.akita.jp
  daisen.akita.jp
  fujisato.akita.jp
  gojome.akita.jp
  hachirogata.akita.jp
  happou.akita.jp
  higashinaruse.akita.jp
  honjo.akita.jp
  honjyo.akita.jp
  ikawa.akita.jp
  kamikoani.akita.jp
  kamioka.akita.jp
  katagami.akita.jp
  kazuno.akita.jp
  kitaakita.akita.jp
  kosaka.akita.jp
  kyowa.akita.jp
  misato.akita.jp
  mitane.akita.jp
  moriyoshi.akita.jp
  nikaho.akita.jp
  noshiro.akita.jp
  odate.akita.jp
  oga.akita.jp
  ogata.akita.jp
  semboku.akita.jp
  yokote.akita.jp
  yurihonjo.akita.jp
  aomori.aomori.jp
  gonohe.aomori.jp
  hachinohe.aomori.jp
  hashikami.aomori.jp
  hiranai.aomori.jp
  hirosaki.aomori.jp
  itayanagi.aomori.jp
  kuroishi.aomori.jp
  misawa.aomori.jp
  mutsu.aomori.jp
  nakadomari.aomori.jp
  noheji.aomori.jp
  oirase.aomori.jp
  owani.aomori.jp
  rokunohe.aomori.jp
  sannohe.aomori.jp
  shichinohe.aomori.jp
  shingo.aomori.jp
  takko.aomori.jp
  towada.aomori.jp
  tsugaru.aomori.jp
  tsuruta.aomori.jp
  abiko.chiba.jp
  asahi.chiba.jp
  chonan.chiba.jp
  chosei.chiba.jp
  choshi.chiba.jp
  chuo.chiba.jp
  funabashi.chiba.jp
  futtsu.chiba.jp
  hanamigawa.chiba.jp
  ichihara.chiba.jp
  ichikawa.chiba.jp
  ichinomiya.chiba.jp
  inzai.chiba.jp
  isumi.chiba.jp
  kamagaya.chiba.jp
  kamogawa.chiba.jp
  kashiwa.chiba.jp
  katori.chiba.jp
  katsuura.chiba.jp
  kimitsu.chiba.jp
  kisarazu.chiba.jp
  kozaki.chiba.jp
  kujukuri.chiba.jp
  kyonan.chiba.jp
  matsudo.chiba.jp
  midori.chiba.jp
  mihama.chiba.jp
  minamiboso.chiba.jp
  mobara.chiba.jp
  mutsuzawa.chiba.jp
  nagara.chiba.jp
  nagareyama.chiba.jp
  narashino.chiba.jp
  narita.chiba.jp
  noda.chiba.jp
  oamishirasato.chiba.jp
  omigawa.chiba.jp
  onjuku.chiba.jp
  otaki.chiba.jp
  sakae.chiba.jp
  sakura.chiba.jp
  shimofusa.chiba.jp
  shirako.chiba.jp
  shiroi.chiba.jp
  shisui.chiba.jp
  sodegaura.chiba.jp
  sosa.chiba.jp
  tako.chiba.jp
  tateyama.chiba.jp
  togane.chiba.jp
  tohnosho.chiba.jp
  tomisato.chiba.jp
  urayasu.chiba.jp
  yachimata.chiba.jp
  yachiyo.chiba.jp
  yokaichiba.chiba.jp
  yokoshibahikari.chiba.jp
  yotsukaido.chiba.jp
  ainan.ehime.jp
  honai.ehime.jp
  ikata.ehime.jp
  imabari.ehime.jp
  iyo.ehime.jp
  kamijima.ehime.jp
  kihoku.ehime.jp
  kumakogen.ehime.jp
  masaki.ehime.jp
  matsuno.ehime.jp
  matsuyama.ehime.jp
  namikata.ehime.jp
  niihama.ehime.jp
  ozu.ehime.jp
  saijo.ehime.jp
  seiyo.ehime.jp
  shikokuchuo.ehime.jp
  tobe.ehime.jp
  toon.ehime.jp
  uchiko.ehime.jp
  uwajima.ehime.jp
  yawatahama.ehime.jp
  echizen.fukui.jp
  eiheiji.fukui.jp
  fukui.fukui.jp
  ikeda.fukui.jp
  katsuyama.fukui.jp
  mihama.fukui.jp
  minamiechizen.fukui.jp
  obama.fukui.jp
  ohi.fukui.jp
  ono.fukui.jp
  sabae.fukui.jp
  sakai.fukui.jp
  takahama.fukui.jp
  tsuruga.fukui.jp
  wakasa.fukui.jp
  ashiya.fukuoka.jp
  buzen.fukuoka.jp
  chikugo.fukuoka.jp
  chikuho.fukuoka.jp
  chikujo.fukuoka.jp
  chikushino.fukuoka.jp
  chikuzen.fukuoka.jp
  chuo.fukuoka.jp
  dazaifu.fukuoka.jp
  fukuchi.fukuoka.jp
  hakata.fukuoka.jp
  higashi.fukuoka.jp
  hirokawa.fukuoka.jp
  hisayama.fukuoka.jp
  iizuka.fukuoka.jp
  inatsuki.fukuoka.jp
  kaho.fukuoka.jp
  kasuga.fukuoka.jp
  kasuya.fukuoka.jp
  kawara.fukuoka.jp
  keisen.fukuoka.jp
  koga.fukuoka.jp
  kurate.fukuoka.jp
  kurogi.fukuoka.jp
  kurume.fukuoka.jp
  minami.fukuoka.jp
  miyako.fukuoka.jp
  miyama.fukuoka.jp
  miyawaka.fukuoka.jp
  mizumaki.fukuoka.jp
  munakata.fukuoka.jp
  nakagawa.fukuoka.jp
  nakama.fukuoka.jp
  nishi.fukuoka.jp
  nogata.fukuoka.jp
  ogori.fukuoka.jp
  okagaki.fukuoka.jp
  okawa.fukuoka.jp
  oki.fukuoka.jp
  omuta.fukuoka.jp
  onga.fukuoka.jp
  onojo.fukuoka.jp
  oto.fukuoka.jp
  saigawa.fukuoka.jp
  sasaguri.fukuoka.jp
  shingu.fukuoka.jp
  shinyoshitomi.fukuoka.jp
  shonai.fukuoka.jp
  soeda.fukuoka.jp
  sue.fukuoka.jp
  tachiarai.fukuoka.jp
  tagawa.fukuoka.jp
  takata.fukuoka.jp
  toho.fukuoka.jp
  toyotsu.fukuoka.jp
  tsuiki.fukuoka.jp
  ukiha.fukuoka.jp
  umi.fukuoka.jp
  usui.fukuoka.jp
  yamada.fukuoka.jp
  yame.fukuoka.jp
  yanagawa.fukuoka.jp
  yukuhashi.fukuoka.jp
  aizubange.fukushima.jp
  aizumisato.fukushima.jp
  aizuwakamatsu.fukushima.jp
  asakawa.fukushima.jp
  bandai.fukushima.jp
  date.fukushima.jp
  fukushima.fukushima.jp
  furudono.fukushima.jp
  futaba.fukushima.jp
  hanawa.fukushima.jp
  higashi.fukushima.jp
  hirata.fukushima.jp
  hirono.fukushima.jp
  iitate.fukushima.jp
  inawashiro.fukushima.jp
  ishikawa.fukushima.jp
  iwaki.fukushima.jp
  izumizaki.fukushima.jp
  kagamiishi.fukushima.jp
  kaneyama.fukushima.jp
  kawamata.fukushima.jp
  kitakata.fukushima.jp
  kitashiobara.fukushima.jp
  koori.fukushima.jp
  koriyama.fukushima.jp
  kunimi.fukushima.jp
  miharu.fukushima.jp
  mishima.fukushima.jp
  namie.fukushima.jp
  nango.fukushima.jp
  nishiaizu.fukushima.jp
  nishigo.fukushima.jp
  okuma.fukushima.jp
  omotego.fukushima.jp
  ono.fukushima.jp
  otama.fukushima.jp
  samegawa.fukushima.jp
  shimogo.fukushima.jp
  shirakawa.fukushima.jp
  showa.fukushima.jp
  soma.fukushima.jp
  sukagawa.fukushima.jp
  taishin.fukushima.jp
  tamakawa.fukushima.jp
  tanagura.fukushima.jp
  tenei.fukushima.jp
  yabuki.fukushima.jp
  yamato.fukushima.jp
  yamatsuri.fukushima.jp
  yanaizu.fukushima.jp
  yugawa.fukushima.jp
  anpachi.gifu.jp
  ena.gifu.jp
  gifu.gifu.jp
  ginan.gifu.jp
  godo.gifu.jp
  gujo.gifu.jp
  hashima.gifu.jp
  hichiso.gifu.jp
  hida.gifu.jp
  higashishirakawa.gifu.jp
  ibigawa.gifu.jp
  ikeda.gifu.jp
  kakamigahara.gifu.jp
  kani.gifu.jp
  kasahara.gifu.jp
  kasamatsu.gifu.jp
  kawaue.gifu.jp
  kitagata.gifu.jp
  mino.gifu.jp
  minokamo.gifu.jp
  mitake.gifu.jp
  mizunami.gifu.jp
  motosu.gifu.jp
  nakatsugawa.gifu.jp
  ogaki.gifu.jp
  sakahogi.gifu.jp
  seki.gifu.jp
  sekigahara.gifu.jp
  shirakawa.gifu.jp
  tajimi.gifu.jp
  takayama.gifu.jp
  tarui.gifu.jp
  toki.gifu.jp
  tomika.gifu.jp
  wanouchi.gifu.jp
  yamagata.gifu.jp
  yaotsu.gifu.jp
  yoro.gifu.jp
  annaka.gunma.jp
  chiyoda.gunma.jp
  fujioka.gunma.jp
  higashiagatsuma.gunma.jp
  isesaki.gunma.jp
  itakura.gunma.jp
  kanna.gunma.jp
  kanra.gunma.jp
  katashina.gunma.jp
  kawaba.gunma.jp
  kiryu.gunma.jp
  kusatsu.gunma.jp
  maebashi.gunma.jp
  meiwa.gunma.jp
  midori.gunma.jp
  minakami.gunma.jp
  naganohara.gunma.jp
  nakanojo.gunma.jp
  nanmoku.gunma.jp
  numata.gunma.jp
  oizumi.gunma.jp
  ora.gunma.jp
  ota.gunma.jp
  shibukawa.gunma.jp
  shimonita.gunma.jp
  shinto.gunma.jp
  showa.gunma.jp
  takasaki.gunma.jp
  takayama.gunma.jp
  tamamura.gunma.jp
  tatebayashi.gunma.jp
  tomioka.gunma.jp
  tsukiyono.gunma.jp
  tsumagoi.gunma.jp
  ueno.gunma.jp
  yoshioka.gunma.jp
  asaminami.hiroshima.jp
  daiwa.hiroshima.jp
  etajima.hiroshima.jp
  fuchu.hiroshima.jp
  fukuyama.hiroshima.jp
  hatsukaichi.hiroshima.jp
  higashihiroshima.hiroshima.jp
  hongo.hiroshima.jp
  jinsekikogen.hiroshima.jp
  kaita.hiroshima.jp
  kui.hiroshima.jp
  kumano.hiroshima.jp
  kure.hiroshima.jp
  mihara.hiroshima.jp
  miyoshi.hiroshima.jp
  naka.hiroshima.jp
  onomichi.hiroshima.jp
  osakikamijima.hiroshima.jp
  otake.hiroshima.jp
  saka.hiroshima.jp
  sera.hiroshima.jp
  seranishi.hiroshima.jp
  shinichi.hiroshima.jp
  shobara.hiroshima.jp
  takehara.hiroshima.jp
  abashiri.hokkaido.jp
  abira.hokkaido.jp
  aibetsu.hokkaido.jp
  akabira.hokkaido.jp
  akkeshi.hokkaido.jp
  asahikawa.hokkaido.jp
  ashibetsu.hokkaido.jp
  ashoro.hokkaido.jp
  assabu.hokkaido.jp
  atsuma.hokkaido.jp
  bibai.hokkaido.jp
  biei.hokkaido.jp
  bifuka.hokkaido.jp
  bihoro.hokkaido.jp
  biratori.hokkaido.jp
  chippubetsu.hokkaido.jp
  chitose.hokkaido.jp
  date.hokkaido.jp
  ebetsu.hokkaido.jp
  embetsu.hokkaido.jp
  eniwa.hokkaido.jp
  erimo.hokkaido.jp
  esan.hokkaido.jp
  esashi.hokkaido.jp
  fukagawa.hokkaido.jp
  fukushima.hokkaido.jp
  furano.hokkaido.jp
  furubira.hokkaido.jp
  haboro.hokkaido.jp
  hakodate.hokkaido.jp
  hamatonbetsu.hokkaido.jp
  hidaka.hokkaido.jp
  higashikagura.hokkaido.jp
  higashikawa.hokkaido.jp
  hiroo.hokkaido.jp
  hokuryu.hokkaido.jp
  hokuto.hokkaido.jp
  honbetsu.hokkaido.jp
  horokanai.hokkaido.jp
  horonobe.hokkaido.jp
  ikeda.hokkaido.jp
  imakane.hokkaido.jp
  ishikari.hokkaido.jp
  iwamizawa.hokkaido.jp
  iwanai.hokkaido.jp
  kamifurano.hokkaido.jp
  kamikawa.hokkaido.jp
  kamishihoro.hokkaido.jp
  kamisunagawa.hokkaido.jp
  kamoenai.hokkaido.jp
  kayabe.hokkaido.jp
  kembuchi.hokkaido.jp
  kikonai.hokkaido.jp
  kimobetsu.hokkaido.jp
  kitahiroshima.hokkaido.jp
  kitami.hokkaido.jp
  kiyosato.hokkaido.jp
  koshimizu.hokkaido.jp
  kunneppu.hokkaido.jp
  kuriyama.hokkaido.jp
  kuromatsunai.hokkaido.jp
  kushiro.hokkaido.jp
  kutchan.hokkaido.jp
  kyowa.hokkaido.jp
  mashike.hokkaido.jp
  matsumae.hokkaido.jp
  mikasa.hokkaido.jp
  minamifurano.hokkaido.jp
  mombetsu.hokkaido.jp
  moseushi.hokkaido.jp
  mukawa.hokkaido.jp
  muroran.hokkaido.jp
  naie.hokkaido.jp
  nakagawa.hokkaido.jp
  nakasatsunai.hokkaido.jp
  nakatombetsu.hokkaido.jp
  nanae.hokkaido.jp
  nanporo.hokkaido.jp
  nayoro.hokkaido.jp
  nemuro.hokkaido.jp
  niikappu.hokkaido.jp
  niki.hokkaido.jp
  nishiokoppe.hokkaido.jp
  noboribetsu.hokkaido.jp
  numata.hokkaido.jp
  obihiro.hokkaido.jp
  obira.hokkaido.jp
  oketo.hokkaido.jp
  okoppe.hokkaido.jp
  otaru.hokkaido.jp
  otobe.hokkaido.jp
  otofuke.hokkaido.jp
  otoineppu.hokkaido.jp
  oumu.hokkaido.jp
  ozora.hokkaido.jp
  pippu.hokkaido.jp
  rankoshi.hokkaido.jp
  rebun.hokkaido.jp
  rikubetsu.hokkaido.jp
  rishiri.hokkaido.jp
  rishirifuji.hokkaido.jp
  saroma.hokkaido.jp
  sarufutsu.hokkaido.jp
  shakotan.hokkaido.jp
  shari.hokkaido.jp
  shibecha.hokkaido.jp
  shibetsu.hokkaido.jp
  shikabe.hokkaido.jp
  shikaoi.hokkaido.jp
  shimamaki.hokkaido.jp
  shimizu.hokkaido.jp
  shimokawa.hokkaido.jp
  shinshinotsu.hokkaido.jp
  shintoku.hokkaido.jp
  shiranuka.hokkaido.jp
  shiraoi.hokkaido.jp
  shiriuchi.hokkaido.jp
  sobetsu.hokkaido.jp
  sunagawa.hokkaido.jp
  taiki.hokkaido.jp
  takasu.hokkaido.jp
  takikawa.hokkaido.jp
  takinoue.hokkaido.jp
  teshikaga.hokkaido.jp
  tobetsu.hokkaido.jp
  tohma.hokkaido.jp
  tomakomai.hokkaido.jp
  tomari.hokkaido.jp
  toya.hokkaido.jp
  toyako.hokkaido.jp
  toyotomi.hokkaido.jp
  toyoura.hokkaido.jp
  tsubetsu.hokkaido.jp
  tsukigata.hokkaido.jp
  urakawa.hokkaido.jp
  urausu.hokkaido.jp
  uryu.hokkaido.jp
  utashinai.hokkaido.jp
  wakkanai.hokkaido.jp
  wassamu.hokkaido.jp
  yakumo.hokkaido.jp
  yoichi.hokkaido.jp
  aioi.hyogo.jp
  akashi.hyogo.jp
  ako.hyogo.jp
  amagasaki.hyogo.jp
  aogaki.hyogo.jp
  asago.hyogo.jp
  ashiya.hyogo.jp
  awaji.hyogo.jp
  fukusaki.hyogo.jp
  goshiki.hyogo.jp
  harima.hyogo.jp
  himeji.hyogo.jp
  ichikawa.hyogo.jp
  inagawa.hyogo.jp
  itami.hyogo.jp
  kakogawa.hyogo.jp
  kamigori.hyogo.jp
  kamikawa.hyogo.jp
  kasai.hyogo.jp
  kasuga.hyogo.jp
  kawanishi.hyogo.jp
  miki.hyogo.jp
  minamiawaji.hyogo.jp
  nishinomiya.hyogo.jp
  nishiwaki.hyogo.jp
  ono.hyogo.jp
  sanda.hyogo.jp
  sannan.hyogo.jp
  sasayama.hyogo.jp
  sayo.hyogo.jp
  shingu.hyogo.jp
  shinonsen.hyogo.jp
  shiso.hyogo.jp
  sumoto.hyogo.jp
  taishi.hyogo.jp
  taka.hyogo.jp
  takarazuka.hyogo.jp
  takasago.hyogo.jp
  takino.hyogo.jp
  tamba.hyogo.jp
  tatsuno.hyogo.jp
  toyooka.hyogo.jp
  yabu.hyogo.jp
  yashiro.hyogo.jp
  yoka.hyogo.jp
  yokawa.hyogo.jp
  ami.ibaraki.jp
  asahi.ibaraki.jp
  bando.ibaraki.jp
  chikusei.ibaraki.jp
  daigo.ibaraki.jp
  fujishiro.ibaraki.jp
  hitachi.ibaraki.jp
  hitachinaka.ibaraki.jp
  hitachiomiya.ibaraki.jp
  hitachiota.ibaraki.jp
  ibaraki.ibaraki.jp
  ina.ibaraki.jp
  inashiki.ibaraki.jp
  itako.ibaraki.jp
  iwama.ibaraki.jp
  joso.ibaraki.jp
  kamisu.ibaraki.jp
  kasama.ibaraki.jp
  kashima.ibaraki.jp
  kasumigaura.ibaraki.jp
  koga.ibaraki.jp
  miho.ibaraki.jp
  mito.ibaraki.jp
  moriya.ibaraki.jp
  naka.ibaraki.jp
  namegata.ibaraki.jp
  oarai.ibaraki.jp
  ogawa.ibaraki.jp
  omitama.ibaraki.jp
  ryugasaki.ibaraki.jp
  sakai.ibaraki.jp
  sakuragawa.ibaraki.jp
  shimodate.ibaraki.jp
  shimotsuma.ibaraki.jp
  shirosato.ibaraki.jp
  sowa.ibaraki.jp
  suifu.ibaraki.jp
  takahagi.ibaraki.jp
  tamatsukuri.ibaraki.jp
  tokai.ibaraki.jp
  tomobe.ibaraki.jp
  tone.ibaraki.jp
  toride.ibaraki.jp
  tsuchiura.ibaraki.jp
  tsukuba.ibaraki.jp
  uchihara.ibaraki.jp
  ushiku.ibaraki.jp
  yachiyo.ibaraki.jp
  yamagata.ibaraki.jp
  yawara.ibaraki.jp
  yuki.ibaraki.jp
  anamizu.ishikawa.jp
  hakui.ishikawa.jp
  hakusan.ishikawa.jp
  kaga.ishikawa.jp
  kahoku.ishikawa.jp
  kanazawa.ishikawa.jp
  kawakita.ishikawa.jp
  komatsu.ishikawa.jp
  nakanoto.ishikawa.jp
  nanao.ishikawa.jp
  nomi.ishikawa.jp
  nonoichi.ishikawa.jp
  noto.ishikawa.jp
  shika.ishikawa.jp
  suzu.ishikawa.jp
  tsubata.ishikawa.jp
  tsurugi.ishikawa.jp
  uchinada.ishikawa.jp
  wajima.ishikawa.jp
  fudai.iwate.jp
  fujisawa.iwate.jp
  hanamaki.iwate.jp
  hiraizumi.iwate.jp
  hirono.iwate.jp
  ichinohe.iwate.jp
  ichinoseki.iwate.jp
  iwaizumi.iwate.jp
  iwate.iwate.jp
  joboji.iwate.jp
  kamaishi.iwate.jp
  kanegasaki.iwate.jp
  karumai.iwate.jp
  kawai.iwate.jp
  kitakami.iwate.jp
  kuji.iwate.jp
  kunohe.iwate.jp
  kuzumaki.iwate.jp
  miyako.iwate.jp
  mizusawa.iwate.jp
  morioka.iwate.jp
  ninohe.iwate.jp
  noda.iwate.jp
  ofunato.iwate.jp
  oshu.iwate.jp
  otsuchi.iwate.jp
  rikuzentakata.iwate.jp
  shiwa.iwate.jp
  shizukuishi.iwate.jp
  sumita.iwate.jp
  tanohata.iwate.jp
  tono.iwate.jp
  yahaba.iwate.jp
  yamada.iwate.jp
  ayagawa.kagawa.jp
  higashikagawa.kagawa.jp
  kanonji.kagawa.jp
  kotohira.kagawa.jp
  manno.kagawa.jp
  marugame.kagawa.jp
  mitoyo.kagawa.jp
  naoshima.kagawa.jp
  sanuki.kagawa.jp
  tadotsu.kagawa.jp
  takamatsu.kagawa.jp
  tonosho.kagawa.jp
  uchinomi.kagawa.jp
  utazu.kagawa.jp
  zentsuji.kagawa.jp
  akune.kagoshima.jp
  amami.kagoshima.jp
  hioki.kagoshima.jp
  isa.kagoshima.jp
  isen.kagoshima.jp
  izumi.kagoshima.jp
  kagoshima.kagoshima.jp
  kanoya.kagoshima.jp
  kawanabe.kagoshima.jp
  kinko.kagoshima.jp
  kouyama.kagoshima.jp
  makurazaki.kagoshima.jp
  matsumoto.kagoshima.jp
  minamitane.kagoshima.jp
  nakatane.kagoshima.jp
  nishinoomote.kagoshima.jp
  satsumasendai.kagoshima.jp
  soo.kagoshima.jp
  tarumizu.kagoshima.jp
  yusui.kagoshima.jp
  aikawa.kanagawa.jp
  atsugi.kanagawa.jp
  ayase.kanagawa.jp
  chigasaki.kanagawa.jp
  ebina.kanagawa.jp
  fujisawa.kanagawa.jp
  hadano.kanagawa.jp
  hakone.kanagawa.jp
  hiratsuka.kanagawa.jp
  isehara.kanagawa.jp
  kaisei.kanagawa.jp
  kamakura.kanagawa.jp
  kiyokawa.kanagawa.jp
  matsuda.kanagawa.jp
  minamiashigara.kanagawa.jp
  miura.kanagawa.jp
  nakai.kanagawa.jp
  ninomiya.kanagawa.jp
  odawara.kanagawa.jp
  oi.kanagawa.jp
  oiso.kanagawa.jp
  sagamihara.kanagawa.jp
  samukawa.kanagawa.jp
  tsukui.kanagawa.jp
  yamakita.kanagawa.jp
  yamato.kanagawa.jp
  yokosuka.kanagawa.jp
  yugawara.kanagawa.jp
  zama.kanagawa.jp
  zushi.kanagawa.jp
  aki.kochi.jp
  geisei.kochi.jp
  hidaka.kochi.jp
  higashitsuno.kochi.jp
  ino.kochi.jp
  kagami.kochi.jp
  kami.kochi.jp
  kitagawa.kochi.jp
  kochi.kochi.jp
  mihara.kochi.jp
  motoyama.kochi.jp
  muroto.kochi.jp
  nahari.kochi.jp
  nakamura.kochi.jp
  nankoku.kochi.jp
  nishitosa.kochi.jp
  niyodogawa.kochi.jp
  ochi.kochi.jp
  okawa.kochi.jp
  otoyo.kochi.jp
  otsuki.kochi.jp
  sakawa.kochi.jp
  sukumo.kochi.jp
  susaki.kochi.jp
  tosa.kochi.jp
  tosashimizu.kochi.jp
  toyo.kochi.jp
  tsuno.kochi.jp
  umaji.kochi.jp
  yasuda.kochi.jp
  yusuhara.kochi.jp
  amakusa.kumamoto.jp
  arao.kumamoto.jp
  aso.kumamoto.jp
  choyo.kumamoto.jp
  gyokuto.kumamoto.jp
  hitoyoshi.kumamoto.jp
  kamiamakusa.kumamoto.jp
  kashima.kumamoto.jp
  kikuchi.kumamoto.jp
  kosa.kumamoto.jp
  kumamoto.kumamoto.jp
  mashiki.kumamoto.jp
  mifune.kumamoto.jp
  minamata.kumamoto.jp
  minamioguni.kumamoto.jp
  nagasu.kumamoto.jp
  nishihara.kumamoto.jp
  oguni.kumamoto.jp
  ozu.kumamoto.jp
  sumoto.kumamoto.jp
  takamori.kumamoto.jp
  uki.kumamoto.jp
  uto.kumamoto.jp
  yamaga.kumamoto.jp
  yamato.kumamoto.jp
  yatsushiro.kumamoto.jp
  ayabe.kyoto.jp
  fukuchiyama.kyoto.jp
  higashiyama.kyoto.jp
  ide.kyoto.jp
  ine.kyoto.jp
  joyo.kyoto.jp
  kameoka.kyoto.jp
  kamo.kyoto.jp
  kita.kyoto.jp
  kizu.kyoto.jp
  kumiyama.kyoto.jp
  kyotamba.kyoto.jp
  kyotanabe.kyoto.jp
  kyotango.kyoto.jp
  maizuru.kyoto.jp
  minami.kyoto.jp
  minamiyamashiro.kyoto.jp
  miyazu.kyoto.jp
  muko.kyoto.jp
  nagaokakyo.kyoto.jp
  nakagyo.kyoto.jp
  nantan.kyoto.jp
  oyamazaki.kyoto.jp
  sakyo.kyoto.jp
  seika.kyoto.jp
  tanabe.kyoto.jp
  uji.kyoto.jp
  ujitawara.kyoto.jp
  wazuka.kyoto.jp
  yamashina.kyoto.jp
  yawata.kyoto.jp
  asahi.mie.jp
  inabe.mie.jp
  ise.mie.jp
  kameyama.mie.jp
  kawagoe.mie.jp
  kiho.mie.jp
  kisosaki.mie.jp
  kiwa.mie.jp
  komono.mie.jp
  kumano.mie.jp
  kuwana.mie.jp
  matsusaka.mie.jp
  meiwa.mie.jp
  mihama.mie.jp
  minamiise.mie.jp
  misugi.mie.jp
  miyama.mie.jp
  nabari.mie.jp
  shima.mie.jp
  suzuka.mie.jp
  tado.mie.jp
  taiki.mie.jp
  taki.mie.jp
  tamaki.mie.jp
  toba.mie.jp
  tsu.mie.jp
  udono.mie.jp
  ureshino.mie.jp
  watarai.mie.jp
  yokkaichi.mie.jp
  furukawa.miyagi.jp
  higashimatsushima.miyagi.jp
  ishinomaki.miyagi.jp
  iwanuma.miyagi.jp
  kakuda.miyagi.jp
  kami.miyagi.jp
  kawasaki.miyagi.jp
  kesennuma.miyagi.jp
  marumori.miyagi.jp
  matsushima.miyagi.jp
  minamisanriku.miyagi.jp
  misato.miyagi.jp
  murata.miyagi.jp
  natori.miyagi.jp
  ogawara.miyagi.jp
  ohira.miyagi.jp
  onagawa.miyagi.jp
  osaki.miyagi.jp
  rifu.miyagi.jp
  semine.miyagi.jp
  shibata.miyagi.jp
  shichikashuku.miyagi.jp
  shikama.miyagi.jp
  shiogama.miyagi.jp
  shiroishi.miyagi.jp
  tagajo.miyagi.jp
  taiwa.miyagi.jp
  tome.miyagi.jp
  tomiya.miyagi.jp
  wakuya.miyagi.jp
  watari.miyagi.jp
  yamamoto.miyagi.jp
  zao.miyagi.jp
  aya.miyazaki.jp
  ebino.miyazaki.jp
  gokase.miyazaki.jp
  hyuga.miyazaki.jp
  kadogawa.miyazaki.jp
  kawaminami.miyazaki.jp
  kijo.miyazaki.jp
  kitagawa.miyazaki.jp
  kitakata.miyazaki.jp
  kitaura.miyazaki.jp
  kobayashi.miyazaki.jp
  kunitomi.miyazaki.jp
  kushima.miyazaki.jp
  mimata.miyazaki.jp
  miyakonojo.miyazaki.jp
  miyazaki.miyazaki.jp
  morotsuka.miyazaki.jp
  nichinan.miyazaki.jp
  nishimera.miyazaki.jp
  nobeoka.miyazaki.jp
  saito.miyazaki.jp
  shiiba.miyazaki.jp
  shintomi.miyazaki.jp
  takaharu.miyazaki.jp
  takanabe.miyazaki.jp
  takazaki.miyazaki.jp
  tsuno.miyazaki.jp
  achi.nagano.jp
  agematsu.nagano.jp
  anan.nagano.jp
  aoki.nagano.jp
  asahi.nagano.jp
  azumino.nagano.jp
  chikuhoku.nagano.jp
  chikuma.nagano.jp
  chino.nagano.jp
  fujimi.nagano.jp
  hakuba.nagano.jp
  hara.nagano.jp
  hiraya.nagano.jp
  iida.nagano.jp
  iijima.nagano.jp
  iiyama.nagano.jp
  iizuna.nagano.jp
  ikeda.nagano.jp
  ikusaka.nagano.jp
  ina.nagano.jp
  karuizawa.nagano.jp
  kawakami.nagano.jp
  kiso.nagano.jp
  kisofukushima.nagano.jp
  kitaaiki.nagano.jp
  komagane.nagano.jp
  komoro.nagano.jp
  matsukawa.nagano.jp
  matsumoto.nagano.jp
  miasa.nagano.jp
  minamiaiki.nagano.jp
  minamimaki.nagano.jp
  minamiminowa.nagano.jp
  minowa.nagano.jp
  miyada.nagano.jp
  miyota.nagano.jp
  mochizuki.nagano.jp
  nagano.nagano.jp
  nagawa.nagano.jp
  nagiso.nagano.jp
  nakagawa.nagano.jp
  nakano.nagano.jp
  nozawaonsen.nagano.jp
  obuse.nagano.jp
  ogawa.nagano.jp
  okaya.nagano.jp
  omachi.nagano.jp
  omi.nagano.jp
  ookuwa.nagano.jp
  ooshika.nagano.jp
  otaki.nagano.jp
  otari.nagano.jp
  sakae.nagano.jp
  sakaki.nagano.jp
  saku.nagano.jp
  sakuho.nagano.jp
  shimosuwa.nagano.jp
  shinanomachi.nagano.jp
  shiojiri.nagano.jp
  suwa.nagano.jp
  suzaka.nagano.jp
  takagi.nagano.jp
  takamori.nagano.jp
  takayama.nagano.jp
  tateshina.nagano.jp
  tatsuno.nagano.jp
  togakushi.nagano.jp
  togura.nagano.jp
  tomi.nagano.jp
  ueda.nagano.jp
  wada.nagano.jp
  yamagata.nagano.jp
  yamanouchi.nagano.jp
  yasaka.nagano.jp
  yasuoka.nagano.jp
  chijiwa.nagasaki.jp
  futsu.nagasaki.jp
  goto.nagasaki.jp
  hasami.nagasaki.jp
  hirado.nagasaki.jp
  iki.nagasaki.jp
  isahaya.nagasaki.jp
  kawatana.nagasaki.jp
  kuchinotsu.nagasaki.jp
  matsuura.nagasaki.jp
  nagasaki.nagasaki.jp
  obama.nagasaki.jp
  omura.nagasaki.jp
  oseto.nagasaki.jp
  saikai.nagasaki.jp
  sasebo.nagasaki.jp
  seihi.nagasaki.jp
  shimabara.nagasaki.jp
  shinkamigoto.nagasaki.jp
  togitsu.nagasaki.jp
  tsushima.nagasaki.jp
  unzen.nagasaki.jp
  ando.nara.jp
  gose.nara.jp
  heguri.nara.jp
  higashiyoshino.nara.jp
  ikaruga.nara.jp
  ikoma.nara.jp
  kamikitayama.nara.jp
  kanmaki.nara.jp
  kashiba.nara.jp
  kashihara.nara.jp
  katsuragi.nara.jp
  kawai.nara.jp
  kawakami.nara.jp
  kawanishi.nara.jp
  koryo.nara.jp
  kurotaki.nara.jp
  mitsue.nara.jp
  miyake.nara.jp
  nara.nara.jp
  nosegawa.nara.jp
  oji.nara.jp
  ouda.nara.jp
  oyodo.nara.jp
  sakurai.nara.jp
  sango.nara.jp
  shimoichi.nara.jp
  shimokitayama.nara.jp
  shinjo.nara.jp
  soni.nara.jp
  takatori.nara.jp
  tawaramoto.nara.jp
  tenkawa.nara.jp
  tenri.nara.jp
  uda.nara.jp
  yamatokoriyama.nara.jp
  yamatotakada.nara.jp
  yamazoe.nara.jp
  yoshino.nara.jp
  aga.niigata.jp
  agano.niigata.jp
  gosen.niigata.jp
  itoigawa.niigata.jp
  izumozaki.niigata.jp
  joetsu.niigata.jp
  kamo.niigata.jp
  kariwa.niigata.jp
  kashiwazaki.niigata.jp
  minamiuonuma.niigata.jp
  mitsuke.niigata.jp
  muika.niigata.jp
  murakami.niigata.jp
  myoko.niigata.jp
  nagaoka.niigata.jp
  niigata.niigata.jp
  ojiya.niigata.jp
  omi.niigata.jp
  sado.niigata.jp
  sanjo.niigata.jp
  seiro.niigata.jp
  seirou.niigata.jp
  sekikawa.niigata.jp
  shibata.niigata.jp
  tagami.niigata.jp
  tainai.niigata.jp
  tochio.niigata.jp
  tokamachi.niigata.jp
  tsubame.niigata.jp
  tsunan.niigata.jp
  uonuma.niigata.jp
  yahiko.niigata.jp
  yoita.niigata.jp
  yuzawa.niigata.jp
  beppu.oita.jp
  bungoono.oita.jp
  bungotakada.oita.jp
  hasama.oita.jp
  hiji.oita.jp
  himeshima.oita.jp
  hita.oita.jp
  kamitsue.oita.jp
  kokonoe.oita.jp
  kuju.oita.jp
  kunisaki.oita.jp
  kusu.oita.jp
  oita.oita.jp
  saiki.oita.jp
  taketa.oita.jp
  tsukumi.oita.jp
  usa.oita.jp
  usuki.oita.jp
  yufu.oita.jp
  akaiwa.okayama.jp
  asakuchi.okayama.jp
  bizen.okayama.jp
  hayashima.okayama.jp
  ibara.okayama.jp
  kagamino.okayama.jp
  kasaoka.okayama.jp
  kibichuo.okayama.jp
  kumenan.okayama.jp
  kurashiki.okayama.jp
  maniwa.okayama.jp
  misaki.okayama.jp
  nagi.okayama.jp
  niimi.okayama.jp
  nishiawakura.okayama.jp
  okayama.okayama.jp
  satosho.okayama.jp
  setouchi.okayama.jp
  shinjo.okayama.jp
  shoo.okayama.jp
  soja.okayama.jp
  takahashi.okayama.jp
  tamano.okayama.jp
  tsuyama.okayama.jp
  wake.okayama.jp
  yakage.okayama.jp
  aguni.okinawa.jp
  ginowan.okinawa.jp
  ginoza.okinawa.jp
  gushikami.okinawa.jp
  haebaru.okinawa.jp
  higashi.okinawa.jp
  hirara.okinawa.jp
  iheya.okinawa.jp
  ishigaki.okinawa.jp
  ishikawa.okinawa.jp
  itoman.okinawa.jp
  izena.okinawa.jp
  kadena.okinawa.jp
  kin.okinawa.jp
  kitadaito.okinawa.jp
  kitanakagusuku.okinawa.jp
  kumejima.okinawa.jp
  kunigami.okinawa.jp
  minamidaito.okinawa.jp
  motobu.okinawa.jp
  nago.okinawa.jp
  naha.okinawa.jp
  nakagusuku.okinawa.jp
  nakijin.okinawa.jp
  nanjo.okinawa.jp
  nishihara.okinawa.jp
  ogimi.okinawa.jp
  okinawa.okinawa.jp
  onna.okinawa.jp
  shimoji.okinawa.jp
  taketomi.okinawa.jp
  tarama.okinawa.jp
  tokashiki.okinawa.jp
  tomigusuku.okinawa.jp
  tonaki.okinawa.jp
  urasoe.okinawa.jp
  uruma.okinawa.jp
  yaese.okinawa.jp
  yomitan.okinawa.jp
  yonabaru.okinawa.jp
  yonaguni.okinawa.jp
  zamami.okinawa.jp
  abeno.osaka.jp
  chihayaakasaka.osaka.jp
  chuo.osaka.jp
  daito.osaka.jp
  fujiidera.osaka.jp
  habikino.osaka.jp
  hannan.osaka.jp
  higashiosaka.osaka.jp
  higashisumiyoshi.osaka.jp
  higashiyodogawa.osaka.jp
  hirakata.osaka.jp
  ibaraki.osaka.jp
  ikeda.osaka.jp
  izumi.osaka.jp
  izumiotsu.osaka.jp
  izumisano.osaka.jp
  kadoma.osaka.jp
  kaizuka.osaka.jp
  kanan.osaka.jp
  kashiwara.osaka.jp
  katano.osaka.jp
  kawachinagano.osaka.jp
  kishiwada.osaka.jp
  kita.osaka.jp
  kumatori.osaka.jp
  matsubara.osaka.jp
  minato.osaka.jp
  minoh.osaka.jp
  misaki.osaka.jp
  moriguchi.osaka.jp
  neyagawa.osaka.jp
  nishi.osaka.jp
  nose.osaka.jp
  osakasayama.osaka.jp
  sakai.osaka.jp
  sayama.osaka.jp
  sennan.osaka.jp
  settsu.osaka.jp
  shijonawate.osaka.jp
  shimamoto.osaka.jp
  suita.osaka.jp
  tadaoka.osaka.jp
  taishi.osaka.jp
  tajiri.osaka.jp
  takaishi.osaka.jp
  takatsuki.osaka.jp
  tondabayashi.osaka.jp
  toyonaka.osaka.jp
  toyono.osaka.jp
  yao.osaka.jp
  ariake.saga.jp
  arita.saga.jp
  fukudomi.saga.jp
  genkai.saga.jp
  hamatama.saga.jp
  hizen.saga.jp
  imari.saga.jp
  kamimine.saga.jp
  kanzaki.saga.jp
  karatsu.saga.jp
  kashima.saga.jp
  kitagata.saga.jp
  kitahata.saga.jp
  kiyama.saga.jp
  kouhoku.saga.jp
  kyuragi.saga.jp
  nishiarita.saga.jp
  ogi.saga.jp
  omachi.saga.jp
  ouchi.saga.jp
  saga.saga.jp
  shiroishi.saga.jp
  taku.saga.jp
  tara.saga.jp
  tosu.saga.jp
  yoshinogari.saga.jp
  arakawa.saitama.jp
  asaka.saitama.jp
  chichibu.saitama.jp
  fujimi.saitama.jp
  fujimino.saitama.jp
  fukaya.saitama.jp
  hanno.saitama.jp
  hanyu.saitama.jp
  hasuda.saitama.jp
  hatogaya.saitama.jp
  hatoyama.saitama.jp
  hidaka.saitama.jp
  higashichichibu.saitama.jp
  higashimatsuyama.saitama.jp
  honjo.saitama.jp
  ina.saitama.jp
  iruma.saitama.jp
  iwatsuki.saitama.jp
  kamiizumi.saitama.jp
  kamikawa.saitama.jp
  kamisato.saitama.jp
  kasukabe.saitama.jp
  kawagoe.saitama.jp
  kawaguchi.saitama.jp
  kawajima.saitama.jp
  kazo.saitama.jp
  kitamoto.saitama.jp
  koshigaya.saitama.jp
  kounosu.saitama.jp
  kuki.saitama.jp
  kumagaya.saitama.jp
  matsubushi.saitama.jp
  minano.saitama.jp
  misato.saitama.jp
  miyashiro.saitama.jp
  miyoshi.saitama.jp
  moroyama.saitama.jp
  nagatoro.saitama.jp
  namegawa.saitama.jp
  niiza.saitama.jp
  ogano.saitama.jp
  ogawa.saitama.jp
  ogose.saitama.jp
  okegawa.saitama.jp
  omiya.saitama.jp
  otaki.saitama.jp
  ranzan.saitama.jp
  ryokami.saitama.jp
  saitama.saitama.jp
  sakado.saitama.jp
  satte.saitama.jp
  sayama.saitama.jp
  shiki.saitama.jp
  shiraoka.saitama.jp
  soka.saitama.jp
  sugito.saitama.jp
  toda.saitama.jp
  tokigawa.saitama.jp
  tokorozawa.saitama.jp
  tsurugashima.saitama.jp
  urawa.saitama.jp
  warabi.saitama.jp
  yashio.saitama.jp
  yokoze.saitama.jp
  yono.saitama.jp
  yorii.saitama.jp
  yoshida.saitama.jp
  yoshikawa.saitama.jp
  yoshimi.saitama.jp
  aisho.shiga.jp
  gamo.shiga.jp
  higashiomi.shiga.jp
  hikone.shiga.jp
  koka.shiga.jp
  konan.shiga.jp
  kosei.shiga.jp
  koto.shiga.jp
  kusatsu.shiga.jp
  maibara.shiga.jp
  moriyama.shiga.jp
  nagahama.shiga.jp
  nishiazai.shiga.jp
  notogawa.shiga.jp
  omihachiman.shiga.jp
  otsu.shiga.jp
  ritto.shiga.jp
  ryuoh.shiga.jp
  takashima.shiga.jp
  takatsuki.shiga.jp
  torahime.shiga.jp
  toyosato.shiga.jp
  yasu.shiga.jp
  akagi.shimane.jp
  ama.shimane.jp
  gotsu.shimane.jp
  hamada.shimane.jp
  higashiizumo.shimane.jp
  hikawa.shimane.jp
  hikimi.shimane.jp
  izumo.shimane.jp
  kakinoki.shimane.jp
  masuda.shimane.jp
  matsue.shimane.jp
  misato.shimane.jp
  nishinoshima.shimane.jp
  ohda.shimane.jp
  okinoshima.shimane.jp
  okuizumo.shimane.jp
  shimane.shimane.jp
  tamayu.shimane.jp
  tsuwano.shimane.jp
  unnan.shimane.jp
  yakumo.shimane.jp
  yasugi.shimane.jp
  yatsuka.shimane.jp
  arai.shizuoka.jp
  atami.shizuoka.jp
  fuji.shizuoka.jp
  fujieda.shizuoka.jp
  fujikawa.shizuoka.jp
  fujinomiya.shizuoka.jp
  fukuroi.shizuoka.jp
  gotemba.shizuoka.jp
  haibara.shizuoka.jp
  hamamatsu.shizuoka.jp
  higashiizu.shizuoka.jp
  ito.shizuoka.jp
  iwata.shizuoka.jp
  izu.shizuoka.jp
  izunokuni.shizuoka.jp
  kakegawa.shizuoka.jp
  kannami.shizuoka.jp
  kawanehon.shizuoka.jp
  kawazu.shizuoka.jp
  kikugawa.shizuoka.jp
  kosai.shizuoka.jp
  makinohara.shizuoka.jp
  matsuzaki.shizuoka.jp
  minamiizu.shizuoka.jp
  mishima.shizuoka.jp
  morimachi.shizuoka.jp
  nishiizu.shizuoka.jp
  numazu.shizuoka.jp
  omaezaki.shizuoka.jp
  shimada.shizuoka.jp
  shimizu.shizuoka.jp
  shimoda.shizuoka.jp
  shizuoka.shizuoka.jp
  susono.shizuoka.jp
  yaizu.shizuoka.jp
  yoshida.shizuoka.jp
  ashikaga.tochigi.jp
  bato.tochigi.jp
  haga.tochigi.jp
  ichikai.tochigi.jp
  iwafune.tochigi.jp
  kaminokawa.tochigi.jp
  kanuma.tochigi.jp
  karasuyama.tochigi.jp
  kuroiso.tochigi.jp
  mashiko.tochigi.jp
  mibu.tochigi.jp
  moka.tochigi.jp
  motegi.tochigi.jp
  nasu.tochigi.jp
  nasushiobara.tochigi.jp
  nikko.tochigi.jp
  nishikata.tochigi.jp
  nogi.tochigi.jp
  ohira.tochigi.jp
  ohtawara.tochigi.jp
  oyama.tochigi.jp
  sakura.tochigi.jp
  sano.tochigi.jp
  shimotsuke.tochigi.jp
  shioya.tochigi.jp
  takanezawa.tochigi.jp
  tochigi.tochigi.jp
  tsuga.tochigi.jp
  ujiie.tochigi.jp
  utsunomiya.tochigi.jp
  yaita.tochigi.jp
  aizumi.tokushima.jp
  anan.tokushima.jp
  ichiba.tokushima.jp
  itano.tokushima.jp
  kainan.tokushima.jp
  komatsushima.tokushima.jp
  matsushige.tokushima.jp
  mima.tokushima.jp
  minami.tokushima.jp
  miyoshi.tokushima.jp
  mugi.tokushima.jp
  nakagawa.tokushima.jp
  naruto.tokushima.jp
  sanagochi.tokushima.jp
  shishikui.tokushima.jp
  tokushima.tokushima.jp
  wajiki.tokushima.jp
  adachi.tokyo.jp
  akiruno.tokyo.jp
  akishima.tokyo.jp
  aogashima.tokyo.jp
  arakawa.tokyo.jp
  bunkyo.tokyo.jp
  chiyoda.tokyo.jp
  chofu.tokyo.jp
  chuo.tokyo.jp
  edogawa.tokyo.jp
  fuchu.tokyo.jp
  fussa.tokyo.jp
  hachijo.tokyo.jp
  hachioji.tokyo.jp
  hamura.tokyo.jp
  higashikurume.tokyo.jp
  higashimurayama.tokyo.jp
  higashiyamato.tokyo.jp
  hino.tokyo.jp
  hinode.tokyo.jp
  hinohara.tokyo.jp
  inagi.tokyo.jp
  itabashi.tokyo.jp
  katsushika.tokyo.jp
  kita.tokyo.jp
  kiyose.tokyo.jp
  kodaira.tokyo.jp
  koganei.tokyo.jp
  kokubunji.tokyo.jp
  komae.tokyo.jp
  koto.tokyo.jp
  kouzushima.tokyo.jp
  kunitachi.tokyo.jp
  machida.tokyo.jp
  meguro.tokyo.jp
  minato.tokyo.jp
  mitaka.tokyo.jp
  mizuho.tokyo.jp
  musashimurayama.tokyo.jp
  musashino.tokyo.jp
  nakano.tokyo.jp
  nerima.tokyo.jp
  ogasawara.tokyo.jp
  okutama.tokyo.jp
  ome.tokyo.jp
  oshima.tokyo.jp
  ota.tokyo.jp
  setagaya.tokyo.jp
  shibuya.tokyo.jp
  shinagawa.tokyo.jp
  shinjuku.tokyo.jp
  suginami.tokyo.jp
  sumida.tokyo.jp
  tachikawa.tokyo.jp
  taito.tokyo.jp
  tama.tokyo.jp
  toshima.tokyo.jp
  chizu.tottori.jp
  hino.tottori.jp
  kawahara.tottori.jp
  koge.tottori.jp
  kotoura.tottori.jp
  misasa.tottori.jp
  nanbu.tottori.jp
  nichinan.tottori.jp
  sakaiminato.tottori.jp
  tottori.tottori.jp
  wakasa.tottori.jp
  yazu.tottori.jp
  yonago.tottori.jp
  asahi.toyama.jp
  fuchu.toyama.jp
  fukumitsu.toyama.jp
  funahashi.toyama.jp
  himi.toyama.jp
  imizu.toyama.jp
  inami.toyama.jp
  johana.toyama.jp
  kamiichi.toyama.jp
  kurobe.toyama.jp
  nakaniikawa.toyama.jp
  namerikawa.toyama.jp
  nanto.toyama.jp
  nyuzen.toyama.jp
  oyabe.toyama.jp
  taira.toyama.jp
  takaoka.toyama.jp
  tateyama.toyama.jp
  toga.toyama.jp
  tonami.toyama.jp
  toyama.toyama.jp
  unazuki.toyama.jp
  uozu.toyama.jp
  yamada.toyama.jp
  arida.wakayama.jp
  aridagawa.wakayama.jp
  gobo.wakayama.jp
  hashimoto.wakayama.jp
  hidaka.wakayama.jp
  hirogawa.wakayama.jp
  inami.wakayama.jp
  iwade.wakayama.jp
  kainan.wakayama.jp
  kamitonda.wakayama.jp
  katsuragi.wakayama.jp
  kimino.wakayama.jp
  kinokawa.wakayama.jp
  kitayama.wakayama.jp
  koya.wakayama.jp
  koza.wakayama.jp
  kozagawa.wakayama.jp
  kudoyama.wakayama.jp
  kushimoto.wakayama.jp
  mihama.wakayama.jp
  misato.wakayama.jp
  nachikatsuura.wakayama.jp
  shingu.wakayama.jp
  shirahama.wakayama.jp
  taiji.wakayama.jp
  tanabe.wakayama.jp
  wakayama.wakayama.jp
  yuasa.wakayama.jp
  yura.wakayama.jp
  asahi.yamagata.jp
  funagata.yamagata.jp
  higashine.yamagata.jp
  iide.yamagata.jp
  kahoku.yamagata.jp
  kaminoyama.yamagata.jp
  kaneyama.yamagata.jp
  kawanishi.yamagata.jp
  mamurogawa.yamagata.jp
  mikawa.yamagata.jp
  murayama.yamagata.jp
  nagai.yamagata.jp
  nakayama.yamagata.jp
  nanyo.yamagata.jp
  nishikawa.yamagata.jp
  obanazawa.yamagata.jp
  oe.yamagata.jp
  oguni.yamagata.jp
  ohkura.yamagata.jp
  oishida.yamagata.jp
  sagae.yamagata.jp
  sakata.yamagata.jp
  sakegawa.yamagata.jp
  shinjo.yamagata.jp
  shirataka.yamagata.jp
  shonai.yamagata.jp
  takahata.yamagata.jp
  tendo.yamagata.jp
  tozawa.yamagata.jp
  tsuruoka.yamagata.jp
  yamagata.yamagata.jp
  yamanobe.yamagata.jp
  yonezawa.yamagata.jp
  yuza.yamagata.jp
  abu.yamaguchi.jp
  hagi.yamaguchi.jp
  hikari.yamaguchi.jp
  hofu.yamaguchi.jp
  iwakuni.yamaguchi.jp
  kudamatsu.yamaguchi.jp
  mitou.yamaguchi.jp
  nagato.yamaguchi.jp
  oshima.yamaguchi.jp
  shimonoseki.yamaguchi.jp
  shunan.yamaguchi.jp
  tabuse.yamaguchi.jp
  tokuyama.yamaguchi.jp
  toyota.yamaguchi.jp
  ube.yamaguchi.jp
  yuu.yamaguchi.jp
  chuo.yamanashi.jp
  doshi.yamanashi.jp
  fuefuki.yamanashi.jp
  fujikawa.yamanashi.jp
  fujikawaguchiko.yamanashi.jp
  fujiyoshida.yamanashi.jp
  hayakawa.yamanashi.jp
  hokuto.yamanashi.jp
  ichikawamisato.yamanashi.jp
  kai.yamanashi.jp
  kofu.yamanashi.jp
  koshu.yamanashi.jp
  kosuge.yamanashi.jp
  minami-alps.yamanashi.jp
  minobu.yamanashi.jp
  nakamichi.yamanashi.jp
  nanbu.yamanashi.jp
  narusawa.yamanashi.jp
  nirasaki.yamanashi.jp
  nishikatsura.yamanashi.jp
  oshino.yamanashi.jp
  otsuki.yamanashi.jp
  showa.yamanashi.jp
  tabayama.yamanashi.jp
  tsuru.yamanashi.jp
  uenohara.yamanashi.jp
  yamanakako.yamanashi.jp
  yamanashi.yamanashi.jp
  
  // ke : http://www.kenic.or.ke/index.php?option=com_content&task=view&id=117&Itemid=145
  *.ke
  
  // kg : http://www.domain.kg/dmn_n.html
  kg
  org.kg
  net.kg
  com.kg
  edu.kg
  gov.kg
  mil.kg
  
  // kh : http://www.mptc.gov.kh/dns_registration.htm
  *.kh
  
  // ki : http://www.ki/dns/index.html
  ki
  edu.ki
  biz.ki
  net.ki
  org.ki
  gov.ki
  info.ki
  com.ki
  
  // km : http://en.wikipedia.org/wiki/.km
  // http://www.domaine.km/documents/charte.doc
  km
  org.km
  nom.km
  gov.km
  prd.km
  tm.km
  edu.km
  mil.km
  ass.km
  com.km
  // These are only mentioned as proposed suggestions at domaine.km, but
  // http://en.wikipedia.org/wiki/.km says they're available for registration:
  coop.km
  asso.km
  presse.km
  medecin.km
  notaires.km
  pharmaciens.km
  veterinaire.km
  gouv.km
  
  // kn : http://en.wikipedia.org/wiki/.kn
  // http://www.dot.kn/domainRules.html
  kn
  net.kn
  org.kn
  edu.kn
  gov.kn
  
  // kp : http://www.kcce.kp/en_index.php
  kp
  com.kp
  edu.kp
  gov.kp
  org.kp
  rep.kp
  tra.kp
  
  // kr : http://en.wikipedia.org/wiki/.kr
  // see also: http://domain.nida.or.kr/eng/registration.jsp
  kr
  ac.kr
  co.kr
  es.kr
  go.kr
  hs.kr
  kg.kr
  mil.kr
  ms.kr
  ne.kr
  or.kr
  pe.kr
  re.kr
  sc.kr
  // kr geographical names
  busan.kr
  chungbuk.kr
  chungnam.kr
  daegu.kr
  daejeon.kr
  gangwon.kr
  gwangju.kr
  gyeongbuk.kr
  gyeonggi.kr
  gyeongnam.kr
  incheon.kr
  jeju.kr
  jeonbuk.kr
  jeonnam.kr
  seoul.kr
  ulsan.kr
  
  // kw : http://en.wikipedia.org/wiki/.kw
  *.kw
  
  // ky : http://www.icta.ky/da_ky_reg_dom.php
  // Confirmed by registry <kysupport@perimeterusa.com> 2008-06-17
  ky
  edu.ky
  gov.ky
  com.ky
  org.ky
  net.ky
  
  // kz : http://en.wikipedia.org/wiki/.kz
  // see also: http://www.nic.kz/rules/index.jsp
  kz
  org.kz
  edu.kz
  net.kz
  gov.kz
  mil.kz
  com.kz
  
  // la : http://en.wikipedia.org/wiki/.la
  // Submitted by registry <gavin.brown@nic.la> 2008-06-10
  la
  int.la
  net.la
  info.la
  edu.la
  gov.la
  per.la
  com.la
  org.la
  
  // lb : http://en.wikipedia.org/wiki/.lb
  // Submitted by registry <randy@psg.com> 2008-06-17
  lb
  com.lb
  edu.lb
  gov.lb
  net.lb
  org.lb
  
  // lc : http://en.wikipedia.org/wiki/.lc
  // see also: http://www.nic.lc/rules.htm
  lc
  com.lc
  net.lc
  co.lc
  org.lc
  edu.lc
  gov.lc
  
  // li : http://en.wikipedia.org/wiki/.li
  li
  
  // lk : http://www.nic.lk/seclevpr.html
  lk
  gov.lk
  sch.lk
  net.lk
  int.lk
  com.lk
  org.lk
  edu.lk
  ngo.lk
  soc.lk
  web.lk
  ltd.lk
  assn.lk
  grp.lk
  hotel.lk
  ac.lk
  
  // lr : http://psg.com/dns/lr/lr.txt
  // Submitted by registry <randy@psg.com> 2008-06-17
  lr
  com.lr
  edu.lr
  gov.lr
  org.lr
  net.lr
  
  // ls : http://en.wikipedia.org/wiki/.ls
  ls
  co.ls
  org.ls
  
  // lt : http://en.wikipedia.org/wiki/.lt
  lt
  // gov.lt : http://www.gov.lt/index_en.php
  gov.lt
  
  // lu : http://www.dns.lu/en/
  lu
  
  // lv : http://www.nic.lv/DNS/En/generic.php
  lv
  com.lv
  edu.lv
  gov.lv
  org.lv
  mil.lv
  id.lv
  net.lv
  asn.lv
  conf.lv
  
  // ly : http://www.nic.ly/regulations.php
  ly
  com.ly
  net.ly
  gov.ly
  plc.ly
  edu.ly
  sch.ly
  med.ly
  org.ly
  id.ly
  
  // ma : http://en.wikipedia.org/wiki/.ma
  // http://www.anrt.ma/fr/admin/download/upload/file_fr782.pdf
  ma
  co.ma
  net.ma
  gov.ma
  org.ma
  ac.ma
  press.ma
  
  // mc : http://www.nic.mc/
  mc
  tm.mc
  asso.mc
  
  // md : http://en.wikipedia.org/wiki/.md
  md
  
  // me : http://en.wikipedia.org/wiki/.me
  me
  co.me
  net.me
  org.me
  edu.me
  ac.me
  gov.me
  its.me
  priv.me
  
  // mg : http://nic.mg/nicmg/?page_id=39
  mg
  org.mg
  nom.mg
  gov.mg
  prd.mg
  tm.mg
  edu.mg
  mil.mg
  com.mg
  co.mg
  
  // mh : http://en.wikipedia.org/wiki/.mh
  mh
  
  // mil : http://en.wikipedia.org/wiki/.mil
  mil
  
  // mk : http://en.wikipedia.org/wiki/.mk
  // see also: http://dns.marnet.net.mk/postapka.php
  mk
  com.mk
  org.mk
  net.mk
  edu.mk
  gov.mk
  inf.mk
  name.mk
  
  // ml : http://www.gobin.info/domainname/ml-template.doc
  // see also: http://en.wikipedia.org/wiki/.ml
  ml
  com.ml
  edu.ml
  gouv.ml
  gov.ml
  net.ml
  org.ml
  presse.ml
  
  // mm : http://en.wikipedia.org/wiki/.mm
  *.mm
  
  // mn : http://en.wikipedia.org/wiki/.mn
  mn
  gov.mn
  edu.mn
  org.mn
  
  // mo : http://www.monic.net.mo/
  mo
  com.mo
  net.mo
  org.mo
  edu.mo
  gov.mo
  
  // mobi : http://en.wikipedia.org/wiki/.mobi
  mobi
  
  // mp : http://www.dot.mp/
  // Confirmed by registry <dcamacho@saipan.com> 2008-06-17
  mp
  
  // mq : http://en.wikipedia.org/wiki/.mq
  mq
  
  // mr : http://en.wikipedia.org/wiki/.mr
  mr
  gov.mr
  
  // ms : http://www.nic.ms/pdf/MS_Domain_Name_Rules.pdf
  ms
  com.ms
  edu.ms
  gov.ms
  net.ms
  org.ms
  
  // mt : https://www.nic.org.mt/go/policy
  // Submitted by registry <help@nic.org.mt> 2013-11-19
  mt
  com.mt
  edu.mt
  net.mt
  org.mt
  
  // mu : http://en.wikipedia.org/wiki/.mu
  mu
  com.mu
  net.mu
  org.mu
  gov.mu
  ac.mu
  co.mu
  or.mu
  
  // museum : http://about.museum/naming/
  // http://index.museum/
  museum
  academy.museum
  agriculture.museum
  air.museum
  airguard.museum
  alabama.museum
  alaska.museum
  amber.museum
  ambulance.museum
  american.museum
  americana.museum
  americanantiques.museum
  americanart.museum
  amsterdam.museum
  and.museum
  annefrank.museum
  anthro.museum
  anthropology.museum
  antiques.museum
  aquarium.museum
  arboretum.museum
  archaeological.museum
  archaeology.museum
  architecture.museum
  art.museum
  artanddesign.museum
  artcenter.museum
  artdeco.museum
  arteducation.museum
  artgallery.museum
  arts.museum
  artsandcrafts.museum
  asmatart.museum
  assassination.museum
  assisi.museum
  association.museum
  astronomy.museum
  atlanta.museum
  austin.museum
  australia.museum
  automotive.museum
  aviation.museum
  axis.museum
  badajoz.museum
  baghdad.museum
  bahn.museum
  bale.museum
  baltimore.museum
  barcelona.museum
  baseball.museum
  basel.museum
  baths.museum
  bauern.museum
  beauxarts.museum
  beeldengeluid.museum
  bellevue.museum
  bergbau.museum
  berkeley.museum
  berlin.museum
  bern.museum
  bible.museum
  bilbao.museum
  bill.museum
  birdart.museum
  birthplace.museum
  bonn.museum
  boston.museum
  botanical.museum
  botanicalgarden.museum
  botanicgarden.museum
  botany.museum
  brandywinevalley.museum
  brasil.museum
  bristol.museum
  british.museum
  britishcolumbia.museum
  broadcast.museum
  brunel.museum
  brussel.museum
  brussels.museum
  bruxelles.museum
  building.museum
  burghof.museum
  bus.museum
  bushey.museum
  cadaques.museum
  california.museum
  cambridge.museum
  can.museum
  canada.museum
  capebreton.museum
  carrier.museum
  cartoonart.museum
  casadelamoneda.museum
  castle.museum
  castres.museum
  celtic.museum
  center.museum
  chattanooga.museum
  cheltenham.museum
  chesapeakebay.museum
  chicago.museum
  children.museum
  childrens.museum
  childrensgarden.museum
  chiropractic.museum
  chocolate.museum
  christiansburg.museum
  cincinnati.museum
  cinema.museum
  circus.museum
  civilisation.museum
  civilization.museum
  civilwar.museum
  clinton.museum
  clock.museum
  coal.museum
  coastaldefence.museum
  cody.museum
  coldwar.museum
  collection.museum
  colonialwilliamsburg.museum
  coloradoplateau.museum
  columbia.museum
  columbus.museum
  communication.museum
  communications.museum
  community.museum
  computer.museum
  computerhistory.museum
  xn--comunicaes-v6a2o.museum
  contemporary.museum
  contemporaryart.museum
  convent.museum
  copenhagen.museum
  corporation.museum
  xn--correios-e-telecomunicaes-ghc29a.museum
  corvette.museum
  costume.museum
  countryestate.museum
  county.museum
  crafts.museum
  cranbrook.museum
  creation.museum
  cultural.museum
  culturalcenter.museum
  culture.museum
  cyber.museum
  cymru.museum
  dali.museum
  dallas.museum
  database.museum
  ddr.museum
  decorativearts.museum
  delaware.museum
  delmenhorst.museum
  denmark.museum
  depot.museum
  design.museum
  detroit.museum
  dinosaur.museum
  discovery.museum
  dolls.museum
  donostia.museum
  durham.museum
  eastafrica.museum
  eastcoast.museum
  education.museum
  educational.museum
  egyptian.museum
  eisenbahn.museum
  elburg.museum
  elvendrell.museum
  embroidery.museum
  encyclopedic.museum
  england.museum
  entomology.museum
  environment.museum
  environmentalconservation.museum
  epilepsy.museum
  essex.museum
  estate.museum
  ethnology.museum
  exeter.museum
  exhibition.museum
  family.museum
  farm.museum
  farmequipment.museum
  farmers.museum
  farmstead.museum
  field.museum
  figueres.museum
  filatelia.museum
  film.museum
  fineart.museum
  finearts.museum
  finland.museum
  flanders.museum
  florida.museum
  force.museum
  fortmissoula.museum
  fortworth.museum
  foundation.museum
  francaise.museum
  frankfurt.museum
  franziskaner.museum
  freemasonry.museum
  freiburg.museum
  fribourg.museum
  frog.museum
  fundacio.museum
  furniture.museum
  gallery.museum
  garden.museum
  gateway.museum
  geelvinck.museum
  gemological.museum
  geology.museum
  georgia.museum
  giessen.museum
  glas.museum
  glass.museum
  gorge.museum
  grandrapids.museum
  graz.museum
  guernsey.museum
  halloffame.museum
  hamburg.museum
  handson.museum
  harvestcelebration.museum
  hawaii.museum
  health.museum
  heimatunduhren.museum
  hellas.museum
  helsinki.museum
  hembygdsforbund.museum
  heritage.museum
  histoire.museum
  historical.museum
  historicalsociety.museum
  historichouses.museum
  historisch.museum
  historisches.museum
  history.museum
  historyofscience.museum
  horology.museum
  house.museum
  humanities.museum
  illustration.museum
  imageandsound.museum
  indian.museum
  indiana.museum
  indianapolis.museum
  indianmarket.museum
  intelligence.museum
  interactive.museum
  iraq.museum
  iron.museum
  isleofman.museum
  jamison.museum
  jefferson.museum
  jerusalem.museum
  jewelry.museum
  jewish.museum
  jewishart.museum
  jfk.museum
  journalism.museum
  judaica.museum
  judygarland.museum
  juedisches.museum
  juif.museum
  karate.museum
  karikatur.museum
  kids.museum
  koebenhavn.museum
  koeln.museum
  kunst.museum
  kunstsammlung.museum
  kunstunddesign.museum
  labor.museum
  labour.museum
  lajolla.museum
  lancashire.museum
  landes.museum
  lans.museum
  xn--lns-qla.museum
  larsson.museum
  lewismiller.museum
  lincoln.museum
  linz.museum
  living.museum
  livinghistory.museum
  localhistory.museum
  london.museum
  losangeles.museum
  louvre.museum
  loyalist.museum
  lucerne.museum
  luxembourg.museum
  luzern.museum
  mad.museum
  madrid.museum
  mallorca.museum
  manchester.museum
  mansion.museum
  mansions.museum
  manx.museum
  marburg.museum
  maritime.museum
  maritimo.museum
  maryland.museum
  marylhurst.museum
  media.museum
  medical.museum
  medizinhistorisches.museum
  meeres.museum
  memorial.museum
  mesaverde.museum
  michigan.museum
  midatlantic.museum
  military.museum
  mill.museum
  miners.museum
  mining.museum
  minnesota.museum
  missile.museum
  missoula.museum
  modern.museum
  moma.museum
  money.museum
  monmouth.museum
  monticello.museum
  montreal.museum
  moscow.museum
  motorcycle.museum
  muenchen.museum
  muenster.museum
  mulhouse.museum
  muncie.museum
  museet.museum
  museumcenter.museum
  museumvereniging.museum
  music.museum
  national.museum
  nationalfirearms.museum
  nationalheritage.museum
  nativeamerican.museum
  naturalhistory.museum
  naturalhistorymuseum.museum
  naturalsciences.museum
  nature.museum
  naturhistorisches.museum
  natuurwetenschappen.museum
  naumburg.museum
  naval.museum
  nebraska.museum
  neues.museum
  newhampshire.museum
  newjersey.museum
  newmexico.museum
  newport.museum
  newspaper.museum
  newyork.museum
  niepce.museum
  norfolk.museum
  north.museum
  nrw.museum
  nuernberg.museum
  nuremberg.museum
  nyc.museum
  nyny.museum
  oceanographic.museum
  oceanographique.museum
  omaha.museum
  online.museum
  ontario.museum
  openair.museum
  oregon.museum
  oregontrail.museum
  otago.museum
  oxford.museum
  pacific.museum
  paderborn.museum
  palace.museum
  paleo.museum
  palmsprings.museum
  panama.museum
  paris.museum
  pasadena.museum
  pharmacy.museum
  philadelphia.museum
  philadelphiaarea.museum
  philately.museum
  phoenix.museum
  photography.museum
  pilots.museum
  pittsburgh.museum
  planetarium.museum
  plantation.museum
  plants.museum
  plaza.museum
  portal.museum
  portland.museum
  portlligat.museum
  posts-and-telecommunications.museum
  preservation.museum
  presidio.museum
  press.museum
  project.museum
  public.museum
  pubol.museum
  quebec.museum
  railroad.museum
  railway.museum
  research.museum
  resistance.museum
  riodejaneiro.museum
  rochester.museum
  rockart.museum
  roma.museum
  russia.museum
  saintlouis.museum
  salem.museum
  salvadordali.museum
  salzburg.museum
  sandiego.museum
  sanfrancisco.museum
  santabarbara.museum
  santacruz.museum
  santafe.museum
  saskatchewan.museum
  satx.museum
  savannahga.museum
  schlesisches.museum
  schoenbrunn.museum
  schokoladen.museum
  school.museum
  schweiz.museum
  science.museum
  scienceandhistory.museum
  scienceandindustry.museum
  sciencecenter.museum
  sciencecenters.museum
  science-fiction.museum
  sciencehistory.museum
  sciences.museum
  sciencesnaturelles.museum
  scotland.museum
  seaport.museum
  settlement.museum
  settlers.museum
  shell.museum
  sherbrooke.museum
  sibenik.museum
  silk.museum
  ski.museum
  skole.museum
  society.museum
  sologne.museum
  soundandvision.museum
  southcarolina.museum
  southwest.museum
  space.museum
  spy.museum
  square.museum
  stadt.museum
  stalbans.museum
  starnberg.museum
  state.museum
  stateofdelaware.museum
  station.museum
  steam.museum
  steiermark.museum
  stjohn.museum
  stockholm.museum
  stpetersburg.museum
  stuttgart.museum
  suisse.museum
  surgeonshall.museum
  surrey.museum
  svizzera.museum
  sweden.museum
  sydney.museum
  tank.museum
  tcm.museum
  technology.museum
  telekommunikation.museum
  television.museum
  texas.museum
  textile.museum
  theater.museum
  time.museum
  timekeeping.museum
  topology.museum
  torino.museum
  touch.museum
  town.museum
  transport.museum
  tree.museum
  trolley.museum
  trust.museum
  trustee.museum
  uhren.museum
  ulm.museum
  undersea.museum
  university.museum
  usa.museum
  usantiques.museum
  usarts.museum
  uscountryestate.museum
  usculture.museum
  usdecorativearts.museum
  usgarden.museum
  ushistory.museum
  ushuaia.museum
  uslivinghistory.museum
  utah.museum
  uvic.museum
  valley.museum
  vantaa.museum
  versailles.museum
  viking.museum
  village.museum
  virginia.museum
  virtual.museum
  virtuel.museum
  vlaanderen.museum
  volkenkunde.museum
  wales.museum
  wallonie.museum
  war.museum
  washingtondc.museum
  watchandclock.museum
  watch-and-clock.museum
  western.museum
  westfalen.museum
  whaling.museum
  wildlife.museum
  williamsburg.museum
  windmill.museum
  workshop.museum
  york.museum
  yorkshire.museum
  yosemite.museum
  youth.museum
  zoological.museum
  zoology.museum
  xn--9dbhblg6di.museum
  xn--h1aegh.museum
  
  // mv : http://en.wikipedia.org/wiki/.mv
  // "mv" included because, contra Wikipedia, google.mv exists.
  mv
  aero.mv
  biz.mv
  com.mv
  coop.mv
  edu.mv
  gov.mv
  info.mv
  int.mv
  mil.mv
  museum.mv
  name.mv
  net.mv
  org.mv
  pro.mv
  
  // mw : http://www.registrar.mw/
  mw
  ac.mw
  biz.mw
  co.mw
  com.mw
  coop.mw
  edu.mw
  gov.mw
  int.mw
  museum.mw
  net.mw
  org.mw
  
  // mx : http://www.nic.mx/
  // Submitted by registry <farias@nic.mx> 2008-06-19
  mx
  com.mx
  org.mx
  gob.mx
  edu.mx
  net.mx
  
  // my : http://www.mynic.net.my/
  my
  com.my
  net.my
  org.my
  gov.my
  edu.my
  mil.my
  name.my
  
  // mz : http://www.gobin.info/domainname/mz-template.doc
  *.mz
  !teledata.mz
  
  // na : http://www.na-nic.com.na/
  // http://www.info.na/domain/
  na
  info.na
  pro.na
  name.na
  school.na
  or.na
  dr.na
  us.na
  mx.na
  ca.na
  in.na
  cc.na
  tv.na
  ws.na
  mobi.na
  co.na
  com.na
  org.na
  
  // name : has 2nd-level tlds, but there's no list of them
  name
  
  // nc : http://www.cctld.nc/
  nc
  asso.nc
  
  // ne : http://en.wikipedia.org/wiki/.ne
  ne
  
  // net : http://en.wikipedia.org/wiki/.net
  net
  
  // nf : http://en.wikipedia.org/wiki/.nf
  nf
  com.nf
  net.nf
  per.nf
  rec.nf
  web.nf
  arts.nf
  firm.nf
  info.nf
  other.nf
  store.nf
  
  // ng : http://psg.com/dns/ng/
  ng
  com.ng
  edu.ng
  name.ng
  net.ng
  org.ng
  sch.ng
  gov.ng
  mil.ng
  mobi.ng
  
  // ni : http://www.nic.ni/
  com.ni
  gob.ni
  edu.ni
  org.ni
  nom.ni
  net.ni
  mil.ni
  co.ni
  biz.ni
  web.ni
  int.ni
  ac.ni
  in.ni
  info.ni
  
  // nl : http://en.wikipedia.org/wiki/.nl
  //      https://www.sidn.nl/
  //      ccTLD for the Netherlands
  nl
  
  // BV.nl will be a registry for dutch BV's (besloten vennootschap)
  bv.nl
  
  // no : http://www.norid.no/regelverk/index.en.html
  // The Norwegian registry has declined to notify us of updates. The web pages
  // referenced below are the official source of the data. There is also an
  // announce mailing list:
  // https://postlister.uninett.no/sympa/info/norid-diskusjon
  no
  // Norid generic domains : http://www.norid.no/regelverk/vedlegg-c.en.html
  fhs.no
  vgs.no
  fylkesbibl.no
  folkebibl.no
  museum.no
  idrett.no
  priv.no
  // Non-Norid generic domains : http://www.norid.no/regelverk/vedlegg-d.en.html
  mil.no
  stat.no
  dep.no
  kommune.no
  herad.no
  // no geographical names : http://www.norid.no/regelverk/vedlegg-b.en.html
  // counties
  aa.no
  ah.no
  bu.no
  fm.no
  hl.no
  hm.no
  jan-mayen.no
  mr.no
  nl.no
  nt.no
  of.no
  ol.no
  oslo.no
  rl.no
  sf.no
  st.no
  svalbard.no
  tm.no
  tr.no
  va.no
  vf.no
  // primary and lower secondary schools per county
  gs.aa.no
  gs.ah.no
  gs.bu.no
  gs.fm.no
  gs.hl.no
  gs.hm.no
  gs.jan-mayen.no
  gs.mr.no
  gs.nl.no
  gs.nt.no
  gs.of.no
  gs.ol.no
  gs.oslo.no
  gs.rl.no
  gs.sf.no
  gs.st.no
  gs.svalbard.no
  gs.tm.no
  gs.tr.no
  gs.va.no
  gs.vf.no
  // cities
  akrehamn.no
  xn--krehamn-dxa.no
  algard.no
  xn--lgrd-poac.no
  arna.no
  brumunddal.no
  bryne.no
  bronnoysund.no
  xn--brnnysund-m8ac.no
  drobak.no
  xn--drbak-wua.no
  egersund.no
  fetsund.no
  floro.no
  xn--flor-jra.no
  fredrikstad.no
  hokksund.no
  honefoss.no
  xn--hnefoss-q1a.no
  jessheim.no
  jorpeland.no
  xn--jrpeland-54a.no
  kirkenes.no
  kopervik.no
  krokstadelva.no
  langevag.no
  xn--langevg-jxa.no
  leirvik.no
  mjondalen.no
  xn--mjndalen-64a.no
  mo-i-rana.no
  mosjoen.no
  xn--mosjen-eya.no
  nesoddtangen.no
  orkanger.no
  osoyro.no
  xn--osyro-wua.no
  raholt.no
  xn--rholt-mra.no
  sandnessjoen.no
  xn--sandnessjen-ogb.no
  skedsmokorset.no
  slattum.no
  spjelkavik.no
  stathelle.no
  stavern.no
  stjordalshalsen.no
  xn--stjrdalshalsen-sqb.no
  tananger.no
  tranby.no
  vossevangen.no
  // communities
  afjord.no
  xn--fjord-lra.no
  agdenes.no
  al.no
  xn--l-1fa.no
  alesund.no
  xn--lesund-hua.no
  alstahaug.no
  alta.no
  xn--lt-liac.no
  alaheadju.no
  xn--laheadju-7ya.no
  alvdal.no
  amli.no
  xn--mli-tla.no
  amot.no
  xn--mot-tla.no
  andebu.no
  andoy.no
  xn--andy-ira.no
  andasuolo.no
  ardal.no
  xn--rdal-poa.no
  aremark.no
  arendal.no
  xn--s-1fa.no
  aseral.no
  xn--seral-lra.no
  asker.no
  askim.no
  askvoll.no
  askoy.no
  xn--asky-ira.no
  asnes.no
  xn--snes-poa.no
  audnedaln.no
  aukra.no
  aure.no
  aurland.no
  aurskog-holand.no
  xn--aurskog-hland-jnb.no
  austevoll.no
  austrheim.no
  averoy.no
  xn--avery-yua.no
  balestrand.no
  ballangen.no
  balat.no
  xn--blt-elab.no
  balsfjord.no
  bahccavuotna.no
  xn--bhccavuotna-k7a.no
  bamble.no
  bardu.no
  beardu.no
  beiarn.no
  bajddar.no
  xn--bjddar-pta.no
  baidar.no
  xn--bidr-5nac.no
  berg.no
  bergen.no
  berlevag.no
  xn--berlevg-jxa.no
  bearalvahki.no
  xn--bearalvhki-y4a.no
  bindal.no
  birkenes.no
  bjarkoy.no
  xn--bjarky-fya.no
  bjerkreim.no
  bjugn.no
  bodo.no
  xn--bod-2na.no
  badaddja.no
  xn--bdddj-mrabd.no
  budejju.no
  bokn.no
  bremanger.no
  bronnoy.no
  xn--brnny-wuac.no
  bygland.no
  bykle.no
  barum.no
  xn--brum-voa.no
  bo.telemark.no
  xn--b-5ga.telemark.no
  bo.nordland.no
  xn--b-5ga.nordland.no
  bievat.no
  xn--bievt-0qa.no
  bomlo.no
  xn--bmlo-gra.no
  batsfjord.no
  xn--btsfjord-9za.no
  bahcavuotna.no
  xn--bhcavuotna-s4a.no
  dovre.no
  drammen.no
  drangedal.no
  dyroy.no
  xn--dyry-ira.no
  donna.no
  xn--dnna-gra.no
  eid.no
  eidfjord.no
  eidsberg.no
  eidskog.no
  eidsvoll.no
  eigersund.no
  elverum.no
  enebakk.no
  engerdal.no
  etne.no
  etnedal.no
  evenes.no
  evenassi.no
  xn--eveni-0qa01ga.no
  evje-og-hornnes.no
  farsund.no
  fauske.no
  fuossko.no
  fuoisku.no
  fedje.no
  fet.no
  finnoy.no
  xn--finny-yua.no
  fitjar.no
  fjaler.no
  fjell.no
  flakstad.no
  flatanger.no
  flekkefjord.no
  flesberg.no
  flora.no
  fla.no
  xn--fl-zia.no
  folldal.no
  forsand.no
  fosnes.no
  frei.no
  frogn.no
  froland.no
  frosta.no
  frana.no
  xn--frna-woa.no
  froya.no
  xn--frya-hra.no
  fusa.no
  fyresdal.no
  forde.no
  xn--frde-gra.no
  gamvik.no
  gangaviika.no
  xn--ggaviika-8ya47h.no
  gaular.no
  gausdal.no
  gildeskal.no
  xn--gildeskl-g0a.no
  giske.no
  gjemnes.no
  gjerdrum.no
  gjerstad.no
  gjesdal.no
  gjovik.no
  xn--gjvik-wua.no
  gloppen.no
  gol.no
  gran.no
  grane.no
  granvin.no
  gratangen.no
  grimstad.no
  grong.no
  kraanghke.no
  xn--kranghke-b0a.no
  grue.no
  gulen.no
  hadsel.no
  halden.no
  halsa.no
  hamar.no
  hamaroy.no
  habmer.no
  xn--hbmer-xqa.no
  hapmir.no
  xn--hpmir-xqa.no
  hammerfest.no
  hammarfeasta.no
  xn--hmmrfeasta-s4ac.no
  haram.no
  hareid.no
  harstad.no
  hasvik.no
  aknoluokta.no
  xn--koluokta-7ya57h.no
  hattfjelldal.no
  aarborte.no
  haugesund.no
  hemne.no
  hemnes.no
  hemsedal.no
  heroy.more-og-romsdal.no
  xn--hery-ira.xn--mre-og-romsdal-qqb.no
  heroy.nordland.no
  xn--hery-ira.nordland.no
  hitra.no
  hjartdal.no
  hjelmeland.no
  hobol.no
  xn--hobl-ira.no
  hof.no
  hol.no
  hole.no
  holmestrand.no
  holtalen.no
  xn--holtlen-hxa.no
  hornindal.no
  horten.no
  hurdal.no
  hurum.no
  hvaler.no
  hyllestad.no
  hagebostad.no
  xn--hgebostad-g3a.no
  hoyanger.no
  xn--hyanger-q1a.no
  hoylandet.no
  xn--hylandet-54a.no
  ha.no
  xn--h-2fa.no
  ibestad.no
  inderoy.no
  xn--indery-fya.no
  iveland.no
  jevnaker.no
  jondal.no
  jolster.no
  xn--jlster-bya.no
  karasjok.no
  karasjohka.no
  xn--krjohka-hwab49j.no
  karlsoy.no
  galsa.no
  xn--gls-elac.no
  karmoy.no
  xn--karmy-yua.no
  kautokeino.no
  guovdageaidnu.no
  klepp.no
  klabu.no
  xn--klbu-woa.no
  kongsberg.no
  kongsvinger.no
  kragero.no
  xn--krager-gya.no
  kristiansand.no
  kristiansund.no
  krodsherad.no
  xn--krdsherad-m8a.no
  kvalsund.no
  rahkkeravju.no
  xn--rhkkervju-01af.no
  kvam.no
  kvinesdal.no
  kvinnherad.no
  kviteseid.no
  kvitsoy.no
  xn--kvitsy-fya.no
  kvafjord.no
  xn--kvfjord-nxa.no
  giehtavuoatna.no
  kvanangen.no
  xn--kvnangen-k0a.no
  navuotna.no
  xn--nvuotna-hwa.no
  kafjord.no
  xn--kfjord-iua.no
  gaivuotna.no
  xn--givuotna-8ya.no
  larvik.no
  lavangen.no
  lavagis.no
  loabat.no
  xn--loabt-0qa.no
  lebesby.no
  davvesiida.no
  leikanger.no
  leirfjord.no
  leka.no
  leksvik.no
  lenvik.no
  leangaviika.no
  xn--leagaviika-52b.no
  lesja.no
  levanger.no
  lier.no
  lierne.no
  lillehammer.no
  lillesand.no
  lindesnes.no
  lindas.no
  xn--linds-pra.no
  lom.no
  loppa.no
  lahppi.no
  xn--lhppi-xqa.no
  lund.no
  lunner.no
  luroy.no
  xn--lury-ira.no
  luster.no
  lyngdal.no
  lyngen.no
  ivgu.no
  lardal.no
  lerdal.no
  xn--lrdal-sra.no
  lodingen.no
  xn--ldingen-q1a.no
  lorenskog.no
  xn--lrenskog-54a.no
  loten.no
  xn--lten-gra.no
  malvik.no
  masoy.no
  xn--msy-ula0h.no
  muosat.no
  xn--muost-0qa.no
  mandal.no
  marker.no
  marnardal.no
  masfjorden.no
  meland.no
  meldal.no
  melhus.no
  meloy.no
  xn--mely-ira.no
  meraker.no
  xn--merker-kua.no
  moareke.no
  xn--moreke-jua.no
  midsund.no
  midtre-gauldal.no
  modalen.no
  modum.no
  molde.no
  moskenes.no
  moss.no
  mosvik.no
  malselv.no
  xn--mlselv-iua.no
  malatvuopmi.no
  xn--mlatvuopmi-s4a.no
  namdalseid.no
  aejrie.no
  namsos.no
  namsskogan.no
  naamesjevuemie.no
  xn--nmesjevuemie-tcba.no
  laakesvuemie.no
  nannestad.no
  narvik.no
  narviika.no
  naustdal.no
  nedre-eiker.no
  nes.akershus.no
  nes.buskerud.no
  nesna.no
  nesodden.no
  nesseby.no
  unjarga.no
  xn--unjrga-rta.no
  nesset.no
  nissedal.no
  nittedal.no
  nord-aurdal.no
  nord-fron.no
  nord-odal.no
  norddal.no
  nordkapp.no
  davvenjarga.no
  xn--davvenjrga-y4a.no
  nordre-land.no
  nordreisa.no
  raisa.no
  xn--risa-5na.no
  nore-og-uvdal.no
  notodden.no
  naroy.no
  xn--nry-yla5g.no
  notteroy.no
  xn--nttery-byae.no
  odda.no
  oksnes.no
  xn--ksnes-uua.no
  oppdal.no
  oppegard.no
  xn--oppegrd-ixa.no
  orkdal.no
  orland.no
  xn--rland-uua.no
  orskog.no
  xn--rskog-uua.no
  orsta.no
  xn--rsta-fra.no
  os.hedmark.no
  os.hordaland.no
  osen.no
  osteroy.no
  xn--ostery-fya.no
  ostre-toten.no
  xn--stre-toten-zcb.no
  overhalla.no
  ovre-eiker.no
  xn--vre-eiker-k8a.no
  oyer.no
  xn--yer-zna.no
  oygarden.no
  xn--ygarden-p1a.no
  oystre-slidre.no
  xn--ystre-slidre-ujb.no
  porsanger.no
  porsangu.no
  xn--porsgu-sta26f.no
  porsgrunn.no
  radoy.no
  xn--rady-ira.no
  rakkestad.no
  rana.no
  ruovat.no
  randaberg.no
  rauma.no
  rendalen.no
  rennebu.no
  rennesoy.no
  xn--rennesy-v1a.no
  rindal.no
  ringebu.no
  ringerike.no
  ringsaker.no
  rissa.no
  risor.no
  xn--risr-ira.no
  roan.no
  rollag.no
  rygge.no
  ralingen.no
  xn--rlingen-mxa.no
  rodoy.no
  xn--rdy-0nab.no
  romskog.no
  xn--rmskog-bya.no
  roros.no
  xn--rros-gra.no
  rost.no
  xn--rst-0na.no
  royken.no
  xn--ryken-vua.no
  royrvik.no
  xn--ryrvik-bya.no
  rade.no
  xn--rde-ula.no
  salangen.no
  siellak.no
  saltdal.no
  salat.no
  xn--slt-elab.no
  xn--slat-5na.no
  samnanger.no
  sande.more-og-romsdal.no
  sande.xn--mre-og-romsdal-qqb.no
  sande.vestfold.no
  sandefjord.no
  sandnes.no
  sandoy.no
  xn--sandy-yua.no
  sarpsborg.no
  sauda.no
  sauherad.no
  sel.no
  selbu.no
  selje.no
  seljord.no
  sigdal.no
  siljan.no
  sirdal.no
  skaun.no
  skedsmo.no
  ski.no
  skien.no
  skiptvet.no
  skjervoy.no
  xn--skjervy-v1a.no
  skierva.no
  xn--skierv-uta.no
  skjak.no
  xn--skjk-soa.no
  skodje.no
  skanland.no
  xn--sknland-fxa.no
  skanit.no
  xn--sknit-yqa.no
  smola.no
  xn--smla-hra.no
  snillfjord.no
  snasa.no
  xn--snsa-roa.no
  snoasa.no
  snaase.no
  xn--snase-nra.no
  sogndal.no
  sokndal.no
  sola.no
  solund.no
  songdalen.no
  sortland.no
  spydeberg.no
  stange.no
  stavanger.no
  steigen.no
  steinkjer.no
  stjordal.no
  xn--stjrdal-s1a.no
  stokke.no
  stor-elvdal.no
  stord.no
  stordal.no
  storfjord.no
  omasvuotna.no
  strand.no
  stranda.no
  stryn.no
  sula.no
  suldal.no
  sund.no
  sunndal.no
  surnadal.no
  sveio.no
  svelvik.no
  sykkylven.no
  sogne.no
  xn--sgne-gra.no
  somna.no
  xn--smna-gra.no
  sondre-land.no
  xn--sndre-land-0cb.no
  sor-aurdal.no
  xn--sr-aurdal-l8a.no
  sor-fron.no
  xn--sr-fron-q1a.no
  sor-odal.no
  xn--sr-odal-q1a.no
  sor-varanger.no
  xn--sr-varanger-ggb.no
  matta-varjjat.no
  xn--mtta-vrjjat-k7af.no
  sorfold.no
  xn--srfold-bya.no
  sorreisa.no
  xn--srreisa-q1a.no
  sorum.no
  xn--srum-gra.no
  tana.no
  deatnu.no
  time.no
  tingvoll.no
  tinn.no
  tjeldsund.no
  dielddanuorri.no
  tjome.no
  xn--tjme-hra.no
  tokke.no
  tolga.no
  torsken.no
  tranoy.no
  xn--trany-yua.no
  tromso.no
  xn--troms-zua.no
  tromsa.no
  romsa.no
  trondheim.no
  troandin.no
  trysil.no
  trana.no
  xn--trna-woa.no
  trogstad.no
  xn--trgstad-r1a.no
  tvedestrand.no
  tydal.no
  tynset.no
  tysfjord.no
  divtasvuodna.no
  divttasvuotna.no
  tysnes.no
  tysvar.no
  xn--tysvr-vra.no
  tonsberg.no
  xn--tnsberg-q1a.no
  ullensaker.no
  ullensvang.no
  ulvik.no
  utsira.no
  vadso.no
  xn--vads-jra.no
  cahcesuolo.no
  xn--hcesuolo-7ya35b.no
  vaksdal.no
  valle.no
  vang.no
  vanylven.no
  vardo.no
  xn--vard-jra.no
  varggat.no
  xn--vrggt-xqad.no
  vefsn.no
  vaapste.no
  vega.no
  vegarshei.no
  xn--vegrshei-c0a.no
  vennesla.no
  verdal.no
  verran.no
  vestby.no
  vestnes.no
  vestre-slidre.no
  vestre-toten.no
  vestvagoy.no
  xn--vestvgy-ixa6o.no
  vevelstad.no
  vik.no
  vikna.no
  vindafjord.no
  volda.no
  voss.no
  varoy.no
  xn--vry-yla5g.no
  vagan.no
  xn--vgan-qoa.no
  voagat.no
  vagsoy.no
  xn--vgsy-qoa0j.no
  vaga.no
  xn--vg-yiab.no
  valer.ostfold.no
  xn--vler-qoa.xn--stfold-9xa.no
  valer.hedmark.no
  xn--vler-qoa.hedmark.no
  
  // np : http://www.mos.com.np/register.html
  *.np
  
  // nr : http://cenpac.net.nr/dns/index.html
  // Confirmed by registry <technician@cenpac.net.nr> 2008-06-17
  nr
  biz.nr
  info.nr
  gov.nr
  edu.nr
  org.nr
  net.nr
  com.nr
  
  // nu : http://en.wikipedia.org/wiki/.nu
  nu
  
  // nz : http://en.wikipedia.org/wiki/.nz
  // Confirmed by registry <jay@nzrs.net.nz> 2014-05-19
  nz
  ac.nz
  co.nz
  cri.nz
  geek.nz
  gen.nz
  govt.nz
  health.nz
  iwi.nz
  kiwi.nz
  maori.nz
  mil.nz
  xn--mori-qsa.nz
  net.nz
  org.nz
  parliament.nz
  school.nz
  
  // om : http://en.wikipedia.org/wiki/.om
  om
  co.om
  com.om
  edu.om
  gov.om
  med.om
  museum.om
  net.om
  org.om
  pro.om
  
  // org : http://en.wikipedia.org/wiki/.org
  org
  
  // pa : http://www.nic.pa/
  // Some additional second level "domains" resolve directly as hostnames, such as
  // pannet.pa, so we add a rule for "pa".
  pa
  ac.pa
  gob.pa
  com.pa
  org.pa
  sld.pa
  edu.pa
  net.pa
  ing.pa
  abo.pa
  med.pa
  nom.pa
  
  // pe : https://www.nic.pe/InformeFinalComision.pdf
  pe
  edu.pe
  gob.pe
  nom.pe
  mil.pe
  org.pe
  com.pe
  net.pe
  
  // pf : http://www.gobin.info/domainname/formulaire-pf.pdf
  pf
  com.pf
  org.pf
  edu.pf
  
  // pg : http://en.wikipedia.org/wiki/.pg
  *.pg
  
  // ph : http://www.domains.ph/FAQ2.asp
  // Submitted by registry <jed@email.com.ph> 2008-06-13
  ph
  com.ph
  net.ph
  org.ph
  gov.ph
  edu.ph
  ngo.ph
  mil.ph
  i.ph
  
  // pk : http://pk5.pknic.net.pk/pk5/msgNamepk.PK
  pk
  com.pk
  net.pk
  edu.pk
  org.pk
  fam.pk
  biz.pk
  web.pk
  gov.pk
  gob.pk
  gok.pk
  gon.pk
  gop.pk
  gos.pk
  info.pk
  
  // pl http://www.dns.pl/english/index.html
  // updated by .PL registry on 2015-04-28
  pl
  com.pl
  net.pl
  org.pl
  // pl functional domains (http://www.dns.pl/english/index.html)
  aid.pl
  agro.pl
  atm.pl
  auto.pl
  biz.pl
  edu.pl
  gmina.pl
  gsm.pl
  info.pl
  mail.pl
  miasta.pl
  media.pl
  mil.pl
  nieruchomosci.pl
  nom.pl
  pc.pl
  powiat.pl
  priv.pl
  realestate.pl
  rel.pl
  sex.pl
  shop.pl
  sklep.pl
  sos.pl
  szkola.pl
  targi.pl
  tm.pl
  tourism.pl
  travel.pl
  turystyka.pl
  // Government domains
  gov.pl
  ap.gov.pl
  ic.gov.pl
  is.gov.pl
  us.gov.pl
  kmpsp.gov.pl
  kppsp.gov.pl
  kwpsp.gov.pl
  psp.gov.pl
  wskr.gov.pl
  kwp.gov.pl
  mw.gov.pl
  ug.gov.pl
  um.gov.pl
  umig.gov.pl
  ugim.gov.pl
  upow.gov.pl
  uw.gov.pl
  starostwo.gov.pl
  pa.gov.pl
  po.gov.pl
  psse.gov.pl
  pup.gov.pl
  rzgw.gov.pl
  sa.gov.pl
  so.gov.pl
  sr.gov.pl
  wsa.gov.pl
  sko.gov.pl
  uzs.gov.pl
  wiih.gov.pl
  winb.gov.pl
  pinb.gov.pl
  wios.gov.pl
  witd.gov.pl
  wzmiuw.gov.pl
  piw.gov.pl
  wiw.gov.pl
  griw.gov.pl
  wif.gov.pl
  oum.gov.pl
  sdn.gov.pl
  zp.gov.pl
  uppo.gov.pl
  mup.gov.pl
  wuoz.gov.pl
  konsulat.gov.pl
  oirm.gov.pl
  // pl regional domains (http://www.dns.pl/english/index.html)
  augustow.pl
  babia-gora.pl
  bedzin.pl
  beskidy.pl
  bialowieza.pl
  bialystok.pl
  bielawa.pl
  bieszczady.pl
  boleslawiec.pl
  bydgoszcz.pl
  bytom.pl
  cieszyn.pl
  czeladz.pl
  czest.pl
  dlugoleka.pl
  elblag.pl
  elk.pl
  glogow.pl
  gniezno.pl
  gorlice.pl
  grajewo.pl
  ilawa.pl
  jaworzno.pl
  jelenia-gora.pl
  jgora.pl
  kalisz.pl
  kazimierz-dolny.pl
  karpacz.pl
  kartuzy.pl
  kaszuby.pl
  katowice.pl
  kepno.pl
  ketrzyn.pl
  klodzko.pl
  kobierzyce.pl
  kolobrzeg.pl
  konin.pl
  konskowola.pl
  kutno.pl
  lapy.pl
  lebork.pl
  legnica.pl
  lezajsk.pl
  limanowa.pl
  lomza.pl
  lowicz.pl
  lubin.pl
  lukow.pl
  malbork.pl
  malopolska.pl
  mazowsze.pl
  mazury.pl
  mielec.pl
  mielno.pl
  mragowo.pl
  naklo.pl
  nowaruda.pl
  nysa.pl
  olawa.pl
  olecko.pl
  olkusz.pl
  olsztyn.pl
  opoczno.pl
  opole.pl
  ostroda.pl
  ostroleka.pl
  ostrowiec.pl
  ostrowwlkp.pl
  pila.pl
  pisz.pl
  podhale.pl
  podlasie.pl
  polkowice.pl
  pomorze.pl
  pomorskie.pl
  prochowice.pl
  pruszkow.pl
  przeworsk.pl
  pulawy.pl
  radom.pl
  rawa-maz.pl
  rybnik.pl
  rzeszow.pl
  sanok.pl
  sejny.pl
  slask.pl
  slupsk.pl
  sosnowiec.pl
  stalowa-wola.pl
  skoczow.pl
  starachowice.pl
  stargard.pl
  suwalki.pl
  swidnica.pl
  swiebodzin.pl
  swinoujscie.pl
  szczecin.pl
  szczytno.pl
  tarnobrzeg.pl
  tgory.pl
  turek.pl
  tychy.pl
  ustka.pl
  walbrzych.pl
  warmia.pl
  warszawa.pl
  waw.pl
  wegrow.pl
  wielun.pl
  wlocl.pl
  wloclawek.pl
  wodzislaw.pl
  wolomin.pl
  wroclaw.pl
  zachpomor.pl
  zagan.pl
  zarow.pl
  zgora.pl
  zgorzelec.pl
  
  // pm : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  pm
  
  // pn : http://www.government.pn/PnRegistry/policies.htm
  pn
  gov.pn
  co.pn
  org.pn
  edu.pn
  net.pn
  
  // post : http://en.wikipedia.org/wiki/.post
  post
  
  // pr : http://www.nic.pr/index.asp?f=1
  pr
  com.pr
  net.pr
  org.pr
  gov.pr
  edu.pr
  isla.pr
  pro.pr
  biz.pr
  info.pr
  name.pr
  // these aren't mentioned on nic.pr, but on http://en.wikipedia.org/wiki/.pr
  est.pr
  prof.pr
  ac.pr
  
  // pro : http://www.nic.pro/support_faq.htm
  pro
  aca.pro
  bar.pro
  cpa.pro
  jur.pro
  law.pro
  med.pro
  eng.pro
  
  // ps : http://en.wikipedia.org/wiki/.ps
  // http://www.nic.ps/registration/policy.html#reg
  ps
  edu.ps
  gov.ps
  sec.ps
  plo.ps
  com.ps
  org.ps
  net.ps
  
  // pt : http://online.dns.pt/dns/start_dns
  pt
  net.pt
  gov.pt
  org.pt
  edu.pt
  int.pt
  publ.pt
  com.pt
  nome.pt
  
  // pw : http://en.wikipedia.org/wiki/.pw
  pw
  co.pw
  ne.pw
  or.pw
  ed.pw
  go.pw
  belau.pw
  
  // py : http://www.nic.py/pautas.html#seccion_9
  // Confirmed by registry 2012-10-03
  py
  com.py
  coop.py
  edu.py
  gov.py
  mil.py
  net.py
  org.py
  
  // qa : http://domains.qa/en/
  qa
  com.qa
  edu.qa
  gov.qa
  mil.qa
  name.qa
  net.qa
  org.qa
  sch.qa
  
  // re : http://www.afnic.re/obtenir/chartes/nommage-re/annexe-descriptifs
  re
  com.re
  asso.re
  nom.re
  
  // ro : http://www.rotld.ro/
  ro
  com.ro
  org.ro
  tm.ro
  nt.ro
  nom.ro
  info.ro
  rec.ro
  arts.ro
  firm.ro
  store.ro
  www.ro
  
  // rs : http://en.wikipedia.org/wiki/.rs
  rs
  co.rs
  org.rs
  edu.rs
  ac.rs
  gov.rs
  in.rs
  
  // ru : http://www.cctld.ru/ru/docs/aktiv_8.php
  // Industry domains
  ru
  ac.ru
  com.ru
  edu.ru
  int.ru
  net.ru
  org.ru
  pp.ru
  // Geographical domains
  adygeya.ru
  altai.ru
  amur.ru
  arkhangelsk.ru
  astrakhan.ru
  bashkiria.ru
  belgorod.ru
  bir.ru
  bryansk.ru
  buryatia.ru
  cbg.ru
  chel.ru
  chelyabinsk.ru
  chita.ru
  chukotka.ru
  chuvashia.ru
  dagestan.ru
  dudinka.ru
  e-burg.ru
  grozny.ru
  irkutsk.ru
  ivanovo.ru
  izhevsk.ru
  jar.ru
  joshkar-ola.ru
  kalmykia.ru
  kaluga.ru
  kamchatka.ru
  karelia.ru
  kazan.ru
  kchr.ru
  kemerovo.ru
  khabarovsk.ru
  khakassia.ru
  khv.ru
  kirov.ru
  koenig.ru
  komi.ru
  kostroma.ru
  krasnoyarsk.ru
  kuban.ru
  kurgan.ru
  kursk.ru
  lipetsk.ru
  magadan.ru
  mari.ru
  mari-el.ru
  marine.ru
  mordovia.ru
  // mosreg.ru  Bug 1090800 - removed at request of Aleksey Konstantinov <konstantinovav@mosreg.ru>
  msk.ru
  murmansk.ru
  nalchik.ru
  nnov.ru
  nov.ru
  novosibirsk.ru
  nsk.ru
  omsk.ru
  orenburg.ru
  oryol.ru
  palana.ru
  penza.ru
  perm.ru
  ptz.ru
  rnd.ru
  ryazan.ru
  sakhalin.ru
  samara.ru
  saratov.ru
  simbirsk.ru
  smolensk.ru
  spb.ru
  stavropol.ru
  stv.ru
  surgut.ru
  tambov.ru
  tatarstan.ru
  tom.ru
  tomsk.ru
  tsaritsyn.ru
  tsk.ru
  tula.ru
  tuva.ru
  tver.ru
  tyumen.ru
  udm.ru
  udmurtia.ru
  ulan-ude.ru
  vladikavkaz.ru
  vladimir.ru
  vladivostok.ru
  volgograd.ru
  vologda.ru
  voronezh.ru
  vrn.ru
  vyatka.ru
  yakutia.ru
  yamal.ru
  yaroslavl.ru
  yekaterinburg.ru
  yuzhno-sakhalinsk.ru
  // More geographical domains
  amursk.ru
  baikal.ru
  cmw.ru
  fareast.ru
  jamal.ru
  kms.ru
  k-uralsk.ru
  kustanai.ru
  kuzbass.ru
  mytis.ru
  nakhodka.ru
  nkz.ru
  norilsk.ru
  oskol.ru
  pyatigorsk.ru
  rubtsovsk.ru
  snz.ru
  syzran.ru
  vdonsk.ru
  zgrad.ru
  // State domains
  gov.ru
  mil.ru
  // Technical domains
  test.ru
  
  // rw : http://www.nic.rw/cgi-bin/policy.pl
  rw
  gov.rw
  net.rw
  edu.rw
  ac.rw
  com.rw
  co.rw
  int.rw
  mil.rw
  gouv.rw
  
  // sa : http://www.nic.net.sa/
  sa
  com.sa
  net.sa
  org.sa
  gov.sa
  med.sa
  pub.sa
  edu.sa
  sch.sa
  
  // sb : http://www.sbnic.net.sb/
  // Submitted by registry <lee.humphries@telekom.com.sb> 2008-06-08
  sb
  com.sb
  edu.sb
  gov.sb
  net.sb
  org.sb
  
  // sc : http://www.nic.sc/
  sc
  com.sc
  gov.sc
  net.sc
  org.sc
  edu.sc
  
  // sd : http://www.isoc.sd/sudanic.isoc.sd/billing_pricing.htm
  // Submitted by registry <admin@isoc.sd> 2008-06-17
  sd
  com.sd
  net.sd
  org.sd
  edu.sd
  med.sd
  tv.sd
  gov.sd
  info.sd
  
  // se : http://en.wikipedia.org/wiki/.se
  // Submitted by registry <patrik.wallstrom@iis.se> 2014-03-18
  se
  a.se
  ac.se
  b.se
  bd.se
  brand.se
  c.se
  d.se
  e.se
  f.se
  fh.se
  fhsk.se
  fhv.se
  g.se
  h.se
  i.se
  k.se
  komforb.se
  kommunalforbund.se
  komvux.se
  l.se
  lanbib.se
  m.se
  n.se
  naturbruksgymn.se
  o.se
  org.se
  p.se
  parti.se
  pp.se
  press.se
  r.se
  s.se
  t.se
  tm.se
  u.se
  w.se
  x.se
  y.se
  z.se
  
  // sg : http://www.nic.net.sg/page/registration-policies-procedures-and-guidelines
  sg
  com.sg
  net.sg
  org.sg
  gov.sg
  edu.sg
  per.sg
  
  // sh : http://www.nic.sh/registrar.html
  sh
  com.sh
  net.sh
  gov.sh
  org.sh
  mil.sh
  
  // si : http://en.wikipedia.org/wiki/.si
  si
  
  // sj : No registrations at this time.
  // Submitted by registry <jarle@uninett.no> 2008-06-16
  sj
  
  // sk : http://en.wikipedia.org/wiki/.sk
  // list of 2nd level domains ?
  sk
  
  // sl : http://www.nic.sl
  // Submitted by registry <adam@neoip.com> 2008-06-12
  sl
  com.sl
  net.sl
  edu.sl
  gov.sl
  org.sl
  
  // sm : http://en.wikipedia.org/wiki/.sm
  sm
  
  // sn : http://en.wikipedia.org/wiki/.sn
  sn
  art.sn
  com.sn
  edu.sn
  gouv.sn
  org.sn
  perso.sn
  univ.sn
  
  // so : http://www.soregistry.com/
  so
  com.so
  net.so
  org.so
  
  // sr : http://en.wikipedia.org/wiki/.sr
  sr
  
  // st : http://www.nic.st/html/policyrules/
  st
  co.st
  com.st
  consulado.st
  edu.st
  embaixada.st
  gov.st
  mil.st
  net.st
  org.st
  principe.st
  saotome.st
  store.st
  
  // su : http://en.wikipedia.org/wiki/.su
  su
  adygeya.su
  arkhangelsk.su
  balashov.su
  bashkiria.su
  bryansk.su
  dagestan.su
  grozny.su
  ivanovo.su
  kalmykia.su
  kaluga.su
  karelia.su
  khakassia.su
  krasnodar.su
  kurgan.su
  lenug.su
  mordovia.su
  msk.su
  murmansk.su
  nalchik.su
  nov.su
  obninsk.su
  penza.su
  pokrovsk.su
  sochi.su
  spb.su
  togliatti.su
  troitsk.su
  tula.su
  tuva.su
  vladikavkaz.su
  vladimir.su
  vologda.su
  
  // sv : http://www.svnet.org.sv/niveldos.pdf
  sv
  com.sv
  edu.sv
  gob.sv
  org.sv
  red.sv
  
  // sx : http://en.wikipedia.org/wiki/.sx
  // Confirmed by registry <jcvignes@openregistry.com> 2012-05-31
  sx
  gov.sx
  
  // sy : http://en.wikipedia.org/wiki/.sy
  // see also: http://www.gobin.info/domainname/sy.doc
  sy
  edu.sy
  gov.sy
  net.sy
  mil.sy
  com.sy
  org.sy
  
  // sz : http://en.wikipedia.org/wiki/.sz
  // http://www.sispa.org.sz/
  sz
  co.sz
  ac.sz
  org.sz
  
  // tc : http://en.wikipedia.org/wiki/.tc
  tc
  
  // td : http://en.wikipedia.org/wiki/.td
  td
  
  // tel: http://en.wikipedia.org/wiki/.tel
  // http://www.telnic.org/
  tel
  
  // tf : http://en.wikipedia.org/wiki/.tf
  tf
  
  // tg : http://en.wikipedia.org/wiki/.tg
  // http://www.nic.tg/
  tg
  
  // th : http://en.wikipedia.org/wiki/.th
  // Submitted by registry <krit@thains.co.th> 2008-06-17
  th
  ac.th
  co.th
  go.th
  in.th
  mi.th
  net.th
  or.th
  
  // tj : http://www.nic.tj/policy.html
  tj
  ac.tj
  biz.tj
  co.tj
  com.tj
  edu.tj
  go.tj
  gov.tj
  int.tj
  mil.tj
  name.tj
  net.tj
  nic.tj
  org.tj
  test.tj
  web.tj
  
  // tk : http://en.wikipedia.org/wiki/.tk
  tk
  
  // tl : http://en.wikipedia.org/wiki/.tl
  tl
  gov.tl
  
  // tm : http://www.nic.tm/local.html
  tm
  com.tm
  co.tm
  org.tm
  net.tm
  nom.tm
  gov.tm
  mil.tm
  edu.tm
  
  // tn : http://en.wikipedia.org/wiki/.tn
  // http://whois.ati.tn/
  tn
  com.tn
  ens.tn
  fin.tn
  gov.tn
  ind.tn
  intl.tn
  nat.tn
  net.tn
  org.tn
  info.tn
  perso.tn
  tourism.tn
  edunet.tn
  rnrt.tn
  rns.tn
  rnu.tn
  mincom.tn
  agrinet.tn
  defense.tn
  turen.tn
  
  // to : http://en.wikipedia.org/wiki/.to
  // Submitted by registry <egullich@colo.to> 2008-06-17
  to
  com.to
  gov.to
  net.to
  org.to
  edu.to
  mil.to
  
  // tp : No registrations at this time.
  // Submitted by Ryan Sleevi <ryan.sleevi@gmail.com> 2014-01-03
  tp
  
  // subTLDs: https://www.nic.tr/forms/eng/policies.pdf
  //     and: https://www.nic.tr/forms/politikalar.pdf
  // Submitted by <mehmetgurevin@gmail.com> 2014-07-19
  tr
  com.tr
  info.tr
  biz.tr
  net.tr
  org.tr
  web.tr
  gen.tr
  tv.tr
  av.tr
  dr.tr
  bbs.tr
  name.tr
  tel.tr
  gov.tr
  bel.tr
  pol.tr
  mil.tr
  k12.tr
  edu.tr
  kep.tr
  
  // Used by Northern Cyprus
  nc.tr
  
  // Used by government agencies of Northern Cyprus
  gov.nc.tr
  
  // travel : http://en.wikipedia.org/wiki/.travel
  travel
  
  // tt : http://www.nic.tt/
  tt
  co.tt
  com.tt
  org.tt
  net.tt
  biz.tt
  info.tt
  pro.tt
  int.tt
  coop.tt
  jobs.tt
  mobi.tt
  travel.tt
  museum.tt
  aero.tt
  name.tt
  gov.tt
  edu.tt
  
  // tv : http://en.wikipedia.org/wiki/.tv
  // Not listing any 2LDs as reserved since none seem to exist in practice,
  // Wikipedia notwithstanding.
  tv
  
  // tw : http://en.wikipedia.org/wiki/.tw
  tw
  edu.tw
  gov.tw
  mil.tw
  com.tw
  net.tw
  org.tw
  idv.tw
  game.tw
  ebiz.tw
  club.tw
  xn--zf0ao64a.tw
  xn--uc0atv.tw
  xn--czrw28b.tw
  
  // tz : http://www.tznic.or.tz/index.php/domains
  // Confirmed by registry <manager@tznic.or.tz> 2013-01-22
  tz
  ac.tz
  co.tz
  go.tz
  hotel.tz
  info.tz
  me.tz
  mil.tz
  mobi.tz
  ne.tz
  or.tz
  sc.tz
  tv.tz
  
  // ua : https://hostmaster.ua/policy/?ua
  // Submitted by registry <dk@cctld.ua> 2012-04-27
  ua
  // ua 2LD
  com.ua
  edu.ua
  gov.ua
  in.ua
  net.ua
  org.ua
  // ua geographic names
  // https://hostmaster.ua/2ld/
  cherkassy.ua
  cherkasy.ua
  chernigov.ua
  chernihiv.ua
  chernivtsi.ua
  chernovtsy.ua
  ck.ua
  cn.ua
  cr.ua
  crimea.ua
  cv.ua
  dn.ua
  dnepropetrovsk.ua
  dnipropetrovsk.ua
  dominic.ua
  donetsk.ua
  dp.ua
  if.ua
  ivano-frankivsk.ua
  kh.ua
  kharkiv.ua
  kharkov.ua
  kherson.ua
  khmelnitskiy.ua
  khmelnytskyi.ua
  kiev.ua
  kirovograd.ua
  km.ua
  kr.ua
  krym.ua
  ks.ua
  kv.ua
  kyiv.ua
  lg.ua
  lt.ua
  lugansk.ua
  lutsk.ua
  lv.ua
  lviv.ua
  mk.ua
  mykolaiv.ua
  nikolaev.ua
  od.ua
  odesa.ua
  odessa.ua
  pl.ua
  poltava.ua
  rivne.ua
  rovno.ua
  rv.ua
  sb.ua
  sebastopol.ua
  sevastopol.ua
  sm.ua
  sumy.ua
  te.ua
  ternopil.ua
  uz.ua
  uzhgorod.ua
  vinnica.ua
  vinnytsia.ua
  vn.ua
  volyn.ua
  yalta.ua
  zaporizhzhe.ua
  zaporizhzhia.ua
  zhitomir.ua
  zhytomyr.ua
  zp.ua
  zt.ua
  
  // ug : https://www.registry.co.ug/
  ug
  co.ug
  or.ug
  ac.ug
  sc.ug
  go.ug
  ne.ug
  com.ug
  org.ug
  
  // uk : http://en.wikipedia.org/wiki/.uk
  // Submitted by registry <Michael.Daly@nominet.org.uk>
  uk
  ac.uk
  co.uk
  gov.uk
  ltd.uk
  me.uk
  net.uk
  nhs.uk
  org.uk
  plc.uk
  police.uk
  *.sch.uk
  
  // us : http://en.wikipedia.org/wiki/.us
  us
  dni.us
  fed.us
  isa.us
  kids.us
  nsn.us
  // us geographic names
  ak.us
  al.us
  ar.us
  as.us
  az.us
  ca.us
  co.us
  ct.us
  dc.us
  de.us
  fl.us
  ga.us
  gu.us
  hi.us
  ia.us
  id.us
  il.us
  in.us
  ks.us
  ky.us
  la.us
  ma.us
  md.us
  me.us
  mi.us
  mn.us
  mo.us
  ms.us
  mt.us
  nc.us
  nd.us
  ne.us
  nh.us
  nj.us
  nm.us
  nv.us
  ny.us
  oh.us
  ok.us
  or.us
  pa.us
  pr.us
  ri.us
  sc.us
  sd.us
  tn.us
  tx.us
  ut.us
  vi.us
  vt.us
  va.us
  wa.us
  wi.us
  wv.us
  wy.us
  // The registrar notes several more specific domains available in each state,
  // such as state.*.us, dst.*.us, etc., but resolution of these is somewhat
  // haphazard; in some states these domains resolve as addresses, while in others
  // only subdomains are available, or even nothing at all. We include the
  // most common ones where it's clear that different sites are different
  // entities.
  k12.ak.us
  k12.al.us
  k12.ar.us
  k12.as.us
  k12.az.us
  k12.ca.us
  k12.co.us
  k12.ct.us
  k12.dc.us
  k12.de.us
  k12.fl.us
  k12.ga.us
  k12.gu.us
  // k12.hi.us  Bug 614565 - Hawaii has a state-wide DOE login
  k12.ia.us
  k12.id.us
  k12.il.us
  k12.in.us
  k12.ks.us
  k12.ky.us
  k12.la.us
  k12.ma.us
  k12.md.us
  k12.me.us
  k12.mi.us
  k12.mn.us
  k12.mo.us
  k12.ms.us
  k12.mt.us
  k12.nc.us
  // k12.nd.us  Bug 1028347 - Removed at request of Travis Rosso <trossow@nd.gov>
  k12.ne.us
  k12.nh.us
  k12.nj.us
  k12.nm.us
  k12.nv.us
  k12.ny.us
  k12.oh.us
  k12.ok.us
  k12.or.us
  k12.pa.us
  k12.pr.us
  k12.ri.us
  k12.sc.us
  // k12.sd.us  Bug 934131 - Removed at request of James Booze <James.Booze@k12.sd.us>
  k12.tn.us
  k12.tx.us
  k12.ut.us
  k12.vi.us
  k12.vt.us
  k12.va.us
  k12.wa.us
  k12.wi.us
  // k12.wv.us  Bug 947705 - Removed at request of Verne Britton <verne@wvnet.edu>
  k12.wy.us
  cc.ak.us
  cc.al.us
  cc.ar.us
  cc.as.us
  cc.az.us
  cc.ca.us
  cc.co.us
  cc.ct.us
  cc.dc.us
  cc.de.us
  cc.fl.us
  cc.ga.us
  cc.gu.us
  cc.hi.us
  cc.ia.us
  cc.id.us
  cc.il.us
  cc.in.us
  cc.ks.us
  cc.ky.us
  cc.la.us
  cc.ma.us
  cc.md.us
  cc.me.us
  cc.mi.us
  cc.mn.us
  cc.mo.us
  cc.ms.us
  cc.mt.us
  cc.nc.us
  cc.nd.us
  cc.ne.us
  cc.nh.us
  cc.nj.us
  cc.nm.us
  cc.nv.us
  cc.ny.us
  cc.oh.us
  cc.ok.us
  cc.or.us
  cc.pa.us
  cc.pr.us
  cc.ri.us
  cc.sc.us
  cc.sd.us
  cc.tn.us
  cc.tx.us
  cc.ut.us
  cc.vi.us
  cc.vt.us
  cc.va.us
  cc.wa.us
  cc.wi.us
  cc.wv.us
  cc.wy.us
  lib.ak.us
  lib.al.us
  lib.ar.us
  lib.as.us
  lib.az.us
  lib.ca.us
  lib.co.us
  lib.ct.us
  lib.dc.us
  lib.de.us
  lib.fl.us
  lib.ga.us
  lib.gu.us
  lib.hi.us
  lib.ia.us
  lib.id.us
  lib.il.us
  lib.in.us
  lib.ks.us
  lib.ky.us
  lib.la.us
  lib.ma.us
  lib.md.us
  lib.me.us
  lib.mi.us
  lib.mn.us
  lib.mo.us
  lib.ms.us
  lib.mt.us
  lib.nc.us
  lib.nd.us
  lib.ne.us
  lib.nh.us
  lib.nj.us
  lib.nm.us
  lib.nv.us
  lib.ny.us
  lib.oh.us
  lib.ok.us
  lib.or.us
  lib.pa.us
  lib.pr.us
  lib.ri.us
  lib.sc.us
  lib.sd.us
  lib.tn.us
  lib.tx.us
  lib.ut.us
  lib.vi.us
  lib.vt.us
  lib.va.us
  lib.wa.us
  lib.wi.us
  // lib.wv.us  Bug 941670 - Removed at request of Larry W Arnold <arnold@wvlc.lib.wv.us>
  lib.wy.us
  // k12.ma.us contains school districts in Massachusetts. The 4LDs are
  //  managed indepedently except for private (PVT), charter (CHTR) and
  //  parochial (PAROCH) schools.  Those are delegated dorectly to the
  //  5LD operators.   <k12-ma-hostmaster _ at _ rsuc.gweep.net>
  pvt.k12.ma.us
  chtr.k12.ma.us
  paroch.k12.ma.us
  
  // uy : http://www.nic.org.uy/
  uy
  com.uy
  edu.uy
  gub.uy
  mil.uy
  net.uy
  org.uy
  
  // uz : http://www.reg.uz/
  uz
  co.uz
  com.uz
  net.uz
  org.uz
  
  // va : http://en.wikipedia.org/wiki/.va
  va
  
  // vc : http://en.wikipedia.org/wiki/.vc
  // Submitted by registry <kshah@ca.afilias.info> 2008-06-13
  vc
  com.vc
  net.vc
  org.vc
  gov.vc
  mil.vc
  edu.vc
  
  // ve : https://registro.nic.ve/
  // Confirmed by registry 2012-10-04
  // Updated 2014-05-20 - Bug 940478
  ve
  arts.ve
  co.ve
  com.ve
  e12.ve
  edu.ve
  firm.ve
  gob.ve
  gov.ve
  info.ve
  int.ve
  mil.ve
  net.ve
  org.ve
  rec.ve
  store.ve
  tec.ve
  web.ve
  
  // vg : http://en.wikipedia.org/wiki/.vg
  vg
  
  // vi : http://www.nic.vi/newdomainform.htm
  // http://www.nic.vi/Domain_Rules/body_domain_rules.html indicates some other
  // TLDs are "reserved", such as edu.vi and gov.vi, but doesn't actually say they
  // are available for registration (which they do not seem to be).
  vi
  co.vi
  com.vi
  k12.vi
  net.vi
  org.vi
  
  // vn : https://www.dot.vn/vnnic/vnnic/domainregistration.jsp
  vn
  com.vn
  net.vn
  org.vn
  edu.vn
  gov.vn
  int.vn
  ac.vn
  biz.vn
  info.vn
  name.vn
  pro.vn
  health.vn
  
  // vu : http://en.wikipedia.org/wiki/.vu
  // http://www.vunic.vu/
  vu
  com.vu
  edu.vu
  net.vu
  org.vu
  
  // wf : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  wf
  
  // ws : http://en.wikipedia.org/wiki/.ws
  // http://samoanic.ws/index.dhtml
  ws
  com.ws
  net.ws
  org.ws
  gov.ws
  edu.ws
  
  // yt : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  yt
  
  // IDN ccTLDs
  // When submitting patches, please maintain a sort by ISO 3166 ccTLD, then
  // U-label, and follow this format:
  // // A-Label ("<Latin renderings>", <language name>[, variant info]) : <ISO 3166 ccTLD>
  // // [sponsoring org]
  // U-Label
  
  // xn--mgbaam7a8h ("Emerat", Arabic) : AE
  // http://nic.ae/english/arabicdomain/rules.jsp
  xn--mgbaam7a8h
  
  // xn--y9a3aq ("hye", Armenian) : AM
  // ISOC AM (operated by .am Registry)
  xn--y9a3aq
  
  // xn--54b7fta0cc ("Bangla", Bangla) : BD
  xn--54b7fta0cc
  
  // xn--90ais ("bel", Belarusian/Russian Cyrillic) : BY
  // Operated by .by registry
  xn--90ais
  
  // xn--fiqs8s ("Zhongguo/China", Chinese, Simplified) : CN
  // CNNIC
  // http://cnnic.cn/html/Dir/2005/10/11/3218.htm
  xn--fiqs8s
  
  // xn--fiqz9s ("Zhongguo/China", Chinese, Traditional) : CN
  // CNNIC
  // http://cnnic.cn/html/Dir/2005/10/11/3218.htm
  xn--fiqz9s
  
  // xn--lgbbat1ad8j ("Algeria/Al Jazair", Arabic) : DZ
  xn--lgbbat1ad8j
  
  // xn--wgbh1c ("Egypt/Masr", Arabic) : EG
  // http://www.dotmasr.eg/
  xn--wgbh1c
  
  // xn--node ("ge", Georgian Mkhedruli) : GE
  xn--node
  
  // xn--qxam ("el", Greek) : GR
  // Hellenic Ministry of Infrastructure, Transport, and Networks
  xn--qxam
  
  // xn--j6w193g ("Hong Kong", Chinese) : HK
  // https://www2.hkirc.hk/register/rules.jsp
  xn--j6w193g
  
  // xn--h2brj9c ("Bharat", Devanagari) : IN
  // India
  xn--h2brj9c
  
  // xn--mgbbh1a71e ("Bharat", Arabic) : IN
  // India
  xn--mgbbh1a71e
  
  // xn--fpcrj9c3d ("Bharat", Telugu) : IN
  // India
  xn--fpcrj9c3d
  
  // xn--gecrj9c ("Bharat", Gujarati) : IN
  // India
  xn--gecrj9c
  
  // xn--s9brj9c ("Bharat", Gurmukhi) : IN
  // India
  xn--s9brj9c
  
  // xn--45brj9c ("Bharat", Bengali) : IN
  // India
  xn--45brj9c
  
  // xn--xkc2dl3a5ee0h ("India", Tamil) : IN
  // India
  xn--xkc2dl3a5ee0h
  
  // xn--mgba3a4f16a ("Iran", Persian) : IR
  xn--mgba3a4f16a
  
  // xn--mgba3a4fra ("Iran", Arabic) : IR
  xn--mgba3a4fra
  
  // xn--mgbtx2b ("Iraq", Arabic) : IQ
  // Communications and Media Commission
  xn--mgbtx2b
  
  // xn--mgbayh7gpa ("al-Ordon", Arabic) : JO
  // National Information Technology Center (NITC)
  // Royal Scientific Society, Al-Jubeiha
  xn--mgbayh7gpa
  
  // xn--3e0b707e ("Republic of Korea", Hangul) : KR
  xn--3e0b707e
  
  // xn--80ao21a ("Kaz", Kazakh) : KZ
  xn--80ao21a
  
  // xn--fzc2c9e2c ("Lanka", Sinhalese-Sinhala) : LK
  // http://nic.lk
  xn--fzc2c9e2c
  
  // xn--xkc2al3hye2a ("Ilangai", Tamil) : LK
  // http://nic.lk
  xn--xkc2al3hye2a
  
  // xn--mgbc0a9azcg ("Morocco/al-Maghrib", Arabic) : MA
  xn--mgbc0a9azcg
  
  // xn--d1alf ("mkd", Macedonian) : MK
  // MARnet
  xn--d1alf
  
  // xn--l1acc ("mon", Mongolian) : MN
  xn--l1acc
  
  // xn--mix891f ("Macao", Chinese, Traditional) : MO
  // MONIC / HNET Asia (Registry Operator for .mo)
  xn--mix891f
  
  // xn--mix082f ("Macao", Chinese, Simplified) : MO
  xn--mix082f
  
  // xn--mgbx4cd0ab ("Malaysia", Malay) : MY
  xn--mgbx4cd0ab
  
  // xn--mgb9awbf ("Oman", Arabic) : OM
  xn--mgb9awbf
  
  // xn--mgbai9azgqp6j ("Pakistan", Urdu/Arabic) : PK
  xn--mgbai9azgqp6j
  
  // xn--mgbai9a5eva00b ("Pakistan", Urdu/Arabic, variant) : PK
  xn--mgbai9a5eva00b
  
  // xn--ygbi2ammx ("Falasteen", Arabic) : PS
  // The Palestinian National Internet Naming Authority (PNINA)
  // http://www.pnina.ps
  xn--ygbi2ammx
  
  // xn--90a3ac ("srb", Cyrillic) : RS
  // http://www.rnids.rs/en/the-.срб-domain
  xn--90a3ac
  xn--o1ac.xn--90a3ac
  xn--c1avg.xn--90a3ac
  xn--90azh.xn--90a3ac
  xn--d1at.xn--90a3ac
  xn--o1ach.xn--90a3ac
  xn--80au.xn--90a3ac
  
  // xn--p1ai ("rf", Russian-Cyrillic) : RU
  // http://www.cctld.ru/en/docs/rulesrf.php
  xn--p1ai
  
  // xn--wgbl6a ("Qatar", Arabic) : QA
  // http://www.ict.gov.qa/
  xn--wgbl6a
  
  // xn--mgberp4a5d4ar ("AlSaudiah", Arabic) : SA
  // http://www.nic.net.sa/
  xn--mgberp4a5d4ar
  
  // xn--mgberp4a5d4a87g ("AlSaudiah", Arabic, variant)  : SA
  xn--mgberp4a5d4a87g
  
  // xn--mgbqly7c0a67fbc ("AlSaudiah", Arabic, variant) : SA
  xn--mgbqly7c0a67fbc
  
  // xn--mgbqly7cvafr ("AlSaudiah", Arabic, variant) : SA
  xn--mgbqly7cvafr
  
  // xn--mgbpl2fh ("sudan", Arabic) : SD
  // Operated by .sd registry
  xn--mgbpl2fh
  
  // xn--yfro4i67o Singapore ("Singapore", Chinese) : SG
  xn--yfro4i67o
  
  // xn--clchc0ea0b2g2a9gcd ("Singapore", Tamil) : SG
  xn--clchc0ea0b2g2a9gcd
  
  // xn--ogbpf8fl ("Syria", Arabic) : SY
  xn--ogbpf8fl
  
  // xn--mgbtf8fl ("Syria", Arabic, variant) : SY
  xn--mgbtf8fl
  
  // xn--o3cw4h ("Thai", Thai) : TH
  // http://www.thnic.co.th
  xn--o3cw4h
  
  // xn--pgbs0dh ("Tunisia", Arabic) : TN
  // http://nic.tn
  xn--pgbs0dh
  
  // xn--kpry57d ("Taiwan", Chinese, Traditional) : TW
  // http://www.twnic.net/english/dn/dn_07a.htm
  xn--kpry57d
  
  // xn--kprw13d ("Taiwan", Chinese, Simplified) : TW
  // http://www.twnic.net/english/dn/dn_07a.htm
  xn--kprw13d
  
  // xn--nnx388a ("Taiwan", Chinese, variant) : TW
  xn--nnx388a
  
  // xn--j1amh ("ukr", Cyrillic) : UA
  xn--j1amh
  
  // xn--mgb2ddes ("AlYemen", Arabic) : YE
  xn--mgb2ddes
  
  // xxx : http://icmregistry.com
  xxx
  
  // ye : http://www.y.net.ye/services/domain_name.htm
  *.ye
  
  // za : http://www.zadna.org.za/content/page/domain-information
  ac.za
  agrica.za
  alt.za
  co.za
  edu.za
  gov.za
  grondar.za
  law.za
  mil.za
  net.za
  ngo.za
  nis.za
  nom.za
  org.za
  school.za
  tm.za
  web.za
  
  // zm : http://en.wikipedia.org/wiki/.zm
  *.zm
  
  // zw : http://en.wikipedia.org/wiki/.zw
  *.zw
  
  
  // List of new gTLDs imported from https://newgtlds.icann.org/newgtlds.csv on 2015-11-12T22:43:48Z
  
  // aaa : 2015-02-26 American Automobile Association, Inc.
  aaa
  
  // aarp : 2015-05-21 AARP
  aarp
  
  // abarth : 2015-07-30 Fiat Chrysler Automobiles N.V.
  abarth
  
  // abb : 2014-10-24 ABB Ltd
  abb
  
  // abbott : 2014-07-24 Abbott Laboratories, Inc.
  abbott
  
  // abbvie : 2015-07-30 AbbVie Inc.
  abbvie
  
  // abc : 2015-07-30 Disney Enterprises, Inc.
  abc
  
  // able : 2015-06-25 Able Inc.
  able
  
  // abogado : 2014-04-24 Top Level Domain Holdings Limited
  abogado
  
  // abudhabi : 2015-07-30 Abu Dhabi Systems and Information Centre
  abudhabi
  
  // academy : 2013-11-07 Half Oaks, LLC
  academy
  
  // accenture : 2014-08-15 Accenture plc
  accenture
  
  // accountant : 2014-11-20 dot Accountant Limited
  accountant
  
  // accountants : 2014-03-20 Knob Town, LLC
  accountants
  
  // aco : 2015-01-08 ACO Severin Ahlmann GmbH & Co. KG
  aco
  
  // active : 2014-05-01 The Active Network, Inc
  active
  
  // actor : 2013-12-12 United TLD Holdco Ltd.
  actor
  
  // adac : 2015-07-16 Allgemeiner Deutscher Automobil-Club e.V. (ADAC)
  adac
  
  // ads : 2014-12-04 Charleston Road Registry Inc.
  ads
  
  // adult : 2014-10-16 ICM Registry AD LLC
  adult
  
  // aeg : 2015-03-19 Aktiebolaget Electrolux
  aeg
  
  // aetna : 2015-05-21 Aetna Life Insurance Company
  aetna
  
  // afamilycompany : 2015-07-23 Johnson Shareholdings, Inc.
  afamilycompany
  
  // afl : 2014-10-02 Australian Football League
  afl
  
  // africa : 2014-03-24 ZA Central Registry NPC trading as Registry.Africa
  africa
  
  // africamagic : 2015-03-05 Electronic Media Network (Pty) Ltd
  africamagic
  
  // agakhan : 2015-04-23 Fondation Aga Khan (Aga Khan Foundation)
  agakhan
  
  // agency : 2013-11-14 Steel Falls, LLC
  agency
  
  // aig : 2014-12-18 American International Group, Inc.
  aig
  
  // aigo : 2015-08-06 aigo Digital Technology Co,Ltd.
  aigo
  
  // airbus : 2015-07-30 Airbus S.A.S.
  airbus
  
  // airforce : 2014-03-06 United TLD Holdco Ltd.
  airforce
  
  // airtel : 2014-10-24 Bharti Airtel Limited
  airtel
  
  // akdn : 2015-04-23 Fondation Aga Khan (Aga Khan Foundation)
  akdn
  
  // alfaromeo : 2015-07-31 Fiat Chrysler Automobiles N.V.
  alfaromeo
  
  // alibaba : 2015-01-15 Alibaba Group Holding Limited
  alibaba
  
  // alipay : 2015-01-15 Alibaba Group Holding Limited
  alipay
  
  // allfinanz : 2014-07-03 Allfinanz Deutsche Vermögensberatung Aktiengesellschaft
  allfinanz
  
  // allstate : 2015-07-31 Allstate Fire and Casualty Insurance Company
  allstate
  
  // ally : 2015-06-18 Ally Financial Inc.
  ally
  
  // alsace : 2014-07-02 REGION D ALSACE
  alsace
  
  // alstom : 2015-07-30 ALSTOM
  alstom
  
  // americanexpress : 2015-07-31 American Express Travel Related Services Company, Inc.
  americanexpress
  
  // americanfamily : 2015-07-23 AmFam, Inc.
  americanfamily
  
  // amex : 2015-07-31 American Express Travel Related Services Company, Inc.
  amex
  
  // amfam : 2015-07-23 AmFam, Inc.
  amfam
  
  // amica : 2015-05-28 Amica Mutual Insurance Company
  amica
  
  // amsterdam : 2014-07-24 Gemeente Amsterdam
  amsterdam
  
  // analytics : 2014-12-18 Campus IP LLC
  analytics
  
  // android : 2014-08-07 Charleston Road Registry Inc.
  android
  
  // anquan : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  anquan
  
  // anz : 2015-07-31 Australia and New Zealand Banking Group Limited
  anz
  
  // aol : 2015-09-17 AOL Inc.
  aol
  
  // apartments : 2014-12-11 June Maple, LLC
  apartments
  
  // app : 2015-05-14 Charleston Road Registry Inc.
  app
  
  // apple : 2015-05-14 Apple Inc.
  apple
  
  // aquarelle : 2014-07-24 Aquarelle.com
  aquarelle
  
  // aramco : 2014-11-20 Aramco Services Company
  aramco
  
  // archi : 2014-02-06 STARTING DOT LIMITED
  archi
  
  // army : 2014-03-06 United TLD Holdco Ltd.
  army
  
  // arte : 2014-12-11 Association Relative à la Télévision Européenne G.E.I.E.
  arte
  
  // asda : 2015-07-31 Wal-Mart Stores, Inc.
  asda
  
  // associates : 2014-03-06 Baxter Hill, LLC
  associates
  
  // athleta : 2015-07-30 The Gap, Inc.
  athleta
  
  // attorney : 2014-03-20
  attorney
  
  // auction : 2014-03-20
  auction
  
  // audi : 2015-05-21 AUDI Aktiengesellschaft
  audi
  
  // audible : 2015-06-25 Amazon EU S.à r.l.
  audible
  
  // audio : 2014-03-20 Uniregistry, Corp.
  audio
  
  // auspost : 2015-08-13 Australian Postal Corporation
  auspost
  
  // author : 2014-12-18 Amazon EU S.à r.l.
  author
  
  // auto : 2014-11-13
  auto
  
  // autos : 2014-01-09 DERAutos, LLC
  autos
  
  // avianca : 2015-01-08 Aerovias del Continente Americano S.A. Avianca
  avianca
  
  // aws : 2015-06-25 Amazon EU S.à r.l.
  aws
  
  // axa : 2013-12-19 AXA SA
  axa
  
  // azure : 2014-12-18 Microsoft Corporation
  azure
  
  // baby : 2015-04-09 Johnson & Johnson Services, Inc.
  baby
  
  // baidu : 2015-01-08 Baidu, Inc.
  baidu
  
  // banamex : 2015-07-30 Citigroup Inc.
  banamex
  
  // bananarepublic : 2015-07-31 The Gap, Inc.
  bananarepublic
  
  // band : 2014-06-12
  band
  
  // bank : 2014-09-25 fTLD Registry Services LLC
  bank
  
  // bar : 2013-12-12 Punto 2012 Sociedad Anonima Promotora de Inversion de Capital Variable
  bar
  
  // barcelona : 2014-07-24 Municipi de Barcelona
  barcelona
  
  // barclaycard : 2014-11-20 Barclays Bank PLC
  barclaycard
  
  // barclays : 2014-11-20 Barclays Bank PLC
  barclays
  
  // barefoot : 2015-06-11 Gallo Vineyards, Inc.
  barefoot
  
  // bargains : 2013-11-14 Half Hallow, LLC
  bargains
  
  // baseball : 2015-10-29 MLB Advanced Media DH, LLC
  baseball
  
  // basketball : 2015-08-20 Fédération Internationale de Basketball (FIBA)
  basketball
  
  // bauhaus : 2014-04-17 Werkhaus GmbH
  bauhaus
  
  // bayern : 2014-01-23 Bayern Connect GmbH
  bayern
  
  // bbc : 2014-12-18 British Broadcasting Corporation
  bbc
  
  // bbt : 2015-07-23 BB&T Corporation
  bbt
  
  // bbva : 2014-10-02 BANCO BILBAO VIZCAYA ARGENTARIA, S.A.
  bbva
  
  // bcg : 2015-04-02 The Boston Consulting Group, Inc.
  bcg
  
  // bcn : 2014-07-24 Municipi de Barcelona
  bcn
  
  // beats : 2015-05-14 Beats Electronics, LLC
  beats
  
  // beer : 2014-01-09 Top Level Domain Holdings Limited
  beer
  
  // bentley : 2014-12-18 Bentley Motors Limited
  bentley
  
  // berlin : 2013-10-31 dotBERLIN GmbH & Co. KG
  berlin
  
  // best : 2013-12-19 BestTLD Pty Ltd
  best
  
  // bestbuy : 2015-07-31 BBY Solutions, Inc.
  bestbuy
  
  // bet : 2015-05-07 Afilias plc
  bet
  
  // bharti : 2014-01-09 Bharti Enterprises (Holding) Private Limited
  bharti
  
  // bible : 2014-06-19 American Bible Society
  bible
  
  // bid : 2013-12-19 dot Bid Limited
  bid
  
  // bike : 2013-08-27 Grand Hollow, LLC
  bike
  
  // bing : 2014-12-18 Microsoft Corporation
  bing
  
  // bingo : 2014-12-04 Sand Cedar, LLC
  bingo
  
  // bio : 2014-03-06 STARTING DOT LIMITED
  bio
  
  // black : 2014-01-16 Afilias Limited
  black
  
  // blackfriday : 2014-01-16 Uniregistry, Corp.
  blackfriday
  
  // blanco : 2015-07-16 BLANCO GmbH + Co KG
  blanco
  
  // blockbuster : 2015-07-30 Dish DBS Corporation
  blockbuster
  
  // blog : 2015-05-14 PRIMER NIVEL S.A.
  blog
  
  // bloomberg : 2014-07-17 Bloomberg IP Holdings LLC
  bloomberg
  
  // blue : 2013-11-07 Afilias Limited
  blue
  
  // bms : 2014-10-30 Bristol-Myers Squibb Company
  bms
  
  // bmw : 2014-01-09 Bayerische Motoren Werke Aktiengesellschaft
  bmw
  
  // bnl : 2014-07-24 Banca Nazionale del Lavoro
  bnl
  
  // bnpparibas : 2014-05-29 BNP Paribas
  bnpparibas
  
  // boats : 2014-12-04 DERBoats, LLC
  boats
  
  // boehringer : 2015-07-09 Boehringer Ingelheim International GmbH
  boehringer
  
  // bofa : 2015-07-31 NMS Services, Inc.
  bofa
  
  // bom : 2014-10-16 Núcleo de Informação e Coordenação do Ponto BR - NIC.br
  bom
  
  // bond : 2014-06-05 Bond University Limited
  bond
  
  // boo : 2014-01-30 Charleston Road Registry Inc.
  boo
  
  // book : 2015-08-27 Amazon EU S.à r.l.
  book
  
  // booking : 2015-07-16 Booking.com B.V.
  booking
  
  // boots : 2015-01-08 THE BOOTS COMPANY PLC
  boots
  
  // bosch : 2015-06-18 Robert Bosch GMBH
  bosch
  
  // bostik : 2015-05-28 Bostik SA
  bostik
  
  // bot : 2014-12-18 Amazon EU S.à r.l.
  bot
  
  // boutique : 2013-11-14 Over Galley, LLC
  boutique
  
  // bradesco : 2014-12-18 Banco Bradesco S.A.
  bradesco
  
  // bridgestone : 2014-12-18 Bridgestone Corporation
  bridgestone
  
  // broadway : 2014-12-22 Celebrate Broadway, Inc.
  broadway
  
  // broker : 2014-12-11 IG Group Holdings PLC
  broker
  
  // brother : 2015-01-29 Brother Industries, Ltd.
  brother
  
  // brussels : 2014-02-06 DNS.be vzw
  brussels
  
  // budapest : 2013-11-21 Top Level Domain Holdings Limited
  budapest
  
  // bugatti : 2015-07-23 Bugatti International SA
  bugatti
  
  // build : 2013-11-07 Plan Bee LLC
  build
  
  // builders : 2013-11-07 Atomic Madison, LLC
  builders
  
  // business : 2013-11-07 Spring Cross, LLC
  business
  
  // buy : 2014-12-18 Amazon EU S.à r.l.
  buy
  
  // buzz : 2013-10-02 DOTSTRATEGY CO.
  buzz
  
  // bzh : 2014-02-27 Association www.bzh
  bzh
  
  // cab : 2013-10-24 Half Sunset, LLC
  cab
  
  // cafe : 2015-02-11 Pioneer Canyon, LLC
  cafe
  
  // cal : 2014-07-24 Charleston Road Registry Inc.
  cal
  
  // call : 2014-12-18 Amazon EU S.à r.l.
  call
  
  // calvinklein : 2015-07-30 PVH gTLD Holdings LLC
  calvinklein
  
  // camera : 2013-08-27 Atomic Maple, LLC
  camera
  
  // camp : 2013-11-07 Delta Dynamite, LLC
  camp
  
  // cancerresearch : 2014-05-15 Australian Cancer Research Foundation
  cancerresearch
  
  // canon : 2014-09-12 Canon Inc.
  canon
  
  // capetown : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  capetown
  
  // capital : 2014-03-06 Delta Mill, LLC
  capital
  
  // capitalone : 2015-08-06 Capital One Financial Corporation
  capitalone
  
  // car : 2015-01-22
  car
  
  // caravan : 2013-12-12 Caravan International, Inc.
  caravan
  
  // cards : 2013-12-05 Foggy Hollow, LLC
  cards
  
  // care : 2014-03-06 Goose Cross
  care
  
  // career : 2013-10-09 dotCareer LLC
  career
  
  // careers : 2013-10-02 Wild Corner, LLC
  careers
  
  // cars : 2014-11-13
  cars
  
  // cartier : 2014-06-23 Richemont DNS Inc.
  cartier
  
  // casa : 2013-11-21 Top Level Domain Holdings Limited
  casa
  
  // case : 2015-09-03 CNH Industrial N.V.
  case
  
  // caseih : 2015-09-03 CNH Industrial N.V.
  caseih
  
  // cash : 2014-03-06 Delta Lake, LLC
  cash
  
  // casino : 2014-12-18 Binky Sky, LLC
  casino
  
  // catering : 2013-12-05 New Falls. LLC
  catering
  
  // catholic : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  catholic
  
  // cba : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  cba
  
  // cbn : 2014-08-22 The Christian Broadcasting Network, Inc.
  cbn
  
  // cbre : 2015-07-02 CBRE, Inc.
  cbre
  
  // cbs : 2015-08-06 CBS Domains Inc.
  cbs
  
  // ceb : 2015-04-09 The Corporate Executive Board Company
  ceb
  
  // center : 2013-11-07 Tin Mill, LLC
  center
  
  // ceo : 2013-11-07 CEOTLD Pty Ltd
  ceo
  
  // cern : 2014-06-05 European Organization for Nuclear Research ("CERN")
  cern
  
  // cfa : 2014-08-28 CFA Institute
  cfa
  
  // cfd : 2014-12-11 IG Group Holdings PLC
  cfd
  
  // chanel : 2015-04-09 Chanel International B.V.
  chanel
  
  // channel : 2014-05-08 Charleston Road Registry Inc.
  channel
  
  // chase : 2015-04-30 JPMorgan Chase & Co.
  chase
  
  // chat : 2014-12-04 Sand Fields, LLC
  chat
  
  // cheap : 2013-11-14 Sand Cover, LLC
  cheap
  
  // chintai : 2015-06-11 CHINTAI Corporation
  chintai
  
  // chloe : 2014-10-16 Richemont DNS Inc.
  chloe
  
  // christmas : 2013-11-21 Uniregistry, Corp.
  christmas
  
  // chrome : 2014-07-24 Charleston Road Registry Inc.
  chrome
  
  // chrysler : 2015-07-30 FCA US LLC.
  chrysler
  
  // church : 2014-02-06 Holly Fields, LLC
  church
  
  // cipriani : 2015-02-19 Hotel Cipriani Srl
  cipriani
  
  // circle : 2014-12-18 Amazon EU S.à r.l.
  circle
  
  // cisco : 2014-12-22 Cisco Technology, Inc.
  cisco
  
  // citadel : 2015-07-23 Citadel Domain LLC
  citadel
  
  // citi : 2015-07-30 Citigroup Inc.
  citi
  
  // citic : 2014-01-09 CITIC Group Corporation
  citic
  
  // city : 2014-05-29 Snow Sky, LLC
  city
  
  // cityeats : 2014-12-11 Lifestyle Domain Holdings, Inc.
  cityeats
  
  // claims : 2014-03-20 Black Corner, LLC
  claims
  
  // cleaning : 2013-12-05 Fox Shadow, LLC
  cleaning
  
  // click : 2014-06-05 Uniregistry, Corp.
  click
  
  // clinic : 2014-03-20 Goose Park, LLC
  clinic
  
  // clinique : 2015-10-01 The Estée Lauder Companies Inc.
  clinique
  
  // clothing : 2013-08-27 Steel Lake, LLC
  clothing
  
  // cloud : 2015-04-16 ARUBA S.p.A.
  cloud
  
  // club : 2013-11-08 .CLUB DOMAINS, LLC
  club
  
  // clubmed : 2015-06-25 Club Méditerranée S.A.
  clubmed
  
  // coach : 2014-10-09 Koko Island, LLC
  coach
  
  // codes : 2013-10-31 Puff Willow, LLC
  codes
  
  // coffee : 2013-10-17 Trixy Cover, LLC
  coffee
  
  // college : 2014-01-16 XYZ.COM LLC
  college
  
  // cologne : 2014-02-05 NetCologne Gesellschaft für Telekommunikation mbH
  cologne
  
  // comcast : 2015-07-23 Comcast IP Holdings I, LLC
  comcast
  
  // commbank : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  commbank
  
  // community : 2013-12-05 Fox Orchard, LLC
  community
  
  // company : 2013-11-07 Silver Avenue, LLC
  company
  
  // compare : 2015-10-08 iSelect Ltd
  compare
  
  // computer : 2013-10-24 Pine Mill, LLC
  computer
  
  // comsec : 2015-01-08 VeriSign, Inc.
  comsec
  
  // condos : 2013-12-05 Pine House, LLC
  condos
  
  // construction : 2013-09-16 Fox Dynamite, LLC
  construction
  
  // consulting : 2013-12-05
  consulting
  
  // contact : 2015-01-08 Top Level Spectrum, Inc.
  contact
  
  // contractors : 2013-09-10 Magic Woods, LLC
  contractors
  
  // cooking : 2013-11-21 Top Level Domain Holdings Limited
  cooking
  
  // cookingchannel : 2015-07-02 Lifestyle Domain Holdings, Inc.
  cookingchannel
  
  // cool : 2013-11-14 Koko Lake, LLC
  cool
  
  // corsica : 2014-09-25 Collectivité Territoriale de Corse
  corsica
  
  // country : 2013-12-19 Top Level Domain Holdings Limited
  country
  
  // coupon : 2015-02-26 Amazon EU S.à r.l.
  coupon
  
  // coupons : 2015-03-26 Black Island, LLC
  coupons
  
  // courses : 2014-12-04 OPEN UNIVERSITIES AUSTRALIA PTY LTD
  courses
  
  // credit : 2014-03-20 Snow Shadow, LLC
  credit
  
  // creditcard : 2014-03-20 Binky Frostbite, LLC
  creditcard
  
  // creditunion : 2015-01-22 CUNA Performance Resources, LLC
  creditunion
  
  // cricket : 2014-10-09 dot Cricket Limited
  cricket
  
  // crown : 2014-10-24 Crown Equipment Corporation
  crown
  
  // crs : 2014-04-03 Federated Co-operatives Limited
  crs
  
  // cruises : 2013-12-05 Spring Way, LLC
  cruises
  
  // csc : 2014-09-25 Alliance-One Services, Inc.
  csc
  
  // cuisinella : 2014-04-03 SALM S.A.S.
  cuisinella
  
  // cymru : 2014-05-08 Nominet UK
  cymru
  
  // cyou : 2015-01-22 Beijing Gamease Age Digital Technology Co., Ltd.
  cyou
  
  // dabur : 2014-02-06 Dabur India Limited
  dabur
  
  // dad : 2014-01-23 Charleston Road Registry Inc.
  dad
  
  // dance : 2013-10-24 United TLD Holdco Ltd.
  dance
  
  // date : 2014-11-20 dot Date Limited
  date
  
  // dating : 2013-12-05 Pine Fest, LLC
  dating
  
  // datsun : 2014-03-27 NISSAN MOTOR CO., LTD.
  datsun
  
  // day : 2014-01-30 Charleston Road Registry Inc.
  day
  
  // dclk : 2014-11-20 Charleston Road Registry Inc.
  dclk
  
  // dds : 2015-05-07 Top Level Domain Holdings Limited
  dds
  
  // deal : 2015-06-25 Amazon EU S.à r.l.
  deal
  
  // dealer : 2014-12-22 Dealer Dot Com, Inc.
  dealer
  
  // deals : 2014-05-22 Sand Sunset, LLC
  deals
  
  // degree : 2014-03-06
  degree
  
  // delivery : 2014-09-11 Steel Station, LLC
  delivery
  
  // dell : 2014-10-24 Dell Inc.
  dell
  
  // deloitte : 2015-07-31 Deloitte Touche Tohmatsu
  deloitte
  
  // delta : 2015-02-19 Delta Air Lines, Inc.
  delta
  
  // democrat : 2013-10-24 United TLD Holdco Ltd.
  democrat
  
  // dental : 2014-03-20 Tin Birch, LLC
  dental
  
  // dentist : 2014-03-20
  dentist
  
  // desi : 2013-11-14 Desi Networks LLC
  desi
  
  // design : 2014-11-07 Top Level Design, LLC
  design
  
  // dev : 2014-10-16 Charleston Road Registry Inc.
  dev
  
  // dhl : 2015-07-23 Deutsche Post AG
  dhl
  
  // diamonds : 2013-09-22 John Edge, LLC
  diamonds
  
  // diet : 2014-06-26 Uniregistry, Corp.
  diet
  
  // digital : 2014-03-06 Dash Park, LLC
  digital
  
  // direct : 2014-04-10 Half Trail, LLC
  direct
  
  // directory : 2013-09-20 Extra Madison, LLC
  directory
  
  // discount : 2014-03-06 Holly Hill, LLC
  discount
  
  // discover : 2015-07-23 Discover Financial Services
  discover
  
  // dish : 2015-07-30 Dish DBS Corporation
  dish
  
  // diy : 2015-11-05 Lifestyle Domain Holdings, Inc.
  diy
  
  // dnp : 2013-12-13 Dai Nippon Printing Co., Ltd.
  dnp
  
  // docs : 2014-10-16 Charleston Road Registry Inc.
  docs
  
  // dodge : 2015-07-30 FCA US LLC.
  dodge
  
  // dog : 2014-12-04 Koko Mill, LLC
  dog
  
  // doha : 2014-09-18 Communications Regulatory Authority (CRA)
  doha
  
  // domains : 2013-10-17 Sugar Cross, LLC
  domains
  
  // doosan : 2014-04-03 Doosan Corporation
  doosan
  
  // dot : 2015-05-21 Dish DBS Corporation
  dot
  
  // download : 2014-11-20 dot Support Limited
  download
  
  // drive : 2015-03-05 Charleston Road Registry Inc.
  drive
  
  // dstv : 2015-03-12 MultiChoice (Proprietary) Limited
  dstv
  
  // dtv : 2015-06-04 Dish DBS Corporation
  dtv
  
  // dubai : 2015-01-01 Dubai Smart Government Department
  dubai
  
  // duck : 2015-07-23 Johnson Shareholdings, Inc.
  duck
  
  // dunlop : 2015-07-02 The Goodyear Tire & Rubber Company
  dunlop
  
  // duns : 2015-08-06 The Dun & Bradstreet Corporation
  duns
  
  // dupont : 2015-06-25 E.I. du Pont de Nemours and Company
  dupont
  
  // durban : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  durban
  
  // dvag : 2014-06-23 Deutsche Vermögensberatung Aktiengesellschaft DVAG
  dvag
  
  // dwg : 2015-07-23 Autodesk, Inc.
  dwg
  
  // earth : 2014-12-04 Interlink Co., Ltd.
  earth
  
  // eat : 2014-01-23 Charleston Road Registry Inc.
  eat
  
  // edeka : 2014-12-18 EDEKA Verband kaufmännischer Genossenschaften e.V.
  edeka
  
  // education : 2013-11-07 Brice Way, LLC
  education
  
  // email : 2013-10-31 Spring Madison, LLC
  email
  
  // emerck : 2014-04-03 Merck KGaA
  emerck
  
  // emerson : 2015-07-23 Emerson Electric Co.
  emerson
  
  // energy : 2014-09-11 Binky Birch, LLC
  energy
  
  // engineer : 2014-03-06 United TLD Holdco Ltd.
  engineer
  
  // engineering : 2014-03-06 Romeo Canyon
  engineering
  
  // enterprises : 2013-09-20 Snow Oaks, LLC
  enterprises
  
  // epost : 2015-07-23 Deutsche Post AG
  epost
  
  // epson : 2014-12-04 Seiko Epson Corporation
  epson
  
  // equipment : 2013-08-27 Corn Station, LLC
  equipment
  
  // ericsson : 2015-07-09 Telefonaktiebolaget L M Ericsson
  ericsson
  
  // erni : 2014-04-03 ERNI Group Holding AG
  erni
  
  // esq : 2014-05-08 Charleston Road Registry Inc.
  esq
  
  // estate : 2013-08-27 Trixy Park, LLC
  estate
  
  // esurance : 2015-07-23 Esurance Insurance Company
  esurance
  
  // etisalat : 2015-09-03 Emirates Telecommunications Corporation (trading as Etisalat)
  etisalat
  
  // eurovision : 2014-04-24 European Broadcasting Union (EBU)
  eurovision
  
  // eus : 2013-12-12 Puntueus Fundazioa
  eus
  
  // events : 2013-12-05 Pioneer Maple, LLC
  events
  
  // everbank : 2014-05-15 EverBank
  everbank
  
  // exchange : 2014-03-06 Spring Falls, LLC
  exchange
  
  // expert : 2013-11-21 Magic Pass, LLC
  expert
  
  // exposed : 2013-12-05 Victor Beach, LLC
  exposed
  
  // express : 2015-02-11 Sea Sunset, LLC
  express
  
  // extraspace : 2015-05-14 Extra Space Storage LLC
  extraspace
  
  // fage : 2014-12-18 Fage International S.A.
  fage
  
  // fail : 2014-03-06 Atomic Pipe, LLC
  fail
  
  // fairwinds : 2014-11-13 FairWinds Partners, LLC
  fairwinds
  
  // faith : 2014-11-20 dot Faith Limited
  faith
  
  // family : 2015-04-02
  family
  
  // fan : 2014-03-06
  fan
  
  // fans : 2014-11-07 Asiamix Digital Limited
  fans
  
  // farm : 2013-11-07 Just Maple, LLC
  farm
  
  // farmers : 2015-07-09 Farmers Insurance Exchange
  farmers
  
  // fashion : 2014-07-03 Top Level Domain Holdings Limited
  fashion
  
  // fast : 2014-12-18 Amazon EU S.à r.l.
  fast
  
  // fedex : 2015-08-06 Federal Express Corporation
  fedex
  
  // feedback : 2013-12-19 Top Level Spectrum, Inc.
  feedback
  
  // ferrari : 2015-07-31 Fiat Chrysler Automobiles N.V.
  ferrari
  
  // ferrero : 2014-12-18 Ferrero Trading Lux S.A.
  ferrero
  
  // fiat : 2015-07-31 Fiat Chrysler Automobiles N.V.
  fiat
  
  // fidelity : 2015-07-30 Fidelity Brokerage Services LLC
  fidelity
  
  // fido : 2015-08-06 Rogers Communications Partnership
  fido
  
  // film : 2015-01-08 Motion Picture Domain Registry Pty Ltd
  film
  
  // final : 2014-10-16 Núcleo de Informação e Coordenação do Ponto BR - NIC.br
  final
  
  // finance : 2014-03-20 Cotton Cypress, LLC
  finance
  
  // financial : 2014-03-06 Just Cover, LLC
  financial
  
  // fire : 2015-06-25 Amazon EU S.à r.l.
  fire
  
  // firestone : 2014-12-18 Bridgestone Corporation
  firestone
  
  // firmdale : 2014-03-27 Firmdale Holdings Limited
  firmdale
  
  // fish : 2013-12-12 Fox Woods, LLC
  fish
  
  // fishing : 2013-11-21 Top Level Domain Holdings Limited
  fishing
  
  // fit : 2014-11-07 Top Level Domain Holdings Limited
  fit
  
  // fitness : 2014-03-06 Brice Orchard, LLC
  fitness
  
  // flickr : 2015-04-02 Yahoo! Domain Services Inc.
  flickr
  
  // flights : 2013-12-05 Fox Station, LLC
  flights
  
  // flir : 2015-07-23 FLIR Systems, Inc.
  flir
  
  // florist : 2013-11-07 Half Cypress, LLC
  florist
  
  // flowers : 2014-10-09 Uniregistry, Corp.
  flowers
  
  // flsmidth : 2014-07-24 FLSmidth A/S
  flsmidth
  
  // fly : 2014-05-08 Charleston Road Registry Inc.
  fly
  
  // foo : 2014-01-23 Charleston Road Registry Inc.
  foo
  
  // foodnetwork : 2015-07-02 Lifestyle Domain Holdings, Inc.
  foodnetwork
  
  // football : 2014-12-18 Foggy Farms, LLC
  football
  
  // ford : 2014-11-13 Ford Motor Company
  ford
  
  // forex : 2014-12-11 IG Group Holdings PLC
  forex
  
  // forsale : 2014-05-22
  forsale
  
  // forum : 2015-04-02 Fegistry, LLC
  forum
  
  // foundation : 2013-12-05 John Dale, LLC
  foundation
  
  // fox : 2015-09-11 FOX Registry, LLC
  fox
  
  // fresenius : 2015-07-30 Fresenius Immobilien-Verwaltungs-GmbH
  fresenius
  
  // frl : 2014-05-15 FRLregistry B.V.
  frl
  
  // frogans : 2013-12-19 OP3FT
  frogans
  
  // frontdoor : 2015-07-02 Lifestyle Domain Holdings, Inc.
  frontdoor
  
  // frontier : 2015-02-05 Frontier Communications Corporation
  frontier
  
  // ftr : 2015-07-16 Frontier Communications Corporation
  ftr
  
  // fujitsu : 2015-07-30 Fujitsu Limited
  fujitsu
  
  // fujixerox : 2015-07-23 Xerox DNHC LLC
  fujixerox
  
  // fund : 2014-03-20 John Castle, LLC
  fund
  
  // furniture : 2014-03-20 Lone Fields, LLC
  furniture
  
  // futbol : 2013-09-20
  futbol
  
  // fyi : 2015-04-02 Silver Tigers, LLC
  fyi
  
  // gal : 2013-11-07 Asociación puntoGAL
  gal
  
  // gallery : 2013-09-13 Sugar House, LLC
  gallery
  
  // gallo : 2015-06-11 Gallo Vineyards, Inc.
  gallo
  
  // gallup : 2015-02-19 Gallup, Inc.
  gallup
  
  // game : 2015-05-28 Uniregistry, Corp.
  game
  
  // games : 2015-05-28 Foggy Beach, LLC
  games
  
  // gap : 2015-07-31 The Gap, Inc.
  gap
  
  // garden : 2014-06-26 Top Level Domain Holdings Limited
  garden
  
  // gbiz : 2014-07-17 Charleston Road Registry Inc.
  gbiz
  
  // gdn : 2014-07-31 Joint Stock Company "Navigation-information systems"
  gdn
  
  // gea : 2014-12-04 GEA Group Aktiengesellschaft
  gea
  
  // gent : 2014-01-23 COMBELL GROUP NV/SA
  gent
  
  // genting : 2015-03-12 Resorts World Inc Pte. Ltd.
  genting
  
  // george : 2015-07-31 Wal-Mart Stores, Inc.
  george
  
  // ggee : 2014-01-09 GMO Internet, Inc.
  ggee
  
  // gift : 2013-10-17 Uniregistry, Corp.
  gift
  
  // gifts : 2014-07-03 Goose Sky, LLC
  gifts
  
  // gives : 2014-03-06 United TLD Holdco Ltd.
  gives
  
  // giving : 2014-11-13 Giving Limited
  giving
  
  // glade : 2015-07-23 Johnson Shareholdings, Inc.
  glade
  
  // glass : 2013-11-07 Black Cover, LLC
  glass
  
  // gle : 2014-07-24 Charleston Road Registry Inc.
  gle
  
  // global : 2014-04-17 Dot GLOBAL AS
  global
  
  // globo : 2013-12-19 Globo Comunicação e Participações S.A
  globo
  
  // gmail : 2014-05-01 Charleston Road Registry Inc.
  gmail
  
  // gmo : 2014-01-09 GMO Internet, Inc.
  gmo
  
  // gmx : 2014-04-24 1&1 Mail & Media GmbH
  gmx
  
  // godaddy : 2015-07-23 Go Daddy East, LLC
  godaddy
  
  // gold : 2015-01-22 June Edge, LLC
  gold
  
  // goldpoint : 2014-11-20 YODOBASHI CAMERA CO.,LTD.
  goldpoint
  
  // golf : 2014-12-18 Lone falls, LLC
  golf
  
  // goo : 2014-12-18 NTT Resonant Inc.
  goo
  
  // goodhands : 2015-07-31 Allstate Fire and Casualty Insurance Company
  goodhands
  
  // goodyear : 2015-07-02 The Goodyear Tire & Rubber Company
  goodyear
  
  // goog : 2014-11-20 Charleston Road Registry Inc.
  goog
  
  // google : 2014-07-24 Charleston Road Registry Inc.
  google
  
  // gop : 2014-01-16 Republican State Leadership Committee, Inc.
  gop
  
  // got : 2014-12-18 Amazon EU S.à r.l.
  got
  
  // gotv : 2015-03-12 MultiChoice (Proprietary) Limited
  gotv
  
  // grainger : 2015-05-07 Grainger Registry Services, LLC
  grainger
  
  // graphics : 2013-09-13 Over Madison, LLC
  graphics
  
  // gratis : 2014-03-20 Pioneer Tigers, LLC
  gratis
  
  // green : 2014-05-08 Afilias Limited
  green
  
  // gripe : 2014-03-06 Corn Sunset, LLC
  gripe
  
  // group : 2014-08-15 Romeo Town, LLC
  group
  
  // guardian : 2015-07-30 The Guardian Life Insurance Company of America
  guardian
  
  // gucci : 2014-11-13 Guccio Gucci S.p.a.
  gucci
  
  // guge : 2014-08-28 Charleston Road Registry Inc.
  guge
  
  // guide : 2013-09-13 Snow Moon, LLC
  guide
  
  // guitars : 2013-11-14 Uniregistry, Corp.
  guitars
  
  // guru : 2013-08-27 Pioneer Cypress, LLC
  guru
  
  // hamburg : 2014-02-20 Hamburg Top-Level-Domain GmbH
  hamburg
  
  // hangout : 2014-11-13 Charleston Road Registry Inc.
  hangout
  
  // haus : 2013-12-05
  haus
  
  // hbo : 2015-07-30 HBO Registry Services, Inc.
  hbo
  
  // hdfc : 2015-07-30 HOUSING DEVELOPMENT FINANCE CORPORATION LIMITED
  hdfc
  
  // hdfcbank : 2015-02-12 HDFC Bank Limited
  hdfcbank
  
  // health : 2015-02-11 DotHealth, LLC
  health
  
  // healthcare : 2014-06-12 Silver Glen, LLC
  healthcare
  
  // help : 2014-06-26 Uniregistry, Corp.
  help
  
  // helsinki : 2015-02-05 City of Helsinki
  helsinki
  
  // here : 2014-02-06 Charleston Road Registry Inc.
  here
  
  // hermes : 2014-07-10 HERMES INTERNATIONAL
  hermes
  
  // hgtv : 2015-07-02 Lifestyle Domain Holdings, Inc.
  hgtv
  
  // hiphop : 2014-03-06 Uniregistry, Corp.
  hiphop
  
  // hisamitsu : 2015-07-16 Hisamitsu Pharmaceutical Co.,Inc.
  hisamitsu
  
  // hitachi : 2014-10-31 Hitachi, Ltd.
  hitachi
  
  // hiv : 2014-03-13 dotHIV gemeinnuetziger e.V.
  hiv
  
  // hkt : 2015-05-14 PCCW-HKT DataCom Services Limited
  hkt
  
  // hockey : 2015-03-19 Half Willow, LLC
  hockey
  
  // holdings : 2013-08-27 John Madison, LLC
  holdings
  
  // holiday : 2013-11-07 Goose Woods, LLC
  holiday
  
  // homedepot : 2015-04-02 Homer TLC, Inc.
  homedepot
  
  // homegoods : 2015-07-16 The TJX Companies, Inc.
  homegoods
  
  // homes : 2014-01-09 DERHomes, LLC
  homes
  
  // homesense : 2015-07-16 The TJX Companies, Inc.
  homesense
  
  // honda : 2014-12-18 Honda Motor Co., Ltd.
  honda
  
  // honeywell : 2015-07-23 Honeywell GTLD LLC
  honeywell
  
  // horse : 2013-11-21 Top Level Domain Holdings Limited
  horse
  
  // host : 2014-04-17 DotHost Inc.
  host
  
  // hosting : 2014-05-29 Uniregistry, Corp.
  hosting
  
  // hot : 2015-08-27 Amazon EU S.à r.l.
  hot
  
  // hoteles : 2015-03-05 Travel Reservations SRL
  hoteles
  
  // hotmail : 2014-12-18 Microsoft Corporation
  hotmail
  
  // house : 2013-11-07 Sugar Park, LLC
  house
  
  // how : 2014-01-23 Charleston Road Registry Inc.
  how
  
  // hsbc : 2014-10-24 HSBC Holdings PLC
  hsbc
  
  // htc : 2015-04-02 HTC corporation
  htc
  
  // hughes : 2015-07-30 Hughes Satellite Systems Corporation
  hughes
  
  // hyatt : 2015-07-30 Hyatt GTLD, L.L.C.
  hyatt
  
  // hyundai : 2015-07-09 Hyundai Motor Company
  hyundai
  
  // ibm : 2014-07-31 International Business Machines Corporation
  ibm
  
  // icbc : 2015-02-19 Industrial and Commercial Bank of China Limited
  icbc
  
  // ice : 2014-10-30 IntercontinentalExchange, Inc.
  ice
  
  // icu : 2015-01-08 One.com A/S
  icu
  
  // ieee : 2015-07-23 IEEE Global LLC
  ieee
  
  // ifm : 2014-01-30 ifm electronic gmbh
  ifm
  
  // iinet : 2014-07-03 Connect West Pty. Ltd.
  iinet
  
  // ikano : 2015-07-09 Ikano S.A.
  ikano
  
  // imamat : 2015-08-06 Fondation Aga Khan (Aga Khan Foundation)
  imamat
  
  // imdb : 2015-06-25 Amazon EU S.à r.l.
  imdb
  
  // immo : 2014-07-10 Auburn Bloom, LLC
  immo
  
  // immobilien : 2013-11-07 United TLD Holdco Ltd.
  immobilien
  
  // industries : 2013-12-05 Outer House, LLC
  industries
  
  // infiniti : 2014-03-27 NISSAN MOTOR CO., LTD.
  infiniti
  
  // ing : 2014-01-23 Charleston Road Registry Inc.
  ing
  
  // ink : 2013-12-05 Top Level Design, LLC
  ink
  
  // institute : 2013-11-07 Outer Maple, LLC
  institute
  
  // insurance : 2015-02-19 fTLD Registry Services LLC
  insurance
  
  // insure : 2014-03-20 Pioneer Willow, LLC
  insure
  
  // intel : 2015-08-06 Intel Corporation
  intel
  
  // international : 2013-11-07 Wild Way, LLC
  international
  
  // intuit : 2015-07-30 Intuit Administrative Services, Inc.
  intuit
  
  // investments : 2014-03-20 Holly Glen, LLC
  investments
  
  // ipiranga : 2014-08-28 Ipiranga Produtos de Petroleo S.A.
  ipiranga
  
  // irish : 2014-08-07 Dot-Irish LLC
  irish
  
  // iselect : 2015-02-11 iSelect Ltd
  iselect
  
  // ismaili : 2015-08-06 Fondation Aga Khan (Aga Khan Foundation)
  ismaili
  
  // ist : 2014-08-28 Istanbul Metropolitan Municipality
  ist
  
  // istanbul : 2014-08-28 Istanbul Metropolitan Municipality
  istanbul
  
  // itau : 2014-10-02 Itau Unibanco Holding S.A.
  itau
  
  // itv : 2015-07-09 ITV Services Limited
  itv
  
  // iveco : 2015-09-03 CNH Industrial N.V.
  iveco
  
  // iwc : 2014-06-23 Richemont DNS Inc.
  iwc
  
  // jaguar : 2014-11-13 Jaguar Land Rover Ltd
  jaguar
  
  // java : 2014-06-19 Oracle Corporation
  java
  
  // jcb : 2014-11-20 JCB Co., Ltd.
  jcb
  
  // jcp : 2015-04-23 JCP Media, Inc.
  jcp
  
  // jeep : 2015-07-30 FCA US LLC.
  jeep
  
  // jetzt : 2014-01-09 New TLD Company AB
  jetzt
  
  // jewelry : 2015-03-05 Wild Bloom, LLC
  jewelry
  
  // jio : 2015-04-02 Affinity Names, Inc.
  jio
  
  // jlc : 2014-12-04 Richemont DNS Inc.
  jlc
  
  // jll : 2015-04-02 Jones Lang LaSalle Incorporated
  jll
  
  // jmp : 2015-03-26 Matrix IP LLC
  jmp
  
  // jnj : 2015-06-18 Johnson & Johnson Services, Inc.
  jnj
  
  // joburg : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  joburg
  
  // jot : 2014-12-18 Amazon EU S.à r.l.
  jot
  
  // joy : 2014-12-18 Amazon EU S.à r.l.
  joy
  
  // jpmorgan : 2015-04-30 JPMorgan Chase & Co.
  jpmorgan
  
  // jprs : 2014-09-18 Japan Registry Services Co., Ltd.
  jprs
  
  // juegos : 2014-03-20 Uniregistry, Corp.
  juegos
  
  // juniper : 2015-07-30 JUNIPER NETWORKS, INC.
  juniper
  
  // kaufen : 2013-11-07 United TLD Holdco Ltd.
  kaufen
  
  // kddi : 2014-09-12 KDDI CORPORATION
  kddi
  
  // kerryhotels : 2015-04-30 Kerry Trading Co. Limited
  kerryhotels
  
  // kerrylogistics : 2015-04-09 Kerry Trading Co. Limited
  kerrylogistics
  
  // kerryproperties : 2015-04-09 Kerry Trading Co. Limited
  kerryproperties
  
  // kfh : 2014-12-04 Kuwait Finance House
  kfh
  
  // kia : 2015-07-09 KIA MOTORS CORPORATION
  kia
  
  // kim : 2013-09-23 Afilias Limited
  kim
  
  // kinder : 2014-11-07 Ferrero Trading Lux S.A.
  kinder
  
  // kindle : 2015-06-25 Amazon EU S.à r.l.
  kindle
  
  // kitchen : 2013-09-20 Just Goodbye, LLC
  kitchen
  
  // kiwi : 2013-09-20 DOT KIWI LIMITED
  kiwi
  
  // koeln : 2014-01-09 NetCologne Gesellschaft für Telekommunikation mbH
  koeln
  
  // komatsu : 2015-01-08 Komatsu Ltd.
  komatsu
  
  // kosher : 2015-08-20 Kosher Marketing Assets LLC
  kosher
  
  // kpmg : 2015-04-23 KPMG International Cooperative (KPMG International Genossenschaft)
  kpmg
  
  // kpn : 2015-01-08 Koninklijke KPN N.V.
  kpn
  
  // krd : 2013-12-05 KRG Department of Information Technology
  krd
  
  // kred : 2013-12-19 KredTLD Pty Ltd
  kred
  
  // kuokgroup : 2015-04-09 Kerry Trading Co. Limited
  kuokgroup
  
  // kyknet : 2015-03-05 Electronic Media Network (Pty) Ltd
  kyknet
  
  // kyoto : 2014-11-07 Academic Institution: Kyoto Jyoho Gakuen
  kyoto
  
  // lacaixa : 2014-01-09 CAIXA D'ESTALVIS I PENSIONS DE BARCELONA
  lacaixa
  
  // ladbrokes : 2015-08-06 LADBROKES INTERNATIONAL PLC
  ladbrokes
  
  // lamborghini : 2015-06-04 Automobili Lamborghini S.p.A.
  lamborghini
  
  // lamer : 2015-10-01 The Estée Lauder Companies Inc.
  lamer
  
  // lancaster : 2015-02-12 LANCASTER
  lancaster
  
  // lancia : 2015-07-31 Fiat Chrysler Automobiles N.V.
  lancia
  
  // lancome : 2015-07-23 L'Oréal
  lancome
  
  // land : 2013-09-10 Pine Moon, LLC
  land
  
  // landrover : 2014-11-13 Jaguar Land Rover Ltd
  landrover
  
  // lanxess : 2015-07-30 LANXESS Corporation
  lanxess
  
  // lasalle : 2015-04-02 Jones Lang LaSalle Incorporated
  lasalle
  
  // lat : 2014-10-16 ECOM-LAC Federaciòn de Latinoamèrica y el Caribe para Internet y el Comercio Electrònico
  lat
  
  // latino : 2015-07-30 Dish DBS Corporation
  latino
  
  // latrobe : 2014-06-16 La Trobe University
  latrobe
  
  // law : 2015-01-22 Minds + Machines Group Limited
  law
  
  // lawyer : 2014-03-20
  lawyer
  
  // lds : 2014-03-20 IRI Domain Management, LLC ("Applicant")
  lds
  
  // lease : 2014-03-06 Victor Trail, LLC
  lease
  
  // leclerc : 2014-08-07 A.C.D. LEC Association des Centres Distributeurs Edouard Leclerc
  leclerc
  
  // lefrak : 2015-07-16 LeFrak Organization, Inc.
  lefrak
  
  // legal : 2014-10-16 Blue Falls, LLC
  legal
  
  // lego : 2015-07-16 LEGO Juris A/S
  lego
  
  // lexus : 2015-04-23 TOYOTA MOTOR CORPORATION
  lexus
  
  // lgbt : 2014-05-08 Afilias Limited
  lgbt
  
  // liaison : 2014-10-02 Liaison Technologies, Incorporated
  liaison
  
  // lidl : 2014-09-18 Schwarz Domains und Services GmbH & Co. KG
  lidl
  
  // life : 2014-02-06 Trixy Oaks, LLC
  life
  
  // lifeinsurance : 2015-01-15 American Council of Life Insurers
  lifeinsurance
  
  // lifestyle : 2014-12-11 Lifestyle Domain Holdings, Inc.
  lifestyle
  
  // lighting : 2013-08-27 John McCook, LLC
  lighting
  
  // like : 2014-12-18 Amazon EU S.à r.l.
  like
  
  // lilly : 2015-07-31 Eli Lilly and Company
  lilly
  
  // limited : 2014-03-06 Big Fest, LLC
  limited
  
  // limo : 2013-10-17 Hidden Frostbite, LLC
  limo
  
  // lincoln : 2014-11-13 Ford Motor Company
  lincoln
  
  // linde : 2014-12-04 Linde Aktiengesellschaft
  linde
  
  // link : 2013-11-14 Uniregistry, Corp.
  link
  
  // lipsy : 2015-06-25 Lipsy Ltd
  lipsy
  
  // live : 2014-12-04
  live
  
  // living : 2015-07-30 Lifestyle Domain Holdings, Inc.
  living
  
  // lixil : 2015-03-19 LIXIL Group Corporation
  lixil
  
  // loan : 2014-11-20 dot Loan Limited
  loan
  
  // loans : 2014-03-20 June Woods, LLC
  loans
  
  // locker : 2015-06-04 Dish DBS Corporation
  locker
  
  // locus : 2015-06-25 Locus Analytics LLC
  locus
  
  // loft : 2015-07-30 Annco, Inc.
  loft
  
  // lol : 2015-01-30 Uniregistry, Corp.
  lol
  
  // london : 2013-11-14 Dot London Domains Limited
  london
  
  // lotte : 2014-11-07 Lotte Holdings Co., Ltd.
  lotte
  
  // lotto : 2014-04-10 Afilias Limited
  lotto
  
  // love : 2014-12-22 Merchant Law Group LLP
  love
  
  // lpl : 2015-07-30 LPL Holdings, Inc.
  lpl
  
  // lplfinancial : 2015-07-30 LPL Holdings, Inc.
  lplfinancial
  
  // ltd : 2014-09-25 Over Corner, LLC
  ltd
  
  // ltda : 2014-04-17 DOMAIN ROBOT SERVICOS DE HOSPEDAGEM NA INTERNET LTDA
  ltda
  
  // lundbeck : 2015-08-06 H. Lundbeck A/S
  lundbeck
  
  // lupin : 2014-11-07 LUPIN LIMITED
  lupin
  
  // luxe : 2014-01-09 Top Level Domain Holdings Limited
  luxe
  
  // luxury : 2013-10-17 Luxury Partners, LLC
  luxury
  
  // macys : 2015-07-31 Macys, Inc.
  macys
  
  // madrid : 2014-05-01 Comunidad de Madrid
  madrid
  
  // maif : 2014-10-02 Mutuelle Assurance Instituteur France (MAIF)
  maif
  
  // maison : 2013-12-05 Victor Frostbite, LLC
  maison
  
  // makeup : 2015-01-15 L'Oréal
  makeup
  
  // man : 2014-12-04 MAN SE
  man
  
  // management : 2013-11-07 John Goodbye, LLC
  management
  
  // mango : 2013-10-24 PUNTO FA S.L.
  mango
  
  // market : 2014-03-06
  market
  
  // marketing : 2013-11-07 Fern Pass, LLC
  marketing
  
  // markets : 2014-12-11 IG Group Holdings PLC
  markets
  
  // marriott : 2014-10-09 Marriott Worldwide Corporation
  marriott
  
  // marshalls : 2015-07-16 The TJX Companies, Inc.
  marshalls
  
  // maserati : 2015-07-31 Fiat Chrysler Automobiles N.V.
  maserati
  
  // mattel : 2015-08-06 Mattel Sites, Inc.
  mattel
  
  // mba : 2015-04-02 Lone Hollow, LLC
  mba
  
  // mcd : 2015-07-30 McDonald’s Corporation
  mcd
  
  // mcdonalds : 2015-07-30 McDonald’s Corporation
  mcdonalds
  
  // mckinsey : 2015-07-31 McKinsey Holdings, Inc.
  mckinsey
  
  // med : 2015-08-06 Medistry LLC
  med
  
  // media : 2014-03-06 Grand Glen, LLC
  media
  
  // meet : 2014-01-16
  meet
  
  // melbourne : 2014-05-29 The Crown in right of the State of Victoria, represented by its Department of State Development, Business and Innovation
  melbourne
  
  // meme : 2014-01-30 Charleston Road Registry Inc.
  meme
  
  // memorial : 2014-10-16 Dog Beach, LLC
  memorial
  
  // men : 2015-02-26 Exclusive Registry Limited
  men
  
  // menu : 2013-09-11 Wedding TLD2, LLC
  menu
  
  // meo : 2014-11-07 PT Comunicacoes S.A.
  meo
  
  // metlife : 2015-05-07 MetLife Services and Solutions, LLC
  metlife
  
  // miami : 2013-12-19 Top Level Domain Holdings Limited
  miami
  
  // microsoft : 2014-12-18 Microsoft Corporation
  microsoft
  
  // mini : 2014-01-09 Bayerische Motoren Werke Aktiengesellschaft
  mini
  
  // mint : 2015-07-30 Intuit Administrative Services, Inc.
  mint
  
  // mit : 2015-07-02 Massachusetts Institute of Technology
  mit
  
  // mitsubishi : 2015-07-23 Mitsubishi Corporation
  mitsubishi
  
  // mlb : 2015-05-21 MLB Advanced Media DH, LLC
  mlb
  
  // mls : 2015-04-23 The Canadian Real Estate Association
  mls
  
  // mma : 2014-11-07 MMA IARD
  mma
  
  // mnet : 2015-03-05 Electronic Media Network (Pty) Ltd
  mnet
  
  // mobily : 2014-12-18 GreenTech Consultancy Company W.L.L.
  mobily
  
  // moda : 2013-11-07 United TLD Holdco Ltd.
  moda
  
  // moe : 2013-11-13 Interlink Co., Ltd.
  moe
  
  // moi : 2014-12-18 Amazon EU S.à r.l.
  moi
  
  // mom : 2015-04-16 Uniregistry, Corp.
  mom
  
  // monash : 2013-09-30 Monash University
  monash
  
  // money : 2014-10-16 Outer McCook, LLC
  money
  
  // monster : 2015-09-11 Monster Worldwide, Inc.
  monster
  
  // montblanc : 2014-06-23 Richemont DNS Inc.
  montblanc
  
  // mopar : 2015-07-30 FCA US LLC.
  mopar
  
  // mormon : 2013-12-05 IRI Domain Management, LLC ("Applicant")
  mormon
  
  // mortgage : 2014-03-20
  mortgage
  
  // moscow : 2013-12-19 Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)
  moscow
  
  // moto : 2015-06-04 Charleston Road Registry Inc.
  moto
  
  // motorcycles : 2014-01-09 DERMotorcycles, LLC
  motorcycles
  
  // mov : 2014-01-30 Charleston Road Registry Inc.
  mov
  
  // movie : 2015-02-05 New Frostbite, LLC
  movie
  
  // movistar : 2014-10-16 Telefónica S.A.
  movistar
  
  // msd : 2015-07-23 MSD Registry Holdings, Inc.
  msd
  
  // mtn : 2014-12-04 MTN Dubai Limited
  mtn
  
  // mtpc : 2014-11-20 Mitsubishi Tanabe Pharma Corporation
  mtpc
  
  // mtr : 2015-03-12 MTR Corporation Limited
  mtr
  
  // multichoice : 2015-03-12 MultiChoice (Proprietary) Limited
  multichoice
  
  // mutual : 2015-04-02 Northwestern Mutual MU TLD Registry, LLC
  mutual
  
  // mutuelle : 2015-06-18 Fédération Nationale de la Mutualité Française
  mutuelle
  
  // mzansimagic : 2015-03-05 Electronic Media Network (Pty) Ltd
  mzansimagic
  
  // nab : 2015-08-20 National Australia Bank Limited
  nab
  
  // nadex : 2014-12-11 IG Group Holdings PLC
  nadex
  
  // nagoya : 2013-10-24 GMO Registry, Inc.
  nagoya
  
  // naspers : 2015-02-12 Intelprop (Proprietary) Limited
  naspers
  
  // nationwide : 2015-07-23 Nationwide Mutual Insurance Company
  nationwide
  
  // natura : 2015-03-12 NATURA COSMÉTICOS S.A.
  natura
  
  // navy : 2014-03-06 United TLD Holdco Ltd.
  navy
  
  // nba : 2015-07-31 NBA REGISTRY, LLC
  nba
  
  // nec : 2015-01-08 NEC Corporation
  nec
  
  // netbank : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  netbank
  
  // netflix : 2015-06-18 Netflix, Inc.
  netflix
  
  // network : 2013-11-14 Trixy Manor, LLC
  network
  
  // neustar : 2013-12-05 NeuStar, Inc.
  neustar
  
  // new : 2014-01-30 Charleston Road Registry Inc.
  new
  
  // newholland : 2015-09-03 CNH Industrial N.V.
  newholland
  
  // news : 2014-12-18
  news
  
  // next : 2015-06-18 Next plc
  next
  
  // nextdirect : 2015-06-18 Next plc
  nextdirect
  
  // nexus : 2014-07-24 Charleston Road Registry Inc.
  nexus
  
  // nfl : 2015-07-23 NFL Reg Ops LLC
  nfl
  
  // ngo : 2014-03-06 Public Interest Registry
  ngo
  
  // nhk : 2014-02-13 Japan Broadcasting Corporation (NHK)
  nhk
  
  // nico : 2014-12-04 DWANGO Co., Ltd.
  nico
  
  // nike : 2015-07-23 NIKE, Inc.
  nike
  
  // nikon : 2015-05-21 NIKON CORPORATION
  nikon
  
  // ninja : 2013-11-07 United TLD Holdco Ltd.
  ninja
  
  // nissan : 2014-03-27 NISSAN MOTOR CO., LTD.
  nissan
  
  // nissay : 2015-10-29 Nippon Life Insurance Company
  nissay
  
  // nokia : 2015-01-08 Nokia Corporation
  nokia
  
  // northwesternmutual : 2015-06-18 Northwestern Mutual Registry, LLC
  northwesternmutual
  
  // norton : 2014-12-04 Symantec Corporation
  norton
  
  // now : 2015-06-25 Amazon EU S.à r.l.
  now
  
  // nowruz : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  nowruz
  
  // nowtv : 2015-05-14 Starbucks (HK) Limited
  nowtv
  
  // nra : 2014-05-22 NRA Holdings Company, INC.
  nra
  
  // nrw : 2013-11-21 Minds + Machines GmbH
  nrw
  
  // ntt : 2014-10-31 NIPPON TELEGRAPH AND TELEPHONE CORPORATION
  ntt
  
  // nyc : 2014-01-23 The City of New York by and through the New York City Department of Information Technology & Telecommunications
  nyc
  
  // obi : 2014-09-25 OBI Group Holding SE & Co. KGaA
  obi
  
  // observer : 2015-04-30 Guardian News and Media Limited
  observer
  
  // off : 2015-07-23 Johnson Shareholdings, Inc.
  off
  
  // office : 2015-03-12 Microsoft Corporation
  office
  
  // okinawa : 2013-12-05 BusinessRalliart Inc.
  okinawa
  
  // olayan : 2015-05-14 Crescent Holding GmbH
  olayan
  
  // olayangroup : 2015-05-14 Crescent Holding GmbH
  olayangroup
  
  // oldnavy : 2015-07-31 The Gap, Inc.
  oldnavy
  
  // ollo : 2015-06-04 Dish DBS Corporation
  ollo
  
  // omega : 2015-01-08 The Swatch Group Ltd
  omega
  
  // one : 2014-11-07 One.com A/S
  one
  
  // ong : 2014-03-06 Public Interest Registry
  ong
  
  // onl : 2013-09-16 I-Registry Ltd.
  onl
  
  // online : 2015-01-15 DotOnline Inc.
  online
  
  // onyourside : 2015-07-23 Nationwide Mutual Insurance Company
  onyourside
  
  // ooo : 2014-01-09 INFIBEAM INCORPORATION LIMITED
  ooo
  
  // open : 2015-07-31 American Express Travel Related Services Company, Inc.
  open
  
  // oracle : 2014-06-19 Oracle Corporation
  oracle
  
  // orange : 2015-03-12 Orange Brand Services Limited
  orange
  
  // organic : 2014-03-27 Afilias Limited
  organic
  
  // orientexpress : 2015-02-05 Belmond Ltd.
  orientexpress
  
  // origins : 2015-10-01 The Estée Lauder Companies Inc.
  origins
  
  // osaka : 2014-09-04 Interlink Co., Ltd.
  osaka
  
  // otsuka : 2013-10-11 Otsuka Holdings Co., Ltd.
  otsuka
  
  // ott : 2015-06-04 Dish DBS Corporation
  ott
  
  // ovh : 2014-01-16 OVH SAS
  ovh
  
  // page : 2014-12-04 Charleston Road Registry Inc.
  page
  
  // pamperedchef : 2015-02-05 The Pampered Chef, Ltd.
  pamperedchef
  
  // panasonic : 2015-07-30 Panasonic Corporation
  panasonic
  
  // panerai : 2014-11-07 Richemont DNS Inc.
  panerai
  
  // paris : 2014-01-30 City of Paris
  paris
  
  // pars : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  pars
  
  // partners : 2013-12-05 Magic Glen, LLC
  partners
  
  // parts : 2013-12-05 Sea Goodbye, LLC
  parts
  
  // party : 2014-09-11 Blue Sky Registry Limited
  party
  
  // passagens : 2015-03-05 Travel Reservations SRL
  passagens
  
  // pay : 2015-08-27 Amazon EU S.à r.l.
  pay
  
  // payu : 2015-02-12 MIH PayU B.V.
  payu
  
  // pccw : 2015-05-14 PCCW Enterprises Limited
  pccw
  
  // pet : 2015-05-07 Afilias plc
  pet
  
  // pfizer : 2015-09-11 Pfizer Inc.
  pfizer
  
  // pharmacy : 2014-06-19 National Association of Boards of Pharmacy
  pharmacy
  
  // philips : 2014-11-07 Koninklijke Philips N.V.
  philips
  
  // photo : 2013-11-14 Uniregistry, Corp.
  photo
  
  // photography : 2013-09-20 Sugar Glen, LLC
  photography
  
  // photos : 2013-10-17 Sea Corner, LLC
  photos
  
  // physio : 2014-05-01 PhysBiz Pty Ltd
  physio
  
  // piaget : 2014-10-16 Richemont DNS Inc.
  piaget
  
  // pics : 2013-11-14 Uniregistry, Corp.
  pics
  
  // pictet : 2014-06-26 Pictet Europe S.A.
  pictet
  
  // pictures : 2014-03-06 Foggy Sky, LLC
  pictures
  
  // pid : 2015-01-08 Top Level Spectrum, Inc.
  pid
  
  // pin : 2014-12-18 Amazon EU S.à r.l.
  pin
  
  // ping : 2015-06-11 Ping Registry Provider, Inc.
  ping
  
  // pink : 2013-10-01 Afilias Limited
  pink
  
  // pioneer : 2015-07-16 Pioneer Corporation
  pioneer
  
  // pizza : 2014-06-26 Foggy Moon, LLC
  pizza
  
  // place : 2014-04-24 Snow Galley, LLC
  place
  
  // play : 2015-03-05 Charleston Road Registry Inc.
  play
  
  // playstation : 2015-07-02 Sony Computer Entertainment Inc.
  playstation
  
  // plumbing : 2013-09-10 Spring Tigers, LLC
  plumbing
  
  // plus : 2015-02-05 Sugar Mill, LLC
  plus
  
  // pnc : 2015-07-02 PNC Domain Co., LLC
  pnc
  
  // pohl : 2014-06-23 Deutsche Vermögensberatung Aktiengesellschaft DVAG
  pohl
  
  // poker : 2014-07-03 Afilias Domains No. 5 Limited
  poker
  
  // politie : 2015-08-20 Politie Nederland
  politie
  
  // porn : 2014-10-16 ICM Registry PN LLC
  porn
  
  // pramerica : 2015-07-30 Prudential Financial, Inc.
  pramerica
  
  // praxi : 2013-12-05 Praxi S.p.A.
  praxi
  
  // press : 2014-04-03 DotPress Inc.
  press
  
  // prime : 2015-06-25 Amazon EU S.à r.l.
  prime
  
  // prod : 2014-01-23 Charleston Road Registry Inc.
  prod
  
  // productions : 2013-12-05 Magic Birch, LLC
  productions
  
  // prof : 2014-07-24 Charleston Road Registry Inc.
  prof
  
  // progressive : 2015-07-23 Progressive Casualty Insurance Company
  progressive
  
  // promo : 2014-12-18 Play.PROMO Oy
  promo
  
  // properties : 2013-12-05 Big Pass, LLC
  properties
  
  // property : 2014-05-22 Uniregistry, Corp.
  property
  
  // protection : 2015-04-23
  protection
  
  // pru : 2015-07-30 Prudential Financial, Inc.
  pru
  
  // prudential : 2015-07-30 Prudential Financial, Inc.
  prudential
  
  // pub : 2013-12-12 United TLD Holdco Ltd.
  pub
  
  // pwc : 2015-10-29 PricewaterhouseCoopers LLP
  pwc
  
  // qpon : 2013-11-14 dotCOOL, Inc.
  qpon
  
  // quebec : 2013-12-19 PointQuébec Inc
  quebec
  
  // quest : 2015-03-26 Quest ION Limited
  quest
  
  // qvc : 2015-07-30 QVC, Inc.
  qvc
  
  // racing : 2014-12-04 Premier Registry Limited
  racing
  
  // raid : 2015-07-23 Johnson Shareholdings, Inc.
  raid
  
  // read : 2014-12-18 Amazon EU S.à r.l.
  read
  
  // realestate : 2015-09-11 dotRealEstate LLC
  realestate
  
  // realtor : 2014-05-29 Real Estate Domains LLC
  realtor
  
  // realty : 2015-03-19 Fegistry, LLC
  realty
  
  // recipes : 2013-10-17 Grand Island, LLC
  recipes
  
  // red : 2013-11-07 Afilias Limited
  red
  
  // redstone : 2014-10-31 Redstone Haute Couture Co., Ltd.
  redstone
  
  // redumbrella : 2015-03-26 Travelers TLD, LLC
  redumbrella
  
  // rehab : 2014-03-06 United TLD Holdco Ltd.
  rehab
  
  // reise : 2014-03-13
  reise
  
  // reisen : 2014-03-06 New Cypress, LLC
  reisen
  
  // reit : 2014-09-04 National Association of Real Estate Investment Trusts, Inc.
  reit
  
  // reliance : 2015-04-02 Reliance Industries Limited
  reliance
  
  // ren : 2013-12-12 Beijing Qianxiang Wangjing Technology Development Co., Ltd.
  ren
  
  // rent : 2014-12-04 DERRent, LLC
  rent
  
  // rentals : 2013-12-05 Big Hollow,LLC
  rentals
  
  // repair : 2013-11-07 Lone Sunset, LLC
  repair
  
  // report : 2013-12-05 Binky Glen, LLC
  report
  
  // republican : 2014-03-20 United TLD Holdco Ltd.
  republican
  
  // rest : 2013-12-19 Punto 2012 Sociedad Anonima Promotora de Inversion de Capital Variable
  rest
  
  // restaurant : 2014-07-03 Snow Avenue, LLC
  restaurant
  
  // review : 2014-11-20 dot Review Limited
  review
  
  // reviews : 2013-09-13
  reviews
  
  // rexroth : 2015-06-18 Robert Bosch GMBH
  rexroth
  
  // rich : 2013-11-21 I-Registry Ltd.
  rich
  
  // richardli : 2015-05-14 Pacific Century Asset Management (HK) Limited
  richardli
  
  // ricoh : 2014-11-20 Ricoh Company, Ltd.
  ricoh
  
  // rightathome : 2015-07-23 Johnson Shareholdings, Inc.
  rightathome
  
  // ril : 2015-04-02 Reliance Industries Limited
  ril
  
  // rio : 2014-02-27 Empresa Municipal de Informática SA - IPLANRIO
  rio
  
  // rip : 2014-07-10 United TLD Holdco Ltd.
  rip
  
  // rocher : 2014-12-18 Ferrero Trading Lux S.A.
  rocher
  
  // rocks : 2013-11-14
  rocks
  
  // rodeo : 2013-12-19 Top Level Domain Holdings Limited
  rodeo
  
  // rogers : 2015-08-06 Rogers Communications Partnership
  rogers
  
  // room : 2014-12-18 Amazon EU S.à r.l.
  room
  
  // rsvp : 2014-05-08 Charleston Road Registry Inc.
  rsvp
  
  // ruhr : 2013-10-02 regiodot GmbH & Co. KG
  ruhr
  
  // run : 2015-03-19 Snow Park, LLC
  run
  
  // rwe : 2015-04-02 RWE AG
  rwe
  
  // ryukyu : 2014-01-09 BusinessRalliart Inc.
  ryukyu
  
  // saarland : 2013-12-12 dotSaarland GmbH
  saarland
  
  // safe : 2014-12-18 Amazon EU S.à r.l.
  safe
  
  // safety : 2015-01-08 Safety Registry Services, LLC.
  safety
  
  // sakura : 2014-12-18 SAKURA Internet Inc.
  sakura
  
  // sale : 2014-10-16
  sale
  
  // salon : 2014-12-11 Outer Orchard, LLC
  salon
  
  // samsclub : 2015-07-31 Wal-Mart Stores, Inc.
  samsclub
  
  // samsung : 2014-04-03 SAMSUNG SDS CO., LTD
  samsung
  
  // sandvik : 2014-11-13 Sandvik AB
  sandvik
  
  // sandvikcoromant : 2014-11-07 Sandvik AB
  sandvikcoromant
  
  // sanofi : 2014-10-09 Sanofi
  sanofi
  
  // sap : 2014-03-27 SAP AG
  sap
  
  // sapo : 2014-11-07 PT Comunicacoes S.A.
  sapo
  
  // sarl : 2014-07-03 Delta Orchard, LLC
  sarl
  
  // sas : 2015-04-02 Research IP LLC
  sas
  
  // save : 2015-06-25 Amazon EU S.à r.l.
  save
  
  // saxo : 2014-10-31 Saxo Bank A/S
  saxo
  
  // sbi : 2015-03-12 STATE BANK OF INDIA
  sbi
  
  // sbs : 2014-11-07 SPECIAL BROADCASTING SERVICE CORPORATION
  sbs
  
  // sca : 2014-03-13 SVENSKA CELLULOSA AKTIEBOLAGET SCA (publ)
  sca
  
  // scb : 2014-02-20 The Siam Commercial Bank Public Company Limited ("SCB")
  scb
  
  // schaeffler : 2015-08-06 Schaeffler Technologies AG & Co. KG
  schaeffler
  
  // schmidt : 2014-04-03 SALM S.A.S.
  schmidt
  
  // scholarships : 2014-04-24 Scholarships.com, LLC
  scholarships
  
  // school : 2014-12-18 Little Galley, LLC
  school
  
  // schule : 2014-03-06 Outer Moon, LLC
  schule
  
  // schwarz : 2014-09-18 Schwarz Domains und Services GmbH & Co. KG
  schwarz
  
  // science : 2014-09-11 dot Science Limited
  science
  
  // scjohnson : 2015-07-23 Johnson Shareholdings, Inc.
  scjohnson
  
  // scor : 2014-10-31 SCOR SE
  scor
  
  // scot : 2014-01-23 Dot Scot Registry Limited
  scot
  
  // seat : 2014-05-22 SEAT, S.A. (Sociedad Unipersonal)
  seat
  
  // secure : 2015-08-27 Amazon EU S.à r.l.
  secure
  
  // security : 2015-05-14
  security
  
  // seek : 2014-12-04 Seek Limited
  seek
  
  // select : 2015-10-08 iSelect Ltd
  select
  
  // sener : 2014-10-24 Sener Ingeniería y Sistemas, S.A.
  sener
  
  // services : 2014-02-27 Fox Castle, LLC
  services
  
  // ses : 2015-07-23 SES
  ses
  
  // seven : 2015-08-06 Seven West Media Ltd
  seven
  
  // sew : 2014-07-17 SEW-EURODRIVE GmbH & Co KG
  sew
  
  // sex : 2014-11-13 ICM Registry SX LLC
  sex
  
  // sexy : 2013-09-11 Uniregistry, Corp.
  sexy
  
  // sfr : 2015-08-13 Societe Francaise du Radiotelephone - SFR
  sfr
  
  // shangrila : 2015-09-03 Shangri‐La International Hotel Management Limited
  shangrila
  
  // sharp : 2014-05-01 Sharp Corporation
  sharp
  
  // shaw : 2015-04-23 Shaw Cablesystems G.P.
  shaw
  
  // shell : 2015-07-30 Shell Information Technology International Inc
  shell
  
  // shia : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  shia
  
  // shiksha : 2013-11-14 Afilias Limited
  shiksha
  
  // shoes : 2013-10-02 Binky Galley, LLC
  shoes
  
  // shouji : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  shouji
  
  // show : 2015-03-05 Snow Beach, LLC
  show
  
  // showtime : 2015-08-06 CBS Domains Inc.
  showtime
  
  // shriram : 2014-01-23 Shriram Capital Ltd.
  shriram
  
  // silk : 2015-06-25 Amazon EU S.à r.l.
  silk
  
  // sina : 2015-03-12 Sina Corporation
  sina
  
  // singles : 2013-08-27 Fern Madison, LLC
  singles
  
  // site : 2015-01-15 DotSite Inc.
  site
  
  // ski : 2015-04-09 STARTING DOT LIMITED
  ski
  
  // skin : 2015-01-15 L'Oréal
  skin
  
  // sky : 2014-06-19 Sky IP International Ltd, a company incorporated in England and Wales, operating via its registered Swiss branch
  sky
  
  // skype : 2014-12-18 Microsoft Corporation
  skype
  
  // sling : 2015-07-30 Hughes Satellite Systems Corporation
  sling
  
  // smart : 2015-07-09 Smart Communications, Inc. (SMART)
  smart
  
  // smile : 2014-12-18 Amazon EU S.à r.l.
  smile
  
  // sncf : 2015-02-19 Société Nationale des Chemins de fer Francais S N C F
  sncf
  
  // soccer : 2015-03-26 Foggy Shadow, LLC
  soccer
  
  // social : 2013-11-07 United TLD Holdco Ltd.
  social
  
  // softbank : 2015-07-02 SoftBank Corp.
  softbank
  
  // software : 2014-03-20
  software
  
  // sohu : 2013-12-19 Sohu.com Limited
  sohu
  
  // solar : 2013-11-07 Ruby Town, LLC
  solar
  
  // solutions : 2013-11-07 Silver Cover, LLC
  solutions
  
  // song : 2015-02-26 Amazon EU S.à r.l.
  song
  
  // sony : 2015-01-08 Sony Corporation
  sony
  
  // soy : 2014-01-23 Charleston Road Registry Inc.
  soy
  
  // space : 2014-04-03 DotSpace Inc.
  space
  
  // spiegel : 2014-02-05 SPIEGEL-Verlag Rudolf Augstein GmbH & Co. KG
  spiegel
  
  // spot : 2015-02-26 Amazon EU S.à r.l.
  spot
  
  // spreadbetting : 2014-12-11 IG Group Holdings PLC
  spreadbetting
  
  // srl : 2015-05-07 mySRL GmbH
  srl
  
  // srt : 2015-07-30 FCA US LLC.
  srt
  
  // stada : 2014-11-13 STADA Arzneimittel AG
  stada
  
  // staples : 2015-07-30 Staples, Inc.
  staples
  
  // star : 2015-01-08 Star India Private Limited
  star
  
  // starhub : 2015-02-05 StarHub Ltd
  starhub
  
  // statebank : 2015-03-12 STATE BANK OF INDIA
  statebank
  
  // statefarm : 2015-07-30 State Farm Mutual Automobile Insurance Company
  statefarm
  
  // statoil : 2014-12-04 Statoil ASA
  statoil
  
  // stc : 2014-10-09 Saudi Telecom Company
  stc
  
  // stcgroup : 2014-10-09 Saudi Telecom Company
  stcgroup
  
  // stockholm : 2014-12-18 Stockholms kommun
  stockholm
  
  // storage : 2014-12-22 Self Storage Company LLC
  storage
  
  // store : 2015-04-09 DotStore Inc.
  store
  
  // studio : 2015-02-11
  studio
  
  // study : 2014-12-11 OPEN UNIVERSITIES AUSTRALIA PTY LTD
  study
  
  // style : 2014-12-04 Binky Moon, LLC
  style
  
  // sucks : 2014-12-22 Vox Populi Registry Inc.
  sucks
  
  // supersport : 2015-03-05 SuperSport International Holdings Proprietary Limited
  supersport
  
  // supplies : 2013-12-19 Atomic Fields, LLC
  supplies
  
  // supply : 2013-12-19 Half Falls, LLC
  supply
  
  // support : 2013-10-24 Grand Orchard, LLC
  support
  
  // surf : 2014-01-09 Top Level Domain Holdings Limited
  surf
  
  // surgery : 2014-03-20 Tin Avenue, LLC
  surgery
  
  // suzuki : 2014-02-20 SUZUKI MOTOR CORPORATION
  suzuki
  
  // swatch : 2015-01-08 The Swatch Group Ltd
  swatch
  
  // swiftcover : 2015-07-23 Swiftcover Insurance Services Limited
  swiftcover
  
  // swiss : 2014-10-16 Swiss Confederation
  swiss
  
  // sydney : 2014-09-18 State of New South Wales, Department of Premier and Cabinet
  sydney
  
  // symantec : 2014-12-04 Symantec Corporation
  symantec
  
  // systems : 2013-11-07 Dash Cypress, LLC
  systems
  
  // tab : 2014-12-04 Tabcorp Holdings Limited
  tab
  
  // taipei : 2014-07-10 Taipei City Government
  taipei
  
  // talk : 2015-04-09 Amazon EU S.à r.l.
  talk
  
  // taobao : 2015-01-15 Alibaba Group Holding Limited
  taobao
  
  // target : 2015-07-31 Target Domain Holdings, LLC
  target
  
  // tatamotors : 2015-03-12 Tata Motors Ltd
  tatamotors
  
  // tatar : 2014-04-24 Limited Liability Company "Coordination Center of Regional Domain of Tatarstan Republic"
  tatar
  
  // tattoo : 2013-08-30 Uniregistry, Corp.
  tattoo
  
  // tax : 2014-03-20 Storm Orchard, LLC
  tax
  
  // taxi : 2015-03-19 Pine Falls, LLC
  taxi
  
  // tci : 2014-09-12 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  tci
  
  // tdk : 2015-06-11 TDK Corporation
  tdk
  
  // team : 2015-03-05 Atomic Lake, LLC
  team
  
  // tech : 2015-01-30 Dot Tech LLC
  tech
  
  // technology : 2013-09-13 Auburn Falls
  technology
  
  // telecity : 2015-02-19 TelecityGroup International Limited
  telecity
  
  // telefonica : 2014-10-16 Telefónica S.A.
  telefonica
  
  // temasek : 2014-08-07 Temasek Holdings (Private) Limited
  temasek
  
  // tennis : 2014-12-04 Cotton Bloom, LLC
  tennis
  
  // teva : 2015-07-02 Teva Pharmaceutical Industries Limited
  teva
  
  // thd : 2015-04-02 Homer TLC, Inc.
  thd
  
  // theater : 2015-03-19 Blue Tigers, LLC
  theater
  
  // theatre : 2015-05-07
  theatre
  
  // theguardian : 2015-04-30 Guardian News and Media Limited
  theguardian
  
  // tiaa : 2015-07-23 Teachers Insurance and Annuity Association of America
  tiaa
  
  // tickets : 2015-02-05 Accent Media Limited
  tickets
  
  // tienda : 2013-11-14 Victor Manor, LLC
  tienda
  
  // tiffany : 2015-01-30 Tiffany and Company
  tiffany
  
  // tips : 2013-09-20 Corn Willow, LLC
  tips
  
  // tires : 2014-11-07 Dog Edge, LLC
  tires
  
  // tirol : 2014-04-24 punkt Tirol GmbH
  tirol
  
  // tjmaxx : 2015-07-16 The TJX Companies, Inc.
  tjmaxx
  
  // tjx : 2015-07-16 The TJX Companies, Inc.
  tjx
  
  // tkmaxx : 2015-07-16 The TJX Companies, Inc.
  tkmaxx
  
  // tmall : 2015-01-15 Alibaba Group Holding Limited
  tmall
  
  // today : 2013-09-20 Pearl Woods, LLC
  today
  
  // tokyo : 2013-11-13 GMO Registry, Inc.
  tokyo
  
  // tools : 2013-11-21 Pioneer North, LLC
  tools
  
  // top : 2014-03-20 Jiangsu Bangning Science & Technology Co.,Ltd.
  top
  
  // toray : 2014-12-18 Toray Industries, Inc.
  toray
  
  // toshiba : 2014-04-10 TOSHIBA Corporation
  toshiba
  
  // total : 2015-08-06 Total SA
  total
  
  // tours : 2015-01-22 Sugar Station, LLC
  tours
  
  // town : 2014-03-06 Koko Moon, LLC
  town
  
  // toyota : 2015-04-23 TOYOTA MOTOR CORPORATION
  toyota
  
  // toys : 2014-03-06 Pioneer Orchard, LLC
  toys
  
  // trade : 2014-01-23 Elite Registry Limited
  trade
  
  // trading : 2014-12-11 IG Group Holdings PLC
  trading
  
  // training : 2013-11-07 Wild Willow, LLC
  training
  
  // travelchannel : 2015-07-02 Lifestyle Domain Holdings, Inc.
  travelchannel
  
  // travelers : 2015-03-26 Travelers TLD, LLC
  travelers
  
  // travelersinsurance : 2015-03-26 Travelers TLD, LLC
  travelersinsurance
  
  // trust : 2014-10-16
  trust
  
  // trv : 2015-03-26 Travelers TLD, LLC
  trv
  
  // tube : 2015-06-11 Latin American Telecom LLC
  tube
  
  // tui : 2014-07-03 TUI AG
  tui
  
  // tunes : 2015-02-26 Amazon EU S.à r.l.
  tunes
  
  // tushu : 2014-12-18 Amazon EU S.à r.l.
  tushu
  
  // tvs : 2015-02-19 T V SUNDRAM IYENGAR  & SONS LIMITED
  tvs
  
  // ubank : 2015-08-20 National Australia Bank Limited
  ubank
  
  // ubs : 2014-12-11 UBS AG
  ubs
  
  // uconnect : 2015-07-30 FCA US LLC.
  uconnect
  
  // unicom : 2015-10-15 China United Network Communications Corporation Limited
  unicom
  
  // university : 2014-03-06 Little Station, LLC
  university
  
  // uno : 2013-09-11 Dot Latin LLC
  uno
  
  // uol : 2014-05-01 UBN INTERNET LTDA.
  uol
  
  // ups : 2015-06-25 UPS Market Driver, Inc.
  ups
  
  // vacations : 2013-12-05 Atomic Tigers, LLC
  vacations
  
  // vana : 2014-12-11 Lifestyle Domain Holdings, Inc.
  vana
  
  // vanguard : 2015-09-03 The Vanguard Group, Inc.
  vanguard
  
  // vegas : 2014-01-16 Dot Vegas, Inc.
  vegas
  
  // ventures : 2013-08-27 Binky Lake, LLC
  ventures
  
  // verisign : 2015-08-13 VeriSign, Inc.
  verisign
  
  // versicherung : 2014-03-20 dotversicherung-registry GmbH
  versicherung
  
  // vet : 2014-03-06
  vet
  
  // viajes : 2013-10-17 Black Madison, LLC
  viajes
  
  // video : 2014-10-16
  video
  
  // vig : 2015-05-14 VIENNA INSURANCE GROUP AG Wiener Versicherung Gruppe
  vig
  
  // viking : 2015-04-02 Viking River Cruises (Bermuda) Ltd.
  viking
  
  // villas : 2013-12-05 New Sky, LLC
  villas
  
  // vin : 2015-06-18 Holly Shadow, LLC
  vin
  
  // vip : 2015-01-22 Minds + Machines Group Limited
  vip
  
  // virgin : 2014-09-25 Virgin Enterprises Limited
  virgin
  
  // visa : 2015-07-30 Visa Worldwide Pte. Limited
  visa
  
  // vision : 2013-12-05 Koko Station, LLC
  vision
  
  // vista : 2014-09-18 Vistaprint Limited
  vista
  
  // vistaprint : 2014-09-18 Vistaprint Limited
  vistaprint
  
  // viva : 2014-11-07 Saudi Telecom Company
  viva
  
  // vivo : 2015-07-31 Telefonica Brasil S.A.
  vivo
  
  // vlaanderen : 2014-02-06 DNS.be vzw
  vlaanderen
  
  // vodka : 2013-12-19 Top Level Domain Holdings Limited
  vodka
  
  // volkswagen : 2015-05-14 Volkswagen Group of America Inc.
  volkswagen
  
  // vote : 2013-11-21 Monolith Registry LLC
  vote
  
  // voting : 2013-11-13 Valuetainment Corp.
  voting
  
  // voto : 2013-11-21 Monolith Registry LLC
  voto
  
  // voyage : 2013-08-27 Ruby House, LLC
  voyage
  
  // vuelos : 2015-03-05 Travel Reservations SRL
  vuelos
  
  // wales : 2014-05-08 Nominet UK
  wales
  
  // walmart : 2015-07-31 Wal-Mart Stores, Inc.
  walmart
  
  // walter : 2014-11-13 Sandvik AB
  walter
  
  // wang : 2013-10-24 Zodiac Leo Limited
  wang
  
  // wanggou : 2014-12-18 Amazon EU S.à r.l.
  wanggou
  
  // warman : 2015-06-18 Weir Group IP Limited
  warman
  
  // watch : 2013-11-14 Sand Shadow, LLC
  watch
  
  // watches : 2014-12-22 Richemont DNS Inc.
  watches
  
  // weather : 2015-01-08 The Weather Channel, LLC
  weather
  
  // weatherchannel : 2015-03-12 The Weather Channel, LLC
  weatherchannel
  
  // webcam : 2014-01-23 dot Webcam Limited
  webcam
  
  // weber : 2015-06-04 Saint-Gobain Weber SA
  weber
  
  // website : 2014-04-03 DotWebsite Inc.
  website
  
  // wed : 2013-10-01 Atgron, Inc.
  wed
  
  // wedding : 2014-04-24 Top Level Domain Holdings Limited
  wedding
  
  // weibo : 2015-03-05 Sina Corporation
  weibo
  
  // weir : 2015-01-29 Weir Group IP Limited
  weir
  
  // whoswho : 2014-02-20 Who's Who Registry
  whoswho
  
  // wien : 2013-10-28 punkt.wien GmbH
  wien
  
  // wiki : 2013-11-07 Top Level Design, LLC
  wiki
  
  // williamhill : 2014-03-13 William Hill Organization Limited
  williamhill
  
  // win : 2014-11-20 First Registry Limited
  win
  
  // windows : 2014-12-18 Microsoft Corporation
  windows
  
  // wine : 2015-06-18 June Station, LLC
  wine
  
  // winners : 2015-07-16 The TJX Companies, Inc.
  winners
  
  // wme : 2014-02-13 William Morris Endeavor Entertainment, LLC
  wme
  
  // wolterskluwer : 2015-08-06 Wolters Kluwer N.V.
  wolterskluwer
  
  // woodside : 2015-07-09 Woodside Petroleum Limited
  woodside
  
  // work : 2013-12-19 Top Level Domain Holdings Limited
  work
  
  // works : 2013-11-14 Little Dynamite, LLC
  works
  
  // world : 2014-06-12 Bitter Fields, LLC
  world
  
  // wow : 2015-10-08 Amazon EU S.à r.l.
  wow
  
  // wtc : 2013-12-19 World Trade Centers Association, Inc.
  wtc
  
  // wtf : 2014-03-06 Hidden Way, LLC
  wtf
  
  // xbox : 2014-12-18 Microsoft Corporation
  xbox
  
  // xerox : 2014-10-24 Xerox DNHC LLC
  xerox
  
  // xfinity : 2015-07-09 Comcast IP Holdings I, LLC
  xfinity
  
  // xihuan : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  xihuan
  
  // xin : 2014-12-11 Elegant Leader Limited
  xin
  
  // xn--11b4c3d : 2015-01-15 VeriSign Sarl
  xn--11b4c3d
  
  // xn--1ck2e1b : 2015-02-26 Amazon EU S.à r.l.
  xn--1ck2e1b
  
  // xn--1qqw23a : 2014-01-09 Guangzhou YU Wei Information Technology Co., Ltd.
  xn--1qqw23a
  
  // xn--30rr7y : 2014-06-12 Excellent First Limited
  xn--30rr7y
  
  // xn--3bst00m : 2013-09-13 Eagle Horizon Limited
  xn--3bst00m
  
  // xn--3ds443g : 2013-09-08 TLD REGISTRY LIMITED
  xn--3ds443g
  
  // xn--3oq18vl8pn36a : 2015-07-02 Volkswagen (China) Investment Co., Ltd.
  xn--3oq18vl8pn36a
  
  // xn--3pxu8k : 2015-01-15 VeriSign Sarl
  xn--3pxu8k
  
  // xn--42c2d9a : 2015-01-15 VeriSign Sarl
  xn--42c2d9a
  
  // xn--45q11c : 2013-11-21 Zodiac Scorpio Limited
  xn--45q11c
  
  // xn--4gbrim : 2013-10-04 Suhub Electronic Establishment
  xn--4gbrim
  
  // xn--4gq48lf9j : 2015-07-31 Wal-Mart Stores, Inc.
  xn--4gq48lf9j
  
  // xn--55qw42g : 2013-11-08 China Organizational Name Administration Center
  xn--55qw42g
  
  // xn--55qx5d : 2013-11-14 Computer Network Information Center of Chinese Academy of Sciences （China Internet Network Information Center）
  xn--55qx5d
  
  // xn--5su34j936bgsg : 2015-09-03 Shangri‐La International Hotel Management Limited
  xn--5su34j936bgsg
  
  // xn--5tzm5g : 2014-12-22 Global Website TLD Asia Limited
  xn--5tzm5g
  
  // xn--6frz82g : 2013-09-23 Afilias Limited
  xn--6frz82g
  
  // xn--6qq986b3xl : 2013-09-13 Tycoon Treasure Limited
  xn--6qq986b3xl
  
  // xn--80adxhks : 2013-12-19 Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)
  xn--80adxhks
  
  // xn--80aqecdr1a : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--80aqecdr1a
  
  // xn--80asehdb : 2013-07-14 CORE Association
  xn--80asehdb
  
  // xn--80aswg : 2013-07-14 CORE Association
  xn--80aswg
  
  // xn--8y0a063a : 2015-03-26 China United Network Communications Corporation Limited
  xn--8y0a063a
  
  // xn--9dbq2a : 2015-01-15 VeriSign Sarl
  xn--9dbq2a
  
  // xn--9et52u : 2014-06-12 RISE VICTORY LIMITED
  xn--9et52u
  
  // xn--9krt00a : 2015-03-12 Sina Corporation
  xn--9krt00a
  
  // xn--b4w605ferd : 2014-08-07 Temasek Holdings (Private) Limited
  xn--b4w605ferd
  
  // xn--bck1b9a5dre4c : 2015-02-26 Amazon EU S.à r.l.
  xn--bck1b9a5dre4c
  
  // xn--c1avg : 2013-11-14 Public Interest Registry
  xn--c1avg
  
  // xn--c2br7g : 2015-01-15 VeriSign Sarl
  xn--c2br7g
  
  // xn--cck2b3b : 2015-02-26 Amazon EU S.à r.l.
  xn--cck2b3b
  
  // xn--cg4bki : 2013-09-27 SAMSUNG SDS CO., LTD
  xn--cg4bki
  
  // xn--czr694b : 2014-01-16 HU YI GLOBAL INFORMATION RESOURCES (HOLDING) COMPANY. HONGKONG LIMITED
  xn--czr694b
  
  // xn--czrs0t : 2013-12-19 Wild Island, LLC
  xn--czrs0t
  
  // xn--czru2d : 2013-11-21 Zodiac Capricorn Limited
  xn--czru2d
  
  // xn--d1acj3b : 2013-11-20 The Foundation for Network Initiatives “The Smart Internet”
  xn--d1acj3b
  
  // xn--eckvdtc9d : 2014-12-18 Amazon EU S.à r.l.
  xn--eckvdtc9d
  
  // xn--efvy88h : 2014-08-22 Xinhua News Agency Guangdong Branch 新华通讯社广东分社
  xn--efvy88h
  
  // xn--estv75g : 2015-02-19 Industrial and Commercial Bank of China Limited
  xn--estv75g
  
  // xn--fct429k : 2015-04-09 Amazon EU S.à r.l.
  xn--fct429k
  
  // xn--fhbei : 2015-01-15 VeriSign Sarl
  xn--fhbei
  
  // xn--fiq228c5hs : 2013-09-08 TLD REGISTRY LIMITED
  xn--fiq228c5hs
  
  // xn--fiq64b : 2013-10-14 CITIC Group Corporation
  xn--fiq64b
  
  // xn--fjq720a : 2014-05-22 Will Bloom, LLC
  xn--fjq720a
  
  // xn--flw351e : 2014-07-31 Charleston Road Registry Inc.
  xn--flw351e
  
  // xn--fzys8d69uvgm : 2015-05-14 PCCW Enterprises Limited
  xn--fzys8d69uvgm
  
  // xn--g2xx48c : 2015-01-30 Minds + Machines Group Limited
  xn--g2xx48c
  
  // xn--gckr3f0f : 2015-02-26 Amazon EU S.à r.l.
  xn--gckr3f0f
  
  // xn--gk3at1e : 2015-10-08 Amazon EU S.à r.l.
  xn--gk3at1e
  
  // xn--hxt814e : 2014-05-15 Zodiac Libra Limited
  xn--hxt814e
  
  // xn--i1b6b1a6a2e : 2013-11-14 Public Interest Registry
  xn--i1b6b1a6a2e
  
  // xn--imr513n : 2014-12-11 HU YI GLOBAL INFORMATION RESOURCES (HOLDING) COMPANY. HONGKONG LIMITED
  xn--imr513n
  
  // xn--io0a7i : 2013-11-14 Computer Network Information Center of Chinese Academy of Sciences （China Internet Network Information Center）
  xn--io0a7i
  
  // xn--j1aef : 2015-01-15 VeriSign Sarl
  xn--j1aef
  
  // xn--jlq61u9w7b : 2015-01-08 Nokia Corporation
  xn--jlq61u9w7b
  
  // xn--jvr189m : 2015-02-26 Amazon EU S.à r.l.
  xn--jvr189m
  
  // xn--kcrx77d1x4a : 2014-11-07 Koninklijke Philips N.V.
  xn--kcrx77d1x4a
  
  // xn--kpu716f : 2014-12-22 Richemont DNS Inc.
  xn--kpu716f
  
  // xn--kput3i : 2014-02-13 Beijing RITT-Net Technology Development Co., Ltd
  xn--kput3i
  
  // xn--mgba3a3ejt : 2014-11-20 Aramco Services Company
  xn--mgba3a3ejt
  
  // xn--mgba7c0bbn0a : 2015-05-14 Crescent Holding GmbH
  xn--mgba7c0bbn0a
  
  // xn--mgbaakc7dvf : 2015-09-03 Emirates Telecommunications Corporation (trading as Etisalat)
  xn--mgbaakc7dvf
  
  // xn--mgbab2bd : 2013-10-31 CORE Association
  xn--mgbab2bd
  
  // xn--mgbb9fbpob : 2014-12-18 GreenTech Consultancy Company W.L.L.
  xn--mgbb9fbpob
  
  // xn--mgbca7dzdo : 2015-07-30 Abu Dhabi Systems and Information Centre
  xn--mgbca7dzdo
  
  // xn--mgbi4ecexp : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--mgbi4ecexp
  
  // xn--mgbt3dhd : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  xn--mgbt3dhd
  
  // xn--mk1bu44c : 2015-01-15 VeriSign Sarl
  xn--mk1bu44c
  
  // xn--mxtq1m : 2014-03-06 Net-Chinese Co., Ltd.
  xn--mxtq1m
  
  // xn--ngbc5azd : 2013-07-13 International Domain Registry Pty. Ltd.
  xn--ngbc5azd
  
  // xn--ngbe9e0a : 2014-12-04 Kuwait Finance House
  xn--ngbe9e0a
  
  // xn--nqv7f : 2013-11-14 Public Interest Registry
  xn--nqv7f
  
  // xn--nqv7fs00ema : 2013-11-14 Public Interest Registry
  xn--nqv7fs00ema
  
  // xn--nyqy26a : 2014-11-07 Stable Tone Limited
  xn--nyqy26a
  
  // xn--p1acf : 2013-12-12 Rusnames Limited
  xn--p1acf
  
  // xn--pbt977c : 2014-12-22 Richemont DNS Inc.
  xn--pbt977c
  
  // xn--pssy2u : 2015-01-15 VeriSign Sarl
  xn--pssy2u
  
  // xn--q9jyb4c : 2013-09-17 Charleston Road Registry Inc.
  xn--q9jyb4c
  
  // xn--qcka1pmc : 2014-07-31 Charleston Road Registry Inc.
  xn--qcka1pmc
  
  // xn--rhqv96g : 2013-09-11 Stable Tone Limited
  xn--rhqv96g
  
  // xn--rovu88b : 2015-02-26 Amazon EU S.à r.l.
  xn--rovu88b
  
  // xn--ses554g : 2014-01-16
  xn--ses554g
  
  // xn--t60b56a : 2015-01-15 VeriSign Sarl
  xn--t60b56a
  
  // xn--tckwe : 2015-01-15 VeriSign Sarl
  xn--tckwe
  
  // xn--tiq49xqyj : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--tiq49xqyj
  
  // xn--unup4y : 2013-07-14 Spring Fields, LLC
  xn--unup4y
  
  // xn--vermgensberater-ctb : 2014-06-23 Deutsche Vermögensberatung Aktiengesellschaft DVAG
  xn--vermgensberater-ctb
  
  // xn--vermgensberatung-pwb : 2014-06-23 Deutsche Vermögensberatung Aktiengesellschaft DVAG
  xn--vermgensberatung-pwb
  
  // xn--vhquv : 2013-08-27 Dash McCook, LLC
  xn--vhquv
  
  // xn--vuq861b : 2014-10-16 Beijing Tele-info Network Technology Co., Ltd.
  xn--vuq861b
  
  // xn--w4r85el8fhu5dnra : 2015-04-30 Kerry Trading Co. Limited
  xn--w4r85el8fhu5dnra
  
  // xn--w4rs40l : 2015-07-30 Kerry Trading Co. Limited
  xn--w4rs40l
  
  // xn--xhq521b : 2013-11-14 Guangzhou YU Wei Information Technology Co., Ltd.
  xn--xhq521b
  
  // xn--zfr164b : 2013-11-08 China Organizational Name Administration Center
  xn--zfr164b
  
  // xperia : 2015-05-14 Sony Mobile Communications AB
  xperia
  
  // xyz : 2013-12-05 XYZ.COM LLC
  xyz
  
  // yachts : 2014-01-09 DERYachts, LLC
  yachts
  
  // yahoo : 2015-04-02 Yahoo! Domain Services Inc.
  yahoo
  
  // yamaxun : 2014-12-18 Amazon EU S.à r.l.
  yamaxun
  
  // yandex : 2014-04-10 YANDEX, LLC
  yandex
  
  // yodobashi : 2014-11-20 YODOBASHI CAMERA CO.,LTD.
  yodobashi
  
  // yoga : 2014-05-29 Top Level Domain Holdings Limited
  yoga
  
  // yokohama : 2013-12-12 GMO Registry, Inc.
  yokohama
  
  // you : 2015-04-09 Amazon EU S.à r.l.
  you
  
  // youtube : 2014-05-01 Charleston Road Registry Inc.
  youtube
  
  // yun : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  yun
  
  // zappos : 2015-06-25 Amazon EU S.à r.l.
  zappos
  
  // zara : 2014-11-07 Industria de Diseño Textil, S.A. (INDITEX, S.A.)
  zara
  
  // zero : 2014-12-18 Amazon EU S.à r.l.
  zero
  
  // zip : 2014-05-08 Charleston Road Registry Inc.
  zip
  
  // zippo : 2015-07-02 Zadco Company
  zippo
  
  // zone : 2013-11-14 Outer Falls, LLC
  zone
  
  // zuerich : 2014-11-07 Kanton Zürich (Canton of Zurich)
  zuerich
  
  
  // ===END ICANN DOMAINS===
  // ===BEGIN PRIVATE DOMAINS===
  // (Note: these are in alphabetical order by company name)
  
  // Amazon CloudFront : https://aws.amazon.com/cloudfront/
  // Submitted by Donavan Miller <donavanm@amazon.com> 2013-03-22
  cloudfront.net
  
  // Amazon Elastic Compute Cloud: https://aws.amazon.com/ec2/
  // Submitted by Osman Surkatty <osmans@amazon.com> 2014-12-16
  ap-northeast-1.compute.amazonaws.com
  ap-southeast-1.compute.amazonaws.com
  ap-southeast-2.compute.amazonaws.com
  cn-north-1.compute.amazonaws.cn
  compute.amazonaws.cn
  compute.amazonaws.com
  compute-1.amazonaws.com
  eu-west-1.compute.amazonaws.com
  eu-central-1.compute.amazonaws.com
  sa-east-1.compute.amazonaws.com
  us-east-1.amazonaws.com
  us-gov-west-1.compute.amazonaws.com
  us-west-1.compute.amazonaws.com
  us-west-2.compute.amazonaws.com
  z-1.compute-1.amazonaws.com
  z-2.compute-1.amazonaws.com
  
  // Amazon Elastic Beanstalk : https://aws.amazon.com/elasticbeanstalk/
  // Submitted by Adam Stein <astein@amazon.com> 2013-04-02
  elasticbeanstalk.com
  
  // Amazon Elastic Load Balancing : https://aws.amazon.com/elasticloadbalancing/
  // Submitted by Scott Vidmar <svidmar@amazon.com> 2013-03-27
  elb.amazonaws.com
  
  // Amazon S3 : https://aws.amazon.com/s3/
  // Submitted by Eric Kinolik <kilo@amazon.com> 2015-04-08
  s3.amazonaws.com
  s3-ap-northeast-1.amazonaws.com
  s3-ap-southeast-1.amazonaws.com
  s3-ap-southeast-2.amazonaws.com
  s3-external-1.amazonaws.com
  s3-external-2.amazonaws.com
  s3-fips-us-gov-west-1.amazonaws.com
  s3-eu-central-1.amazonaws.com
  s3-eu-west-1.amazonaws.com
  s3-sa-east-1.amazonaws.com
  s3-us-gov-west-1.amazonaws.com
  s3-us-west-1.amazonaws.com
  s3-us-west-2.amazonaws.com
  s3.cn-north-1.amazonaws.com.cn
  s3.eu-central-1.amazonaws.com
  
  // BetaInABox
  // Submitted by adrian@betainabox.com 2012-09-13
  betainabox.com
  
  // CentralNic : http://www.centralnic.com/names/domains
  // Submitted by registry <gavin.brown@centralnic.com> 2012-09-27
  ae.org
  ar.com
  br.com
  cn.com
  com.de
  com.se
  de.com
  eu.com
  gb.com
  gb.net
  hu.com
  hu.net
  jp.net
  jpn.com
  kr.com
  mex.com
  no.com
  qc.com
  ru.com
  sa.com
  se.com
  se.net
  uk.com
  uk.net
  us.com
  uy.com
  za.bz
  za.com
  
  // Africa.com Web Solutions Ltd : https://registry.africa.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com> 2014-02-04
  africa.com
  
  // iDOT Services Limited : http://www.domain.gr.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com> 2014-02-04
  gr.com
  
  // Radix FZC : http://domains.in.net
  // Submitted by Gavin Brown <gavin.brown@centralnic.com> 2014-02-04
  in.net
  
  // US REGISTRY LLC : http://us.org
  // Submitted by Gavin Brown <gavin.brown@centralnic.com> 2014-02-04
  us.org
  
  // co.com Registry, LLC : https://registry.co.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com> 2014-02-04
  co.com
  
  // c.la : http://www.c.la/
  c.la
  
  // cloudControl : https://www.cloudcontrol.com/
  // Submitted by Tobias Wilken <tw@cloudcontrol.com> 2013-07-23
  cloudcontrolled.com
  cloudcontrolapp.com
  
  // co.ca : http://registry.co.ca/
  co.ca
  
  // CDN77.com : http://www.cdn77.com
  // Submitted by Jan Krpes <jan.krpes@cdn77.com> 2015-07-13
  c.cdn77.org
  cdn77-ssl.net
  r.cdn77.net
  rsc.cdn77.org
  ssl.origin.cdn77-secure.org
  
  // CoDNS B.V.
  co.nl
  co.no
  
  // Commerce Guys, SAS
  // Submitted by Damien Tournoud <damien@commerceguys.com> 2015-01-22
  *.platform.sh
  
  // Cupcake : https://cupcake.io/
  // Submitted by Jonathan Rudenberg <jonathan@cupcake.io> 2013-10-08
  cupcake.is
  
  // DreamHost : http://www.dreamhost.com/
  // Submitted by Andrew Farmer <andrew.farmer@dreamhost.com> 2012-10-02
  dreamhosters.com
  
  // DuckDNS : http://www.duckdns.org/
  // Submitted by Richard Harper <richard@duckdns.org> 2015-05-17
  duckdns.org
  
  // DynDNS.com : http://www.dyndns.com/services/dns/dyndns/
  dyndns-at-home.com
  dyndns-at-work.com
  dyndns-blog.com
  dyndns-free.com
  dyndns-home.com
  dyndns-ip.com
  dyndns-mail.com
  dyndns-office.com
  dyndns-pics.com
  dyndns-remote.com
  dyndns-server.com
  dyndns-web.com
  dyndns-wiki.com
  dyndns-work.com
  dyndns.biz
  dyndns.info
  dyndns.org
  dyndns.tv
  at-band-camp.net
  ath.cx
  barrel-of-knowledge.info
  barrell-of-knowledge.info
  better-than.tv
  blogdns.com
  blogdns.net
  blogdns.org
  blogsite.org
  boldlygoingnowhere.org
  broke-it.net
  buyshouses.net
  cechire.com
  dnsalias.com
  dnsalias.net
  dnsalias.org
  dnsdojo.com
  dnsdojo.net
  dnsdojo.org
  does-it.net
  doesntexist.com
  doesntexist.org
  dontexist.com
  dontexist.net
  dontexist.org
  doomdns.com
  doomdns.org
  dvrdns.org
  dyn-o-saur.com
  dynalias.com
  dynalias.net
  dynalias.org
  dynathome.net
  dyndns.ws
  endofinternet.net
  endofinternet.org
  endoftheinternet.org
  est-a-la-maison.com
  est-a-la-masion.com
  est-le-patron.com
  est-mon-blogueur.com
  for-better.biz
  for-more.biz
  for-our.info
  for-some.biz
  for-the.biz
  forgot.her.name
  forgot.his.name
  from-ak.com
  from-al.com
  from-ar.com
  from-az.net
  from-ca.com
  from-co.net
  from-ct.com
  from-dc.com
  from-de.com
  from-fl.com
  from-ga.com
  from-hi.com
  from-ia.com
  from-id.com
  from-il.com
  from-in.com
  from-ks.com
  from-ky.com
  from-la.net
  from-ma.com
  from-md.com
  from-me.org
  from-mi.com
  from-mn.com
  from-mo.com
  from-ms.com
  from-mt.com
  from-nc.com
  from-nd.com
  from-ne.com
  from-nh.com
  from-nj.com
  from-nm.com
  from-nv.com
  from-ny.net
  from-oh.com
  from-ok.com
  from-or.com
  from-pa.com
  from-pr.com
  from-ri.com
  from-sc.com
  from-sd.com
  from-tn.com
  from-tx.com
  from-ut.com
  from-va.com
  from-vt.com
  from-wa.com
  from-wi.com
  from-wv.com
  from-wy.com
  ftpaccess.cc
  fuettertdasnetz.de
  game-host.org
  game-server.cc
  getmyip.com
  gets-it.net
  go.dyndns.org
  gotdns.com
  gotdns.org
  groks-the.info
  groks-this.info
  ham-radio-op.net
  here-for-more.info
  hobby-site.com
  hobby-site.org
  home.dyndns.org
  homedns.org
  homeftp.net
  homeftp.org
  homeip.net
  homelinux.com
  homelinux.net
  homelinux.org
  homeunix.com
  homeunix.net
  homeunix.org
  iamallama.com
  in-the-band.net
  is-a-anarchist.com
  is-a-blogger.com
  is-a-bookkeeper.com
  is-a-bruinsfan.org
  is-a-bulls-fan.com
  is-a-candidate.org
  is-a-caterer.com
  is-a-celticsfan.org
  is-a-chef.com
  is-a-chef.net
  is-a-chef.org
  is-a-conservative.com
  is-a-cpa.com
  is-a-cubicle-slave.com
  is-a-democrat.com
  is-a-designer.com
  is-a-doctor.com
  is-a-financialadvisor.com
  is-a-geek.com
  is-a-geek.net
  is-a-geek.org
  is-a-green.com
  is-a-guru.com
  is-a-hard-worker.com
  is-a-hunter.com
  is-a-knight.org
  is-a-landscaper.com
  is-a-lawyer.com
  is-a-liberal.com
  is-a-libertarian.com
  is-a-linux-user.org
  is-a-llama.com
  is-a-musician.com
  is-a-nascarfan.com
  is-a-nurse.com
  is-a-painter.com
  is-a-patsfan.org
  is-a-personaltrainer.com
  is-a-photographer.com
  is-a-player.com
  is-a-republican.com
  is-a-rockstar.com
  is-a-socialist.com
  is-a-soxfan.org
  is-a-student.com
  is-a-teacher.com
  is-a-techie.com
  is-a-therapist.com
  is-an-accountant.com
  is-an-actor.com
  is-an-actress.com
  is-an-anarchist.com
  is-an-artist.com
  is-an-engineer.com
  is-an-entertainer.com
  is-by.us
  is-certified.com
  is-found.org
  is-gone.com
  is-into-anime.com
  is-into-cars.com
  is-into-cartoons.com
  is-into-games.com
  is-leet.com
  is-lost.org
  is-not-certified.com
  is-saved.org
  is-slick.com
  is-uberleet.com
  is-very-bad.org
  is-very-evil.org
  is-very-good.org
  is-very-nice.org
  is-very-sweet.org
  is-with-theband.com
  isa-geek.com
  isa-geek.net
  isa-geek.org
  isa-hockeynut.com
  issmarterthanyou.com
  isteingeek.de
  istmein.de
  kicks-ass.net
  kicks-ass.org
  knowsitall.info
  land-4-sale.us
  lebtimnetz.de
  leitungsen.de
  likes-pie.com
  likescandy.com
  merseine.nu
  mine.nu
  misconfused.org
  mypets.ws
  myphotos.cc
  neat-url.com
  office-on-the.net
  on-the-web.tv
  podzone.net
  podzone.org
  readmyblog.org
  saves-the-whales.com
  scrapper-site.net
  scrapping.cc
  selfip.biz
  selfip.com
  selfip.info
  selfip.net
  selfip.org
  sells-for-less.com
  sells-for-u.com
  sells-it.net
  sellsyourhome.org
  servebbs.com
  servebbs.net
  servebbs.org
  serveftp.net
  serveftp.org
  servegame.org
  shacknet.nu
  simple-url.com
  space-to-rent.com
  stuff-4-sale.org
  stuff-4-sale.us
  teaches-yoga.com
  thruhere.net
  traeumtgerade.de
  webhop.biz
  webhop.info
  webhop.net
  webhop.org
  worse-than.tv
  writesthisblog.com
  
  // EU.org https://eu.org/
  // Submitted by Pierre Beyssac <hostmaster@eu.org> 2015-04-17
  
  eu.org
  al.eu.org
  asso.eu.org
  at.eu.org
  au.eu.org
  be.eu.org
  bg.eu.org
  ca.eu.org
  cd.eu.org
  ch.eu.org
  cn.eu.org
  cy.eu.org
  cz.eu.org
  de.eu.org
  dk.eu.org
  edu.eu.org
  ee.eu.org
  es.eu.org
  fi.eu.org
  fr.eu.org
  gr.eu.org
  hr.eu.org
  hu.eu.org
  ie.eu.org
  il.eu.org
  in.eu.org
  int.eu.org
  is.eu.org
  it.eu.org
  jp.eu.org
  kr.eu.org
  lt.eu.org
  lu.eu.org
  lv.eu.org
  mc.eu.org
  me.eu.org
  mk.eu.org
  mt.eu.org
  my.eu.org
  net.eu.org
  ng.eu.org
  nl.eu.org
  no.eu.org
  nz.eu.org
  paris.eu.org
  pl.eu.org
  pt.eu.org
  q-a.eu.org
  ro.eu.org
  ru.eu.org
  se.eu.org
  si.eu.org
  sk.eu.org
  tr.eu.org
  uk.eu.org
  us.eu.org
  
  // Fastly Inc. http://www.fastly.com/
  // Submitted by Vladimir Vuksan <vladimir@fastly.com> 2013-05-31
  a.ssl.fastly.net
  b.ssl.fastly.net
  global.ssl.fastly.net
  a.prod.fastly.net
  global.prod.fastly.net
  
  // Firebase, Inc.
  // Submitted by Chris Raynor <chris@firebase.com> 2014-01-21
  firebaseapp.com
  
  // Flynn : https://flynn.io
  // Submitted by Jonathan Rudenberg <jonathan@flynn.io> 2014-07-12
  flynnhub.com
  
  // GDS : https://www.gov.uk/service-manual/operations/operating-servicegovuk-subdomains
  // Submitted by David Illsley <david.illsley@digital.cabinet-office.gov.uk> 2014-08-28
  service.gov.uk
  
  // GitHub, Inc.
  // Submitted by Ben Toews <btoews@github.com> 2014-02-06
  github.io
  githubusercontent.com
  
  // GlobeHosting, Inc.
  // Submitted by Zoltan Egresi <egresi@globehosting.com> 2013-07-12
  ro.com
  
  // Google, Inc.
  // Submitted by Eduardo Vela <evn@google.com> 2014-12-19
  appspot.com
  blogspot.ae
  blogspot.al
  blogspot.am
  blogspot.ba
  blogspot.be
  blogspot.bg
  blogspot.bj
  blogspot.ca
  blogspot.cf
  blogspot.ch
  blogspot.cl
  blogspot.co.at
  blogspot.co.id
  blogspot.co.il
  blogspot.co.ke
  blogspot.co.nz
  blogspot.co.uk
  blogspot.co.za
  blogspot.com
  blogspot.com.ar
  blogspot.com.au
  blogspot.com.br
  blogspot.com.by
  blogspot.com.co
  blogspot.com.cy
  blogspot.com.ee
  blogspot.com.eg
  blogspot.com.es
  blogspot.com.mt
  blogspot.com.ng
  blogspot.com.tr
  blogspot.com.uy
  blogspot.cv
  blogspot.cz
  blogspot.de
  blogspot.dk
  blogspot.fi
  blogspot.fr
  blogspot.gr
  blogspot.hk
  blogspot.hr
  blogspot.hu
  blogspot.ie
  blogspot.in
  blogspot.is
  blogspot.it
  blogspot.jp
  blogspot.kr
  blogspot.li
  blogspot.lt
  blogspot.lu
  blogspot.md
  blogspot.mk
  blogspot.mr
  blogspot.mx
  blogspot.my
  blogspot.nl
  blogspot.no
  blogspot.pe
  blogspot.pt
  blogspot.qa
  blogspot.re
  blogspot.ro
  blogspot.rs
  blogspot.ru
  blogspot.se
  blogspot.sg
  blogspot.si
  blogspot.sk
  blogspot.sn
  blogspot.td
  blogspot.tw
  blogspot.ug
  blogspot.vn
  codespot.com
  googleapis.com
  googlecode.com
  pagespeedmobilizer.com
  withgoogle.com
  withyoutube.com
  
  // Heroku : https://www.heroku.com/
  // Submitted by Tom Maher <tmaher@heroku.com> 2013-05-02
  herokuapp.com
  herokussl.com
  
  // iki.fi
  // Submitted by Hannu Aronsson <haa@iki.fi> 2009-11-05
  iki.fi
  
  // info.at : http://www.info.at/
  biz.at
  info.at
  
  // Michau Enterprises Limited : http://www.co.pl/
  co.pl
  
  // Microsoft : http://microsoft.com
  // Submitted by Barry Dorrans <bdorrans@microsoft.com> 2014-01-24
  azurewebsites.net
  azure-mobile.net
  cloudapp.net
  
  // Mozilla Foundation : https://mozilla.org/
  // Submited by glob <glob@mozilla.com> 2015-07-06
  bmoattachments.org
  
  // Neustar Inc.
  // Submitted by Trung Tran <Trung.Tran@neustar.biz> 2015-04-23
  4u.com
  
  // ngrok : https://ngrok.com/
  // Submitted by Alan Shreve <alan@ngrok.com> 2015-11-10
  ngrok.io
  
  // NFSN, Inc. : https://www.NearlyFreeSpeech.NET/
  // Submitted by Jeff Wheelhouse <support@nearlyfreespeech.net> 2014-02-02
  nfshost.com
  
  // NYC.mn : http://www.information.nyc.mn
  // Submitted by Matthew Brown <mattbrown@nyc.mn> 2013-03-11
  nyc.mn
  
  // One Fold Media : http://www.onefoldmedia.com/
  // Submitted by Eddie Jones <eddie@onefoldmedia.com> 2014-06-10
  nid.io
  
  // Opera Software, A.S.A.
  // Submitted by Yngve Pettersen <yngve@opera.com> 2009-11-26
  operaunite.com
  
  // OutSystems
  // Submitted by Duarte Santos <domain-admin@outsystemscloud.com> 2014-03-11
  outsystemscloud.com
  
  // .pl domains (grandfathered)
  art.pl
  gliwice.pl
  krakow.pl
  poznan.pl
  wroc.pl
  zakopane.pl
  
  // Pantheon Systems, Inc. : https://pantheon.io/
  // Submitted by Gary Dylina <gary@pantheon.io> 2015-09-14
  pantheon.io
  gotpantheon.com
  
  // priv.at : http://www.nic.priv.at/
  // Submitted by registry <lendl@nic.at> 2008-06-09
  priv.at
  
  // QA2
  // Submitted by Daniel Dent (https://www.danieldent.com/) 2015-07-16
  qa2.com
  
  // Red Hat, Inc. OpenShift : https://openshift.redhat.com/
  // Submitted by Tim Kramer <tkramer@rhcloud.com> 2012-10-24
  rhcloud.com
  
  // Sandstorm Development Group, Inc. : https://sandcats.io/
  // Submitted by Asheesh Laroia <asheesh@sandstorm.io> 2015-07-21
  sandcats.io
  
  // Service Online LLC : http://drs.ua/
  // Submitted by Serhii Bulakh <support@drs.ua> 2015-07-30
  biz.ua
  co.ua
  pp.ua
  
  // SinaAppEngine : http://sae.sina.com.cn/
  // Submitted by SinaAppEngine <saesupport@sinacloud.com> 2015-02-02
  sinaapp.com
  vipsinaapp.com
  1kapp.com
  
  // TASK geographical domains (www.task.gda.pl/uslugi/dns)
  gda.pl
  gdansk.pl
  gdynia.pl
  med.pl
  sopot.pl
  
  // UDR Limited : http://www.udr.hk.com
  // Submitted by registry <hostmaster@udr.hk.com> 2014-11-07
  hk.com
  hk.org
  ltd.hk
  inc.hk
  
  // Yola : https://www.yola.com/
  // Submitted by Stefano Rivera <stefano@yola.com> 2014-07-09
  yolasite.com
  
  // ZaNiC : http://www.za.net/
  // Submitted by registry <hostmaster@nic.za.net> 2009-10-03
  za.net
  za.org
  
  // ===END PRIVATE DOMAINS===
  END_BUILTIN_DATA
  1;
IO_SOCKET_SSL_PUBLICSUFFIX

$fatpacked{"IO/Socket/SSL/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_UTILS';
  
  package IO::Socket::SSL::Utils;
  use strict;
  use warnings;
  use Carp 'croak';
  use Net::SSLeay;
  
  # old versions of Exporter do not export 'import' yet
  require Exporter;
  *import = \&Exporter::import;
  
  our $VERSION = '2.014';
  our @EXPORT = qw(
      PEM_file2cert PEM_string2cert PEM_cert2file PEM_cert2string
      PEM_file2key PEM_string2key PEM_key2file PEM_key2string
      KEY_free CERT_free
      KEY_create_rsa CERT_asHash CERT_create
  );
  
  sub PEM_file2cert {
      my $file = shift;
      my $bio = Net::SSLeay::BIO_new_file($file,'r') or
  	croak "cannot read $file: $!";
      my $cert = Net::SSLeay::PEM_read_bio_X509($bio);
      Net::SSLeay::BIO_free($bio);
      $cert or croak "cannot parse $file as PEM X509 cert: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $cert;
  }
  
  sub PEM_cert2file {
      my ($cert,$file) = @_;
      my $string = Net::SSLeay::PEM_get_string_X509($cert)
  	or croak("cannot get string from cert");
      open( my $fh,'>',$file ) or croak("cannot write $file: $!");
      print $fh $string;
  }
  
  sub PEM_string2cert {
      my $string = shift;
      my $bio = Net::SSLeay::BIO_new( Net::SSLeay::BIO_s_mem());
      Net::SSLeay::BIO_write($bio,$string);
      my $cert = Net::SSLeay::PEM_read_bio_X509($bio);
      Net::SSLeay::BIO_free($bio);
      $cert or croak "cannot parse string as PEM X509 cert: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $cert;
  }
  
  sub PEM_cert2string {
      my $cert = shift;
      return Net::SSLeay::PEM_get_string_X509($cert)
  	|| croak("cannot get string from cert");
  }
  
  sub PEM_file2key {
      my $file = shift;
      my $bio = Net::SSLeay::BIO_new_file($file,'r') or
  	croak "cannot read $file: $!";
      my $key = Net::SSLeay::PEM_read_bio_PrivateKey($bio);
      Net::SSLeay::BIO_free($bio);
      $key or croak "cannot parse $file as PEM private key: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $key;
  }
  
  sub PEM_key2file {
      my ($key,$file) = @_;
      my $string = Net::SSLeay::PEM_get_string_PrivateKey($key)
  	or croak("cannot get string from key");
      open( my $fh,'>',$file ) or croak("cannot write $file: $!");
      print $fh $string;
  }
  
  sub PEM_string2key {
      my $string = shift;
      my $bio = Net::SSLeay::BIO_new( Net::SSLeay::BIO_s_mem());
      Net::SSLeay::BIO_write($bio,$string);
      my $key = Net::SSLeay::PEM_read_bio_PrivateKey($bio);
      Net::SSLeay::BIO_free($bio);
      $key or croak "cannot parse string as PEM private key: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $key;
  }
  
  sub PEM_key2string {
      my $key = shift;
      return Net::SSLeay::PEM_get_string_PrivateKey($key)
  	|| croak("cannot get string from key");
  }
  
  sub CERT_free {
      my $cert = shift or return;
      Net::SSLeay::X509_free($cert);
  }
  
  sub KEY_free {
      my $key = shift or return;
      Net::SSLeay::EVP_PKEY_free($key);
  }
  
  sub KEY_create_rsa {
      my $bits = shift || 2048;
      my $key = Net::SSLeay::EVP_PKEY_new();
      my $rsa = Net::SSLeay::RSA_generate_key($bits, 0x10001); # 0x10001 = RSA_F4
      Net::SSLeay::EVP_PKEY_assign_RSA($key,$rsa);
      return $key;
  }
  
  # extract information from cert
  my %gen2i = qw( OTHERNAME 0 EMAIL 1 DNS 2 X400 3 DIRNAME 4 EDIPARTY 5 URI 6 IP 7 RID 8 );
  my %i2gen = reverse %gen2i;
  sub CERT_asHash {
      my $cert = shift;
      my $digest_name = shift || 'sha256';
  
      my %hash = (
  	version => Net::SSLeay::X509_get_version($cert),
  	not_before => _asn1t2t(Net::SSLeay::X509_get_notBefore($cert)),
  	not_after => _asn1t2t(Net::SSLeay::X509_get_notAfter($cert)),
  	serial => Net::SSLeay::ASN1_INTEGER_get(
  	    Net::SSLeay::X509_get_serialNumber($cert)),
  	crl_uri  => [ Net::SSLeay::P_X509_get_crl_distribution_points($cert) ],
  	keyusage => [ Net::SSLeay::P_X509_get_key_usage($cert) ],
  	extkeyusage => {
  	    oid => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,0) ],
  	    nid => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,1) ],
  	    sn  => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,2) ],
  	    ln  => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,3) ],
  	},
  	"pubkey_digest_$digest_name" => Net::SSLeay::X509_pubkey_digest(
  	    $cert,_digest($digest_name)),
  	"x509_digest_$digest_name" => Net::SSLeay::X509_digest(
  	    $cert,_digest($digest_name)),
  	"fingerprint_$digest_name" => Net::SSLeay::X509_get_fingerprint(
  	    $cert,_digest($digest_name)),
      );
  
      my $subj = Net::SSLeay::X509_get_subject_name($cert);
      my %subj;
      for ( 0..Net::SSLeay::X509_NAME_entry_count($subj)-1 ) {
  	my $e = Net::SSLeay::X509_NAME_get_entry($subj,$_);
  	my $o = Net::SSLeay::X509_NAME_ENTRY_get_object($e);
  	$subj{ Net::SSLeay::OBJ_obj2txt($o) } =
  	    Net::SSLeay::P_ASN1_STRING_get(
  		Net::SSLeay::X509_NAME_ENTRY_get_data($e));
      }
      $hash{subject} = \%subj;
  
      if ( my @names = Net::SSLeay::X509_get_subjectAltNames($cert) ) {
  	my $alt = $hash{subjectAltNames} = [];
  	while (my ($t,$v) = splice(@names,0,2)) {
  	    $t = $i2gen{$t} || die "unknown type $t in subjectAltName";
  	    if ( $t eq 'IP' ) {
  		if (length($v) == 4) {
  		    $v = join('.',unpack("CCCC",$v));
  		} elsif ( length($v) == 16 ) {
  		    my @v = unpack("nnnnnnnn",$v);
  		    my ($best0,$last0);
  		    for(my $i=0;$i<@v;$i++) {
  			if ($v[$i] == 0) {
  			    if ($last0) {
  				$last0->[1] = $i;
  				$last0->[2]++;
  				$best0 = $last0 if ++$last0->[2]>$best0->[2];
  			    } else {
  				$last0 = [ $i,$i,0 ];
  				$best0 ||= $last0;
  			    }
  			} else {
  			    $last0 = undef;
  			}
  		    }
  		    if ($best0) {
  			$v = '';
  			$v .= join(':', map { sprintf( "%x",$_) } @v[0..$best0->[0]-1]) if $best0->[0]>0;
  			$v .= '::';
  			$v .= join(':', map { sprintf( "%x",$_) } @v[$best0->[1]+1..$#v]) if $best0->[1]<$#v;
  		    } else {
  			$v = join(':', map { sprintf( "%x",$_) } @v);
  		    }
  		}
  	    }
  	    push @$alt,[$t,$v]
  	}
      }
  
      my $issuer = Net::SSLeay::X509_get_issuer_name($cert);
      my %issuer;
      for ( 0..Net::SSLeay::X509_NAME_entry_count($issuer)-1 ) {
  	my $e = Net::SSLeay::X509_NAME_get_entry($issuer,$_);
  	my $o = Net::SSLeay::X509_NAME_ENTRY_get_object($e);
  	$issuer{ Net::SSLeay::OBJ_obj2txt($o) } =
  	    Net::SSLeay::P_ASN1_STRING_get(
  		Net::SSLeay::X509_NAME_ENTRY_get_data($e));
      }
      $hash{issuer} = \%issuer;
  
      my @ext;
      for( 0..Net::SSLeay::X509_get_ext_count($cert)-1 ) {
  	my $e = Net::SSLeay::X509_get_ext($cert,$_);
  	my $o = Net::SSLeay::X509_EXTENSION_get_object($e);
  	my $nid = Net::SSLeay::OBJ_obj2nid($o);
  	push @ext, {
  	    oid => Net::SSLeay::OBJ_obj2txt($o),
  	    nid => ( $nid > 0 ) ? $nid : undef,
  	    sn  => ( $nid > 0 ) ? Net::SSLeay::OBJ_nid2sn($nid) : undef,
  	    critical => Net::SSLeay::X509_EXTENSION_get_critical($e),
  	    data => Net::SSLeay::X509V3_EXT_print($e),
  	}
      }
      $hash{ext} = \@ext;
  
      if ( defined(&Net::SSLeay::P_X509_get_ocsp_uri)) {
  	$hash{ocsp_uri} = [ Net::SSLeay::P_X509_get_ocsp_uri($cert) ];
      } else {
  	$hash{ocsp_uri} = [];
  	for( @ext ) {
  	    $_->{sn} or next;
  	    $_->{sn} eq 'authorityInfoAccess' or next;
  	    push @{ $hash{ocsp_uri}}, $_->{data} =~m{\bOCSP - URI:(\S+)}g;
  	}
      }
  
      return \%hash;
  }
  
  sub CERT_create {
      my %args = @_%2 ? %{ shift() } :  @_;
  
      my $cert = Net::SSLeay::X509_new();
      my $digest_name = delete $args{digest} || 'sha256';
  
      Net::SSLeay::ASN1_INTEGER_set(
  	Net::SSLeay::X509_get_serialNumber($cert),
  	delete $args{serial} || rand(2**32),
      );
  
      # version default to 2 (V3)
      Net::SSLeay::X509_set_version($cert,
  	delete $args{version} || 2 );
  
      # not_before default to now
      Net::SSLeay::ASN1_TIME_set(
  	Net::SSLeay::X509_get_notBefore($cert),
  	delete $args{not_before} || time()
      );
  
      # not_after default to now+365 days
      Net::SSLeay::ASN1_TIME_set(
  	Net::SSLeay::X509_get_notAfter($cert),
  	delete $args{not_after} || time() + 365*86400
      );
  
      # set subject
      my $subj_e = Net::SSLeay::X509_get_subject_name($cert);
      my $subj = delete $args{subject} || {
  	organizationName => 'IO::Socket::SSL',
  	commonName => 'IO::Socket::SSL Test'
      };
      while ( my ($k,$v) = each %$subj ) {
  	# Not everything we get is nice - try with MBSTRING_UTF8 first and if it
  	# fails try V_ASN1_T61STRING and finally V_ASN1_OCTET_STRING
  	Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,0x1000,$v,-1,0)
  	    or Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,20,$v,-1,0)
  	    or Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,4,$v,-1,0)
  	    or croak("failed to add entry for $k - ".
  	    Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error()));
      }
  
      my @ext = (
  	&Net::SSLeay::NID_subject_key_identifier => 'hash',
  	&Net::SSLeay::NID_authority_key_identifier => 'keyid',
  	&Net::SSLeay::NID_authority_key_identifier => 'issuer',
      );
      if ( my $altsubj = delete $args{subjectAltNames} ) {
  	push @ext,
  	    &Net::SSLeay::NID_subject_alt_name =>
  	    join(',', map { "$_->[0]:$_->[1]" } @$altsubj)
      }
  
      my $key = delete $args{key} || KEY_create_rsa();
      Net::SSLeay::X509_set_pubkey($cert,$key);
  
      my $is = delete $args{issuer};
      my $issuer_cert = delete $args{issuer_cert} || $is && $is->[0] || $cert;
      my $issuer_key  = delete $args{issuer_key}  || $is && $is->[1] || $key;
  
      my %purpose;
      if (my $p = delete $args{purpose}) {
  	if (!ref($p)) {
  	    $purpose{lc($2)} = (!$1 || $1 eq '+') ? 1:0
  		while $p =~m{([+-]?)(\w+)}g;
  	} elsif (ref($p) eq 'ARRAY') {
  	    for(@$p) {
  		m{^([+-]?)(\w+)$} or die "invalid entry in purpose: $_";
  		$purpose{lc($2)} = (!$1 || $1 eq '+') ? 1:0
  	    }
  	} else {
  	    while( my ($k,$v) = each %$p) {
  		$purpose{lc($k)} = ($v && $v ne '-')?1:0;
  	    }
  	}
      }
      if (defined( my $ca = delete $args{CA})) {
  	# add defaults
  	if ($ca) {
  	    %purpose = (
  		ca => 1, sslca => 1, emailca => 1, objca => 1,
  		%purpose
  	    );
  	} else {
  	    %purpose = (
  		server => 1, client => 1,
  		%purpose
  	    );
  	}
      } elsif (!%purpose) {
  	%purpose = (server => 1, client => 1);
      }
  
      my (%key_usage,%ext_key_usage,%cert_type,%basic_constraints);
  
      my %dS = ( digitalSignature => \%key_usage );
      my %kE = ( keyEncipherment => \%key_usage );
      my %CA = ( 'CA:TRUE' => \%basic_constraints, %dS, keyCertSign => \%key_usage );
      for(
  	[ client  => { %dS, %kE, clientAuth => \%ext_key_usage, client  => \%cert_type } ],
  	[ server  => { %dS, %kE, serverAuth => \%ext_key_usage, server  => \%cert_type } ],
  	[ email   => { %dS, %kE, emailProtection => \%ext_key_usage, email => \%cert_type } ],
  	[ objsign => { %dS, %kE, codeSigning => \%ext_key_usage, objsign => \%cert_type } ],
  
  	[ CA      => { %CA }],
  	[ sslCA   => { %CA, sslCA => \%cert_type }],
  	[ emailCA => { %CA, emailCA => \%cert_type }],
  	[ objCA   => { %CA, objCA => \%cert_type }],
  
  	[ emailProtection  => { %dS, %kE, emailProtection => \%ext_key_usage, email => \%cert_type } ],
  	[ codeSigning      => { %dS, %kE, codeSigning => \%ext_key_usage, objsign => \%cert_type } ],
  
  	[ timeStamping     => { timeStamping => \%ext_key_usage } ],
  	[ digitalSignature => { digitalSignature => \%key_usage } ],
  	[ nonRepudiation   => { nonRepudiation => \%key_usage } ],
  	[ keyEncipherment  => { keyEncipherment => \%key_usage } ],
  	[ dataEncipherment => { dataEncipherment => \%key_usage } ],
  	[ keyAgreement     => { keyAgreement => \%key_usage } ],
  	[ keyCertSign      => { keyCertSign => \%key_usage } ],
  	[ cRLSign          => { cRLSign => \%key_usage } ],
  	[ encipherOnly     => { encipherOnly => \%key_usage } ],
  	[ decipherOnly     => { decipherOnly => \%key_usage } ],
      ) {
  	delete $purpose{lc($_->[0])} or next;
  	while (my($k,$h) = each %{$_->[1]}) {
  	    $h->{$k} = 1;
  	}
      }
      die "unknown purpose ".join(",",keys %purpose) if %purpose;
  
      if (%basic_constraints) {
  	push @ext,&Net::SSLeay::NID_basic_constraints,
  	    => join(",",'critical', sort keys %basic_constraints);
      } else {
  	push @ext, &Net::SSLeay::NID_basic_constraints => 'CA:FALSE';
      }
      push @ext,&Net::SSLeay::NID_key_usage
  	=> join(",",'critical', sort keys %key_usage) if %key_usage;
      push @ext,&Net::SSLeay::NID_netscape_cert_type
  	=> join(",",sort keys %cert_type) if %cert_type;
      push @ext,&Net::SSLeay::NID_ext_key_usage
  	=> join(",",sort keys %ext_key_usage) if %ext_key_usage;
      Net::SSLeay::P_X509_add_extensions($cert, $issuer_cert, @ext);
  
      for my $ext (@{ $args{ext} || [] }) {
  	my $nid = $ext->{nid}
  	    || $ext->{sn} && Net::SSLeay::OBJ_sn2nid($ext->{sn})
  	    || croak "cannot determine NID of extension";
  	my $val = $ext->{data};
  	if ($nid == 177) {
  	    # authorityInfoAccess:
  	    # OpenSSL i2v does not output the same way as expected by i2v :(
  	    for (split(/\n/,$val)) {
  		s{ - }{;}; # "OCSP - URI:..." -> "OCSP;URI:..."
  		$_ = "critical,$_" if $ext->{critical};
  		Net::SSLeay::P_X509_add_extensions($cert,$issuer_cert,$nid,$_);
  	    }
  	} else {
  	    $val = "critical,$val" if $ext->{critical};
  	    Net::SSLeay::P_X509_add_extensions($cert, $issuer_cert, $nid, $val);
  	}
      }
  
      Net::SSLeay::X509_set_issuer_name($cert,
  	Net::SSLeay::X509_get_subject_name($issuer_cert));
      Net::SSLeay::X509_sign($cert,$issuer_key,_digest($digest_name));
  
      return ($cert,$key);
  }
  
  
  
  if ( defined &Net::SSLeay::ASN1_TIME_timet ) {
      *_asn1t2t = \&Net::SSLeay::ASN1_TIME_timet
  } else {
      require Time::Local;
      my %mon2i = qw(
  	Jan 0 Feb 1 Mar 2 Apr 3 May 4 Jun 5
  	Jul 6 Aug 7 Sep 8 Oct 9 Nov 10 Dec 11
      );
      *_asn1t2t = sub {
  	my $t = Net::SSLeay::P_ASN1_TIME_put2string( shift );
  	my ($mon,$d,$h,$m,$s,$y,$tz) = split(/[\s:]+/,$t);
  	defined( $mon = $mon2i{$mon} ) or die "invalid month in $t";
  	$tz ||= $y =~s{^(\d+)([A-Z]\S*)}{$1} && $2;
  	if ( ! $tz ) {
  	    return Time::Local::timelocal($s,$m,$h,$d,$mon,$y)
  	} elsif ( $tz eq 'GMT' ) {
  	    return Time::Local::timegm($s,$m,$h,$d,$mon,$y)
  	} else {
  	    die "unexpected TZ $tz from ASN1_TIME_print";
  	}
      }
  }
  
  {
      my %digest;
      sub _digest {
  	my $digest_name = shift;
  	return $digest{$digest_name} ||= do {
  	    Net::SSLeay::SSLeay_add_ssl_algorithms();
  	    Net::SSLeay::EVP_get_digestbyname($digest_name)
  		or die "Digest algorithm $digest_name is not available";
  	};
      }
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::SSL::Utils -- loading, storing, creating certificates and keys
  
  =head1 SYNOPSIS
  
      use IO::Socket::SSL::Utils;
      my $cert = PEM_file2cert('cert.pem');  # load certificate from file
      my $string = PEM_cert2string($cert);   # convert certificate to PEM string
      CERT_free($cert);                      # free memory within OpenSSL
  
      my $key = KEY_create_rsa(2048);        # create new 2048-bit RSA key
      PEM_string2file($key,"key.pem");       # and write it to file
      KEY_free($key);                        # free memory within OpenSSL
  
  
  =head1 DESCRIPTION
  
  This module provides various utility functions to work with certificates and
  private keys, shielding some of the complexity of the underlying Net::SSLeay and
  OpenSSL.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item *
  
  Functions converting between string or file and certificates and keys.
  They croak if the operation cannot be completed.
  
  =over 8
  
  =item PEM_file2cert(file) -> cert
  
  =item PEM_cert2file(cert,file)
  
  =item PEM_string2cert(string) -> cert
  
  =item PEM_cert2string(cert) -> string
  
  =item PEM_file2key(file) -> key
  
  =item PEM_key2file(key,file)
  
  =item PEM_string2key(string) -> key
  
  =item PEM_key2string(key) -> string
  
  =back
  
  =item *
  
  Functions for cleaning up.
  Each loaded or created cert and key must be freed to not leak memory.
  
  =over 8
  
  =item CERT_free(cert)
  
  =item KEY_free(key)
  
  =back
  
  =item * KEY_create_rsa(bits) -> key
  
  Creates an RSA key pair, bits defaults to 2048.
  
  =item * CERT_asHash(cert,[digest_algo]) -> hash
  
  Extracts the information from the certificate into a hash and uses the given
  digest_algo (default: SHA-256) to determine digest of pubkey and cert.
  The resulting hash contains:
  
  =over 8
  
  =item subject
  
  Hash with the parts of the subject, e.g. commonName, countryName,
  organizationName, stateOrProvinceName, localityName.
  
  =item subjectAltNames
  
  Array with list of alternative names. Each entry in the list is of
  C<[type,value]>, where C<type> can be OTHERNAME, EMAIL, DNS, X400, DIRNAME,
  EDIPARTY, URI, IP or RID.
  
  =item issuer
  
  Hash with the parts of the issuer, e.g. commonName, countryName,
  organizationName, stateOrProvinceName, localityName.
  
  =item not_before, not_after
  
  The time frame, where the certificate is valid, as time_t, e.g. can be converted
  with localtime or similar functions.
  
  =item serial
  
  The serial number
  
  =item crl_uri
  
  List of URIs for CRL distribution.
  
  =item ocsp_uri
  
  List of URIs for revocation checking using OCSP.
  
  =item keyusage
  
  List of keyUsage information in the certificate.
  
  =item extkeyusage
  
  List of extended key usage information from the certificate. Each entry in
  this list consists of a hash with oid, nid, ln and sn.
  
  =item pubkey_digest_xxx
  
  Binary digest of the pubkey using the given digest algorithm, e.g.
  pubkey_digest_sha256 if (the default) SHA-256 was used.
  
  =item x509_digest_xxx
  
  Binary digest of the X.509 certificate using the given digest algorithm, e.g.
  x509_digest_sha256 if (the default) SHA-256 was used.
  
  =item fingerprint_xxx
  
  Fingerprint of the certificate using the given digest algorithm, e.g.
  fingerprint_sha256 if (the default) SHA-256 was used. Contrary to digest_* this
  is an ASCII string with a list if hexadecimal numbers, e.g.
  "73:59:75:5C:6D...".
  
  =item ext
  
  List of extensions.
  Each entry in the list is a hash with oid, nid, sn, critical flag (boolean) and
  data (string representation given by X509V3_EXT_print).
  
  =item version
  
  Certificate version, usually 2 (x509v3)
  
  =back
  
  =item * CERT_create(hash) -> (cert,key)
  
  Creates a certificate based on the given hash.
  If the issuer is not specified the certificate will be self-signed.
  The following keys can be given:
  
  =over 8
  
  =item subject
  
  Hash with the parts of the subject, e.g. commonName, countryName, ... as
  described in C<CERT_asHash>.
  Default points to IO::Socket::SSL.
  
  =item not_before
  
  A time_t value when the certificate starts to be valid. Defaults to current
  time.
  
  =item not_after
  
  A time_t value when the certificate ends to be valid. Defaults to current
  time plus one 365 days.
  
  =item serial
  
  The serial number. If not given a random number will be used.
  
  =item version
  
  The version of the certificate, default 2 (x509v3).
  
  =item CA true|false
  
  If true declare certificate as CA, defaults to false.
  
  =item purpose string|array|hash
  
  Set the purpose of the certificate.
  The different purposes can be given as a string separated by non-word character,
  as array or hash. With string or array each purpose can be prefixed with '+'
  (enable) or '-' (disable) and same can be done with the value when given as a
  hash. By default enabling the purpose is assumed.
  
  If the CA option is given and true the defaults "ca,sslca,emailca,objca" are
  assumed, but can be overridden with explicit purpose.
  If the CA option is given and false the defaults "server,client" are assumed.
  If no CA option and no purpose is given it defaults to "server,client".
  
  Purpose affects basicConstraints, keyUsage, extKeyUsage and netscapeCertType.
  The following purposes are defined (case is not important):
  
      client
      server
      email
      objsign
  
      CA
      sslCA
      emailCA
      objCA
  
      emailProtection
      codeSigning
      timeStamping
  
      digitalSignature
      nonRepudiation
      keyEncipherment
      dataEncipherment
      keyAgreement
      keyCertSign
      cRLSign
      encipherOnly
      decipherOnly
  
  Examples:
  
       # root-CA for SSL certificates
       purpose => 'sslCA'   # or CA => 1
  
       # server certificate and CA (typically self-signed)
       purpose => 'sslCA,server'
  
       # client certificate
       purpose => 'client',
  
  
  =item ext [{ sn => .., data => ... }, ... ]
  
  List of extensions. The type of the extension can be specified as name with
  C<sn> or as NID with C<nid> and the data with C<data>. These data must be in the
  same syntax as expected within openssl.cnf, e.g. something like
  C<OCSP;URI=http://...>. Additionally the critical flag can be set with
  C<critical => 1>.
  
  =item key key
  
  use given key as key for certificate, otherwise a new one will be generated and
  returned
  
  =item issuer_cert cert
  
  set issuer for new certificate
  
  =item issuer_key key
  
  sign new certificate with given key
  
  =item issuer [ cert, key ]
  
  Instead of giving issuer_key and issuer_cert as separate arguments they can be
  given both together.
  
  =item digest algorithm
  
  specify the algorithm used to sign the certificate, default SHA-256.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Steffen Ullrich
IO_SOCKET_SSL_UTILS

$fatpacked{"Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO';
  package Mojo;
  use Mojo::Base -base;
  
  # "Professor: These old Doomsday devices are dangerously unstable. I'll rest
  #             easier not knowing where they are."
  use Carp ();
  use Mojo::Home;
  use Mojo::Log;
  use Mojo::Transaction::HTTP;
  use Mojo::UserAgent;
  use Mojo::Util;
  use Scalar::Util ();
  
  has home => sub { Mojo::Home->new->detect(ref shift) };
  has log  => sub { Mojo::Log->new };
  has ua   => sub {
    my $ua = Mojo::UserAgent->new;
    Scalar::Util::weaken $ua->server->app(shift)->{app};
    return $ua;
  };
  
  sub build_tx { Mojo::Transaction::HTTP->new }
  
  sub config { Mojo::Util::_stash(config => @_) }
  
  sub handler { Carp::croak 'Method "handler" not implemented in subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo - Web development toolkit
  
  =head1 SYNOPSIS
  
    package MyApp;
    use Mojo::Base 'Mojo';
  
    # All the complexities of CGI, PSGI, HTTP and WebSockets get reduced to a
    # single method call!
    sub handler {
      my ($self, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    }
  
  =head1 DESCRIPTION
  
  A powerful web development toolkit, with all the basic tools and helpers needed
  to write simple web applications and higher level web frameworks, such as
  L<Mojolicious>. Some of the most commonly used tools are L<Mojo::UserAgent>,
  L<Mojo::DOM>, L<Mojo::JSON>, L<Mojo::Server::Daemon>, L<Mojo::Server::Prefork>,
  L<Mojo::IOLoop> and L<Mojo::Template>.
  
  See L<Mojolicious::Guides> for more!
  
  =head1 ATTRIBUTES
  
  L<Mojo> implements the following attributes.
  
  =head2 home
  
    my $home = $app->home;
    $app     = $app->home(Mojo::Home->new);
  
  The home directory of your application, defaults to a L<Mojo::Home> object
  which stringifies to the actual path.
  
    # Generate portable path relative to home directory
    my $path = $app->home->rel_file('data/important.txt');
  
  =head2 log
  
    my $log = $app->log;
    $app    = $app->log(Mojo::Log->new);
  
  The logging layer of your application, defaults to a L<Mojo::Log> object.
  
    # Log debug message
    $app->log->debug('It works');
  
  =head2 ua
  
    my $ua = $app->ua;
    $app   = $app->ua(Mojo::UserAgent->new);
  
  A full featured HTTP user agent for use in your applications, defaults to a
  L<Mojo::UserAgent> object.
  
    # Perform blocking request
    say $app->ua->get('example.com')->res->body;
  
  =head1 METHODS
  
  L<Mojo> inherits all methods from L<Mojo::Base> and implements the following
  new ones.
  
  =head2 build_tx
  
    my $tx = $app->build_tx;
  
  Transaction builder, defaults to building a L<Mojo::Transaction::HTTP> object.
  
  =head2 config
  
    my $hash = $app->config;
    my $foo  = $app->config('foo');
    $app     = $app->config({foo => 'bar', baz => 23});
    $app     = $app->config(foo => 'bar', baz => 23);
  
  Application configuration.
  
    # Remove value
    my $foo = delete $app->config->{foo};
  
    # Assign multiple values at once
    $app->config(foo => 'test', bar => 23);
  
  =head2 handler
  
    $app->handler(Mojo::Transaction::HTTP->new);
  
  The handler is the main entry point to your application or framework and will
  be called for each new transaction, which will usually be a
  L<Mojo::Transaction::HTTP> or L<Mojo::Transaction::WebSocket> object. Meant to
  be overloaded in a subclass.
  
    sub handler {
      my ($self, $tx) = @_;
      ...
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO

$fatpacked{"Mojo/Asset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET';
  package Mojo::Asset;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  
  has 'end_range';
  has start_range => 0;
  
  sub add_chunk { croak 'Method "add_chunk" not implemented by subclass' }
  sub contains  { croak 'Method "contains" not implemented by subclass' }
  sub get_chunk { croak 'Method "get_chunk" not implemented by subclass' }
  
  sub is_file {undef}
  
  sub is_range { !!($_[0]->end_range || $_[0]->start_range) }
  
  sub move_to { croak 'Method "move_to" not implemented by subclass' }
  sub mtime   { croak 'Method "mtime" not implemented by subclass' }
  sub size    { croak 'Method "size" not implemented by subclass' }
  sub slurp   { croak 'Method "slurp" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset - HTTP content storage base class
  
  =head1 SYNOPSIS
  
    package Mojo::Asset::MyAsset;
    use Mojo::Base 'Mojo::Asset';
  
    sub add_chunk {...}
    sub contains  {...}
    sub get_chunk {...}
    sub move_to   {...}
    sub mtime     {...}
    sub size      {...}
    sub slurp     {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset> is an abstract base class for HTTP content storage backends,
  like L<Mojo::Asset::File> and L<Mojo::Asset::Memory>.
  
  =head1 EVENTS
  
  L<Mojo::Asset> inherits all events from L<Mojo::EventEmitter>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset> implements the following attributes.
  
  =head2 end_range
  
    my $end = $asset->end_range;
    $asset  = $asset->end_range(8);
  
  Pretend file ends earlier.
  
  =head2 start_range
  
    my $start = $asset->start_range;
    $asset    = $asset->start_range(3);
  
  Pretend file starts later.
  
  =head1 METHODS
  
  L<Mojo::Asset> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $asset = $asset->add_chunk('foo bar baz');
  
  Add chunk of data to asset. Meant to be overloaded in a subclass.
  
  =head2 contains
  
    my $position = $asset->contains('bar');
  
  Check if asset contains a specific string. Meant to be overloaded in a
  subclass.
  
  =head2 get_chunk
  
    my $bytes = $asset->get_chunk($offset);
    my $bytes = $asset->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KB). Meant to be overloaded in a subclass.
  
  =head2 is_file
  
    my $bool = $asset->is_file;
  
  False, this is not a L<Mojo::Asset::File> object.
  
  =head2 is_range
  
    my $bool = $asset->is_range;
  
  Check if asset has a L</"start_range"> or L</"end_range">.
  
  =head2 move_to
  
    $asset = $asset->move_to('/home/sri/foo.txt');
  
  Move asset data into a specific file. Meant to be overloaded in a subclass.
  
  =head2 mtime
  
    my $mtime = $asset->mtime;
  
  Modification time of asset. Meant to be overloaded in a subclass.
  
  =head2 size
  
    my $size = $asset->size;
  
  Size of asset data in bytes. Meant to be overloaded in a subclass.
  
  =head2 slurp
  
    my $bytes = $asset->slurp;
  
  Read all asset data at once. Meant to be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_ASSET

$fatpacked{"Mojo/Asset/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_FILE';
  package Mojo::Asset::File;
  use Mojo::Base 'Mojo::Asset';
  
  use Carp 'croak';
  use Errno 'EEXIST';
  use Fcntl qw(O_APPEND O_CREAT O_EXCL O_RDONLY O_RDWR);
  use File::Copy 'move';
  use File::Spec::Functions 'catfile';
  use IO::File;
  use Mojo::Util 'md5_sum';
  
  has [qw(cleanup path)];
  has handle => sub {
    my $self = shift;
  
    # Open existing file
    my $handle = IO::File->new;
    my $path   = $self->path;
    if (defined $path && -f $path) {
      $handle->open($path, O_RDONLY) or croak qq{Can't open file "$path": $!};
      return $handle;
    }
  
    # Open new or temporary file
    my $base = catfile $self->tmpdir, 'mojo.tmp';
    my $name = $path // $base;
    until ($handle->open($name, O_APPEND | O_CREAT | O_EXCL | O_RDWR)) {
      croak qq{Can't open file "$name": $!} if defined $path || $! != $!{EEXIST};
      $name = "$base." . md5_sum(time . $$ . rand);
    }
    $self->path($name);
  
    # Enable automatic cleanup
    $self->cleanup(1) unless defined $self->cleanup;
  
    return $handle;
  };
  has tmpdir => sub { $ENV{MOJO_TMPDIR} || File::Spec::Functions::tmpdir };
  
  sub DESTROY {
    my $self = shift;
    return unless $self->cleanup && defined(my $path = $self->path);
    if (my $handle = $self->handle) { close $handle }
    unlink $path if -w $path;
  }
  
  sub add_chunk {
    my ($self, $chunk) = @_;
    defined $self->handle->syswrite($chunk) or croak "Can't write to asset: $!";
    return $self;
  }
  
  sub contains {
    my ($self, $str) = @_;
  
    my $handle = $self->handle;
    $handle->sysseek($self->start_range, SEEK_SET);
  
    # Calculate window size
    my $end  = $self->end_range // $self->size;
    my $len  = length $str;
    my $size = $len > 131072 ? $len : 131072;
    $size = $end - $self->start_range if $size > $end - $self->start_range;
  
    # Sliding window search
    my $offset = 0;
    my $start = $handle->sysread(my $window, $len);
    while ($offset < $end) {
  
      # Read as much as possible
      my $diff = $end - ($start + $offset);
      my $read = $handle->sysread(my $buffer, $diff < $size ? $diff : $size);
      $window .= $buffer;
  
      # Search window
      my $pos = index $window, $str;
      return $offset + $pos if $pos >= 0;
      return -1 if $read == 0 || ($offset += $read) == $end;
  
      # Resize window
      substr $window, 0, $read, '';
    }
  
    return -1;
  }
  
  sub get_chunk {
    my ($self, $offset, $max) = @_;
    $max //= 131072;
  
    $offset += $self->start_range;
    my $handle = $self->handle;
    $handle->sysseek($offset, SEEK_SET);
  
    my $buffer;
    if (defined(my $end = $self->end_range)) {
      return '' if (my $chunk = $end + 1 - $offset) <= 0;
      $handle->sysread($buffer, $chunk > $max ? $max : $chunk);
    }
    else { $handle->sysread($buffer, $max) }
  
    return $buffer;
  }
  
  sub is_file {1}
  
  sub move_to {
    my ($self, $to) = @_;
  
    # Windows requires that the handle is closed
    close $self->handle;
    delete $self->{handle};
  
    # Move file and prevent clean up
    my $from = $self->path;
    move($from, $to) or croak qq{Can't move file "$from" to "$to": $!};
    return $self->path($to)->cleanup(0);
  }
  
  sub mtime { (stat shift->handle)[9] }
  
  sub size { -s shift->handle }
  
  sub slurp {
    my $handle = shift->handle;
    $handle->sysseek(0, SEEK_SET);
    defined $handle->sysread(my $content, -s $handle, 0)
      or croak qq{Can't read from asset: $!};
    return $content;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset::File - File storage for HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Asset::File;
  
    # Temporary file
    my $file = Mojo::Asset::File->new;
    $file->add_chunk('foo bar baz');
    say 'File contains "bar"' if $file->contains('bar') >= 0;
    say $file->slurp;
  
    # Existing file
    my $file = Mojo::Asset::File->new(path => '/home/sri/foo.txt');
    $file->move_to('/yada.txt');
    say $file->slurp;
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset::File> is a file storage backend for HTTP content.
  
  =head1 EVENTS
  
  L<Mojo::Asset::File> inherits all events from L<Mojo::Asset>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset::File> inherits all attributes from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 cleanup
  
    my $bool = $file->cleanup;
    $file    = $file->cleanup($bool);
  
  Delete L</"path"> automatically once the file is not used anymore.
  
  =head2 handle
  
    my $handle = $file->handle;
    $file      = $file->handle(IO::File->new);
  
  Filehandle, created on demand for L</"path">, which can be generated
  automatically and safely based on L</"tmpdir">.
  
  =head2 path
  
    my $path = $file->path;
    $file    = $file->path('/home/sri/foo.txt');
  
  File path used to create L</"handle">.
  
  =head2 tmpdir
  
    my $tmpdir = $file->tmpdir;
    $file      = $file->tmpdir('/tmp');
  
  Temporary directory used to generate L</"path">, defaults to the value of the
  C<MOJO_TMPDIR> environment variable or auto-detection.
  
  =head1 METHODS
  
  L<Mojo::Asset::File> inherits all methods from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $file = $file->add_chunk('foo bar baz');
  
  Add chunk of data.
  
  =head2 contains
  
    my $position = $file->contains('bar');
  
  Check if asset contains a specific string.
  
  =head2 get_chunk
  
    my $bytes = $file->get_chunk($offset);
    my $bytes = $file->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KB).
  
  =head2 is_file
  
    my $bool = $file->is_file;
  
  True, this is a L<Mojo::Asset::File> object.
  
  =head2 move_to
  
    $file = $file->move_to('/home/sri/bar.txt');
  
  Move asset data into a specific file and disable L</"cleanup">.
  
  =head2 mtime
  
    my $mtime = $file->mtime;
  
  Modification time of asset.
  
  =head2 size
  
    my $size = $file->size;
  
  Size of asset data in bytes.
  
  =head2 slurp
  
    my $bytes = $file->slurp;
  
  Read all asset data at once.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_ASSET_FILE

$fatpacked{"Mojo/Asset/Memory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_MEMORY';
  package Mojo::Asset::Memory;
  use Mojo::Base 'Mojo::Asset';
  
  use Mojo::Asset::File;
  use Mojo::Util 'spurt';
  
  has 'auto_upgrade';
  has max_memory_size => sub { $ENV{MOJO_MAX_MEMORY_SIZE} || 262144 };
  has mtime => sub {$^T};
  
  sub add_chunk {
    my ($self, $chunk) = @_;
  
    # Upgrade if necessary
    $self->{content} .= $chunk;
    return $self if !$self->auto_upgrade || $self->size <= $self->max_memory_size;
    my $file = Mojo::Asset::File->new;
    return $file->add_chunk($self->emit(upgrade => $file)->slurp);
  }
  
  sub contains {
    my ($self, $str) = @_;
  
    my $start = $self->start_range;
    my $pos = index $self->{content} // '', $str, $start;
    $pos -= $start if $start && $pos >= 0;
    my $end = $self->end_range;
  
    return $end && ($pos + length $str) >= $end ? -1 : $pos;
  }
  
  sub get_chunk {
    my ($self, $offset, $max) = @_;
    $max //= 131072;
  
    $offset += $self->start_range;
    if (my $end = $self->end_range) {
      $max = $end + 1 - $offset if ($offset + $max) > $end;
    }
  
    return substr shift->{content} // '', $offset, $max;
  }
  
  sub move_to {
    my ($self, $to) = @_;
    spurt $self->{content} // '', $to;
    return $self;
  }
  
  sub size { length(shift->{content} // '') }
  
  sub slurp { shift->{content} // '' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset::Memory - In-memory storage for HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Asset::Memory;
  
    my $mem = Mojo::Asset::Memory->new;
    $mem->add_chunk('foo bar baz');
    say $mem->slurp;
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset::Memory> is an in-memory storage backend for HTTP content.
  
  =head1 EVENTS
  
  L<Mojo::Asset::Memory> inherits all events from L<Mojo::Asset> and can emit the
  following new ones.
  
  =head2 upgrade
  
    $mem->on(upgrade => sub {
      my ($mem, $file) = @_;
      ...
    });
  
  Emitted when asset gets upgraded to a L<Mojo::Asset::File> object.
  
    $mem->on(upgrade => sub {
      my ($mem, $file) = @_;
      $file->tmpdir('/tmp');
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset::Memory> inherits all attributes from L<Mojo::Asset> and
  implements the following new ones.
  
  =head2 auto_upgrade
  
    my $bool = $mem->auto_upgrade;
    $mem     = $mem->auto_upgrade($bool);
  
  Try to detect if content size exceeds L</"max_memory_size"> limit and
  automatically upgrade to a L<Mojo::Asset::File> object.
  
  =head2 max_memory_size
  
    my $size = $mem->max_memory_size;
    $mem     = $mem->max_memory_size(1024);
  
  Maximum size in bytes of data to keep in memory before automatically upgrading
  to a L<Mojo::Asset::File> object, defaults to the value of the
  C<MOJO_MAX_MEMORY_SIZE> environment variable or C<262144> (256KB).
  
  =head2 mtime
  
    my $mtime = $mem->mtime;
    $mem      = $mem->mtime(1408567500);
  
  Modification time of asset, defaults to the value of C<$^T>.
  
  =head1 METHODS
  
  L<Mojo::Asset::Memory> inherits all methods from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $mem     = $mem->add_chunk('foo bar baz');
    my $file = $mem->add_chunk('abc' x 262144);
  
  Add chunk of data and upgrade to L<Mojo::Asset::File> object if necessary.
  
  =head2 contains
  
    my $position = $mem->contains('bar');
  
  Check if asset contains a specific string.
  
  =head2 get_chunk
  
    my $bytes = $mem->get_chunk($offset);
    my $bytes = $mem->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KB).
  
  =head2 move_to
  
    $mem = $mem->move_to('/home/sri/foo.txt');
  
  Move asset data into a specific file.
  
  =head2 size
  
    my $size = $mem->size;
  
  Size of asset data in bytes.
  
  =head2 slurp
  
    my $bytes = mem->slurp;
  
  Read all asset data at once.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_ASSET_MEMORY

$fatpacked{"Mojo/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BASE';
  package Mojo::Base;
  
  use strict;
  use warnings;
  use utf8;
  use feature ();
  
  # No imports because we get subclassed, a lot!
  use Carp ();
  
  # Only Perl 5.14+ requires it on demand
  use IO::Handle ();
  
  # Supported on Perl 5.22+
  my $NAME
    = eval { require Sub::Util; Sub::Util->can('set_subname') } || sub { $_[1] };
  
  # Protect subclasses using AUTOLOAD
  sub DESTROY { }
  
  # Declared here to avoid circular require problems in Mojo::Util
  sub _monkey_patch {
    my ($class, %patch) = @_;
    no strict 'refs';
    no warnings 'redefine';
    *{"${class}::$_"} = $NAME->("${class}::$_", $patch{$_}) for keys %patch;
  }
  
  sub attr {
    my ($self, $attrs, $value) = @_;
    return unless (my $class = ref $self || $self) && $attrs;
  
    Carp::croak 'Default has to be a code reference or constant value'
      if ref $value && ref $value ne 'CODE';
  
    for my $attr (@{ref $attrs eq 'ARRAY' ? $attrs : [$attrs]}) {
      Carp::croak qq{Attribute "$attr" invalid} unless $attr =~ /^[a-zA-Z_]\w*$/;
  
      # Very performance-sensitive code with lots of micro-optimizations
      if (ref $value) {
        _monkey_patch $class, $attr, sub {
          return
            exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value->($_[0]))
            if @_ == 1;
          $_[0]{$attr} = $_[1];
          $_[0];
        };
      }
      elsif (defined $value) {
        _monkey_patch $class, $attr, sub {
          return exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value)
            if @_ == 1;
          $_[0]{$attr} = $_[1];
          $_[0];
        };
      }
      else {
        _monkey_patch $class, $attr,
          sub { return $_[0]{$attr} if @_ == 1; $_[0]{$attr} = $_[1]; $_[0] };
      }
    }
  }
  
  sub import {
    my $class = shift;
    return unless my $flag = shift;
  
    # Base
    if ($flag eq '-base') { $flag = $class }
  
    # Strict
    elsif ($flag eq '-strict') { $flag = undef }
  
    # Module
    elsif ((my $file = $flag) && !$flag->can('new')) {
      $file =~ s!::|'!/!g;
      require "$file.pm";
    }
  
    # ISA
    if ($flag) {
      my $caller = caller;
      no strict 'refs';
      push @{"${caller}::ISA"}, $flag;
      _monkey_patch $caller, 'has', sub { attr($caller, @_) };
    }
  
    # Mojo modules are strict!
    $_->import for qw(strict warnings utf8);
    feature->import(':5.10');
  }
  
  sub new {
    my $class = shift;
    bless @_ ? @_ > 1 ? {@_} : {%{$_[0]}} : {}, ref $class || $class;
  }
  
  sub tap {
    my ($self, $cb) = (shift, shift);
    $_->$cb(@_) for $self;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Base - Minimal base class for Mojo projects
  
  =head1 SYNOPSIS
  
    package Cat;
    use Mojo::Base -base;
  
    has name => 'Nyan';
    has ['age', 'weight'] => 4;
  
    package Tiger;
    use Mojo::Base 'Cat';
  
    has friend  => sub { Cat->new };
    has stripes => 42;
  
    package main;
    use Mojo::Base -strict;
  
    my $mew = Cat->new(name => 'Longcat');
    say $mew->age;
    say $mew->age(3)->weight(5)->age;
  
    my $rawr = Tiger->new(stripes => 38, weight => 250);
    say $rawr->tap(sub { $_->friend->name('Tacgnol') })->weight;
  
  =head1 DESCRIPTION
  
  L<Mojo::Base> is a simple base class for L<Mojo> projects with fluent
  interfaces.
  
    # Automatically enables "strict", "warnings", "utf8" and Perl 5.10 features
    use Mojo::Base -strict;
    use Mojo::Base -base;
    use Mojo::Base 'SomeBaseClass';
  
  All three forms save a lot of typing.
  
    # use Mojo::Base -strict;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
  
    # use Mojo::Base -base;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    use Mojo::Base;
    push @ISA, 'Mojo::Base';
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
    # use Mojo::Base 'SomeBaseClass';
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    require SomeBaseClass;
    push @ISA, 'SomeBaseClass';
    use Mojo::Base;
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
  =head1 FUNCTIONS
  
  L<Mojo::Base> implements the following functions, which can be imported with
  the C<-base> flag or by setting a base class.
  
  =head2 has
  
    has 'name';
    has ['name1', 'name2', 'name3'];
    has name => 'foo';
    has name => sub {...};
    has ['name1', 'name2', 'name3'] => 'foo';
    has ['name1', 'name2', 'name3'] => sub {...};
  
  Create attributes for hash-based objects, just like the L</"attr"> method.
  
  =head1 METHODS
  
  L<Mojo::Base> implements the following methods.
  
  =head2 attr
  
    $object->attr('name');
    SubClass->attr('name');
    SubClass->attr(['name1', 'name2', 'name3']);
    SubClass->attr(name => 'foo');
    SubClass->attr(name => sub {...});
    SubClass->attr(['name1', 'name2', 'name3'] => 'foo');
    SubClass->attr(['name1', 'name2', 'name3'] => sub {...});
  
  Create attribute accessors for hash-based objects, an array reference can be
  used to create more than one at a time. Pass an optional second argument to set
  a default value, it should be a constant or a callback. The callback will be
  executed at accessor read time if there's no set value. Accessors can be
  chained, that means they return their invocant when they are called with an
  argument.
  
  =head2 new
  
    my $object = SubClass->new;
    my $object = SubClass->new(name => 'value');
    my $object = SubClass->new({name => 'value'});
  
  This base class provides a basic constructor for hash-based objects. You can
  pass it either a hash or a hash reference with attribute values.
  
  =head2 tap
  
    $object = $object->tap(sub {...});
    $object = $object->tap('some_method');
    $object = $object->tap('some_method', @args);
  
  Tap into a method chain to perform operations on an object within the chain
  (also known as a K combinator or Kestrel). The object will be the first argument
  passed to the callback, and is also available as C<$_>. The callback's return
  value will be ignored; instead, the object (the callback's first argument) will
  be the return value. In this way, arbitrary code can be used within (i.e.,
  spliced or tapped into) a chained set of object method calls.
  
    # Longer version
    $object = $object->tap(sub { $_->some_method(@args) });
  
    # Inject side effects into a method chain
    $object->foo('A')->tap(sub { say $_->foo })->foo('B');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_BASE

$fatpacked{"Mojo/ByteStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BYTESTREAM';
  package Mojo::ByteStream;
  use Mojo::Base -strict;
  use overload bool => sub {1}, '""' => sub { ${$_[0]} }, fallback => 1;
  
  use Exporter 'import';
  use Mojo::Collection;
  use Mojo::Util;
  
  our @EXPORT_OK = ('b');
  
  # Turn most functions from Mojo::Util into methods
  my @UTILS = (
    qw(b64_decode b64_encode camelize decamelize hmac_sha1_sum html_unescape),
    qw(md5_bytes md5_sum punycode_decode punycode_encode quote sha1_bytes),
    qw(sha1_sum slurp spurt squish term_escape trim unindent unquote),
    qw(url_escape url_unescape xml_escape xor_encode)
  );
  for my $name (@UTILS) {
    my $sub = Mojo::Util->can($name);
    Mojo::Util::monkey_patch __PACKAGE__, $name, sub {
      my $self = shift;
      $$self = $sub->($$self, @_);
      return $self;
    };
  }
  
  sub b { __PACKAGE__->new(@_) }
  
  sub clone { $_[0]->new(${$_[0]}) }
  
  sub decode { shift->_delegate(\&Mojo::Util::decode, @_) }
  sub encode { shift->_delegate(\&Mojo::Util::encode, @_) }
  
  sub new {
    my $class = shift;
    return bless \(my $dummy = join '', @_), ref $class || $class;
  }
  
  sub say {
    my ($self, $handle) = @_;
    $handle ||= \*STDOUT;
    say $handle $$self;
    return $self;
  }
  
  sub secure_compare { Mojo::Util::secure_compare ${shift()}, shift }
  
  sub size { length ${$_[0]} }
  
  sub split {
    my ($self, $pattern) = @_;
    return Mojo::Collection->new(map { $self->new($_) } split $pattern, $$self);
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub to_string { ${$_[0]} }
  
  sub _delegate {
    my ($self, $sub) = (shift, shift);
    $$self = $sub->(shift || 'UTF-8', $$self);
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::ByteStream - ByteStream
  
  =head1 SYNOPSIS
  
    use Mojo::ByteStream;
  
    # Manipulate bytestream
    my $stream = Mojo::ByteStream->new('foo_bar_baz');
    say $stream->camelize;
  
    # Chain methods
    my $stream = Mojo::ByteStream->new('foo bar baz')->quote;
    $stream = $stream->unquote->encode('UTF-8')->b64_encode('');
    say "$stream";
  
    # Use the alternative constructor
    use Mojo::ByteStream 'b';
    my $stream = b('foobarbaz')->b64_encode('')->say;
  
  =head1 DESCRIPTION
  
  L<Mojo::ByteStream> is a scalar-based container for bytestreams that provides a
  more friendly API for many of the functions in L<Mojo::Util>.
  
    # Access scalar directly to manipulate bytestream
    my $stream = Mojo::ByteStream->new('foo');
    $$stream .= 'bar';
  
  =head1 FUNCTIONS
  
  L<Mojo::ByteStream> implements the following functions, which can be imported
  individually.
  
  =head2 b
  
    my $stream = b('test123');
  
  Construct a new scalar-based L<Mojo::ByteStream> object.
  
  =head1 METHODS
  
  L<Mojo::ByteStream> implements the following methods.
  
  =head2 b64_decode
  
    $stream = $stream->b64_decode;
  
  Base64 decode bytestream with L<Mojo::Util/"b64_decode">.
  
  =head2 b64_encode
  
    $stream = $stream->b64_encode;
    $stream = $stream->b64_encode("\n");
  
  Base64 encode bytestream with L<Mojo::Util/"b64_encode">.
  
    # "Zm9vIGJhciBiYXo="
    b('foo bar baz')->b64_encode('');
  
  =head2 camelize
  
    $stream = $stream->camelize;
  
  Camelize bytestream with L<Mojo::Util/"camelize">.
  
  =head2 clone
  
    my $stream2 = $stream->clone;
  
  Clone bytestream.
  
  =head2 decamelize
  
    $stream = $stream->decamelize;
  
  Decamelize bytestream with L<Mojo::Util/"decamelize">.
  
  =head2 decode
  
    $stream = $stream->decode;
    $stream = $stream->decode('iso-8859-1');
  
  Decode bytestream with L<Mojo::Util/"decode">, defaults to using C<UTF-8>.
  
    # "♥"
    b('%E2%99%A5')->url_unescape->decode;
  
  =head2 encode
  
    $stream = $stream->encode;
    $stream = $stream->encode('iso-8859-1');
  
  Encode bytestream with L<Mojo::Util/"encode">, defaults to using C<UTF-8>.
  
    # "%E2%99%A5"
    b('♥')->encode->url_escape;
  
  =head2 hmac_sha1_sum
  
    $stream = $stream->hmac_sha1_sum('passw0rd');
  
  Generate HMAC-SHA1 checksum for bytestream with L<Mojo::Util/"hmac_sha1_sum">.
  
    # "7fbdc89263974a89210ea71f171c77d3f8c21471"
    b('foo bar baz')->hmac_sha1_sum('secr3t');
  
  =head2 html_unescape
  
    $stream = $stream->html_unescape;
  
  Unescape all HTML entities in bytestream with L<Mojo::Util/"html_unescape">.
  
    # "%3Chtml%3E"
    b('&lt;html&gt;')->html_unescape->url_escape;
  
  =head2 md5_bytes
  
    $stream = $stream->md5_bytes;
  
  Generate binary MD5 checksum for bytestream with L<Mojo::Util/"md5_bytes">.
  
  =head2 md5_sum
  
    $stream = $stream->md5_sum;
  
  Generate MD5 checksum for bytestream with L<Mojo::Util/"md5_sum">.
  
  =head2 new
  
    my $stream = Mojo::ByteStream->new('test123');
  
  Construct a new scalar-based L<Mojo::ByteStream> object.
  
  =head2 punycode_decode
  
    $stream = $stream->punycode_decode;
  
  Punycode decode bytestream with L<Mojo::Util/"punycode_decode">.
  
  =head2 punycode_encode
  
    $stream = $stream->punycode_encode;
  
  Punycode encode bytestream with L<Mojo::Util/"punycode_encode">.
  
  =head2 quote
  
    $stream = $stream->quote;
  
  Quote bytestream with L<Mojo::Util/"quote">.
  
  =head2 say
  
    $stream = $stream->say;
    $stream = $stream->say(*STDERR);
  
  Print bytestream to handle and append a newline, defaults to using C<STDOUT>.
  
  =head2 secure_compare
  
    my $bool = $stream->secure_compare($str);
  
  Compare bytestream with L<Mojo::Util/"secure_compare">.
  
  =head2 sha1_bytes
  
    $stream = $stream->sha1_bytes;
  
  Generate binary SHA1 checksum for bytestream with L<Mojo::Util/"sha1_bytes">.
  
  =head2 sha1_sum
  
    $stream = $stream->sha1_sum;
  
  Generate SHA1 checksum for bytestream with L<Mojo::Util/"sha1_sum">.
  
  =head2 size
  
    my $size = $stream->size;
  
  Size of bytestream.
  
  =head2 slurp
  
    $stream = $stream->slurp;
  
  Read all data at once from file into bytestream with L<Mojo::Util/"slurp">.
  
    # Read file and print lines in random order
    b('/home/sri/myapp.pl')->slurp->split("\n")->shuffle->join("\n")->say;
  
  =head2 spurt
  
    $stream = $stream->spurt('/home/sri/myapp.pl');
  
  Write all data from bytestream at once to file with L<Mojo::Util/"spurt">.
  
    # Remove unnecessary whitespace from file
    b('/home/sri/foo.txt')->slurp->squish->spurt('/home/sri/bar.txt');
  
  =head2 split
  
    my $collection = $stream->split(',');
  
  Turn bytestream into L<Mojo::Collection> object containing L<Mojo::ByteStream>
  objects.
  
    # "One,Two,Three"
    b("one,two,three")->split(',')->map('camelize')->join(',');
  
  =head2 squish
  
    $stream = $stream->squish;
  
  Trim whitespace characters from both ends of bytestream and then change all
  consecutive groups of whitespace into one space each with
  L<Mojo::Util/"squish">.
  
  =head2 tap
  
    $stream = $stream->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 term_escape
  
    $stream = $stream->term_escape;
  
  Escape POSIX control characters in bytestream with L<Mojo::Util/"term_escape">.
  
    # Print binary checksum to terminal
    b('foo')->sha1_bytes->term_escape->say;
  
  =head2 to_string
  
    my $str = $stream->to_string;
  
  Stringify bytestream.
  
  =head2 trim
  
    $stream = $stream->trim;
  
  Trim whitespace characters from both ends of bytestream with
  L<Mojo::Util/"trim">.
  
  =head2 unindent
  
    $stream = $stream->unindent;
  
  Unindent bytestream with L<Mojo::Util/"unindent">.
  
  =head2 unquote
  
    $stream = $stream->unquote;
  
  Unquote bytestream with L<Mojo::Util/"unquote">.
  
  =head2 url_escape
  
    $stream = $stream->url_escape;
    $stream = $stream->url_escape('^A-Za-z0-9\-._~');
  
  Percent encode all unsafe characters in bytestream with
  L<Mojo::Util/"url_escape">.
  
    # "%E2%98%83"
    b('☃')->encode->url_escape;
  
  =head2 url_unescape
  
    $stream = $stream->url_unescape;
  
  Decode percent encoded characters in bytestream with
  L<Mojo::Util/"url_unescape">.
  
    # "&lt;html&gt;"
    b('%3Chtml%3E')->url_unescape->xml_escape;
  
  =head2 xml_escape
  
    $stream = $stream->xml_escape;
  
  Escape only the characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in
  bytestream with L<Mojo::Util/"xml_escape">.
  
  =head2 xor_encode
  
    $stream = $stream->xor_encode($key);
  
  XOR encode bytestream with L<Mojo::Util/"xor_encode">.
  
    # "%04%0E%15B%03%1B%10"
    b('foo bar')->xor_encode('baz')->url_escape;
  
  =head1 OPERATORS
  
  L<Mojo::ByteStream> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$bytestream;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$bytestream";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_BYTESTREAM

$fatpacked{"Mojo/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CACHE';
  package Mojo::Cache;
  use Mojo::Base -base;
  
  has 'max_keys' => 100;
  
  sub get { (shift->{cache} || {})->{shift()} }
  
  sub set {
    my ($self, $key, $value) = @_;
  
    return $self unless (my $max = $self->max_keys) > 0;
  
    my $cache = $self->{cache} ||= {};
    my $queue = $self->{queue} ||= [];
    delete $cache->{shift @$queue} while @$queue >= $max;
    push @$queue, $key unless exists $cache->{$key};
    $cache->{$key} = $value;
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cache - Naive in-memory cache
  
  =head1 SYNOPSIS
  
    use Mojo::Cache;
  
    my $cache = Mojo::Cache->new(max_keys => 50);
    $cache->set(foo => 'bar');
    my $foo = $cache->get('foo');
  
  =head1 DESCRIPTION
  
  L<Mojo::Cache> is a naive in-memory cache with size limits.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cache> implements the following attributes.
  
  =head2 max_keys
  
    my $max = $cache->max_keys;
    $cache  = $cache->max_keys(50);
  
  Maximum number of cache keys, defaults to C<100>. Setting the value to C<0>
  will disable caching.
  
  =head1 METHODS
  
  L<Mojo::Cache> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 get
  
    my $value = $cache->get('foo');
  
  Get cached value.
  
  =head2 set
  
    $cache = $cache->set(foo => 'bar');
  
  Set cached value.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_CACHE

$fatpacked{"Mojo/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COLLECTION';
  package Mojo::Collection;
  use Mojo::Base -strict;
  
  use Carp 'croak';
  use Exporter 'import';
  use List::Util;
  use Mojo::ByteStream;
  use Scalar::Util 'blessed';
  
  our @EXPORT_OK = ('c');
  
  sub TO_JSON { [@{shift()}] }
  
  sub c { __PACKAGE__->new(@_) }
  
  sub compact {
    my $self = shift;
    return $self->new(grep { defined && (ref || length) } @$self);
  }
  
  sub each {
    my ($self, $cb) = @_;
    return @$self unless $cb;
    my $i = 1;
    $_->$cb($i++) for @$self;
    return $self;
  }
  
  sub first {
    my ($self, $cb) = (shift, shift);
    return $self->[0] unless $cb;
    return List::Util::first { $_ =~ $cb } @$self if ref $cb eq 'Regexp';
    return List::Util::first { $_->$cb(@_) } @$self;
  }
  
  sub flatten { $_[0]->new(_flatten(@{$_[0]})) }
  
  sub grep {
    my ($self, $cb) = (shift, shift);
    return $self->new(grep { $_ =~ $cb } @$self) if ref $cb eq 'Regexp';
    return $self->new(grep { $_->$cb(@_) } @$self);
  }
  
  sub join {
    Mojo::ByteStream->new(join $_[1] // '', map {"$_"} @{$_[0]});
  }
  
  sub last { shift->[-1] }
  
  sub map {
    my ($self, $cb) = (shift, shift);
    return $self->new(map { $_->$cb(@_) } @$self);
  }
  
  sub new {
    my $class = shift;
    return bless [@_], ref $class || $class;
  }
  
  sub reduce {
    my $self = shift;
    @_ = (@_, @$self);
    goto &List::Util::reduce;
  }
  
  sub reverse { $_[0]->new(reverse @{$_[0]}) }
  
  sub shuffle { $_[0]->new(List::Util::shuffle @{$_[0]}) }
  
  sub size { scalar @{$_[0]} }
  
  sub slice {
    my $self = shift;
    return $self->new(@$self[@_]);
  }
  
  sub sort {
    my ($self, $cb) = @_;
  
    return $self->new(sort @$self) unless $cb;
  
    my $caller = caller;
    no strict 'refs';
    my @sorted = sort {
      local (*{"${caller}::a"}, *{"${caller}::b"}) = (\$a, \$b);
      $a->$cb($b);
    } @$self;
    return $self->new(@sorted);
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub to_array { [@{shift()}] }
  
  sub uniq {
    my ($self, $cb) = (shift, shift);
    my %seen;
    return $self->new(grep { !$seen{$_->$cb(@_)}++ } @$self) if $cb;
    return $self->new(grep { !$seen{$_}++ } @$self);
  }
  
  sub _flatten {
    map { _ref($_) ? _flatten(@$_) : $_ } @_;
  }
  
  sub _ref { ref $_[0] eq 'ARRAY' || blessed $_[0] && $_[0]->isa(__PACKAGE__) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Collection - Collection
  
  =head1 SYNOPSIS
  
    use Mojo::Collection;
  
    # Manipulate collection
    my $collection = Mojo::Collection->new(qw(just works));
    unshift @$collection, 'it';
    say $collection->join("\n");
  
    # Chain methods
    $collection->map(sub { ucfirst })->shuffle->each(sub {
      my ($word, $num) = @_;
      say "$num: $word";
    });
  
    # Use the alternative constructor
    use Mojo::Collection 'c';
    c(qw(a b c))->join('/')->url_escape->say;
  
  =head1 DESCRIPTION
  
  L<Mojo::Collection> is an array-based container for collections.
  
    # Access array directly to manipulate collection
    my $collection = Mojo::Collection->new(1 .. 25);
    $collection->[23] += 100;
    say for @$collection;
  
  =head1 FUNCTIONS
  
  L<Mojo::Collection> implements the following functions, which can be imported
  individually.
  
  =head2 c
  
    my $collection = c(1, 2, 3);
  
  Construct a new array-based L<Mojo::Collection> object.
  
  =head1 METHODS
  
  L<Mojo::Collection> implements the following methods.
  
  =head2 TO_JSON
  
    my $array = $collection->TO_JSON;
  
  Alias for L</"to_array">.
  
  =head2 compact
  
    my $new = $collection->compact;
  
  Create a new collection with all elements that are defined and not an empty
  string.
  
    # "0, 1, 2, 3"
    Mojo::Collection->new(0, 1, undef, 2, '', 3)->compact->join(', ');
  
  =head2 each
  
    my @elements = $collection->each;
    $collection  = $collection->each(sub {...});
  
  Evaluate callback for each element in collection, or return all elements as a
  list if none has been provided. The element will be the first argument passed
  to the callback, and is also available as C<$_>.
  
    # Make a numbered list
    $collection->each(sub {
      my ($e, $num) = @_;
      say "$num: $e";
    });
  
  =head2 first
  
    my $first = $collection->first;
    my $first = $collection->first(qr/foo/);
    my $first = $collection->first(sub {...});
    my $first = $collection->first('some_method');
    my $first = $collection->first('some_method', @args);
  
  Evaluate regular expression/callback for, or call method on, each element in
  collection and return the first one that matched the regular expression, or for
  which the callback/method returned true. The element will be the first argument
  passed to the callback, and is also available as C<$_>.
  
    # Longer version
    my $first = $collection->first(sub { $_->some_method(@args) });
  
    # Find first value that contains the word "mojo"
    my $interesting = $collection->first(qr/mojo/i);
  
    # Find first value that is greater than 5
    my $greater = $collection->first(sub { $_ > 5 });
  
  =head2 flatten
  
    my $new = $collection->flatten;
  
  Flatten nested collections/arrays recursively and create a new collection with
  all elements.
  
    # "1, 2, 3, 4, 5, 6, 7"
    Mojo::Collection->new(1, [2, [3, 4], 5, [6]], 7)->flatten->join(', ');
  
  =head2 grep
  
    my $new = $collection->grep(qr/foo/);
    my $new = $collection->grep(sub {...});
    my $new = $collection->grep('some_method');
    my $new = $collection->grep('some_method', @args);
  
  Evaluate regular expression/callback for, or call method on, each element in
  collection and create a new collection with all elements that matched the
  regular expression, or for which the callback/method returned true. The element
  will be the first argument passed to the callback, and is also available as
  C<$_>.
  
    # Longer version
    my $new = $collection->grep(sub { $_->some_method(@args) });
  
    # Find all values that contain the word "mojo"
    my $interesting = $collection->grep(qr/mojo/i);
  
    # Find all values that are greater than 5
    my $greater = $collection->grep(sub { $_ > 5 });
  
  =head2 join
  
    my $stream = $collection->join;
    my $stream = $collection->join("\n");
  
  Turn collection into L<Mojo::ByteStream>.
  
    # Join all values with commas
    $collection->join(', ')->say;
  
  =head2 last
  
    my $last = $collection->last;
  
  Return the last element in collection.
  
  =head2 map
  
    my $new = $collection->map(sub {...});
    my $new = $collection->map('some_method');
    my $new = $collection->map('some_method', @args);
  
  Evaluate callback for, or call method on, each element in collection and create
  a new collection from the results. The element will be the first argument
  passed to the callback, and is also available as C<$_>.
  
    # Longer version
    my $new = $collection->map(sub { $_->some_method(@args) });
  
    # Append the word "mojo" to all values
    my $mojoified = $collection->map(sub { $_ . 'mojo' });
  
  =head2 new
  
    my $collection = Mojo::Collection->new(1, 2, 3);
  
  Construct a new array-based L<Mojo::Collection> object.
  
  =head2 reduce
  
    my $result = $collection->reduce(sub {...});
    my $result = $collection->reduce(sub {...}, $initial);
  
  Reduce elements in collection with a callback and return its final result,
  setting C<$a> and C<$b> each time the callback is executed. The first time C<$a>
  will be set to an optional initial value or the first element in the collection.
  And from then on C<$a> will be set to the return value of the callback, while
  C<$b> will always be set to the next element in the collection.
  
    # Calculate the sum of all values
    my $sum = $collection->reduce(sub { $a + $b });
  
    # Count how often each value occurs in collection
    my $hash = $collection->reduce(sub { $a->{$b}++; $a }, {});
  
  =head2 reverse
  
    my $new = $collection->reverse;
  
  Create a new collection with all elements in reverse order.
  
  =head2 slice
  
    my $new = $collection->slice(4 .. 7);
  
  Create a new collection with all selected elements.
  
    # "B C E"
    Mojo::Collection->new('A', 'B', 'C', 'D', 'E')->slice(1, 2, 4)->join(' ');
  
  =head2 shuffle
  
    my $new = $collection->shuffle;
  
  Create a new collection with all elements in random order.
  
  =head2 size
  
    my $size = $collection->size;
  
  Number of elements in collection.
  
  =head2 sort
  
    my $new = $collection->sort;
    my $new = $collection->sort(sub {...});
  
  Sort elements based on return value of a callback and create a new collection
  from the results, setting C<$a> and C<$b> to the elements being compared, each
  time the callback is executed.
  
    # Sort values case-insensitive
    my $case_insensitive = $collection->sort(sub { uc($a) cmp uc($b) });
  
  =head2 tap
  
    $collection = $collection->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 to_array
  
    my $array = $collection->to_array;
  
  Turn collection into array reference.
  
  =head2 uniq
  
    my $new = $collection->uniq;
    my $new = $collection->uniq(sub {...});
    my $new = $collection->uniq('some_method');
    my $new = $collection->uniq('some_method', @args);
  
  Create a new collection without duplicate elements, using the string
  representation of either the elements or the return value of the
  callback/method.
  
    # Longer version
    my $new = $collection->uniq(sub { $_->some_method(@args) });
  
    # "foo bar baz"
    Mojo::Collection->new('foo', 'bar', 'bar', 'baz')->uniq->join(' ');
  
    # "[[1, 2], [2, 1]]"
    Mojo::Collection->new([1, 2], [2, 1], [3, 2])->uniq(sub{ $_->[1] })->to_array;
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_COLLECTION

$fatpacked{"Mojo/Content.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT';
  package Mojo::Content;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Compress::Raw::Zlib qw(WANT_GZIP Z_STREAM_END);
  use Mojo::Headers;
  use Scalar::Util 'looks_like_number';
  
  has [qw(auto_decompress auto_relax expect_close relaxed skip_body)];
  has headers           => sub { Mojo::Headers->new };
  has max_buffer_size   => sub { $ENV{MOJO_MAX_BUFFER_SIZE} || 262144 };
  has max_leftover_size => sub { $ENV{MOJO_MAX_LEFTOVER_SIZE} || 262144 };
  
  my $BOUNDARY_RE
    = qr!multipart.*boundary\s*=\s*(?:"([^"]+)"|([\w'(),.:?\-+/]+))!i;
  
  sub body_contains {
    croak 'Method "body_contains" not implemented by subclass';
  }
  
  sub body_size { croak 'Method "body_size" not implemented by subclass' }
  
  sub boundary {
    (shift->headers->content_type // '') =~ $BOUNDARY_RE ? $1 // $2 : undef;
  }
  
  sub charset {
    my $type = shift->headers->content_type // '';
    return $type =~ /charset\s*=\s*"?([^"\s;]+)"?/i ? $1 : undef;
  }
  
  sub clone {
    my $self = shift;
    return undef if $self->is_dynamic;
    return $self->new(headers => $self->headers->clone);
  }
  
  sub generate_body_chunk {
    my ($self, $offset) = @_;
  
    $self->emit(drain => $offset) unless length($self->{body_buffer} //= '');
    my $len = $self->headers->content_length;
    return '' if looks_like_number $len && $len == $offset;
    my $chunk = delete $self->{body_buffer};
    return $self->{eof} ? '' : undef unless length $chunk;
  
    return $chunk;
  }
  
  sub get_body_chunk {
    croak 'Method "get_body_chunk" not implemented by subclass';
  }
  
  sub get_header_chunk { substr shift->_headers->{header_buffer}, shift, 131072 }
  
  sub header_size { length shift->_headers->{header_buffer} }
  
  sub headers_contain { index(shift->_headers->{header_buffer}, shift) >= 0 }
  
  sub is_chunked { !!shift->headers->transfer_encoding }
  
  sub is_compressed { lc(shift->headers->content_encoding // '') eq 'gzip' }
  
  sub is_dynamic { !!$_[0]{dynamic} }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub is_multipart {undef}
  
  sub is_parsing_body { (shift->{state} // '') eq 'body' }
  
  sub leftovers { shift->{buffer} }
  
  sub parse {
    my $self = shift;
  
    # Headers
    $self->_parse_until_body(@_);
    return $self if $self->{state} eq 'headers';
  
    # Chunked content
    $self->{real_size} //= 0;
    if ($self->is_chunked && $self->{state} ne 'headers') {
      $self->_parse_chunked;
      $self->{state} = 'finished' if ($self->{chunk_state} // '') eq 'finished';
    }
  
    # Not chunked, pass through to second buffer
    else {
      $self->{real_size} += length $self->{pre_buffer};
      my $limit = $self->is_finished
        && length($self->{buffer}) > $self->max_leftover_size;
      $self->{buffer} .= $self->{pre_buffer} unless $limit;
      $self->{pre_buffer} = '';
    }
  
    # No content
    if ($self->skip_body) {
      $self->{state} = 'finished';
      return $self;
    }
  
    # Relaxed parsing
    my $headers = $self->headers;
    my $len = $headers->content_length // '';
    if ($self->auto_relax && !length $len) {
      my $connection = lc($headers->connection // '');
      $self->relaxed(1)
        if $connection eq 'close' || (!$connection && $self->expect_close);
    }
  
    # Chunked or relaxed content
    if ($self->is_chunked || $self->relaxed) {
      $self->_decompress($self->{buffer} //= '');
      $self->{size} += length $self->{buffer};
      $self->{buffer} = '';
      return $self;
    }
  
    # Normal content
    $len = 0 unless looks_like_number $len;
    if ((my $need = $len - ($self->{size} ||= 0)) > 0) {
      my $len = length $self->{buffer};
      my $chunk = substr $self->{buffer}, 0, $need > $len ? $len : $need, '';
      $self->_decompress($chunk);
      $self->{size} += length $chunk;
    }
    $self->{state} = 'finished' if $len <= $self->progress;
  
    return $self;
  }
  
  sub parse_body {
    my $self = shift;
    $self->{state} = 'body';
    return $self->parse(@_);
  }
  
  sub progress {
    my $self = shift;
    return 0 unless my $state = $self->{state};
    return 0 unless $state eq 'body' || $state eq 'finished';
    return $self->{raw_size} - ($self->{header_size} || 0);
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
  
    $self->{dynamic} = 1;
    $self->{body_buffer} .= $chunk if defined $chunk;
    $self->once(drain => $cb) if $cb;
    $self->{eof} = 1 if defined $chunk && !length $chunk;
  
    return $self;
  }
  
  sub write_chunk {
    my ($self, $chunk, $cb) = @_;
    $self->headers->transfer_encoding('chunked') unless $self->is_chunked;
    $self->write(defined $chunk ? $self->_build_chunk($chunk) : $chunk, $cb);
    $self->{eof} = 1 if defined $chunk && !length $chunk;
    return $self;
  }
  
  sub _build_chunk {
    my ($self, $chunk) = @_;
  
    # End
    return "\x0d\x0a0\x0d\x0a\x0d\x0a" unless length $chunk;
  
    # First chunk has no leading CRLF
    my $crlf = $self->{chunks}++ ? "\x0d\x0a" : '';
    return $crlf . sprintf('%x', length $chunk) . "\x0d\x0a$chunk";
  }
  
  sub _decompress {
    my ($self, $chunk) = @_;
  
    # No compression
    return $self->emit(read => $chunk)
      unless $self->auto_decompress && $self->is_compressed;
  
    # Decompress
    $self->{post_buffer} .= $chunk;
    my $gz = $self->{gz}
      //= Compress::Raw::Zlib::Inflate->new(WindowBits => WANT_GZIP);
    my $status = $gz->inflate(\$self->{post_buffer}, my $out);
    $self->emit(read => $out) if defined $out;
  
    # Replace Content-Encoding with Content-Length
    $self->headers->content_length($gz->total_out)->remove('Content-Encoding')
      if $status == Z_STREAM_END;
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{post_buffer} // '') > $self->max_buffer_size;
  }
  
  sub _headers {
    my $self = shift;
    return $self if defined $self->{header_buffer};
    my $headers = $self->headers->to_string;
    $self->{header_buffer} = $headers ? "$headers\x0d\x0a\x0d\x0a" : "\x0d\x0a";
    return $self;
  }
  
  sub _parse_chunked {
    my $self = shift;
  
    # Trailing headers
    return $self->_parse_chunked_trailing_headers
      if ($self->{chunk_state} // '') eq 'trailing_headers';
  
    while (my $len = length $self->{pre_buffer}) {
  
      # Start new chunk (ignore the chunk extension)
      unless ($self->{chunk_len}) {
        last
          unless $self->{pre_buffer} =~ s/^(?:\x0d?\x0a)?([0-9a-fA-F]+).*\x0a//;
        next if $self->{chunk_len} = hex $1;
  
        # Last chunk
        $self->{chunk_state} = 'trailing_headers';
        last;
      }
  
      # Remove as much as possible from payload
      $len = $self->{chunk_len} if $self->{chunk_len} < $len;
      $self->{buffer} .= substr $self->{pre_buffer}, 0, $len, '';
      $self->{real_size} += $len;
      $self->{chunk_len} -= $len;
    }
  
    # Trailing headers
    $self->_parse_chunked_trailing_headers
      if ($self->{chunk_state} // '') eq 'trailing_headers';
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{pre_buffer} // '') > $self->max_buffer_size;
  }
  
  sub _parse_chunked_trailing_headers {
    my $self = shift;
  
    my $headers = $self->headers->parse(delete $self->{pre_buffer});
    return unless $headers->is_finished;
    $self->{chunk_state} = 'finished';
  
    # Take care of leftover and replace Transfer-Encoding with Content-Length
    $self->{buffer} .= $headers->leftovers;
    $headers->remove('Transfer-Encoding');
    $headers->content_length($self->{real_size}) unless $headers->content_length;
  }
  
  sub _parse_headers {
    my $self = shift;
  
    my $headers = $self->headers->parse(delete $self->{pre_buffer});
    return unless $headers->is_finished;
    $self->{state} = 'body';
  
    # Take care of leftovers
    my $leftovers = $self->{pre_buffer} = $headers->leftovers;
    $self->{header_size} = $self->{raw_size} - length $leftovers;
  }
  
  sub _parse_until_body {
    my ($self, $chunk) = @_;
  
    $self->{raw_size} += length($chunk //= '');
    $self->{pre_buffer} .= $chunk;
    $self->_parse_headers if ($self->{state} ||= 'headers') eq 'headers';
    $self->emit('body') if $self->{state} ne 'headers' && !$self->{body}++;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content - HTTP content base class
  
  =head1 SYNOPSIS
  
    package Mojo::Content::MyContent;
    use Mojo::Base 'Mojo::Content';
  
    sub body_contains  {...}
    sub body_size      {...}
    sub get_body_chunk {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Content> is an abstract base class for HTTP content containers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>, like
  L<Mojo::Content::MultiPart> and L<Mojo::Content::Single>.
  
  =head1 EVENTS
  
  L<Mojo::Content> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 body
  
    $content->on(body => sub {
      my $content = shift;
      ...
    });
  
  Emitted once all headers have been parsed and the body starts.
  
    $content->on(body => sub {
      my $content = shift;
      $content->auto_upgrade(0) if $content->headers->header('X-No-MultiPart');
    });
  
  =head2 drain
  
    $content->on(drain => sub {
      my ($content, $offset) = @_;
      ...
    });
  
  Emitted once all data has been written.
  
    $content->on(drain => sub {
      my $content = shift;
      $content->write_chunk(time);
    });
  
  =head2 read
  
    $content->on(read => sub {
      my ($content, $bytes) = @_;
      ...
    });
  
  Emitted when a new chunk of content arrives.
  
    $content->unsubscribe('read')->on(read => sub {
      my ($content, $bytes) = @_;
      say "Streaming: $bytes";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content> implements the following attributes.
  
  =head2 auto_decompress
  
    my $bool = $content->auto_decompress;
    $content = $content->auto_decompress($bool);
  
  Decompress content automatically if L</"is_compressed"> is true.
  
  =head2 auto_relax
  
    my $bool = $content->auto_relax;
    $content = $content->auto_relax($bool);
  
  Try to detect when relaxed parsing is necessary.
  
  =head2 expect_close
  
    my $bool = $content->expect_close;
    $content = $content->expect_close($bool);
  
  Expect a response that is terminated with a connection close.
  
  =head2 headers
  
    my $headers = $content->headers;
    $content    = $content->headers(Mojo::Headers->new);
  
  Content headers, defaults to a L<Mojo::Headers> object.
  
  =head2 max_buffer_size
  
    my $size = $content->max_buffer_size;
    $content = $content->max_buffer_size(1024);
  
  Maximum size in bytes of buffer for content parser, defaults to the value of
  the C<MOJO_MAX_BUFFER_SIZE> environment variable or C<262144> (256KB).
  
  =head2 max_leftover_size
  
    my $size = $content->max_leftover_size;
    $content = $content->max_leftover_size(1024);
  
  Maximum size in bytes of buffer for pipelined HTTP requests, defaults to the
  value of the C<MOJO_MAX_LEFTOVER_SIZE> environment variable or C<262144>
  (256KB).
  
  =head2 relaxed
  
    my $bool = $content->relaxed;
    $content = $content->relaxed($bool);
  
  Activate relaxed parsing for responses that are terminated with a connection
  close.
  
  =head2 skip_body
  
    my $bool = $content->skip_body;
    $content = $content->skip_body($bool);
  
  Skip body parsing and finish after headers.
  
  =head1 METHODS
  
  L<Mojo::Content> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 body_contains
  
    my $bool = $content->body_contains('foo bar baz');
  
  Check if content contains a specific string. Meant to be overloaded in a
  subclass.
  
  =head2 body_size
  
    my $size = $content->body_size;
  
  Content size in bytes. Meant to be overloaded in a subclass.
  
  =head2 boundary
  
    my $boundary = $content->boundary;
  
  Extract multipart boundary from C<Content-Type> header.
  
  =head2 charset
  
    my $charset = $content->charset;
  
  Extract charset from C<Content-Type> header.
  
  =head2 clone
  
    my $clone = $content->clone;
  
  Clone content if possible, otherwise return C<undef>.
  
  =head2 generate_body_chunk
  
    my $bytes = $content->generate_body_chunk(0);
  
  Generate dynamic content.
  
  =head2 get_body_chunk
  
    my $bytes = $content->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Meant to be
  overloaded in a subclass.
  
  =head2 get_header_chunk
  
    my $bytes = $content->get_header_chunk(13);
  
  Get a chunk of the headers starting from a specific position. Note that this
  method finalizes the content.
  
  =head2 header_size
  
    my $size = $content->header_size;
  
  Size of headers in bytes. Note that this method finalizes the content.
  
  =head2 headers_contain
  
    my $bool = $content->headers_contain('foo bar baz');
  
  Check if headers contain a specific string. Note that this method finalizes the
  content.
  
  =head2 is_chunked
  
    my $bool = $content->is_chunked;
  
  Check if C<Transfer-Encoding> header indicates chunked tranfer encoding.
  
  =head2 is_compressed
  
    my $bool = $content->is_compressed;
  
  Check C<Content-Encoding> header for C<gzip> value.
  
  =head2 is_dynamic
  
    my $bool = $content->is_dynamic;
  
  Check if content will be dynamically generated, which prevents L</"clone"> from
  working.
  
  =head2 is_finished
  
    my $bool = $content->is_finished;
  
  Check if parser is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $content->is_limit_exceeded;
  
  Check if buffer has exceeded L</"max_buffer_size">.
  
  =head2 is_multipart
  
    my $bool = $content->is_multipart;
  
  False, this is not a L<Mojo::Content::MultiPart> object.
  
  =head2 is_parsing_body
  
    my $bool = $content->is_parsing_body;
  
  Check if body parsing started yet.
  
  =head2 leftovers
  
    my $bytes = $content->leftovers;
  
  Get leftover data from content parser.
  
  =head2 parse
  
    $content
      = $content->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
  
  Parse content chunk.
  
  =head2 parse_body
  
    $content = $content->parse_body('Hi!');
  
  Parse body chunk and skip headers.
  
  =head2 progress
  
    my $size = $content->progress;
  
  Size of content already received from message in bytes.
  
  =head2 write
  
    $content = $content->write;
    $content = $content->write('');
    $content = $content->write($bytes);
    $content = $content->write($bytes => sub {...});
  
  Write dynamic content non-blocking, the optional drain callback will be executed
  once all data has been written. Calling this method without a chunk of data
  will finalize the L</"headers"> and allow for dynamic content to be written
  later. You can write an empty chunk of data at any time to end the stream.
  
    # Make sure previous chunk of data has been written before continuing
    $content->write('He' => sub {
      my $content = shift;
      $content->write('llo!' => sub {
        my $content = shift;
        $content->write('');
      });
    });
  
  =head2 write_chunk
  
    $content = $content->write_chunk;
    $content = $content->write_chunk('');
    $content = $content->write_chunk($bytes);
    $content = $content->write_chunk($bytes => sub {...});
  
  Write dynamic content non-blocking with chunked transfer encoding, the optional
  drain callback will be executed once all data has been written. Calling this
  method without a chunk of data will finalize the L</"headers"> and allow for
  dynamic content to be written later. You can write an empty chunk of data at any
  time to end the stream.
  
    # Make sure previous chunk of data has been written before continuing
    $content->write_chunk('He' => sub {
      my $content = shift;
      $content->write_chunk('llo!' => sub {
        my $content = shift;
        $content->write_chunk('');
      });
    });
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_CONTENT

$fatpacked{"Mojo/Content/MultiPart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_MULTIPART';
  package Mojo::Content::MultiPart;
  use Mojo::Base 'Mojo::Content';
  
  use Mojo::Util 'b64_encode';
  
  has parts => sub { [] };
  
  sub body_contains {
    my ($self, $chunk) = @_;
    ($_->headers_contain($chunk) or $_->body_contains($chunk)) and return 1
      for @{$self->parts};
    return undef;
  }
  
  sub body_size {
    my $self = shift;
  
    # Check for existing Content-Lenght header
    if (my $len = $self->headers->content_length) { return $len }
  
    # Calculate length of whole body
    my $len = my $boundary_len = length($self->build_boundary) + 6;
    $len += $_->header_size + $_->body_size + $boundary_len for @{$self->parts};
  
    return $len;
  }
  
  sub build_boundary {
    my $self = shift;
  
    # Check for existing boundary
    my $boundary;
    return $boundary if defined($boundary = $self->boundary);
  
    # Generate and check boundary
    my $size = 1;
    do {
      $boundary = b64_encode join('', map chr(rand 256), 1 .. $size++ * 3);
      $boundary =~ s/\W/X/g;
    } while $self->body_contains($boundary);
  
    # Add boundary to Content-Type header
    my $headers = $self->headers;
    ($headers->content_type // '') =~ m!^(.*multipart/[^;]+)(.*)$!;
    my $before = $1 || 'multipart/mixed';
    my $after  = $2 || '';
    $headers->content_type("$before; boundary=$boundary$after");
  
    return $boundary;
  }
  
  sub clone {
    my $self = shift;
    return undef unless my $clone = $self->SUPER::clone();
    return $clone->parts($self->parts);
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
  
    # Body generator
    return $self->generate_body_chunk($offset) if $self->{dynamic};
  
    # First boundary
    my $boundary     = $self->build_boundary;
    my $boundary_len = length($boundary) + 6;
    my $len          = $boundary_len - 2;
    return substr "--$boundary\x0d\x0a", $offset if $len > $offset;
  
    # Prepare content part by part
    my $parts = $self->parts;
    for (my $i = 0; $i < @$parts; $i++) {
      my $part = $parts->[$i];
  
      # Headers
      my $header_len = $part->header_size;
      return $part->get_header_chunk($offset - $len)
        if ($len + $header_len) > $offset;
      $len += $header_len;
  
      # Content
      my $content_len = $part->body_size;
      return $part->get_body_chunk($offset - $len)
        if ($len + $content_len) > $offset;
      $len += $content_len;
  
      # Boundary
      if ($#$parts == $i) {
        $boundary .= '--';
        $boundary_len += 2;
      }
      return substr "\x0d\x0a--$boundary\x0d\x0a", $offset - $len
        if ($len + $boundary_len) > $offset;
      $len += $boundary_len;
    }
  }
  
  sub is_multipart {1}
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(read => \&_read);
    return $self;
  }
  
  sub _parse_multipart_body {
    my ($self, $boundary) = @_;
  
    # Whole part in buffer
    my $pos = index $self->{multipart}, "\x0d\x0a--$boundary";
    if ($pos < 0) {
      my $len = length($self->{multipart}) - (length($boundary) + 8);
      return undef unless $len > 0;
  
      # Store chunk
      my $chunk = substr $self->{multipart}, 0, $len, '';
      $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
      return undef;
    }
  
    # Store chunk
    my $chunk = substr $self->{multipart}, 0, $pos, '';
    $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
    return !!($self->{multi_state} = 'multipart_boundary');
  }
  
  sub _parse_multipart_boundary {
    my ($self, $boundary) = @_;
  
    # Boundary begins
    if ((index $self->{multipart}, "\x0d\x0a--$boundary\x0d\x0a") == 0) {
      substr $self->{multipart}, 0, length($boundary) + 6, '';
  
      # New part
      my $part = Mojo::Content::Single->new(relaxed => 1);
      $self->emit(part => $part);
      push @{$self->parts}, $part;
      return !!($self->{multi_state} = 'multipart_body');
    }
  
    # Boundary ends
    my $end = "\x0d\x0a--$boundary--";
    if ((index $self->{multipart}, $end) == 0) {
      substr $self->{multipart}, 0, length $end, '';
      $self->{multi_state} = 'finished';
    }
  
    return undef;
  }
  
  sub _parse_multipart_preamble {
    my ($self, $boundary) = @_;
  
    # No boundary yet
    return undef if (my $pos = index $self->{multipart}, "--$boundary") < 0;
  
    # Replace preamble with carriage return and line feed
    substr $self->{multipart}, 0, $pos, "\x0d\x0a";
  
    # Parse boundary
    return !!($self->{multi_state} = 'multipart_boundary');
  }
  
  sub _read {
    my ($self, $chunk) = @_;
  
    $self->{multipart} .= $chunk;
    my $boundary = $self->boundary;
    until (($self->{multi_state} //= 'multipart_preamble') eq 'finished') {
  
      # Preamble
      if ($self->{multi_state} eq 'multipart_preamble') {
        last unless $self->_parse_multipart_preamble($boundary);
      }
  
      # Boundary
      elsif ($self->{multi_state} eq 'multipart_boundary') {
        last unless $self->_parse_multipart_boundary($boundary);
      }
  
      # Body
      elsif ($self->{multi_state} eq 'multipart_body') {
        last unless $self->_parse_multipart_body($boundary);
      }
    }
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{multipart} // '') > $self->max_buffer_size;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content::MultiPart - HTTP multipart content
  
  =head1 SYNOPSIS
  
    use Mojo::Content::MultiPart;
  
    my $multi = Mojo::Content::MultiPart->new;
    $multi->parse('Content-Type: multipart/mixed; boundary=---foobar');
    my $single = $multi->parts->[4];
  
  =head1 DESCRIPTION
  
  L<Mojo::Content::MultiPart> is a container for HTTP multipart content, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 2388|http://tools.ietf.org/html/rfc2388>.
  
  =head1 EVENTS
  
  L<Mojo::Content::Multipart> inherits all events from L<Mojo::Content> and can
  emit the following new ones.
  
  =head2 part
  
    $multi->on(part => sub {
      my ($multi, $single) = @_;
      ...
    });
  
  Emitted when a new L<Mojo::Content::Single> part starts.
  
    $multi->on(part => sub {
      my ($multi, $single) = @_;
      return unless $single->headers->content_disposition =~ /name="([^"]+)"/;
      say "Field: $1";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content::MultiPart> inherits all attributes from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 parts
  
    my $parts = $multi->parts;
    $multi    = $multi->parts([Mojo::Content::Single->new]);
  
  Content parts embedded in this multipart content, usually
  L<Mojo::Content::Single> objects.
  
  =head1 METHODS
  
  L<Mojo::Content::MultiPart> inherits all methods from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 body_contains
  
    my $bool = $multi->body_contains('foobarbaz');
  
  Check if content parts contain a specific string.
  
  =head2 body_size
  
    my $size = $multi->body_size;
  
  Content size in bytes.
  
  =head2 build_boundary
  
    my $boundary = $multi->build_boundary;
  
  Generate a suitable boundary for content and add it to C<Content-Type> header.
  
  =head2 clone
  
    my $clone = $multi->clone;
  
  Clone content if possible, otherwise return C<undef>.
  
  =head2 get_body_chunk
  
    my $bytes = $multi->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 is_multipart
  
    my $bool = $multi->is_multipart;
  
  True, this is a L<Mojo::Content::MultiPart> object.
  
  =head2 new
  
    my $multi = Mojo::Content::MultiPart->new;
    my $multi
      = Mojo::Content::MultiPart->new(parts => [Mojo::Content::Single->new]);
    my $multi
      = Mojo::Content::MultiPart->new({parts => [Mojo::Content::Single->new]});
  
  Construct a new L<Mojo::Content::MultiPart> object and subscribe to L</"read">
  event with default content parser.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_CONTENT_MULTIPART

$fatpacked{"Mojo/Content/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_SINGLE';
  package Mojo::Content::Single;
  use Mojo::Base 'Mojo::Content';
  
  use Mojo::Asset::Memory;
  use Mojo::Content::MultiPart;
  
  has asset => sub { Mojo::Asset::Memory->new(auto_upgrade => 1) };
  has auto_upgrade => 1;
  
  sub body_contains { shift->asset->contains(shift) >= 0 }
  
  sub body_size {
    my $self = shift;
    return ($self->headers->content_length || 0) if $self->{dynamic};
    return $self->asset->size;
  }
  
  sub clone {
    my $self = shift;
    return undef unless my $clone = $self->SUPER::clone();
    return $clone->asset($self->asset);
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
    return $self->generate_body_chunk($offset) if $self->{dynamic};
    return $self->asset->get_chunk($offset);
  }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->{read}
      = $self->on(read => sub { $_[0]->asset($_[0]->asset->add_chunk($_[1])) });
    return $self;
  }
  
  sub parse {
    my $self = shift;
  
    # Parse headers
    $self->_parse_until_body(@_);
  
    # Parse body
    return $self->SUPER::parse
      unless $self->auto_upgrade && defined $self->boundary;
  
    # Content needs to be upgraded to multipart
    $self->unsubscribe(read => $self->{read});
    my $multi = Mojo::Content::MultiPart->new(%$self);
    $self->emit(upgrade => $multi);
    return $multi->parse;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content::Single - HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Content::Single;
  
    my $single = Mojo::Content::Single->new;
    $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
    say $single->headers->content_length;
  
  =head1 DESCRIPTION
  
  L<Mojo::Content::Single> is a container for HTTP content, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Content::Single> inherits all events from L<Mojo::Content> and can emit
  the following new ones.
  
  =head2 upgrade
  
    $single->on(upgrade => sub {
      my ($single, $multi) = @_;
      ...
    });
  
  Emitted when content gets upgraded to a L<Mojo::Content::MultiPart> object.
  
    $single->on(upgrade => sub {
      my ($single, $multi) = @_;
      return unless $multi->headers->content_type =~ /multipart\/([^;]+)/i;
      say "Multipart: $1";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content::Single> inherits all attributes from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 asset
  
    my $asset = $single->asset;
    $single   = $single->asset(Mojo::Asset::Memory->new);
  
  The actual content, defaults to a L<Mojo::Asset::Memory> object with
  L<Mojo::Asset::Memory/"auto_upgrade"> enabled.
  
  =head2 auto_upgrade
  
    my $bool = $single->auto_upgrade;
    $single  = $single->auto_upgrade($bool);
  
  Try to detect multipart content and automatically upgrade to a
  L<Mojo::Content::MultiPart> object, defaults to a true value.
  
  =head1 METHODS
  
  L<Mojo::Content::Single> inherits all methods from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 body_contains
  
    my $bool = $single->body_contains('1234567');
  
  Check if content contains a specific string.
  
  =head2 body_size
  
    my $size = $single->body_size;
  
  Content size in bytes.
  
  =head2 clone
  
    my $clone = $single->clone;
  
  Clone content if possible, otherwise return C<undef>.
  
  =head2 get_body_chunk
  
    my $bytes = $single->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 new
  
    my $single = Mojo::Content::Single->new;
    my $single = Mojo::Content::Single->new(asset => Mojo::Asset::File->new);
    my $single = Mojo::Content::Single->new({asset => Mojo::Asset::File->new});
  
  Construct a new L<Mojo::Content::Single> object and subscribe to L</"read">
  event with default content parser.
  
  =head2 parse
  
    $single = $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
    my $multi
      = $single->parse("Content-Type: multipart/form-data\x0d\x0a\x0d\x0a");
  
  Parse content chunk and upgrade to L<Mojo::Content::MultiPart> object if
  necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_CONTENT_SINGLE

$fatpacked{"Mojo/Cookie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE';
  package Mojo::Cookie;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Carp 'croak';
  
  has [qw(name value)];
  
  sub parse     { croak 'Method "parse" not implemented by subclass' }
  sub to_string { croak 'Method "to_string" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie - HTTP cookie base class
  
  =head1 SYNOPSIS
  
    package Mojo::Cookie::MyCookie;
    use Mojo::Base 'Mojo::Cookie';
  
    sub parse     {...}
    sub to_string {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie> is an abstract base class for HTTP cookie containers, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>, like L<Mojo::Cookie::Request>
  and L<Mojo::Cookie::Response>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie> implements the following attributes.
  
  =head2 name
  
    my $name = $cookie->name;
    $cookie  = $cookie->name('foo');
  
  Cookie name.
  
  =head2 value
  
    my $value = $cookie->value;
    $cookie   = $cookie->value('/test');
  
  Cookie value.
  
  =head1 METHODS
  
  L<Mojo::Cookie> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    my $cookies = $cookie->parse($str);
  
  Parse cookies. Meant to be overloaded in a subclass.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie. Meant to be overloaded in a subclass.
  
  =head1 OPERATORS
  
  L<Mojo::Cookie> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$cookie;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$cookie";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_COOKIE

$fatpacked{"Mojo/Cookie/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_REQUEST';
  package Mojo::Cookie::Request;
  use Mojo::Base 'Mojo::Cookie';
  
  use Mojo::Util qw(quote split_header);
  
  sub parse {
    my ($self, $str) = @_;
  
    my @cookies;
    my @pairs = map {@$_} @{split_header $str // ''};
    while (my ($name, $value) = splice @pairs, 0, 2) {
      next if $name =~ /^\$/;
      push @cookies, $self->new(name => $name, value => $value // '');
    }
  
    return \@cookies;
  }
  
  sub to_string {
    my $self = shift;
    return '' unless length(my $name = $self->name // '');
    my $value = $self->value // '';
    return join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie::Request - HTTP request cookie
  
  =head1 SYNOPSIS
  
    use Mojo::Cookie::Request;
  
    my $cookie = Mojo::Cookie::Request->new;
    $cookie->name('foo');
    $cookie->value('bar');
    say "$cookie";
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie::Request> is a container for HTTP request cookies, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie::Request> inherits all attributes from L<Mojo::Cookie>.
  
  =head1 METHODS
  
  L<Mojo::Cookie::Request> inherits all methods from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 parse
  
    my $cookies = Mojo::Cookie::Request->parse('f=b; g=a');
  
  Parse cookies.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_COOKIE_REQUEST

$fatpacked{"Mojo/Cookie/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_RESPONSE';
  package Mojo::Cookie::Response;
  use Mojo::Base 'Mojo::Cookie';
  
  use Mojo::Date;
  use Mojo::Util qw(quote split_cookie_header);
  
  has [qw(domain expires httponly max_age origin path secure)];
  
  my %ATTRS = map { $_ => 1 } qw(domain expires httponly max-age path secure);
  
  sub parse {
    my ($self, $str) = @_;
  
    my @cookies;
    my $tree = split_cookie_header $str // '';
    while (my $pairs = shift @$tree) {
      my ($name, $value) = splice @$pairs, 0, 2;
      push @cookies, $self->new(name => $name, value => $value // '');
  
      while (my ($name, $value) = splice @$pairs, 0, 2) {
        next unless $ATTRS{my $attr = lc $name};
        $value =~ s/^\.// if $attr eq 'domain' && defined $value;
        $value = Mojo::Date->new($value // '')->epoch if $attr eq 'expires';
        $value = 1 if $attr eq 'secure' || $attr eq 'httponly';
        $cookies[-1]{$attr eq 'max-age' ? 'max_age' : $attr} = $value;
      }
    }
  
    return \@cookies;
  }
  
  sub to_string {
    my $self = shift;
  
    # Name and value
    return '' unless length(my $name = $self->name // '');
    my $value = $self->value // '';
    my $cookie = join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
  
    # "expires"
    my $expires = $self->expires;
    $cookie .= '; expires=' . Mojo::Date->new($expires) if defined $expires;
  
    # "domain"
    if (my $domain = $self->domain) { $cookie .= "; domain=$domain" }
  
    # "path"
    if (my $path = $self->path) { $cookie .= "; path=$path" }
  
    # "secure"
    $cookie .= "; secure" if $self->secure;
  
    # "HttpOnly"
    $cookie .= "; HttpOnly" if $self->httponly;
  
    # "Max-Age"
    if (defined(my $max = $self->max_age)) { $cookie .= "; Max-Age=$max" }
  
    return $cookie;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie::Response - HTTP response cookie
  
  =head1 SYNOPSIS
  
    use Mojo::Cookie::Response;
  
    my $cookie = Mojo::Cookie::Response->new;
    $cookie->name('foo');
    $cookie->value('bar');
    say "$cookie";
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie::Response> is a container for HTTP response cookies, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie::Response> inherits all attributes from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 domain
  
    my $domain = $cookie->domain;
    $cookie    = $cookie->domain('localhost');
  
  Cookie domain.
  
  =head2 expires
  
    my $expires = $cookie->expires;
    $cookie     = $cookie->expires(time + 60);
  
  Expiration for cookie.
  
  =head2 httponly
  
    my $bool = $cookie->httponly;
    $cookie  = $cookie->httponly($bool);
  
  HttpOnly flag, which can prevent client-side scripts from accessing this
  cookie.
  
  =head2 max_age
  
    my $max_age = $cookie->max_age;
    $cookie     = $cookie->max_age(60);
  
  Max age for cookie.
  
  =head2 origin
  
    my $origin = $cookie->origin;
    $cookie    = $cookie->origin('mojolicious.org');
  
  Origin of the cookie.
  
  =head2 path
  
    my $path = $cookie->path;
    $cookie  = $cookie->path('/test');
  
  Cookie path.
  
  =head2 secure
  
    my $bool = $cookie->secure;
    $cookie  = $cookie->secure($bool);
  
  Secure flag, which instructs browsers to only send this cookie over HTTPS
  connections.
  
  =head1 METHODS
  
  L<Mojo::Cookie::Response> inherits all methods from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 parse
  
    my $cookies = Mojo::Cookie::Response->parse('f=b; path=/');
  
  Parse cookies.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_COOKIE_RESPONSE

$fatpacked{"Mojo/DOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM';
  package Mojo::DOM;
  use Mojo::Base -strict;
  use overload
    '@{}'    => sub { shift->child_nodes },
    '%{}'    => sub { shift->attr },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  # "Fry: This snow is beautiful. I'm glad global warming never happened.
  #  Leela: Actually, it did. But thank God nuclear winter canceled it out."
  use Carp 'croak';
  use Mojo::Collection;
  use Mojo::DOM::CSS;
  use Mojo::DOM::HTML;
  use Mojo::Util 'squish';
  use Scalar::Util qw(blessed weaken);
  
  sub all_text { shift->_all_text(1, @_) }
  
  sub ancestors { _select($_[0]->_collect($_[0]->_ancestors), $_[1]) }
  
  sub append { shift->_add(1, @_) }
  sub append_content { shift->_content(1, 0, @_) }
  
  sub at {
    my $self = shift;
    return undef unless my $result = $self->_css->select_one(@_);
    return $self->_build($result, $self->xml);
  }
  
  sub attr {
    my $self = shift;
  
    # Hash
    my $tree = $self->tree;
    my $attrs = $tree->[0] ne 'tag' ? {} : $tree->[2];
    return $attrs unless @_;
  
    # Get
    return $attrs->{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$attrs{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub child_nodes { $_[0]->_collect(_nodes($_[0]->tree)) }
  
  sub children { _select($_[0]->_collect(_nodes($_[0]->tree, 1)), $_[1]) }
  
  sub content {
    my $self = shift;
  
    my $type = $self->type;
    if ($type eq 'root' || $type eq 'tag') {
      return $self->_content(0, 1, @_) if @_;
      my $html = Mojo::DOM::HTML->new(xml => $self->xml);
      return join '', map { $html->tree($_)->render } _nodes($self->tree);
    }
  
    return $self->tree->[1] unless @_;
    $self->tree->[1] = shift;
    return $self;
  }
  
  sub descendant_nodes { $_[0]->_collect(_all(_nodes($_[0]->tree))) }
  
  sub find { $_[0]->_collect(@{$_[0]->_css->select($_[1])}) }
  
  sub following { _select($_[0]->_collect(@{$_[0]->_siblings(1)->[1]}), $_[1]) }
  sub following_nodes { $_[0]->_collect(@{$_[0]->_siblings->[1]}) }
  
  sub matches { shift->_css->matches(@_) }
  
  sub namespace {
    my $self = shift;
  
    return undef if (my $tree = $self->tree)->[0] ne 'tag';
  
    # Extract namespace prefix and search parents
    my $ns = $tree->[1] =~ /^(.*?):/ ? "xmlns:$1" : undef;
    for my $node ($tree, $self->_ancestors) {
  
      # Namespace for prefix
      my $attrs = $node->[2];
      if ($ns) { $_ eq $ns and return $attrs->{$_} for keys %$attrs }
  
      # Namespace attribute
      elsif (defined $attrs->{xmlns}) { return $attrs->{xmlns} }
    }
  
    return undef;
  }
  
  sub new {
    my $class = shift;
    my $self = bless \Mojo::DOM::HTML->new, ref $class || $class;
    return @_ ? $self->parse(@_) : $self;
  }
  
  sub next      { $_[0]->_maybe($_[0]->_siblings(1, 0)->[1]) }
  sub next_node { $_[0]->_maybe($_[0]->_siblings(0, 0)->[1]) }
  
  sub parent {
    my $self = shift;
    return undef if $self->tree->[0] eq 'root';
    return $self->_build($self->_parent, $self->xml);
  }
  
  sub parse { shift->_delegate(parse => @_) }
  
  sub preceding { _select($_[0]->_collect(@{$_[0]->_siblings(1)->[0]}), $_[1]) }
  sub preceding_nodes { $_[0]->_collect(@{$_[0]->_siblings->[0]}) }
  
  sub prepend { shift->_add(0, @_) }
  sub prepend_content { shift->_content(0, 0, @_) }
  
  sub previous      { $_[0]->_maybe($_[0]->_siblings(1, -1)->[0]) }
  sub previous_node { $_[0]->_maybe($_[0]->_siblings(0, -1)->[0]) }
  
  sub remove { shift->replace('') }
  
  sub replace {
    my ($self, $new) = @_;
    return $self->parse($new) if (my $tree = $self->tree)->[0] eq 'root';
    return $self->_replace($self->_parent, $tree, _nodes($self->_parse($new)));
  }
  
  sub root {
    my $self = shift;
    return $self unless my $tree = $self->_ancestors(1);
    return $self->_build($tree, $self->xml);
  }
  
  sub strip {
    my $self = shift;
    return $self if (my $tree = $self->tree)->[0] ne 'tag';
    return $self->_replace($tree->[3], $tree, _nodes($tree));
  }
  
  sub tag {
    my ($self, $tag) = @_;
    return undef if (my $tree = $self->tree)->[0] ne 'tag';
    return $tree->[1] unless $tag;
    $tree->[1] = $tag;
    return $self;
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub text { shift->_all_text(0, @_) }
  
  sub to_string { shift->_delegate('render') }
  
  sub tree { shift->_delegate(tree => @_) }
  
  sub type { shift->tree->[0] }
  
  sub val {
    my $self = shift;
  
    # "option"
    return $self->{value} // $self->text if (my $tag = $self->tag) eq 'option';
  
    # "input" ("type=checkbox" and "type=radio")
    my $type = $self->{type} // '';
    return $self->{value} // 'on'
      if $tag eq 'input' && ($type eq 'radio' || $type eq 'checkbox');
  
    # "textarea", "input" or "button"
    return $tag eq 'textarea' ? $self->text : $self->{value} if $tag ne 'select';
  
    # "select"
    my $v = $self->find('option:checked')->map('val');
    return exists $self->{multiple} ? $v->size ? $v->to_array : undef : $v->last;
  }
  
  sub wrap         { shift->_wrap(0, @_) }
  sub wrap_content { shift->_wrap(1, @_) }
  
  sub xml { shift->_delegate(xml => @_) }
  
  sub _add {
    my ($self, $offset, $new) = @_;
  
    return $self if (my $tree = $self->tree)->[0] eq 'root';
  
    my $parent = $self->_parent;
    splice @$parent, _offset($parent, $tree) + $offset, 0,
      _link($parent, _nodes($self->_parse($new)));
  
    return $self;
  }
  
  sub _all {
    map { $_->[0] eq 'tag' ? ($_, _all(_nodes($_))) : ($_) } @_;
  }
  
  sub _all_text {
    my ($self, $recurse, $trim) = (shift, shift, shift // 1);
  
    # Detect "pre" tag
    my $tree = $self->tree;
    map { $_->[1] eq 'pre' and $trim = 0 } $self->_ancestors, $tree
      if $trim && $tree->[0] ne 'root';
  
    return _text([_nodes($tree)], $recurse, $trim);
  }
  
  sub _ancestors {
    my ($self, $root) = @_;
  
    return () unless my $tree = $self->_parent;
    my @ancestors;
    do { push @ancestors, $tree }
      while ($tree->[0] eq 'tag') && ($tree = $tree->[3]);
    return $root ? $ancestors[-1] : @ancestors[0 .. $#ancestors - 1];
  }
  
  sub _build { shift->new->tree(shift)->xml(shift) }
  
  sub _collect {
    my $self = shift;
    my $xml  = $self->xml;
    return Mojo::Collection->new(map { $self->_build($_, $xml) } @_);
  }
  
  sub _content {
    my ($self, $start, $offset, $new) = @_;
  
    my $tree = $self->tree;
    unless ($tree->[0] eq 'root' || $tree->[0] eq 'tag') {
      my $old = $self->content;
      return $self->content($start ? $old . $new : $new . $old);
    }
  
    $start  = $start  ? ($#$tree + 1) : _start($tree);
    $offset = $offset ? $#$tree       : 0;
    splice @$tree, $start, $offset, _link($tree, _nodes($self->_parse($new)));
  
    return $self;
  }
  
  sub _css { Mojo::DOM::CSS->new(tree => shift->tree) }
  
  sub _delegate {
    my ($self, $method) = (shift, shift);
    return $$self->$method unless @_;
    $$self->$method(@_);
    return $self;
  }
  
  sub _link {
    my ($parent, @children) = @_;
  
    # Link parent to children
    for my $node (@children) {
      my $offset = $node->[0] eq 'tag' ? 3 : 2;
      $node->[$offset] = $parent;
      weaken $node->[$offset];
    }
  
    return @children;
  }
  
  sub _maybe { $_[1] ? $_[0]->_build($_[1], $_[0]->xml) : undef }
  
  sub _nodes {
    return () unless my $tree = shift;
    my @nodes = @$tree[_start($tree) .. $#$tree];
    return shift() ? grep { $_->[0] eq 'tag' } @nodes : @nodes;
  }
  
  sub _offset {
    my ($parent, $child) = @_;
    my $i = _start($parent);
    $_ eq $child ? last : $i++ for @$parent[$i .. $#$parent];
    return $i;
  }
  
  sub _parent { $_[0]->tree->[$_[0]->type eq 'tag' ? 3 : 2] }
  
  sub _parse { Mojo::DOM::HTML->new(xml => shift->xml)->parse(shift)->tree }
  
  sub _replace {
    my ($self, $parent, $child, @nodes) = @_;
    splice @$parent, _offset($parent, $child), 1, _link($parent, @nodes);
    return $self->parent;
  }
  
  sub _select {
    my ($collection, $selector) = @_;
    return $collection unless $selector;
    return $collection->new(grep { $_->matches($selector) } @$collection);
  }
  
  sub _siblings {
    my ($self, $tags, $i) = @_;
  
    return [] unless my $parent = $self->parent;
  
    my $tree = $self->tree;
    my (@before, @after, $match);
    for my $node (_nodes($parent->tree)) {
      ++$match and next if !$match && $node eq $tree;
      next if $tags && $node->[0] ne 'tag';
      $match ? push @after, $node : push @before, $node;
    }
  
    return defined $i ? [$before[$i], $after[$i]] : [\@before, \@after];
  }
  
  sub _start { $_[0][0] eq 'root' ? 1 : 4 }
  
  sub _text {
    my ($nodes, $recurse, $trim) = @_;
  
    # Merge successive text nodes
    my $i = 0;
    while (my $next = $nodes->[$i + 1]) {
      ++$i and next unless $nodes->[$i][0] eq 'text' && $next->[0] eq 'text';
      splice @$nodes, $i, 2, ['text', $nodes->[$i][1] . $next->[1]];
    }
  
    my $text = '';
    for my $node (@$nodes) {
      my $type = $node->[0];
  
      # Text
      my $chunk = '';
      if ($type eq 'text') { $chunk = $trim ? squish $node->[1] : $node->[1] }
  
      # CDATA or raw text
      elsif ($type eq 'cdata' || $type eq 'raw') { $chunk = $node->[1] }
  
      # Nested tag
      elsif ($type eq 'tag' && $recurse) {
        no warnings 'recursion';
        $chunk = _text([_nodes($node)], 1, $node->[1] eq 'pre' ? 0 : $trim);
      }
  
      # Add leading whitespace if punctuation allows it
      $chunk = " $chunk" if $text =~ /\S\z/ && $chunk =~ /^[^.!?,;:\s]+/;
  
      # Trim whitespace blocks
      $text .= $chunk if $chunk =~ /\S+/ || !$trim;
    }
  
    return $text;
  }
  
  sub _wrap {
    my ($self, $content, $new) = @_;
  
    return $self if (my $tree = $self->tree)->[0] eq 'root' && !$content;
    return $self if $tree->[0] ne 'root' && $tree->[0] ne 'tag' && $content;
  
    # Find innermost tag
    my $current;
    my $first = $new = $self->_parse($new);
    $current = $first while $first = (_nodes($first, 1))[0];
    return $self unless $current;
  
    # Wrap content
    if ($content) {
      push @$current, _link($current, _nodes($tree));
      splice @$tree, _start($tree), $#$tree, _link($tree, _nodes($new));
      return $self;
    }
  
    # Wrap element
    $self->_replace($self->_parent, $tree, _nodes($new));
    push @$current, _link($current, $tree);
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM - Minimalistic HTML/XML DOM parser with CSS selectors
  
  =head1 SYNOPSIS
  
    use Mojo::DOM;
  
    # Parse
    my $dom = Mojo::DOM->new('<div><p id="a">Test</p><p id="b">123</p></div>');
  
    # Find
    say $dom->at('#b')->text;
    say $dom->find('p')->map('text')->join("\n");
    say $dom->find('[id]')->map(attr => 'id')->join("\n");
  
    # Iterate
    $dom->find('p[id]')->reverse->each(sub { say $_->{id} });
  
    # Loop
    for my $e ($dom->find('p[id]')->each) {
      say $e->{id}, ':', $e->text;
    }
  
    # Modify
    $dom->find('div p')->last->append('<p id="c">456</p>');
    $dom->find(':not(p)')->map('strip');
  
    # Render
    say "$dom";
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM> is a minimalistic and relaxed HTML/XML DOM parser with CSS
  selector support. It will even try to interpret broken HTML and XML, so you
  should not use it for validation.
  
  =head1 NODES AND ELEMENTS
  
  When we parse an HTML/XML fragment, it gets turned into a tree of nodes.
  
    <!DOCTYPE html>
    <html>
      <head><title>Hello</title></head>
      <body>World!</body>
    </html>
  
  There are currently eight different kinds of nodes, C<cdata>, C<comment>,
  C<doctype>, C<pi>, C<raw>, C<root>, C<tag> and C<text>. Elements are nodes of
  the type C<tag>.
  
    root
    |- doctype (html)
    +- tag (html)
       |- tag (head)
       |  +- tag (title)
       |     +- raw (Hello)
       +- tag (body)
          +- text (World!)
  
  While all node types are represented as L<Mojo::DOM> objects, some methods like
  L</"attr"> and L</"namespace"> only apply to elements.
  
  =head1 CASE-SENSITIVITY
  
  L<Mojo::DOM> defaults to HTML semantics, that means all tags and attribute
  names are lowercased and selectors need to be lowercase as well.
  
    # HTML semantics
    my $dom = Mojo::DOM->new('<P ID="greeting">Hi!</P>');
    say $dom->at('p[id]')->text;
  
  If an XML declaration is found, the parser will automatically switch into XML
  mode and everything becomes case-sensitive.
  
    # XML semantics
    my $dom = Mojo::DOM->new('<?xml version="1.0"?><P ID="greeting">Hi!</P>');
    say $dom->at('P[ID]')->text;
  
  XML detection can also be disabled with the L</"xml"> method.
  
    # Force XML semantics
    my $dom = Mojo::DOM->new->xml(1)->parse('<P ID="greeting">Hi!</P>');
    say $dom->at('P[ID]')->text;
  
    # Force HTML semantics
    my $dom = Mojo::DOM->new->xml(0)->parse('<P ID="greeting">Hi!</P>');
    say $dom->at('p[id]')->text;
  
  =head1 METHODS
  
  L<Mojo::DOM> implements the following methods.
  
  =head2 all_text
  
    my $trimmed   = $dom->all_text;
    my $untrimmed = $dom->all_text(0);
  
  Extract text content from all descendant nodes of this element, smart
  whitespace trimming is enabled by default.
  
    # "foo bar baz"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->all_text;
  
    # "foo\nbarbaz\n"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->all_text(0);
  
  =head2 ancestors
  
    my $collection = $dom->ancestors;
    my $collection = $dom->ancestors('div ~ p');
  
  Find all ancestor elements of this node matching the CSS selector and return a
  L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tag names of ancestor elements
    say $dom->ancestors->map('tag')->join("\n");
  
  =head2 append
  
    $dom = $dom->append('<p>I ♥ Mojolicious!</p>');
  
  Append HTML/XML fragment to this node (for all node types other than C<root>).
  
    # "<div><h1>Test</h1><h2>123</h2></div>"
    $dom->parse('<div><h1>Test</h1></div>')
      ->at('h1')->append('<h2>123</h2>')->root;
  
    # "<p>Test 123</p>"
    $dom->parse('<p>Test</p>')->at('p')
      ->child_nodes->first->append(' 123')->root;
  
  =head2 append_content
  
    $dom = $dom->append_content('<p>I ♥ Mojolicious!</p>');
  
  Append HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this
  node's content.
  
    # "<div><h1>Test123</h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')
      ->at('h1')->append_content('123')->root;
  
    # "<!-- Test 123 --><br>"
    $dom->parse('<!-- Test --><br>')
      ->child_nodes->first->append_content('123 ')->root;
  
    # "<p>Test<i>123</i></p>"
    $dom->parse('<p>Test</p>')->at('p')->append_content('<i>123</i>')->root;
  
  =head2 at
  
    my $result = $dom->at('div ~ p');
  
  Find first descendant element of this element matching the CSS selector and
  return it as a L<Mojo::DOM> object, or C<undef> if none could be found. All
  selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Find first element with "svg" namespace definition
    my $namespace = $dom->at('[xmlns\:svg]')->{'xmlns:svg'};
  
  =head2 attr
  
    my $hash = $dom->attr;
    my $foo  = $dom->attr('foo');
    $dom     = $dom->attr({foo => 'bar'});
    $dom     = $dom->attr(foo => 'bar');
  
  This element's attributes.
  
    # Remove an attribute
    delete $dom->attr->{id};
  
    # Attribute without value
    $dom->attr(selected => undef);
  
    # List id attributes
    say $dom->find('*')->map(attr => 'id')->compact->join("\n");
  
  =head2 child_nodes
  
    my $collection = $dom->child_nodes;
  
  Return a L<Mojo::Collection> object containing all child nodes of this element
  as L<Mojo::DOM> objects.
  
    # "<p><b>123</b></p>"
    $dom->parse('<p>Test<b>123</b></p>')->at('p')->child_nodes->first->remove;
  
    # "<!DOCTYPE html>"
    $dom->parse('<!DOCTYPE html><b>123</b>')->child_nodes->first;
  
    # " Test "
    $dom->parse('<b>123</b><!-- Test -->')->child_nodes->last->content;
  
  =head2 children
  
    my $collection = $dom->children;
    my $collection = $dom->children('div ~ p');
  
  Find all child elements of this element matching the CSS selector and return a
  L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Show tag name of random child element
    say $dom->children->shuffle->first->tag;
  
  =head2 content
  
    my $str = $dom->content;
    $dom    = $dom->content('<p>I ♥ Mojolicious!</p>');
  
  Return this node's content or replace it with HTML/XML fragment (for C<root>
  and C<tag> nodes) or raw content.
  
    # "<b>Test</b>"
    $dom->parse('<div><b>Test</b></div>')->at('div')->content;
  
    # "<div><h1>123</h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('123')->root;
  
    # "<p><i>123</i></p>"
    $dom->parse('<p>Test</p>')->at('p')->content('<i>123</i>')->root;
  
    # "<div><h1></h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('')->root;
  
    # " Test "
    $dom->parse('<!-- Test --><br>')->child_nodes->first->content;
  
    # "<div><!-- 123 -->456</div>"
    $dom->parse('<div><!-- Test -->456</div>')
      ->at('div')->child_nodes->first->content(' 123 ')->root;
  
  =head2 descendant_nodes
  
    my $collection = $dom->descendant_nodes;
  
  Return a L<Mojo::Collection> object containing all descendant nodes of this
  element as L<Mojo::DOM> objects.
  
    # "<p><b>123</b></p>"
    $dom->parse('<p><!-- Test --><b>123<!-- 456 --></b></p>')
      ->descendant_nodes->grep(sub { $_->type eq 'comment' })
      ->map('remove')->first;
  
    # "<p><b>test</b>test</p>"
    $dom->parse('<p><b>123</b>456</p>')
      ->at('p')->descendant_nodes->grep(sub { $_->type eq 'text' })
      ->map(content => 'test')->first->root;
  
  =head2 find
  
    my $collection = $dom->find('div ~ p');
  
  Find all descendant elements of this element matching the CSS selector and
  return a L<Mojo::Collection> object containing these elements as L<Mojo::DOM>
  objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Find a specific element and extract information
    my $id = $dom->find('div')->[23]{id};
  
    # Extract information from multiple elements
    my @headers = $dom->find('h1, h2, h3')->map('text')->each;
  
    # Count all the different tags
    my $hash = $dom->find('*')->reduce(sub { $a->{$b->tag}++; $a }, {});
  
    # Find elements with a class that contains dots
    my @divs = $dom->find('div.foo\.bar')->each;
  
  =head2 following
  
    my $collection = $dom->following;
    my $collection = $dom->following('div ~ p');
  
  Find all sibling elements after this node matching the CSS selector and return
  a L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tags of sibling elements after this node
    say $dom->following->map('tag')->join("\n");
  
  =head2 following_nodes
  
    my $collection = $dom->following_nodes;
  
  Return a L<Mojo::Collection> object containing all sibling nodes after this
  node as L<Mojo::DOM> objects.
  
    # "C"
    $dom->parse('<p>A</p><!-- B -->C')->at('p')->following_nodes->last->content;
  
  =head2 matches
  
    my $bool = $dom->matches('div ~ p');
  
  Check if this element matches the CSS selector. All selectors from
  L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # True
    $dom->parse('<p class="a">A</p>')->at('p')->matches('.a');
    $dom->parse('<p class="a">A</p>')->at('p')->matches('p[class]');
  
    # False
    $dom->parse('<p class="a">A</p>')->at('p')->matches('.b');
    $dom->parse('<p class="a">A</p>')->at('p')->matches('p[id]');
  
  =head2 namespace
  
    my $namespace = $dom->namespace;
  
  Find this element's namespace, or return C<undef> if none could be found.
  
    # Find namespace for an element with namespace prefix
    my $namespace = $dom->at('svg > svg\:circle')->namespace;
  
    # Find namespace for an element that may or may not have a namespace prefix
    my $namespace = $dom->at('svg > circle')->namespace;
  
  =head2 new
  
    my $dom = Mojo::DOM->new;
    my $dom = Mojo::DOM->new('<foo bar="baz">I ♥ Mojolicious!</foo>');
  
  Construct a new scalar-based L<Mojo::DOM> object and L</"parse"> HTML/XML
  fragment if necessary.
  
  =head2 next
  
    my $sibling = $dom->next;
  
  Return L<Mojo::DOM> object for next sibling element, or C<undef> if there are no
  more siblings.
  
    # "<h2>123</h2>"
    $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h1')->next;
  
  =head2 next_node
  
    my $sibling = $dom->next_node;
  
  Return L<Mojo::DOM> object for next sibling node, or C<undef> if there are no
  more siblings.
  
    # "456"
    $dom->parse('<p><b>123</b><!-- Test -->456</p>')
      ->at('b')->next_node->next_node;
  
    # " Test "
    $dom->parse('<p><b>123</b><!-- Test -->456</p>')
      ->at('b')->next_node->content;
  
  =head2 parent
  
    my $parent = $dom->parent;
  
  Return L<Mojo::DOM> object for parent of this node, or C<undef> if this node has
  no parent.
  
    # "<b><i>Test</i></b>"
    $dom->parse('<p><b><i>Test</i></b></p>')->at('i')->parent;
  
  =head2 parse
  
    $dom = $dom->parse('<foo bar="baz">I ♥ Mojolicious!</foo>');
  
  Parse HTML/XML fragment with L<Mojo::DOM::HTML>.
  
    # Parse XML
    my $dom = Mojo::DOM->new->xml(1)->parse('<foo>I ♥ Mojolicious!</foo>');
  
  =head2 preceding
  
    my $collection = $dom->preceding;
    my $collection = $dom->preceding('div ~ p');
  
  Find all sibling elements before this node matching the CSS selector and return
  a L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tags of sibling elements before this node
    say $dom->preceding->map('tag')->join("\n");
  
  =head2 preceding_nodes
  
    my $collection = $dom->preceding_nodes;
  
  Return a L<Mojo::Collection> object containing all sibling nodes before this
  node as L<Mojo::DOM> objects.
  
    # "A"
    $dom->parse('A<!-- B --><p>C</p>')->at('p')->preceding_nodes->first->content;
  
  =head2 prepend
  
    $dom = $dom->prepend('<p>I ♥ Mojolicious!</p>');
  
  Prepend HTML/XML fragment to this node (for all node types other than C<root>).
  
    # "<div><h1>Test</h1><h2>123</h2></div>"
    $dom->parse('<div><h2>123</h2></div>')
      ->at('h2')->prepend('<h1>Test</h1>')->root;
  
    # "<p>Test 123</p>"
    $dom->parse('<p>123</p>')
      ->at('p')->child_nodes->first->prepend('Test ')->root;
  
  =head2 prepend_content
  
    $dom = $dom->prepend_content('<p>I ♥ Mojolicious!</p>');
  
  Prepend HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this
  node's content.
  
    # "<div><h2>Test123</h2></div>"
    $dom->parse('<div><h2>123</h2></div>')
      ->at('h2')->prepend_content('Test')->root;
  
    # "<!-- Test 123 --><br>"
    $dom->parse('<!-- 123 --><br>')
      ->child_nodes->first->prepend_content(' Test')->root;
  
    # "<p><i>123</i>Test</p>"
    $dom->parse('<p>Test</p>')->at('p')->prepend_content('<i>123</i>')->root;
  
  =head2 previous
  
    my $sibling = $dom->previous;
  
  Return L<Mojo::DOM> object for previous sibling element, or C<undef> if there
  are no more siblings.
  
    # "<h1>Test</h1>"
    $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h2')->previous;
  
  =head2 previous_node
  
    my $sibling = $dom->previous_node;
  
  Return L<Mojo::DOM> object for previous sibling node, or C<undef> if there are
  no more siblings.
  
    # "123"
    $dom->parse('<p>123<!-- Test --><b>456</b></p>')
      ->at('b')->previous_node->previous_node;
  
    # " Test "
    $dom->parse('<p>123<!-- Test --><b>456</b></p>')
      ->at('b')->previous_node->content;
  
  =head2 remove
  
    my $parent = $dom->remove;
  
  Remove this node and return L</"root"> (for C<root> nodes) or L</"parent">.
  
    # "<div></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->remove;
  
    # "<p><b>456</b></p>"
    $dom->parse('<p>123<b>456</b></p>')
      ->at('p')->child_nodes->first->remove->root;
  
  =head2 replace
  
    my $parent = $dom->replace('<div>I ♥ Mojolicious!</div>');
  
  Replace this node with HTML/XML fragment and return L</"root"> (for C<root>
  nodes) or L</"parent">.
  
    # "<div><h2>123</h2></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->replace('<h2>123</h2>');
  
    # "<p><b>123</b></p>"
    $dom->parse('<p>Test</p>')
      ->at('p')->child_nodes->[0]->replace('<b>123</b>')->root;
  
  =head2 root
  
    my $root = $dom->root;
  
  Return L<Mojo::DOM> object for C<root> node.
  
  =head2 strip
  
    my $parent = $dom->strip;
  
  Remove this element while preserving its content and return L</"parent">.
  
    # "<div>Test</div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->strip;
  
  =head2 tag
  
    my $tag = $dom->tag;
    $dom    = $dom->tag('div');
  
  This element's tag name.
  
    # List tag names of child elements
    say $dom->children->map('tag')->join("\n");
  
  =head2 tap
  
    $dom = $dom->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 text
  
    my $trimmed   = $dom->text;
    my $untrimmed = $dom->text(0);
  
  Extract text content from this element only (not including child elements),
  smart whitespace trimming is enabled by default.
  
    # "foo baz"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->text;
  
    # "foo\nbaz\n"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->text(0);
  
  =head2 to_string
  
    my $str = $dom->to_string;
  
  Render this node and its content to HTML/XML.
  
    # "<b>Test</b>"
    $dom->parse('<div><b>Test</b></div>')->at('div b')->to_string;
  
  =head2 tree
  
    my $tree = $dom->tree;
    $dom     = $dom->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 type
  
    my $type = $dom->type;
  
  This node's type, usually C<cdata>, C<comment>, C<doctype>, C<pi>, C<raw>,
  C<root>, C<tag> or C<text>.
  
    # "cdata"
    $dom->parse('<![CDATA[Test]]>')->child_nodes->first->type;
  
    # "comment"
    $dom->parse('<!-- Test -->')->child_nodes->first->type;
  
    # "doctype"
    $dom->parse('<!DOCTYPE html>')->child_nodes->first->type;
  
    # "pi"
    $dom->parse('<?xml version="1.0"?>')->child_nodes->first->type;
  
    # "raw"
    $dom->parse('<title>Test</title>')->at('title')->child_nodes->first->type;
  
    # "root"
    $dom->parse('<p>Test</p>')->type;
  
    # "tag"
    $dom->parse('<p>Test</p>')->at('p')->type;
  
    # "text"
    $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->type;
  
  =head2 val
  
    my $value = $dom->val;
  
  Extract value from form element (such as C<button>, C<input>, C<option>,
  C<select> and C<textarea>), or return C<undef> if this element has no value. In
  the case of C<select> with C<multiple> attribute, find C<option> elements with
  C<selected> attribute and return an array reference with all values, or C<undef>
  if none could be found.
  
    # "a"
    $dom->parse('<input name=test value=a>')->at('input')->val;
  
    # "b"
    $dom->parse('<textarea>b</textarea>')->at('textarea')->val;
  
    # "c"
    $dom->parse('<option value="c">Test</option>')->at('option')->val;
  
    # "d"
    $dom->parse('<select><option selected>d</option></select>')
      ->at('select')->val;
  
    # "e"
    $dom->parse('<select multiple><option selected>e</option></select>')
      ->at('select')->val->[0];
  
    # "on"
    $dom->parse('<input name=test type=checkbox>')->at('input')->val;
  
  =head2 wrap
  
    $dom = $dom->wrap('<div></div>');
  
  Wrap HTML/XML fragment around this node (for all node types other than C<root>),
  placing it as the last child of the first innermost element.
  
    # "<p>123<b>Test</b></p>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<p>123</p>')->root;
  
    # "<div><p><b>Test</b></p>123</div>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<div><p></p>123</div>')->root;
  
    # "<p><b>Test</b></p><p>123</p>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<p></p><p>123</p>')->root;
  
    # "<p><b>Test</b></p>"
    $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->wrap('<b>')->root;
  
  =head2 wrap_content
  
    $dom = $dom->wrap_content('<div></div>');
  
  Wrap HTML/XML fragment around this node's content (for C<root> and C<tag>
  nodes), placing it as the last children of the first innermost element.
  
    # "<p><b>123Test</b></p>"
    $dom->parse('<p>Test<p>')->at('p')->wrap_content('<b>123</b>')->root;
  
    # "<p><b>Test</b></p><p>123</p>"
    $dom->parse('<b>Test</b>')->wrap_content('<p></p><p>123</p>');
  
  =head2 xml
  
    my $bool = $dom->xml;
    $dom     = $dom->xml($bool);
  
  Disable HTML semantics in parser and activate case-sensitivity, defaults to
  auto-detection based on XML declarations.
  
  =head1 OPERATORS
  
  L<Mojo::DOM> overloads the following operators.
  
  =head2 array
  
    my @nodes = @$dom;
  
  Alias for L</"child_nodes">.
  
    # "<!-- Test -->"
    $dom->parse('<!-- Test --><b>123</b>')->[0];
  
  =head2 bool
  
    my $bool = !!$dom;
  
  Always true.
  
  =head2 hash
  
    my %attrs = %$dom;
  
  Alias for L</"attr">.
  
    # "test"
    $dom->parse('<div id="test">Test</div>')->at('div')->{id};
  
  =head2 stringify
  
    my $str = "$dom";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_DOM

$fatpacked{"Mojo/DOM/CSS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_CSS';
  package Mojo::DOM::CSS;
  use Mojo::Base -base;
  
  use Mojo::Util 'trim';
  
  has 'tree';
  
  my $ESCAPE_RE = qr/\\[^0-9a-fA-F]|\\[0-9a-fA-F]{1,6}/;
  my $ATTR_RE   = qr/
    \[
    ((?:$ESCAPE_RE|[\w\-])+)                              # Key
    (?:
      (\W)?=                                              # Operator
      (?:"((?:\\"|[^"])*)"|'((?:\\'|[^'])*)'|([^\]]+?))   # Value
      (?:\s+(i))?                                         # Case-sensitivity
    )?
    \]
  /x;
  
  sub matches {
    my $tree = shift->tree;
    return $tree->[0] ne 'tag' ? undef : _match(_compile(shift), $tree, $tree);
  }
  
  sub select     { _select(0, shift->tree, _compile(@_)) }
  sub select_one { _select(1, shift->tree, _compile(@_)) }
  
  sub _ancestor {
    my ($selectors, $current, $tree, $one, $pos) = @_;
  
    while ($current = $current->[3]) {
      return undef if $current->[0] eq 'root' || $current eq $tree;
      return 1 if _combinator($selectors, $current, $tree, $pos);
      last if $one;
    }
  
    return undef;
  }
  
  sub _attr {
    my ($name_re, $value_re, $current) = @_;
  
    my $attrs = $current->[2];
    for my $name (keys %$attrs) {
      next unless $name =~ $name_re;
      return 1 unless defined $attrs->{$name} && defined $value_re;
      return 1 if $attrs->{$name} =~ $value_re;
    }
  
    return undef;
  }
  
  sub _combinator {
    my ($selectors, $current, $tree, $pos) = @_;
  
    # Selector
    return undef unless my $c = $selectors->[$pos];
    if (ref $c) {
      return undef unless _selector($c, $current);
      return 1 unless $c = $selectors->[++$pos];
    }
  
    # ">" (parent only)
    return _ancestor($selectors, $current, $tree, 1, ++$pos) if $c eq '>';
  
    # "~" (preceding siblings)
    return _sibling($selectors, $current, $tree, 0, ++$pos) if $c eq '~';
  
    # "+" (immediately preceding siblings)
    return _sibling($selectors, $current, $tree, 1, ++$pos) if $c eq '+';
  
    # " " (ancestor)
    return _ancestor($selectors, $current, $tree, 0, ++$pos);
  }
  
  sub _compile {
    my $css = trim "$_[0]";
  
    my $group = [[]];
    while (my $selectors = $group->[-1]) {
      push @$selectors, [] unless @$selectors && ref $selectors->[-1];
      my $last = $selectors->[-1];
  
      # Separator
      if ($css =~ /\G\s*,\s*/gc) { push @$group, [] }
  
      # Combinator
      elsif ($css =~ /\G\s*([ >+~])\s*/gc) { push @$selectors, $1 }
  
      # Class or ID
      elsif ($css =~ /\G([.#])((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
        my ($name, $op) = $1 eq '.' ? ('class', '~') : ('id', '');
        push @$last, ['attr', _name($name), _value($op, $2)];
      }
  
      # Attributes
      elsif ($css =~ /\G$ATTR_RE/gco) {
        push @$last, ['attr', _name($1), _value($2 // '', $3 // $4 // $5, $6)];
      }
  
      # Pseudo-class
      elsif ($css =~ /\G:([\w\-]+)(?:\(((?:\([^)]+\)|[^)])+)\))?/gcs) {
        my ($name, $args) = (lc $1, $2);
  
        # ":not" (contains more selectors)
        $args = _compile($args) if $name eq 'not';
  
        # ":nth-*" (with An+B notation)
        $args = _equation($args) if $name =~ /^nth-/;
  
        # ":first-*" (rewrite to ":nth-*")
        ($name, $args) = ("nth-$1", [0, 1]) if $name =~ /^first-(.+)$/;
  
        # ":last-*" (rewrite to ":nth-*")
        ($name, $args) = ("nth-$name", [-1, 1]) if $name =~ /^last-/;
  
        push @$last, ['pc', $name, $args];
      }
  
      # Tag
      elsif ($css =~ /\G((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
        push @$last, ['tag', _name($1)] unless $1 eq '*';
      }
  
      else {last}
    }
  
    return $group;
  }
  
  sub _empty { $_[0][0] eq 'comment' || $_[0][0] eq 'pi' }
  
  sub _equation {
    return [0, 0] unless my $equation = shift;
  
    # "even"
    return [2, 2] if $equation =~ /^\s*even\s*$/i;
  
    # "odd"
    return [2, 1] if $equation =~ /^\s*odd\s*$/i;
  
    # "4", "+4" or "-4"
    return [0, $1] if $equation =~ /^\s*((?:\+|-)?\d+)\s*$/;
  
    # "n", "4n", "+4n", "-4n", "n+1", "4n-1", "+4n-1" (and other variations)
    return [0, 0]
      unless $equation =~ /^\s*((?:\+|-)?(?:\d+)?)?n\s*((?:\+|-)\s*\d+)?\s*$/i;
    return [$1 eq '-' ? -1 : !length $1 ? 1 : $1, join('', split(' ', $2 // 0))];
  }
  
  sub _match {
    my ($group, $current, $tree) = @_;
    _combinator([reverse @$_], $current, $tree, 0) and return 1 for @$group;
    return undef;
  }
  
  sub _name {qr/(?:^|:)\Q@{[_unescape(shift)]}\E$/}
  
  sub _pc {
    my ($class, $args, $current) = @_;
  
    # ":checked"
    return exists $current->[2]{checked} || exists $current->[2]{selected}
      if $class eq 'checked';
  
    # ":not"
    return !_match($args, $current, $current) if $class eq 'not';
  
    # ":empty"
    return !grep { !_empty($_) } @$current[4 .. $#$current] if $class eq 'empty';
  
    # ":root"
    return $current->[3] && $current->[3][0] eq 'root' if $class eq 'root';
  
    # ":nth-child", ":nth-last-child", ":nth-of-type" or ":nth-last-of-type"
    if (ref $args) {
      my $type = $class =~ /of-type$/ ? $current->[1] : undef;
      my @siblings = @{_siblings($current, $type)};
      @siblings = reverse @siblings if $class =~ /^nth-last/;
  
      for my $i (0 .. $#siblings) {
        next if (my $result = $args->[0] * $i + $args->[1]) < 1;
        last unless my $sibling = $siblings[$result - 1];
        return 1 if $sibling eq $current;
      }
    }
  
    # ":only-child" or ":only-of-type"
    elsif ($class eq 'only-child' || $class eq 'only-of-type') {
      my $type = $class eq 'only-of-type' ? $current->[1] : undef;
      $_ ne $current and return undef for @{_siblings($current, $type)};
      return 1;
    }
  
    return undef;
  }
  
  sub _select {
    my ($one, $tree, $group) = @_;
  
    my @results;
    my @queue = @$tree[($tree->[0] eq 'root' ? 1 : 4) .. $#$tree];
    while (my $current = shift @queue) {
      next unless $current->[0] eq 'tag';
  
      unshift @queue, @$current[4 .. $#$current];
      next unless _match($group, $current, $tree);
      $one ? return $current : push @results, $current;
    }
  
    return $one ? undef : \@results;
  }
  
  sub _selector {
    my ($selector, $current) = @_;
  
    for my $s (@$selector) {
      my $type = $s->[0];
  
      # Tag
      if ($type eq 'tag') { return undef unless $current->[1] =~ $s->[1] }
  
      # Attribute
      elsif ($type eq 'attr') { return undef unless _attr(@$s[1, 2], $current) }
  
      # Pseudo-class
      elsif ($type eq 'pc') { return undef unless _pc(@$s[1, 2], $current) }
    }
  
    return 1;
  }
  
  sub _sibling {
    my ($selectors, $current, $tree, $immediate, $pos) = @_;
  
    my $found;
    for my $sibling (@{_siblings($current)}) {
      return $found if $sibling eq $current;
  
      # "+" (immediately preceding sibling)
      if ($immediate) { $found = _combinator($selectors, $sibling, $tree, $pos) }
  
      # "~" (preceding sibling)
      else { return 1 if _combinator($selectors, $sibling, $tree, $pos) }
    }
  
    return undef;
  }
  
  sub _siblings {
    my ($current, $type) = @_;
  
    my $parent = $current->[3];
    my @siblings = grep { $_->[0] eq 'tag' }
      @$parent[($parent->[0] eq 'root' ? 1 : 4) .. $#$parent];
    @siblings = grep { $type eq $_->[1] } @siblings if defined $type;
  
    return \@siblings;
  }
  
  sub _unescape {
    my $value = shift;
  
    # Remove escaped newlines
    $value =~ s/\\\n//g;
  
    # Unescape Unicode characters
    $value =~ s/\\([0-9a-fA-F]{1,6})\s?/pack 'U', hex $1/ge;
  
    # Remove backslash
    $value =~ s/\\//g;
  
    return $value;
  }
  
  sub _value {
    my ($op, $value, $insensitive) = @_;
    return undef unless defined $value;
    $value = ($insensitive ? '(?i)' : '') . quotemeta _unescape($value);
  
    # "~=" (word)
    return qr/(?:^|\s+)$value(?:\s+|$)/ if $op eq '~';
  
    # "*=" (contains)
    return qr/$value/ if $op eq '*';
  
    # "^=" (begins with)
    return qr/^$value/ if $op eq '^';
  
    # "$=" (ends with)
    return qr/$value$/ if $op eq '$';
  
    # Everything else
    return qr/^$value$/;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM::CSS - CSS selector engine
  
  =head1 SYNOPSIS
  
    use Mojo::DOM::CSS;
  
    # Select elements from DOM tree
    my $css = Mojo::DOM::CSS->new(tree => $tree);
    my $elements = $css->select('h1, h2, h3');
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM::CSS> is the CSS selector engine used by L<Mojo::DOM>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org> and
  L<Selectors Level 3|http://www.w3.org/TR/css3-selectors/>.
  
  =head1 SELECTORS
  
  All CSS selectors that make sense for a standalone parser are supported.
  
  =head2 *
  
  Any element.
  
    my $all = $css->select('*');
  
  =head2 E
  
  An element of type C<E>.
  
    my $title = $css->select('title');
  
  =head2 E[foo]
  
  An C<E> element with a C<foo> attribute.
  
    my $links = $css->select('a[href]');
  
  =head2 E[foo="bar"]
  
  An C<E> element whose C<foo> attribute value is exactly equal to C<bar>.
  
    my $case_sensitive = $css->select('input[type="hidden"]');
    my $case_sensitive = $css->select('input[type=hidden]');
  
  =head2 E[foo="bar" i]
  
  An C<E> element whose C<foo> attribute value is exactly equal to any
  (ASCII-range) case-permutation of C<bar>. Note that this selector is
  EXPERIMENTAL and might change without warning!
  
    my $case_insensitive = $css->select('input[type="hidden" i]');
    my $case_insensitive = $css->select('input[type=hidden i]');
    my $case_insensitive = $css->select('input[class~="foo" i]');
  
  This selector is part of
  L<Selectors Level 4|http://dev.w3.org/csswg/selectors-4>, which is still a work
  in progress.
  
  =head2 E[foo~="bar"]
  
  An C<E> element whose C<foo> attribute value is a list of whitespace-separated
  values, one of which is exactly equal to C<bar>.
  
    my $foo = $css->select('input[class~="foo"]');
    my $foo = $css->select('input[class~=foo]');
  
  =head2 E[foo^="bar"]
  
  An C<E> element whose C<foo> attribute value begins exactly with the string
  C<bar>.
  
    my $begins_with = $css->select('input[name^="f"]');
    my $begins_with = $css->select('input[name^=f]');
  
  =head2 E[foo$="bar"]
  
  An C<E> element whose C<foo> attribute value ends exactly with the string
  C<bar>.
  
    my $ends_with = $css->select('input[name$="o"]');
    my $ends_with = $css->select('input[name$=o]');
  
  =head2 E[foo*="bar"]
  
  An C<E> element whose C<foo> attribute value contains the substring C<bar>.
  
    my $contains = $css->select('input[name*="fo"]');
    my $contains = $css->select('input[name*=fo]');
  
  =head2 E:root
  
  An C<E> element, root of the document.
  
    my $root = $css->select(':root');
  
  =head2 E:nth-child(n)
  
  An C<E> element, the C<n-th> child of its parent.
  
    my $third = $css->select('div:nth-child(3)');
    my $odd   = $css->select('div:nth-child(odd)');
    my $even  = $css->select('div:nth-child(even)');
    my $top3  = $css->select('div:nth-child(-n+3)');
  
  =head2 E:nth-last-child(n)
  
  An C<E> element, the C<n-th> child of its parent, counting from the last one.
  
    my $third    = $css->select('div:nth-last-child(3)');
    my $odd      = $css->select('div:nth-last-child(odd)');
    my $even     = $css->select('div:nth-last-child(even)');
    my $bottom3  = $css->select('div:nth-last-child(-n+3)');
  
  =head2 E:nth-of-type(n)
  
  An C<E> element, the C<n-th> sibling of its type.
  
    my $third = $css->select('div:nth-of-type(3)');
    my $odd   = $css->select('div:nth-of-type(odd)');
    my $even  = $css->select('div:nth-of-type(even)');
    my $top3  = $css->select('div:nth-of-type(-n+3)');
  
  =head2 E:nth-last-of-type(n)
  
  An C<E> element, the C<n-th> sibling of its type, counting from the last one.
  
    my $third    = $css->select('div:nth-last-of-type(3)');
    my $odd      = $css->select('div:nth-last-of-type(odd)');
    my $even     = $css->select('div:nth-last-of-type(even)');
    my $bottom3  = $css->select('div:nth-last-of-type(-n+3)');
  
  =head2 E:first-child
  
  An C<E> element, first child of its parent.
  
    my $first = $css->select('div p:first-child');
  
  =head2 E:last-child
  
  An C<E> element, last child of its parent.
  
    my $last = $css->select('div p:last-child');
  
  =head2 E:first-of-type
  
  An C<E> element, first sibling of its type.
  
    my $first = $css->select('div p:first-of-type');
  
  =head2 E:last-of-type
  
  An C<E> element, last sibling of its type.
  
    my $last = $css->select('div p:last-of-type');
  
  =head2 E:only-child
  
  An C<E> element, only child of its parent.
  
    my $lonely = $css->select('div p:only-child');
  
  =head2 E:only-of-type
  
  An C<E> element, only sibling of its type.
  
    my $lonely = $css->select('div p:only-of-type');
  
  =head2 E:empty
  
  An C<E> element that has no children (including text nodes).
  
    my $empty = $css->select(':empty');
  
  =head2 E:checked
  
  A user interface element C<E> which is checked (for instance a radio-button or
  checkbox).
  
    my $input = $css->select(':checked');
  
  =head2 E.warning
  
  An C<E> element whose class is "warning".
  
    my $warning = $css->select('div.warning');
  
  =head2 E#myid
  
  An C<E> element with C<ID> equal to "myid".
  
    my $foo = $css->select('div#foo');
  
  =head2 E:not(s)
  
  An C<E> element that does not match simple selector C<s>.
  
    my $others = $css->select('div p:not(:first-child)');
  
  =head2 E F
  
  An C<F> element descendant of an C<E> element.
  
    my $headlines = $css->select('div h1');
  
  =head2 E E<gt> F
  
  An C<F> element child of an C<E> element.
  
    my $headlines = $css->select('html > body > div > h1');
  
  =head2 E + F
  
  An C<F> element immediately preceded by an C<E> element.
  
    my $second = $css->select('h1 + h2');
  
  =head2 E ~ F
  
  An C<F> element preceded by an C<E> element.
  
    my $second = $css->select('h1 ~ h2');
  
  =head2 E, F, G
  
  Elements of type C<E>, C<F> and C<G>.
  
    my $headlines = $css->select('h1, h2, h3');
  
  =head2 E[foo=bar][bar=baz]
  
  An C<E> element whose attributes match all following attribute selectors.
  
    my $links = $css->select('a[foo^=b][foo$=ar]');
  
  =head1 ATTRIBUTES
  
  L<Mojo::DOM::CSS> implements the following attributes.
  
  =head2 tree
  
    my $tree = $css->tree;
    $css     = $css->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head1 METHODS
  
  L<Mojo::DOM::CSS> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 matches
  
    my $bool = $css->matches('head > title');
  
  Check if first node in L</"tree"> matches the CSS selector.
  
  =head2 select
  
    my $results = $css->select('head > title');
  
  Run CSS selector against L</"tree">.
  
  =head2 select_one
  
    my $result = $css->select_one('head > title');
  
  Run CSS selector against L</"tree"> and stop as soon as the first node matched.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_DOM_CSS

$fatpacked{"Mojo/DOM/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_HTML';
  package Mojo::DOM::HTML;
  use Mojo::Base -base;
  
  use Mojo::Util qw(html_unescape xml_escape);
  use Scalar::Util 'weaken';
  
  has tree => sub { ['root'] };
  has 'xml';
  
  my $ATTR_RE = qr/
    ([^<>=\s\/]+|\/)                     # Key
    (?:
      \s*=\s*
      (?s:(["'])(.*?)\g{-2}|([^>\s]*))   # Value
    )?
    \s*
  /x;
  my $TOKEN_RE = qr/
    ([^<]+)?                                            # Text
    (?:
      <(?:
        !(?:
          DOCTYPE(
          \s+\w+                                        # Doctype
          (?:(?:\s+\w+)?(?:\s+(?:"[^"]*"|'[^']*'))+)?   # External ID
          (?:\s+\[.+?\])?                               # Int Subset
          \s*)
        |
          --(.*?)--\s*                                  # Comment
        |
          \[CDATA\[(.*?)\]\]                            # CDATA
        )
      |
        \?(.*?)\?                                       # Processing Instruction
      |
        \s*([^<>\s]+\s*(?:(?:$ATTR_RE){0,32766})*+)     # Tag
      )>
    |
      (<)                                               # Runaway "<"
    )??
  /xis;
  
  # HTML elements that only contain raw text
  my %RAW = map { $_ => 1 } qw(script style);
  
  # HTML elements that only contain raw text and entities
  my %RCDATA = map { $_ => 1 } qw(title textarea);
  
  # HTML elements with optional end tags
  my %END = (body => 'head', optgroup => 'optgroup', option => 'option');
  
  # HTML elements that break paragraphs
  map { $END{$_} = 'p' } (
    qw(address article aside blockquote dir div dl fieldset footer form h1 h2),
    qw(h3 h4 h5 h6 header hr main menu nav ol p pre section table ul)
  );
  
  # HTML table elements with optional end tags
  my %TABLE = map { $_ => 1 } qw(colgroup tbody td tfoot th thead tr);
  
  # HTML elements with optional end tags and scoping rules
  my %CLOSE
    = (li => [{li => 1}, {ul => 1, ol => 1}], tr => [{tr => 1}, {table => 1}]);
  $CLOSE{$_} = [\%TABLE, {table => 1}] for qw(colgroup tbody tfoot thead);
  $CLOSE{$_} = [{dd => 1, dt => 1}, {dl    => 1}] for qw(dd dt);
  $CLOSE{$_} = [{rp => 1, rt => 1}, {ruby  => 1}] for qw(rp rt);
  $CLOSE{$_} = [{th => 1, td => 1}, {table => 1}] for qw(td th);
  
  # HTML elements without end tags
  my %EMPTY = map { $_ => 1 } (
    qw(area base br col embed hr img input keygen link menuitem meta param),
    qw(source track wbr)
  );
  
  # HTML elements categorized as phrasing content (and obsolete inline elements)
  my @PHRASING = (
    qw(a abbr area audio b bdi bdo br button canvas cite code data datalist),
    qw(del dfn em embed i iframe img input ins kbd keygen label link map mark),
    qw(math meta meter noscript object output picture progress q ruby s samp),
    qw(script select slot small span strong sub sup svg template textarea time u),
    qw(var video wbr)
  );
  my @OBSOLETE = qw(acronym applet basefont big font strike tt);
  my %PHRASING = map { $_ => 1 } @OBSOLETE, @PHRASING;
  
  # HTML elements that don't get their self-closing flag acknowledged
  my %BLOCK = map { $_ => 1 } (
    qw(a address applet article aside b big blockquote body button caption),
    qw(center code col colgroup dd details dialog dir div dl dt em fieldset),
    qw(figcaption figure font footer form frameset h1 h2 h3 h4 h5 h6 head),
    qw(header hgroup html i iframe li listing main marquee menu nav nobr),
    qw(noembed noframes noscript object ol optgroup option p plaintext pre rp),
    qw(rt s script section select small strike strong style summary table),
    qw(tbody td template textarea tfoot th thead title tr tt u ul xmp)
  );
  
  sub parse {
    my ($self, $html) = (shift, "$_[0]");
  
    my $xml = $self->xml;
    my $current = my $tree = ['root'];
    while ($html =~ /\G$TOKEN_RE/gcso) {
      my ($text, $doctype, $comment, $cdata, $pi, $tag, $runaway)
        = ($1, $2, $3, $4, $5, $6, $11);
  
      # Text (and runaway "<")
      $text .= '<' if defined $runaway;
      _node($current, 'text', html_unescape $text) if defined $text;
  
      # Tag
      if (defined $tag) {
  
        # End
        if ($tag =~ /^\/\s*(\S+)/) { _end($xml ? $1 : lc $1, $xml, \$current) }
  
        # Start
        elsif ($tag =~ m!^([^\s/]+)([\s\S]*)!) {
          my ($start, $attr) = ($xml ? $1 : lc $1, $2);
  
          # Attributes
          my (%attrs, $closing);
          while ($attr =~ /$ATTR_RE/go) {
            my ($key, $value) = ($xml ? $1 : lc $1, $3 // $4);
  
            # Empty tag
            ++$closing and next if $key eq '/';
  
            $attrs{$key} = defined $value ? html_unescape $value : $value;
          }
  
          # "image" is an alias for "img"
          $start = 'img' if !$xml && $start eq 'image';
          _start($start, \%attrs, $xml, \$current);
  
          # Element without end tag (self-closing)
          _end($start, $xml, \$current)
            if !$xml && $EMPTY{$start} || ($xml || !$BLOCK{$start}) && $closing;
  
          # Raw text elements
          next if $xml || !$RAW{$start} && !$RCDATA{$start};
          next unless $html =~ m!\G(.*?)<\s*/\s*\Q$start\E\s*>!gcsi;
          _node($current, 'raw', $RCDATA{$start} ? html_unescape $1 : $1);
          _end($start, 0, \$current);
        }
      }
  
      # DOCTYPE
      elsif (defined $doctype) { _node($current, 'doctype', $doctype) }
  
      # Comment
      elsif (defined $comment) { _node($current, 'comment', $comment) }
  
      # CDATA
      elsif (defined $cdata) { _node($current, 'cdata', $cdata) }
  
      # Processing instruction (try to detect XML)
      elsif (defined $pi) {
        $self->xml($xml = 1) if !exists $self->{xml} && $pi =~ /xml/i;
        _node($current, 'pi', $pi);
      }
    }
  
    return $self->tree($tree);
  }
  
  sub render { _render($_[0]->tree, $_[0]->xml) }
  
  sub _end {
    my ($end, $xml, $current) = @_;
  
    # Search stack for start tag
    my $next = $$current;
    do {
  
      # Ignore useless end tag
      return if $next->[0] eq 'root';
  
      # Right tag
      return $$current = $next->[3] if $next->[1] eq $end;
  
      # Phrasing content can only cross phrasing content
      return if !$xml && $PHRASING{$end} && !$PHRASING{$next->[1]};
  
    } while $next = $next->[3];
  }
  
  sub _node {
    my ($current, $type, $content) = @_;
    push @$current, my $new = [$type, $content, $current];
    weaken $new->[2];
  }
  
  sub _render {
    my ($tree, $xml) = @_;
  
    # Text (escaped)
    my $type = $tree->[0];
    return xml_escape $tree->[1] if $type eq 'text';
  
    # Raw text
    return $tree->[1] if $type eq 'raw';
  
    # DOCTYPE
    return '<!DOCTYPE' . $tree->[1] . '>' if $type eq 'doctype';
  
    # Comment
    return '<!--' . $tree->[1] . '-->' if $type eq 'comment';
  
    # CDATA
    return '<![CDATA[' . $tree->[1] . ']]>' if $type eq 'cdata';
  
    # Processing instruction
    return '<?' . $tree->[1] . '?>' if $type eq 'pi';
  
    # Root
    return join '', map { _render($_, $xml) } @$tree[1 .. $#$tree]
      if $type eq 'root';
  
    # Start tag
    my $tag    = $tree->[1];
    my $result = "<$tag";
  
    # Attributes
    for my $key (sort keys %{$tree->[2]}) {
      my $value = $tree->[2]{$key};
      $result .= $xml ? qq{ $key="$key"} : " $key" and next unless defined $value;
      $result .= qq{ $key="} . xml_escape($value) . '"';
    }
  
    # No children
    return $xml ? "$result />" : $EMPTY{$tag} ? "$result>" : "$result></$tag>"
      unless $tree->[4];
  
    # Children
    no warnings 'recursion';
    $result .= '>' . join '', map { _render($_, $xml) } @$tree[4 .. $#$tree];
  
    # End tag
    return "$result</$tag>";
  }
  
  sub _start {
    my ($start, $attrs, $xml, $current) = @_;
  
    # Autoclose optional HTML elements
    if (!$xml && $$current->[0] ne 'root') {
      if (my $end = $END{$start}) { _end($end, 0, $current) }
  
      elsif (my $close = $CLOSE{$start}) {
        my ($allowed, $scope) = @$close;
  
        # Close allowed parent elements in scope
        my $parent = $$current;
        while ($parent->[0] ne 'root' && !$scope->{$parent->[1]}) {
          _end($parent->[1], 0, $current) if $allowed->{$parent->[1]};
          $parent = $parent->[3];
        }
      }
    }
  
    # New tag
    push @$$current, my $new = ['tag', $start, $attrs, $$current];
    weaken $new->[3];
    $$current = $new;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM::HTML - HTML/XML engine
  
  =head1 SYNOPSIS
  
    use Mojo::DOM::HTML;
  
    # Turn HTML into DOM tree
    my $html = Mojo::DOM::HTML->new;
    $html->parse('<div><p id="a">Test</p><p id="b">123</p></div>');
    my $tree = $html->tree;
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM::HTML> is the HTML/XML engine used by L<Mojo::DOM>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org> and the
  L<Extensible Markup Language (XML) 1.0|http://www.w3.org/TR/xml/>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::DOM::HTML> implements the following attributes.
  
  =head2 tree
  
    my $tree = $html->tree;
    $html    = $html->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 xml
  
    my $bool = $html->xml;
    $html    = $html->xml($bool);
  
  Disable HTML semantics in parser and activate case-sensitivity, defaults to
  auto-detection based on XML declarations.
  
  =head1 METHODS
  
  L<Mojo::DOM::HTML> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    $html = $html->parse('<foo bar="baz">I ♥ Mojolicious!</foo>');
  
  Parse HTML/XML fragment.
  
  =head2 render
  
    my $str = $html->render;
  
  Render DOM to HTML/XML.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_DOM_HTML

$fatpacked{"Mojo/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DATE';
  package Mojo::Date;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Time::Local 'timegm';
  
  has epoch => sub {time};
  
  my $RFC3339_RE = qr/
    ^(\d+)-(\d+)-(\d+)\D+(\d+):(\d+):(\d+(?:\.\d+)?)   # Date and time
    (?:Z|([+-])(\d+):(\d+))?$                          # Offset
  /xi;
  
  my @DAYS   = qw(Sun Mon Tue Wed Thu Fri Sat);
  my @MONTHS = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  my %MONTHS;
  @MONTHS{@MONTHS} = (0 .. 11);
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my ($self, $date) = @_;
  
    # epoch (784111777)
    return $self->epoch($date) if $date =~ /^\d+$|^\d+\.\d+$/;
  
    # RFC 822/1123 (Sun, 06 Nov 1994 08:49:37 GMT)
    # RFC 850/1036 (Sunday, 06-Nov-94 08:49:37 GMT)
    my $offset = 0;
    my ($day, $month, $year, $h, $m, $s);
    if ($date =~ /^\w+\W+(\d+)\W+(\w+)\W+(\d+)\W+(\d+):(\d+):(\d+)\W*\w+$/) {
      ($day, $month, $year, $h, $m, $s) = ($1, $MONTHS{$2}, $3, $4, $5, $6);
    }
  
    # RFC 3339 (1994-11-06T08:49:37Z)
    elsif ($date =~ $RFC3339_RE) {
      ($year, $month, $day, $h, $m, $s) = ($1, $2 - 1, $3, $4, $5, $6);
      $offset = (($8 * 3600) + ($9 * 60)) * ($7 eq '+' ? -1 : 1) if $7;
    }
  
    # ANSI C asctime() (Sun Nov  6 08:49:37 1994)
    elsif ($date =~ /^\w+\s+(\w+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)$/) {
      ($month, $day, $h, $m, $s, $year) = ($MONTHS{$1}, $2, $3, $4, $5, $6);
    }
  
    # Invalid
    else { return $self->epoch(undef) }
  
    my $epoch = eval { timegm $s, $m, $h, $day, $month, $year };
    return $self->epoch(
      (defined $epoch && ($epoch += $offset) >= 0) ? $epoch : undef);
  }
  
  sub to_datetime {
  
    # RFC 3339 (1994-11-06T08:49:37Z)
    my ($s, $m, $h, $day, $month, $year) = gmtime(my $epoch = shift->epoch);
    my $str = sprintf '%04d-%02d-%02dT%02d:%02d:%02d', $year + 1900, $month + 1,
      $day, $h, $m, $s;
    return $str . ($epoch =~ /(\.\d+)$/ ? $1 : '') . 'Z';
  }
  
  sub to_string {
  
    # RFC 7231 (Sun, 06 Nov 1994 08:49:37 GMT)
    my ($s, $m, $h, $mday, $month, $year, $wday) = gmtime shift->epoch;
    return sprintf '%s, %02d %s %04d %02d:%02d:%02d GMT', $DAYS[$wday], $mday,
      $MONTHS[$month], $year + 1900, $h, $m, $s;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Date - HTTP date
  
  =head1 SYNOPSIS
  
    use Mojo::Date;
  
    # Parse
    my $date = Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT');
    say $date->epoch;
  
    # Build
    my $date = Mojo::Date->new(time + 60);
    say "$date";
  
  =head1 DESCRIPTION
  
  L<Mojo::Date> implements HTTP date and time functions, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 3339|http://tools.ietf.org/html/rfc3339>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Date> implements the following attributes.
  
  =head2 epoch
  
    my $epoch = $date->epoch;
    $date     = $date->epoch(784111777);
  
  Epoch seconds, defaults to the current time.
  
  =head1 METHODS
  
  L<Mojo::Date> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 new
  
    my $date = Mojo::Date->new;
    my $date = Mojo::Date->new('Sun Nov  6 08:49:37 1994');
  
  Construct a new L<Mojo::Date> object and L</"parse"> date if necessary.
  
  =head2 parse
  
    $date = $date->parse('Sun Nov  6 08:49:37 1994');
  
  Parse date.
  
    # Epoch
    say Mojo::Date->new('784111777')->epoch;
    say Mojo::Date->new('784111777.21')->epoch;
  
    # RFC 822/1123
    say Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT')->epoch;
  
    # RFC 850/1036
    say Mojo::Date->new('Sunday, 06-Nov-94 08:49:37 GMT')->epoch;
  
    # Ansi C asctime()
    say Mojo::Date->new('Sun Nov  6 08:49:37 1994')->epoch;
  
    # RFC 3339
    say Mojo::Date->new('1994-11-06T08:49:37Z')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37.21Z')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37+01:00')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37-01:00')->epoch;
  
  =head2 to_datetime
  
    my $str = $date->to_datetime;
  
  Render L<RFC 3339|http://tools.ietf.org/html/rfc3339> date and time.
  
    # "1994-11-06T08:49:37Z"
    Mojo::Date->new(784111777)->to_datetime;
  
    # "1994-11-06T08:49:37.21Z"
    Mojo::Date->new(784111777.21)->to_datetime;
  
  =head2 to_string
  
    my $str = $date->to_string;
  
  Render date suitable for HTTP messages.
  
    # "Sun, 06 Nov 1994 08:49:37 GMT"
    Mojo::Date->new(784111777)->to_string;
  
  =head1 OPERATORS
  
  L<Mojo::Date> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$date;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$date";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_DATE

$fatpacked{"Mojo/EventEmitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EVENTEMITTER';
  package Mojo::EventEmitter;
  use Mojo::Base -base;
  
  use Scalar::Util qw(blessed weaken);
  
  use constant DEBUG => $ENV{MOJO_EVENTEMITTER_DEBUG} || 0;
  
  sub catch { $_[0]->on(error => $_[1]) and return $_[0] }
  
  sub emit {
    my ($self, $name) = (shift, shift);
  
    if (my $s = $self->{events}{$name}) {
      warn "-- Emit $name in @{[blessed $self]} (@{[scalar @$s]})\n" if DEBUG;
      for my $cb (@$s) { $self->$cb(@_) }
    }
    else {
      warn "-- Emit $name in @{[blessed $self]} (0)\n" if DEBUG;
      die "@{[blessed $self]}: $_[0]" if $name eq 'error';
    }
  
    return $self;
  }
  
  sub has_subscribers { !!shift->{events}{shift()} }
  
  sub on { push @{$_[0]{events}{$_[1]}}, $_[2] and return $_[2] }
  
  sub once {
    my ($self, $name, $cb) = @_;
  
    weaken $self;
    my $wrapper;
    $wrapper = sub {
      $self->unsubscribe($name => $wrapper);
      $cb->(@_);
    };
    $self->on($name => $wrapper);
    weaken $wrapper;
  
    return $wrapper;
  }
  
  sub subscribers { shift->{events}{shift()} ||= [] }
  
  sub unsubscribe {
    my ($self, $name, $cb) = @_;
  
    # One
    if ($cb) {
      $self->{events}{$name} = [grep { $cb ne $_ } @{$self->{events}{$name}}];
      delete $self->{events}{$name} unless @{$self->{events}{$name}};
    }
  
    # All
    else { delete $self->{events}{$name} }
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::EventEmitter - Event emitter base class
  
  =head1 SYNOPSIS
  
    package Cat;
    use Mojo::Base 'Mojo::EventEmitter';
  
    # Emit events
    sub poke {
      my $self = shift;
      $self->emit(roar => 3);
    }
  
    package main;
  
    # Subscribe to events
    my $tiger = Cat->new;
    $tiger->on(roar => sub {
      my ($tiger, $times) = @_;
      say 'RAWR!' for 1 .. $times;
    });
    $tiger->poke;
  
  =head1 DESCRIPTION
  
  L<Mojo::EventEmitter> is a simple base class for event emitting objects.
  
  =head1 EVENTS
  
  L<Mojo::EventEmitter> can emit the following events.
  
  =head2 error
  
    $e->on(error => sub {
      my ($e, $err) = @_;
      ...
    });
  
  This is a special event for errors, it will not be emitted directly by this
  class but is fatal if unhandled.
  
    $e->on(error => sub {
      my ($e, $err) = @_;
      say "This looks bad: $err";
    });
  
  =head1 METHODS
  
  L<Mojo::EventEmitter> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 catch
  
    $e = $e->catch(sub {...});
  
  Subscribe to L</"error"> event.
  
    # Longer version
    $e->on(error => sub {...});
  
  =head2 emit
  
    $e = $e->emit('foo');
    $e = $e->emit('foo', 123);
  
  Emit event.
  
  =head2 has_subscribers
  
    my $bool = $e->has_subscribers('foo');
  
  Check if event has subscribers.
  
  =head2 on
  
    my $cb = $e->on(foo => sub {...});
  
  Subscribe to event.
  
    $e->on(foo => sub {
      my ($e, @args) = @_;
      ...
    });
  
  =head2 once
  
    my $cb = $e->once(foo => sub {...});
  
  Subscribe to event and unsubscribe again after it has been emitted once.
  
    $e->once(foo => sub {
      my ($e, @args) = @_;
      ...
    });
  
  =head2 subscribers
  
    my $subscribers = $e->subscribers('foo');
  
  All subscribers for event.
  
    # Unsubscribe last subscriber
    $e->unsubscribe(foo => $e->subscribers('foo')->[-1]);
  
    # Change order of subscribers
    @{$e->subscribers('foo')} = reverse @{$e->subscribers('foo')};
  
  =head2 unsubscribe
  
    $e = $e->unsubscribe('foo');
    $e = $e->unsubscribe(foo => $cb);
  
  Unsubscribe from event.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_EVENTEMITTER_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_EVENTEMITTER_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_EVENTEMITTER

$fatpacked{"Mojo/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EXCEPTION';
  package Mojo::Exception;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  has [qw(frames line lines_after lines_before)] => sub { [] };
  has message => 'Exception!';
  has 'verbose';
  
  sub inspect {
    my ($self, @sources) = @_;
  
    # Extract file and line from message
    my @files;
    my $msg = $self->lines_before([])->line([])->lines_after([])->message;
    while ($msg =~ /at\s+(.+?)\s+line\s+(\d+)/g) { unshift @files, [$1, $2] }
  
    # Extract file and line from stack trace
    if (my $zero = $self->frames->[0]) { push @files, [$zero->[1], $zero->[2]] }
  
    # Search for context in files
    for my $file (@files) {
      next unless -r $file->[0] && open my $handle, '<:utf8', $file->[0];
      $self->_context($file->[1], [[<$handle>]]);
      return $self;
    }
  
    # Search for context in sources
    $self->_context($files[-1][1], [map { [split "\n"] } @sources]) if @sources;
  
    return $self;
  }
  
  sub new { @_ > 1 ? shift->SUPER::new(message => shift) : shift->SUPER::new }
  
  sub to_string {
    my $self = shift;
  
    my $str = $self->message;
    return $str unless $self->verbose;
  
    $str .= "\n" unless $str =~ /\n$/;
    $str .= $_->[0] . ': ' . $_->[1] . "\n" for @{$self->lines_before};
    $str .= $self->line->[0] . ': ' . $self->line->[1] . "\n" if $self->line->[0];
    $str .= $_->[0] . ': ' . $_->[1] . "\n" for @{$self->lines_after};
  
    return $str;
  }
  
  sub throw { CORE::die shift->new(shift)->trace(2)->inspect }
  
  sub trace {
    my ($self, $start) = (shift, shift // 1);
    my @frames;
    while (my @trace = caller($start++)) { push @frames, \@trace }
    return $self->frames(\@frames);
  }
  
  sub _append {
    my ($stack, $line) = @_;
    chomp $line;
    push @$stack, $line;
  }
  
  sub _context {
    my ($self, $num, $sources) = @_;
  
    # Line
    return unless defined $sources->[0][$num - 1];
    $self->line([$num]);
    _append($self->line, $_->[$num - 1]) for @$sources;
  
    # Before
    for my $i (2 .. 6) {
      last if ((my $previous = $num - $i) < 0);
      unshift @{$self->lines_before}, [$previous + 1];
      _append($self->lines_before->[0], $_->[$previous]) for @$sources;
    }
  
    # After
    for my $i (0 .. 4) {
      next if ((my $next = $num + $i) < 0);
      next unless defined $sources->[0][$next];
      push @{$self->lines_after}, [$next + 1];
      _append($self->lines_after->[-1], $_->[$next]) for @$sources;
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Exception - Exceptions with context
  
  =head1 SYNOPSIS
  
    use Mojo::Exception;
  
    # Throw exception and show stack trace
    eval { Mojo::Exception->throw('Something went wrong!') };
    say "$_->[1]:$_->[2]" for @{$@->frames};
  
    # Customize exception
    eval {
      my $e = Mojo::Exception->new('Died at test.pl line 3.');
      die $e->trace(2)->inspect->verbose(1);
    };
    say $@;
  
  =head1 DESCRIPTION
  
  L<Mojo::Exception> is a container for exceptions with context information.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Exception> implements the following attributes.
  
  =head2 frames
  
    my $frames = $e->frames;
    $e         = $e->frames([$frame1, $frame2]);
  
  Stack trace if available.
  
    # Extract information from the last frame
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext,
        $is_require, $hints, $bitmask, $hinthash) = @{$e->frames->[-1]};
  
  =head2 line
  
    my $line = $e->line;
    $e       = $e->line([3, 'die;']);
  
  The line where the exception occurred if available.
  
  =head2 lines_after
  
    my $lines = $e->lines_after;
    $e        = $e->lines_after([[4, 'say $foo;'], [5, 'say $bar;']]);
  
  Lines after the line where the exception occurred if available.
  
  =head2 lines_before
  
    my $lines = $e->lines_before;
    $e        = $e->lines_before([[1, 'my $foo = 23;'], [2, 'my $bar = 24;']]);
  
  Lines before the line where the exception occurred if available.
  
  =head2 message
  
    my $msg = $e->message;
    $e      = $e->message('Died at test.pl line 3.');
  
  Exception message, defaults to C<Exception!>.
  
  =head2 verbose
  
    my $bool = $e->verbose;
    $e       = $e->verbose($bool);
  
  Enable context information for L</"to_string">.
  
  =head1 METHODS
  
  L<Mojo::Exception> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 inspect
  
    $e = $e->inspect;
    $e = $e->inspect($source1, $source2);
  
  Inspect L</"message">, L</"frames"> and optional additional sources to fill
  L</"lines_before">, L</"line"> and L</"lines_after"> with context information.
  
  =head2 new
  
    my $e = Mojo::Exception->new;
    my $e = Mojo::Exception->new('Died at test.pl line 3.');
  
  Construct a new L<Mojo::Exception> object and assign L</"message"> if necessary.
  
  =head2 to_string
  
    my $str = $e->to_string;
  
  Render exception.
  
    # Render exception with context
    say $e->verbose(1)->to_string;
  
  =head2 throw
  
    Mojo::Exception->throw('Something went wrong!');
  
  Throw exception from the current execution context.
  
    # Longer version
    die Mojo::Exception->new('Something went wrong!')->trace->inspect;
  
  =head2 trace
  
    $e = $e->trace;
    $e = $e->trace($skip);
  
  Generate stack trace and store all L</"frames">, defaults to skipping C<1> call
  frame.
  
    # Skip 3 call frames
    $e->trace(3);
  
    # Skip no call frames
    $e->trace(0);
  
  =head1 OPERATORS
  
  L<Mojo::Exception> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$e;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$e";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_EXCEPTION

$fatpacked{"Mojo/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HEADERS';
  package Mojo::Headers;
  use Mojo::Base -base;
  
  use Mojo::Util 'monkey_patch';
  
  has max_line_size => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
  has max_lines     => sub { $ENV{MOJO_MAX_LINES}     || 100 };
  
  # Common headers
  my %NAMES = map { lc() => $_ } (
    qw(Accept Accept-Charset Accept-Encoding Accept-Language Accept-Ranges),
    qw(Access-Control-Allow-Origin Allow Authorization Cache-Control Connection),
    qw(Content-Disposition Content-Encoding Content-Language Content-Length),
    qw(Content-Location Content-Range Content-Security-Policy Content-Type),
    qw(Cookie DNT Date ETag Expect Expires Host If-Modified-Since If-None-Match),
    qw(Last-Modified Link Location Origin Proxy-Authenticate),
    qw(Proxy-Authorization Range Sec-WebSocket-Accept Sec-WebSocket-Extensions),
    qw(Sec-WebSocket-Key Sec-WebSocket-Protocol Sec-WebSocket-Version Server),
    qw(Set-Cookie Status Strict-Transport-Security TE Trailer Transfer-Encoding),
    qw(Upgrade User-Agent Vary WWW-Authenticate)
  );
  for my $header (keys %NAMES) {
    my $name = $header;
    $name =~ y/-/_/;
    monkey_patch __PACKAGE__, $name, sub {
      my $self = shift;
      $self->{headers}{$header} = [@_] and return $self if @_;
      return undef unless my $headers = $self->{headers}{$header};
      return join ', ', @$headers;
    };
  }
  
  sub add {
    my ($self, $name) = (shift, shift);
  
    # Make sure we have a normal case entry for name
    my $key = lc $name;
    $self->{names}{$key} //= $name unless $NAMES{$key};
    push @{$self->{headers}{$key}}, @_;
  
    return $self;
  }
  
  sub append {
    my ($self, $name, $value) = @_;
    my $old = $self->header($name);
    return $self->header($name => defined $old ? "$old, $value" : $value);
  }
  
  sub clone { $_[0]->new->from_hash($_[0]->to_hash(1)) }
  
  sub from_hash {
    my ($self, $hash) = @_;
  
    # Empty hash deletes all headers
    delete $self->{headers} if keys %{$hash} == 0;
  
    # Merge
    for my $header (keys %$hash) {
      my $value = $hash->{$header};
      $self->add($header => ref $value eq 'ARRAY' ? @$value : $value);
    }
  
    return $self;
  }
  
  sub header {
    my ($self, $name) = (shift, shift);
  
    # Replace
    return $self->remove($name)->add($name, @_) if @_;
  
    return undef unless my $headers = $self->{headers}{lc $name};
    return join ', ', @$headers;
  }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub leftovers { delete shift->{buffer} }
  
  sub names {
    my $self = shift;
    return [map { $NAMES{$_} || $self->{names}{$_} } keys %{$self->{headers}}];
  }
  
  sub parse {
    my ($self, $chunk) = @_;
  
    $self->{state} = 'headers';
    $self->{buffer} .= $chunk;
    my $headers = $self->{cache} ||= [];
    my $size    = $self->max_line_size;
    my $lines   = $self->max_lines;
    while ($self->{buffer} =~ s/^(.*?)\x0d?\x0a//) {
      my $line = $1;
  
      # Check line size limit
      if ($+[0] > $size || @$headers >= $lines) {
        @$self{qw(state limit)} = ('finished', 1);
        return $self;
      }
  
      # New header
      if ($line =~ /^(\S[^:]*)\s*:\s*(.*)$/) { push @$headers, [$1, $2] }
  
      # Multi-line
      elsif ($line =~ s/^\s+// && @$headers) { $headers->[-1][1] .= " $line" }
  
      # Empty line
      else {
        $self->add(@$_) for @$headers;
        @$self{qw(state cache)} = ('finished', []);
        return $self;
      }
    }
  
    # Check line size limit
    @$self{qw(state limit)} = ('finished', 1) if length $self->{buffer} > $size;
  
    return $self;
  }
  
  sub referrer { shift->header(Referer => @_) }
  
  sub remove {
    my ($self, $name) = @_;
    delete $self->{headers}{lc $name};
    return $self;
  }
  
  sub to_hash {
    my ($self, $multi) = @_;
    return {map { $_ => $self->{headers}{lc $_} } @{$self->names}} if $multi;
    return {map { $_ => $self->header($_) } @{$self->names}};
  }
  
  sub to_string {
    my $self = shift;
  
    # Make sure multi-line values are formatted correctly
    my @headers;
    for my $name (@{$self->names}) {
      push @headers, "$name: $_" for @{$self->{headers}{lc $name}};
    }
  
    return join "\x0d\x0a", @headers;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Headers - HTTP headers
  
  =head1 SYNOPSIS
  
    use Mojo::Headers;
  
    # Parse
    my $headers = Mojo::Headers->new;
    $headers->parse("Content-Length: 42\x0d\x0a");
    $headers->parse("Content-Type: text/html\x0d\x0a\x0d\x0a");
    say $headers->content_length;
    say $headers->content_type;
  
    # Build
    my $headers = Mojo::Headers->new;
    $headers->content_length(42);
    $headers->content_type('text/plain');
    say $headers->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Headers> is a container for HTTP headers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Headers> implements the following attributes.
  
  =head2 max_line_size
  
    my $size = $headers->max_line_size;
    $headers = $headers->max_line_size(1024);
  
  Maximum header line size in bytes, defaults to the value of the
  C<MOJO_MAX_LINE_SIZE> environment variable or C<8192> (8KB).
  
  =head2 max_lines
  
    my $num  = $headers->max_lines;
    $headers = $headers->max_lines(200);
  
  Maximum number of header lines, defaults to the value of the C<MOJO_MAX_LINES>
  environment variable or C<100>.
  
  =head1 METHODS
  
  L<Mojo::Headers> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 accept
  
    my $accept = $headers->accept;
    $headers   = $headers->accept('application/json');
  
  Get or replace current header value, shortcut for the C<Accept> header.
  
  =head2 accept_charset
  
    my $charset = $headers->accept_charset;
    $headers    = $headers->accept_charset('UTF-8');
  
  Get or replace current header value, shortcut for the C<Accept-Charset> header.
  
  =head2 accept_encoding
  
    my $encoding = $headers->accept_encoding;
    $headers     = $headers->accept_encoding('gzip');
  
  Get or replace current header value, shortcut for the C<Accept-Encoding> header.
  
  =head2 accept_language
  
    my $language = $headers->accept_language;
    $headers     = $headers->accept_language('de, en');
  
  Get or replace current header value, shortcut for the C<Accept-Language> header.
  
  =head2 accept_ranges
  
    my $ranges = $headers->accept_ranges;
    $headers   = $headers->accept_ranges('bytes');
  
  Get or replace current header value, shortcut for the C<Accept-Ranges> header.
  
  =head2 access_control_allow_origin
  
    my $origin = $headers->access_control_allow_origin;
    $headers   = $headers->access_control_allow_origin('*');
  
  Get or replace current header value, shortcut for the
  C<Access-Control-Allow-Origin> header from
  L<Cross-Origin Resource Sharing|http://www.w3.org/TR/cors/>.
  
  =head2 add
  
    $headers = $headers->add(Foo => 'one value');
    $headers = $headers->add(Foo => 'first value', 'second value');
  
  Add header with one or more lines.
  
    # "Vary: Accept
    #  Vary: Accept-Encoding"
    $headers->add(Vary => 'Accept')->add(Vary => 'Accept-Encoding')->to_string;
  
  =head2 allow
  
    my $allow = $headers->allow;
    $headers  = $headers->allow('GET, POST');
  
  Get or replace current header value, shortcut for the C<Allow> header.
  
  =head2 append
  
    $headers = $headers->append(Vary => 'Accept-Encoding');
  
  Append value to header and flatten it if necessary.
  
    # "Vary: Accept"
    $headers->append(Vary => 'Accept')->to_string;
  
    # "Vary: Accept, Accept-Encoding"
    $headers->vary('Accept')->append(Vary => 'Accept-Encoding')->to_string;
  
  =head2 authorization
  
    my $authorization = $headers->authorization;
    $headers          = $headers->authorization('Basic Zm9vOmJhcg==');
  
  Get or replace current header value, shortcut for the C<Authorization> header.
  
  =head2 cache_control
  
    my $cache_control = $headers->cache_control;
    $headers          = $headers->cache_control('max-age=1, no-cache');
  
  Get or replace current header value, shortcut for the C<Cache-Control> header.
  
  =head2 clone
  
    my $clone = $headers->clone;
  
  Clone headers.
  
  =head2 connection
  
    my $connection = $headers->connection;
    $headers       = $headers->connection('close');
  
  Get or replace current header value, shortcut for the C<Connection> header.
  
  =head2 content_disposition
  
    my $disposition = $headers->content_disposition;
    $headers        = $headers->content_disposition('foo');
  
  Get or replace current header value, shortcut for the C<Content-Disposition>
  header.
  
  =head2 content_encoding
  
    my $encoding = $headers->content_encoding;
    $headers     = $headers->content_encoding('gzip');
  
  Get or replace current header value, shortcut for the C<Content-Encoding>
  header.
  
  =head2 content_language
  
    my $language = $headers->content_language;
    $headers     = $headers->content_language('en');
  
  Get or replace current header value, shortcut for the C<Content-Language>
  header.
  
  =head2 content_length
  
    my $len  = $headers->content_length;
    $headers = $headers->content_length(4000);
  
  Get or replace current header value, shortcut for the C<Content-Length> header.
  
  =head2 content_location
  
    my $location = $headers->content_location;
    $headers     = $headers->content_location('http://127.0.0.1/foo');
  
  Get or replace current header value, shortcut for the C<Content-Location>
  header.
  
  =head2 content_range
  
    my $range = $headers->content_range;
    $headers  = $headers->content_range('bytes 2-8/100');
  
  Get or replace current header value, shortcut for the C<Content-Range> header.
  
  =head2 content_security_policy
  
    my $policy = $headers->content_security_policy;
    $headers   = $headers->content_security_policy('default-src https:');
  
  Get or replace current header value, shortcut for the C<Content-Security-Policy>
  header from L<Content Security Policy 1.0|http://www.w3.org/TR/CSP/>.
  
  =head2 content_type
  
    my $type = $headers->content_type;
    $headers = $headers->content_type('text/plain');
  
  Get or replace current header value, shortcut for the C<Content-Type> header.
  
  =head2 cookie
  
    my $cookie = $headers->cookie;
    $headers   = $headers->cookie('f=b');
  
  Get or replace current header value, shortcut for the C<Cookie> header from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 date
  
    my $date = $headers->date;
    $headers = $headers->date('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<Date> header.
  
  =head2 dnt
  
    my $dnt  = $headers->dnt;
    $headers = $headers->dnt(1);
  
  Get or replace current header value, shortcut for the C<DNT> (Do Not Track)
  header, which has no specification yet, but is very commonly used.
  
  =head2 etag
  
    my $etag = $headers->etag;
    $headers = $headers->etag('"abc321"');
  
  Get or replace current header value, shortcut for the C<ETag> header.
  
  =head2 expect
  
    my $expect = $headers->expect;
    $headers   = $headers->expect('100-continue');
  
  Get or replace current header value, shortcut for the C<Expect> header.
  
  =head2 expires
  
    my $expires = $headers->expires;
    $headers    = $headers->expires('Thu, 01 Dec 1994 16:00:00 GMT');
  
  Get or replace current header value, shortcut for the C<Expires> header.
  
  =head2 from_hash
  
    $headers = $headers->from_hash({'Cookie' => 'a=b'});
    $headers = $headers->from_hash({'Cookie' => ['a=b', 'c=d']});
    $headers = $headers->from_hash({});
  
  Parse headers from a hash reference, an empty hash removes all headers.
  
  =head2 header
  
    my $value = $headers->header('Foo');
    $headers  = $headers->header(Foo => 'one value');
    $headers  = $headers->header(Foo => 'first value', 'second value');
  
  Get or replace the current header values.
  
  =head2 host
  
    my $host = $headers->host;
    $headers = $headers->host('127.0.0.1');
  
  Get or replace current header value, shortcut for the C<Host> header.
  
  =head2 if_modified_since
  
    my $date = $headers->if_modified_since;
    $headers = $headers->if_modified_since('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<If-Modified-Since>
  header.
  
  =head2 if_none_match
  
    my $etag = $headers->if_none_match;
    $headers = $headers->if_none_match('"abc321"');
  
  Get or replace current header value, shortcut for the C<If-None-Match> header.
  
  =head2 is_finished
  
    my $bool = $headers->is_finished;
  
  Check if header parser is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $headers->is_limit_exceeded;
  
  Check if headers have exceeded L</"max_line_size"> or L</"max_lines">.
  
  =head2 last_modified
  
    my $date = $headers->last_modified;
    $headers = $headers->last_modified('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<Last-Modified> header.
  
  =head2 leftovers
  
    my $bytes = $headers->leftovers;
  
  Get and remove leftover data from header parser.
  
  =head2 link
  
    my $link = $headers->link;
    $headers = $headers->link('<http://127.0.0.1/foo/3>; rel="next"');
  
  Get or replace current header value, shortcut for the C<Link> header from
  L<RFC 5988|http://tools.ietf.org/html/rfc5988>.
  
  =head2 location
  
    my $location = $headers->location;
    $headers     = $headers->location('http://127.0.0.1/foo');
  
  Get or replace current header value, shortcut for the C<Location> header.
  
  =head2 names
  
    my $names = $headers->names;
  
  Return an array reference with all currently defined headers.
  
    # Names of all headers
    say for @{$headers->names};
  
  =head2 origin
  
    my $origin = $headers->origin;
    $headers   = $headers->origin('http://example.com');
  
  Get or replace current header value, shortcut for the C<Origin> header from
  L<RFC 6454|http://tools.ietf.org/html/rfc6454>.
  
  =head2 parse
  
    $headers = $headers->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
  
  Parse formatted headers.
  
  =head2 proxy_authenticate
  
    my $authenticate = $headers->proxy_authenticate;
    $headers         = $headers->proxy_authenticate('Basic "realm"');
  
  Get or replace current header value, shortcut for the C<Proxy-Authenticate>
  header.
  
  =head2 proxy_authorization
  
    my $authorization = $headers->proxy_authorization;
    $headers          = $headers->proxy_authorization('Basic Zm9vOmJhcg==');
  
  Get or replace current header value, shortcut for the C<Proxy-Authorization>
  header.
  
  =head2 range
  
    my $range = $headers->range;
    $headers  = $headers->range('bytes=2-8');
  
  Get or replace current header value, shortcut for the C<Range> header.
  
  =head2 referrer
  
    my $referrer = $headers->referrer;
    $headers     = $headers->referrer('http://example.com');
  
  Get or replace current header value, shortcut for the C<Referer> header, there
  was a typo in L<RFC 2068|http://tools.ietf.org/html/rfc2068> which resulted in
  C<Referer> becoming an official header.
  
  =head2 remove
  
    $headers = $headers->remove('Foo');
  
  Remove a header.
  
  =head2 sec_websocket_accept
  
    my $accept = $headers->sec_websocket_accept;
    $headers   = $headers->sec_websocket_accept('s3pPLMBiTxaQ9kYGzzhZRbK+xOo=');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Accept>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_extensions
  
    my $extensions = $headers->sec_websocket_extensions;
    $headers       = $headers->sec_websocket_extensions('foo');
  
  Get or replace current header value, shortcut for the
  C<Sec-WebSocket-Extensions> header from
  L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_key
  
    my $key  = $headers->sec_websocket_key;
    $headers = $headers->sec_websocket_key('dGhlIHNhbXBsZSBub25jZQ==');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Key>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_protocol
  
    my $proto = $headers->sec_websocket_protocol;
    $headers  = $headers->sec_websocket_protocol('sample');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Protocol>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_version
  
    my $version = $headers->sec_websocket_version;
    $headers    = $headers->sec_websocket_version(13);
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Version>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 server
  
    my $server = $headers->server;
    $headers   = $headers->server('Mojo');
  
  Get or replace current header value, shortcut for the C<Server> header.
  
  =head2 set_cookie
  
    my $cookie = $headers->set_cookie;
    $headers   = $headers->set_cookie('f=b; path=/');
  
  Get or replace current header value, shortcut for the C<Set-Cookie> header from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 status
  
    my $status = $headers->status;
    $headers   = $headers->status('200 OK');
  
  Get or replace current header value, shortcut for the C<Status> header from
  L<RFC 3875|http://tools.ietf.org/html/rfc3875>.
  
  =head2 strict_transport_security
  
    my $policy = $headers->strict_transport_security;
    $headers   = $headers->strict_transport_security('max-age=31536000');
  
  Get or replace current header value, shortcut for the
  C<Strict-Transport-Security> header from
  L<RFC 6797|http://tools.ietf.org/html/rfc6797>.
  
  =head2 te
  
    my $te   = $headers->te;
    $headers = $headers->te('chunked');
  
  Get or replace current header value, shortcut for the C<TE> header.
  
  =head2 to_hash
  
    my $single = $headers->to_hash;
    my $multi  = $headers->to_hash(1);
  
  Turn headers into hash reference, array references to represent multiple
  headers with the same name are disabled by default.
  
    say $headers->to_hash->{DNT};
  
  =head2 to_string
  
    my $str = $headers->to_string;
  
  Turn headers into a string, suitable for HTTP messages.
  
  =head2 trailer
  
    my $trailer = $headers->trailer;
    $headers    = $headers->trailer('X-Foo');
  
  Get or replace current header value, shortcut for the C<Trailer> header.
  
  =head2 transfer_encoding
  
    my $encoding = $headers->transfer_encoding;
    $headers     = $headers->transfer_encoding('chunked');
  
  Get or replace current header value, shortcut for the C<Transfer-Encoding>
  header.
  
  =head2 upgrade
  
    my $upgrade = $headers->upgrade;
    $headers    = $headers->upgrade('websocket');
  
  Get or replace current header value, shortcut for the C<Upgrade> header.
  
  =head2 user_agent
  
    my $agent = $headers->user_agent;
    $headers  = $headers->user_agent('Mojo/1.0');
  
  Get or replace current header value, shortcut for the C<User-Agent> header.
  
  =head2 vary
  
    my $vary = $headers->vary;
    $headers = $headers->vary('*');
  
  Get or replace current header value, shortcut for the C<Vary> header.
  
  =head2 www_authenticate
  
    my $authenticate = $headers->www_authenticate;
    $headers         = $headers->www_authenticate('Basic realm="realm"');
  
  Get or replace current header value, shortcut for the C<WWW-Authenticate>
  header.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_HEADERS

$fatpacked{"Mojo/HelloWorld.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HELLOWORLD';
  package Mojo::HelloWorld;
  use Mojolicious::Lite;
  
  app->log->level('error')->path(undef);
  
  any '/*whatever' => {whatever => '', text => 'Your Mojo is working!'};
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::HelloWorld - Hello World!
  
  =head1 SYNOPSIS
  
    use Mojo::HelloWorld;
  
    my $hello = Mojo::HelloWorld->new;
    $hello->start;
  
  =head1 DESCRIPTION
  
  L<Mojo::HelloWorld> is the default L<Mojolicious> application, used mostly for
  testing.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_HELLOWORLD

$fatpacked{"Mojo/Home.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HOME';
  package Mojo::Home;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Cwd qw(abs_path getcwd);
  use File::Basename 'dirname';
  use File::Spec::Functions qw(abs2rel catdir catfile splitdir);
  use Mojo::Util qw(class_to_path files);
  
  has parts => sub { [] };
  
  sub detect {
    my ($self, $class) = @_;
  
    # Environment variable
    return $self->parts([splitdir abs_path $ENV{MOJO_HOME}]) if $ENV{MOJO_HOME};
  
    # Location of the application class
    if ($class && (my $path = $INC{my $file = class_to_path $class})) {
      $path =~ s/\Q$file\E$//;
      my @home = splitdir $path;
  
      # Remove "lib" and "blib"
      pop @home while @home && ($home[-1] =~ /^b?lib$/ || !length $home[-1]);
  
      # Turn into absolute path
      return $self->parts([splitdir abs_path catdir(@home) || '.']);
    }
  
    # Current working directory
    return $self->parts([splitdir getcwd]);
  }
  
  sub lib_dir {
    my $path = catdir @{shift->parts}, 'lib';
    return -d $path ? $path : undef;
  }
  
  sub list_files {
    my ($self, $dir, $options) = (shift, shift // '', shift);
    $dir = catdir @{$self->parts}, split('/', $dir);
    return [map { join '/', splitdir abs2rel($_, $dir) } files $dir, $options];
  }
  
  sub mojo_lib_dir { catdir dirname(__FILE__), '..' }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse { shift->parts([splitdir shift]) }
  
  sub rel_dir  { catdir @{shift->parts},  split('/', shift) }
  sub rel_file { catfile @{shift->parts}, split('/', shift) }
  
  sub to_string { catdir @{shift->parts} }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Home - Home sweet home
  
  =head1 SYNOPSIS
  
    use Mojo::Home;
  
    # Find and manage the project root directory
    my $home = Mojo::Home->new;
    $home->detect;
    say $home->lib_dir;
    say $home->rel_file('templates/layouts/default.html.ep');
    say "$home";
  
  =head1 DESCRIPTION
  
  L<Mojo::Home> is a container for home directories.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Home> implements the following attributes.
  
  =head2 parts
  
    my $parts = $home->parts;
    $home     = $home->parts(['home', 'sri', 'myapp']);
  
  Home directory parts.
  
  =head1 METHODS
  
  L<Mojo::Home> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 detect
  
    $home = $home->detect;
    $home = $home->detect('My::App');
  
  Detect home directory from the value of the C<MOJO_HOME> environment variable,
  location of the application class, or the current working directory.
  
  =head2 lib_dir
  
    my $path = $home->lib_dir;
  
  Path to C<lib> directory of application.
  
  =head2 list_files
  
    my $files = $home->list_files;
    my $files = $home->list_files('foo/bar');
    my $files = $home->list_files('foo/bar', {hidden => 1});
  
  Portably list all files recursively in directory relative to the home directory.
  
    # List layouts
    say $home->rel_file($_) for @{$home->list_files('templates/layouts')};
  
  These options are currently available:
  
  =over 2
  
  =item hidden
  
    hidden => 1
  
  Include hidden files and directories.
  
  =back
  
  =head2 mojo_lib_dir
  
    my $path = $home->mojo_lib_dir;
  
  Path to C<lib> directory in which L<Mojolicious> is installed.
  
  =head2 new
  
    my $home = Mojo::Home->new;
    my $home = Mojo::Home->new('/home/sri/my_app');
  
  Construct a new L<Mojo::Home> object and L</"parse"> home directory if
  necessary.
  
  =head2 parse
  
    $home = $home->parse('/home/sri/my_app');
  
  Parse home directory.
  
  =head2 rel_dir
  
    my $path = $home->rel_dir('foo/bar');
  
  Portably generate an absolute path for a directory relative to the home
  directory.
  
  =head2 rel_file
  
    my $path = $home->rel_file('foo/bar.html');
  
  Portably generate an absolute path for a file relative to the home directory.
  
  =head2 to_string
  
    my $str = $home->to_string;
  
  Home directory.
  
  =head1 OPERATORS
  
  L<Mojo::Home> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$home;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$home";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_HOME

$fatpacked{"Mojo/IOLoop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP';
  package Mojo::IOLoop;
  use Mojo::Base 'Mojo::EventEmitter';
  
  # "Professor: Amy, technology isn't intrinsically good or evil. It's how it's
  #             used. Like the death ray."
  use Carp 'croak';
  use Mojo::IOLoop::Client;
  use Mojo::IOLoop::Delay;
  use Mojo::IOLoop::Server;
  use Mojo::IOLoop::Stream;
  use Mojo::Reactor::Poll;
  use Mojo::Util qw(md5_sum steady_time);
  use Scalar::Util qw(blessed weaken);
  
  use constant DEBUG => $ENV{MOJO_IOLOOP_DEBUG} || 0;
  
  has max_accepts     => 0;
  has max_connections => 1000;
  has reactor         => sub {
    my $class = Mojo::Reactor::Poll->detect;
    warn "-- Reactor initialized ($class)\n" if DEBUG;
    return $class->new->catch(sub { warn "@{[blessed $_[0]]}: $_[1]" });
  };
  
  # Ignore PIPE signal
  $SIG{PIPE} = 'IGNORE';
  
  # Initialize singleton reactor early
  __PACKAGE__->singleton->reactor;
  
  sub acceptor {
    my ($self, $acceptor) = (_instance(shift), @_);
  
    # Find acceptor for id
    return $self->{acceptors}{$acceptor} unless ref $acceptor;
  
    # Connect acceptor with reactor
    $self->{acceptors}{my $id = $self->_id} = $acceptor;
    weaken $acceptor->reactor($self->reactor)->{reactor};
  
    # Allow new acceptor to get picked up
    $self->_not_accepting->_maybe_accepting;
  
    return $id;
  }
  
  sub client {
    my ($self, $cb) = (_instance(shift), pop);
  
    my $id = $self->_id;
    my $client = $self->{out}{$id}{client} = Mojo::IOLoop::Client->new;
    weaken $client->reactor($self->reactor)->{reactor};
  
    weaken $self;
    $client->on(
      connect => sub {
        delete $self->{out}{$id}{client};
        my $stream = Mojo::IOLoop::Stream->new(pop);
        $self->_stream($stream => $id);
        $self->$cb(undef, $stream);
      }
    );
    $client->on(error => sub { $self->_remove($id); $self->$cb(pop, undef) });
    $client->connect(@_);
  
    return $id;
  }
  
  sub delay {
    my $delay = Mojo::IOLoop::Delay->new;
    weaken $delay->ioloop(_instance(shift))->{ioloop};
    return @_ ? $delay->steps(@_) : $delay;
  }
  
  sub is_running { _instance(shift)->reactor->is_running }
  
  sub next_tick {
    my ($self, $cb) = (_instance(shift), @_);
    weaken $self;
    return $self->reactor->next_tick(sub { $self->$cb });
  }
  
  sub one_tick { _instance(shift)->reactor->one_tick }
  
  sub recurring { shift->_timer(recurring => @_) }
  
  sub remove {
    my ($self, $id) = (_instance(shift), @_);
    my $c = $self->{in}{$id} || $self->{out}{$id};
    if ($c && (my $stream = $c->{stream})) { return $stream->close_gracefully }
    $self->_remove($id);
  }
  
  sub reset {
    my $self = _instance(shift);
    delete @$self{qw(accepting acceptors in out stop)};
    $self->reactor->reset;
    $self->stop;
  }
  
  sub server {
    my ($self, $cb) = (_instance(shift), pop);
  
    my $server = Mojo::IOLoop::Server->new;
    weaken $self;
    $server->on(
      accept => sub {
        my $stream = Mojo::IOLoop::Stream->new(pop);
        $self->$cb($stream, $self->_stream($stream, $self->_id, 1));
  
        # Enforce connection limit (randomize to improve load balancing)
        if (my $max = $self->max_accepts) {
          $self->{accepts} //= $max - int rand $max / 2;
          $self->stop_gracefully if ($self->{accepts} -= 1) <= 0;
        }
  
        # Stop accepting if connection limit has been reached
        $self->_not_accepting if $self->_limit;
      }
    );
    $server->listen(@_);
  
    return $self->acceptor($server);
  }
  
  sub singleton { state $loop = shift->SUPER::new }
  
  sub start {
    my $self = _instance(shift);
    croak 'Mojo::IOLoop already running' if $self->is_running;
    $self->reactor->start;
  }
  
  sub stop { _instance(shift)->reactor->stop }
  
  sub stop_gracefully {
    my $self = _instance(shift)->_not_accepting;
    ++$self->{stop} and !$self->emit('finish')->_in and $self->stop;
  }
  
  sub stream {
    my ($self, $stream) = (_instance(shift), @_);
    return $self->_stream($stream => $self->_id) if ref $stream;
    my $c = $self->{in}{$stream} || $self->{out}{$stream} || {};
    return $c->{stream};
  }
  
  sub timer { shift->_timer(timer => @_) }
  
  sub _id {
    my $self = shift;
    my $id;
    do { $id = md5_sum 'c' . steady_time . rand }
      while $self->{in}{$id} || $self->{out}{$id} || $self->{acceptors}{$id};
    return $id;
  }
  
  sub _in { scalar keys %{shift->{in} || {}} }
  
  sub _instance { ref $_[0] ? $_[0] : $_[0]->singleton }
  
  sub _limit { $_[0]{stop} ? 1 : $_[0]->_in >= $_[0]->max_connections }
  
  sub _maybe_accepting {
    my $self = shift;
    return if $self->{accepting} || $self->_limit;
    $_->start for values %{$self->{acceptors} || {}};
    $self->{accepting} = 1;
  }
  
  sub _not_accepting {
    my $self = shift;
    return $self unless delete $self->{accepting};
    $_->stop for values %{$self->{acceptors} || {}};
    return $self;
  }
  
  sub _out { scalar keys %{shift->{out} || {}} }
  
  sub _remove {
    my ($self, $id) = @_;
  
    # Timer
    return unless my $reactor = $self->reactor;
    return if $reactor->remove($id);
  
    # Acceptor
    return $self->_not_accepting->_maybe_accepting
      if delete $self->{acceptors}{$id};
  
    # Connection
    return unless delete $self->{in}{$id} || delete $self->{out}{$id};
    return $self->stop if $self->{stop} && !$self->_in;
    $self->_maybe_accepting;
    warn "-- $id <<< $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
  }
  
  sub _stream {
    my ($self, $stream, $id, $server) = @_;
  
    # Connect stream with reactor
    $self->{$server ? 'in' : 'out'}{$id}{stream} = $stream;
    warn "-- $id >>> $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
    weaken $stream->reactor($self->reactor)->{reactor};
    weaken $self;
    $stream->on(close => sub { $self && $self->_remove($id) });
    $stream->start;
  
    return $id;
  }
  
  sub _timer {
    my ($self, $method, $after, $cb) = (_instance(shift), @_);
    weaken $self;
    return $self->reactor->$method($after => sub { $self->$cb });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop - Minimalistic event loop
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop;
  
    # Listen on port 3000
    Mojo::IOLoop->server({port => 3000} => sub {
      my ($loop, $stream) = @_;
  
      $stream->on(read => sub {
        my ($stream, $bytes) = @_;
  
        # Process input chunk
        say $bytes;
  
        # Write response
        $stream->write('HTTP/1.1 200 OK');
      });
    });
  
    # Connect to port 3000
    my $id = Mojo::IOLoop->client({port => 3000} => sub {
      my ($loop, $err, $stream) = @_;
  
      $stream->on(read => sub {
        my ($stream, $bytes) = @_;
  
        # Process input
        say "Input: $bytes";
      });
  
      # Write request
      $stream->write("GET / HTTP/1.1\x0d\x0a\x0d\x0a");
    });
  
    # Add a timer
    Mojo::IOLoop->timer(5 => sub {
      my $loop = shift;
      $loop->remove($id);
    });
  
    # Start event loop if necessary
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop> is a very minimalistic event loop based on L<Mojo::Reactor>, it
  has been reduced to the absolute minimal feature set required to build solid
  and scalable non-blocking TCP clients and servers.
  
  Depending on operating system, the default per-process and system-wide file
  descriptor limits are often very low and need to be tuned for better
  scalability. The C<LIBEV_FLAGS> environment variable should also be used to
  select the best possible L<EV> backend, which usually defaults to the not very
  scalable C<select>.
  
    LIBEV_FLAGS=1   # select
    LIBEV_FLAGS=2   # poll
    LIBEV_FLAGS=4   # epoll (Linux)
    LIBEV_FLAGS=8   # kqueue (*BSD, OS X)
  
  The event loop will be resilient to time jumps if a monotonic clock is
  available through L<Time::HiRes>. A TLS certificate and key are also built
  right in, to make writing test servers as easy as possible. Also note that for
  convenience the C<PIPE> signal will be set to C<IGNORE> when L<Mojo::IOLoop> is
  loaded.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NDN>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"REAL-TIME WEB"> for more.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 finish
  
    $loop->on(finish => sub {
      my $loop = shift;
      ...
    });
  
  Emitted when the event loop wants to shut down gracefully and is just waiting
  for all existing connections to be closed.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop> implements the following attributes.
  
  =head2 max_accepts
  
    my $max = $loop->max_accepts;
    $loop   = $loop->max_accepts(1000);
  
  The maximum number of connections this event loop is allowed to accept, before
  shutting down gracefully without interrupting existing connections, defaults to
  C<0>. Setting the value to C<0> will allow this event loop to accept new
  connections indefinitely. Note that up to half of this value can be subtracted
  randomly to improve load balancing between multiple server processes.
  
  =head2 max_connections
  
    my $max = $loop->max_connections;
    $loop   = $loop->max_connections(100);
  
  The maximum number of accepted connections this event loop is allowed to handle
  concurrently, before stopping to accept new incoming connections, defaults to
  C<1000>.
  
  =head2 reactor
  
    my $reactor = $loop->reactor;
    $loop       = $loop->reactor(Mojo::Reactor->new);
  
  Low-level event reactor, usually a L<Mojo::Reactor::Poll> or
  L<Mojo::Reactor::EV> object with a default subscriber to the event
  L<Mojo::Reactor/"error">.
  
    # Watch if handle becomes readable or writable
    $loop->reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $loop->reactor->watch($handle, 0, 1);
  
    # Remove handle again
    $loop->reactor->remove($handle);
  
  =head1 METHODS
  
  L<Mojo::IOLoop> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 acceptor
  
    my $server = Mojo::IOLoop->acceptor($id);
    my $server = $loop->acceptor($id);
    my $id     = $loop->acceptor(Mojo::IOLoop::Server->new);
  
  Get L<Mojo::IOLoop::Server> object for id or turn object into an acceptor.
  
  =head2 client
  
    my $id
      = Mojo::IOLoop->client(address => '127.0.0.1', port => 3000, sub {...});
    my $id = $loop->client(address => '127.0.0.1', port => 3000, sub {...});
    my $id = $loop->client({address => '127.0.0.1', port => 3000} => sub {...});
  
  Open TCP connection with L<Mojo::IOLoop::Client>, takes the same arguments as
  L<Mojo::IOLoop::Client/"connect">.
  
    # Connect to 127.0.0.1 on port 3000
    Mojo::IOLoop->client({port => 3000} => sub {
      my ($loop, $err, $stream) = @_;
      ...
    });
  
  =head2 delay
  
    my $delay = Mojo::IOLoop->delay;
    my $delay = $loop->delay;
    my $delay = $loop->delay(sub {...});
    my $delay = $loop->delay(sub {...}, sub {...});
  
  Build L<Mojo::IOLoop::Delay> object to manage callbacks and control the flow of
  events for this event loop, which can help you avoid deep nested closures that
  often result from continuation-passing style. Callbacks will be passed along to
  L<Mojo::IOLoop::Delay/"steps">.
  
    # Synchronize multiple non-blocking operations
    my $delay = Mojo::IOLoop->delay(sub { say 'BOOM!' });
    for my $i (1 .. 10) {
      my $end = $delay->begin;
      Mojo::IOLoop->timer($i => sub {
        say 10 - $i;
        $end->();
      });
    }
    $delay->wait;
  
    # Sequentialize multiple non-blocking operations
    Mojo::IOLoop->delay(
  
      # First step (simple timer)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(2 => $delay->begin);
        say 'Second step in 2 seconds.';
      },
  
      # Second step (concurrent timers)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(1 => $delay->begin);
        Mojo::IOLoop->timer(3 => $delay->begin);
        say 'Third step in 3 seconds.';
      },
  
      # Third step (the end)
      sub { say 'And done after 5 seconds total.' }
    )->wait;
  
    # Handle exceptions in all steps
    Mojo::IOLoop->delay(
      sub {
        my $delay = shift;
        die 'Intentional error';
      },
      sub {
        my ($delay, @args) = @_;
        say 'Never actually reached.';
      }
    )->catch(sub {
      my ($delay, $err) = @_;
      say "Something went wrong: $err";
    })->wait;
  
  =head2 is_running
  
    my $bool = Mojo::IOLoop->is_running;
    my $bool = $loop->is_running;
  
  Check if event loop is running.
  
    exit unless Mojo::IOLoop->is_running;
  
  =head2 next_tick
  
    my $undef = Mojo::IOLoop->next_tick(sub {...});
    my $undef = $loop->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  
    # Perform operation on next reactor tick
    Mojo::IOLoop->next_tick(sub {
      my $loop = shift;
      ...
    });
  
  =head2 one_tick
  
    Mojo::IOLoop->one_tick;
    $loop->one_tick;
  
  Run event loop until an event occurs. Note that this method can recurse back
  into the reactor, so you need to be careful.
  
    # Don't block longer than 0.5 seconds
    my $id = Mojo::IOLoop->timer(0.5 => sub {});
    Mojo::IOLoop->one_tick;
    Mojo::IOLoop->remove($id);
  
  =head2 recurring
  
    my $id = Mojo::IOLoop->recurring(3 => sub {...});
    my $id = $loop->recurring(0 => sub {...});
    my $id = $loop->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
    # Perform operation every 5 seconds
    Mojo::IOLoop->recurring(5 => sub {
      my $loop = shift;
      ...
    });
  
  =head2 remove
  
    Mojo::IOLoop->remove($id);
    $loop->remove($id);
  
  Remove anything with an id, connections will be dropped gracefully by allowing
  them to finish writing all data in their write buffers.
  
  =head2 reset
  
    Mojo::IOLoop->reset;
    $loop->reset;
  
  Remove everything and stop the event loop.
  
  =head2 server
  
    my $id = Mojo::IOLoop->server(port => 3000, sub {...});
    my $id = $loop->server(port => 3000, sub {...});
    my $id = $loop->server({port => 3000} => sub {...});
  
  Accept TCP connections with L<Mojo::IOLoop::Server>, takes the same arguments
  as L<Mojo::IOLoop::Server/"listen">.
  
    # Listen on port 3000
    Mojo::IOLoop->server({port => 3000} => sub {
      my ($loop, $stream, $id) = @_;
      ...
    });
  
    # Listen on random port
    my $id = Mojo::IOLoop->server({address => '127.0.0.1'} => sub {
      my ($loop, $stream, $id) = @_;
      ...
    });
    my $port = Mojo::IOLoop->acceptor($id)->port;
  
  =head2 singleton
  
    my $loop = Mojo::IOLoop->singleton;
  
  The global L<Mojo::IOLoop> singleton, used to access a single shared event loop
  object from everywhere inside the process.
  
    # Many methods also allow you to take shortcuts
    Mojo::IOLoop->timer(2 => sub { Mojo::IOLoop->stop });
    Mojo::IOLoop->start;
  
    # Restart active timer
    my $id = Mojo::IOLoop->timer(3 => sub { say 'Timeout!' });
    Mojo::IOLoop->singleton->reactor->again($id);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $handle = IO::Handle->new_from_fd($fd, 'r');
    Mojo::IOLoop->singleton->reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    })->watch($handle, 1, 0);
  
  =head2 start
  
    Mojo::IOLoop->start;
    $loop->start;
  
  Start the event loop, this will block until L</"stop"> is called. Note that
  some reactors stop automatically if there are no events being watched anymore.
  
    # Start event loop only if it is not running already
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 stop
  
    Mojo::IOLoop->stop;
    $loop->stop;
  
  Stop the event loop, this will not interrupt any existing connections and the
  event loop can be restarted by running L</"start"> again.
  
  =head2 stop_gracefully
  
    Mojo::IOLoop->stop_gracefully;
    $loop->stop_gracefully;
  
  Stop accepting new connections and wait for already accepted connections to be
  closed, before stopping the event loop.
  
  =head2 stream
  
    my $stream = Mojo::IOLoop->stream($id);
    my $stream = $loop->stream($id);
    my $id     = $loop->stream(Mojo::IOLoop::Stream->new);
  
  Get L<Mojo::IOLoop::Stream> object for id or turn object into a connection.
  
    # Increase inactivity timeout for connection to 300 seconds
    Mojo::IOLoop->stream($id)->timeout(300);
  
  =head2 timer
  
    my $id = Mojo::IOLoop->timer(3 => sub {...});
    my $id = $loop->timer(0 => sub {...});
    my $id = $loop->timer(0.25 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
    # Perform operation in 5 seconds
    Mojo::IOLoop->timer(5 => sub {
      my $loop = shift;
      ...
    });
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_IOLOOP_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_IOLOOP_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP

$fatpacked{"Mojo/IOLoop/Client.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_CLIENT';
  package Mojo::IOLoop::Client;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Errno 'EINPROGRESS';
  use IO::Socket::IP;
  use Mojo::IOLoop;
  use Scalar::Util 'weaken';
  use Socket qw(IPPROTO_TCP SOCK_STREAM TCP_NODELAY);
  
  # Non-blocking name resolution requires Net::DNS::Native
  use constant NDN => $ENV{MOJO_NO_NDN}
    ? 0
    : eval 'use Net::DNS::Native 0.15 (); 1';
  my $NDN = NDN ? Net::DNS::Native->new(pool => 5, extra_thread => 1) : undef;
  
  # TLS support requires IO::Socket::SSL
  use constant TLS => $ENV{MOJO_NO_TLS}
    ? 0
    : eval 'use IO::Socket::SSL 1.94 (); 1';
  use constant TLS_READ  => TLS ? IO::Socket::SSL::SSL_WANT_READ()  : 0;
  use constant TLS_WRITE => TLS ? IO::Socket::SSL::SSL_WANT_WRITE() : 0;
  
  # SOCKS support requires IO::Socket::Socks
  use constant SOCKS => $ENV{MOJO_NO_SOCKS}
    ? 0
    : eval 'use IO::Socket::Socks 0.64 (); 1';
  use constant SOCKS_READ  => SOCKS ? IO::Socket::Socks::SOCKS_WANT_READ()  : 0;
  use constant SOCKS_WRITE => SOCKS ? IO::Socket::Socks::SOCKS_WANT_WRITE() : 0;
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY { shift->_cleanup }
  
  sub connect {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Timeout
    weaken $self;
    my $reactor = $self->reactor;
    $self->{timer} = $reactor->timer($args->{timeout} || 10,
      sub { $self->emit(error => 'Connect timeout') });
  
    # Blocking name resolution
    $_ && s/[[\]]//g for @$args{qw(address socks_address)};
    my $address = $args->{socks_address} || ($args->{address} ||= '127.0.0.1');
    return $reactor->next_tick(sub { $self && $self->_connect($args) })
      if !NDN || $args->{handle};
  
    # Non-blocking name resolution
    my $handle = $self->{dns} = $NDN->getaddrinfo($address, _port($args),
      {protocol => IPPROTO_TCP, socktype => SOCK_STREAM});
    $reactor->io(
      $handle => sub {
        my $reactor = shift;
  
        $reactor->remove($self->{dns});
        my ($err, @res) = $NDN->get_result(delete $self->{dns});
        return $self->emit(error => "Can't resolve: $err") if $err;
  
        $args->{addr_info} = \@res;
        $self->_connect($args);
      }
    )->watch($handle, 1, 0);
  }
  
  sub _cleanup {
    my $self = shift;
    $NDN->timedout($self->{dns}) if $self->{dns};
    return unless my $reactor = $self->reactor;
    $self->{$_} && $reactor->remove(delete $self->{$_}) for qw(dns timer handle);
    return $self;
  }
  
  sub _connect {
    my ($self, $args) = @_;
  
    my $handle;
    my $address = $args->{socks_address} || $args->{address};
    unless ($handle = $self->{handle} = $args->{handle}) {
      my %options = (PeerAddr => $address, PeerPort => _port($args));
      %options = (PeerAddrInfo => $args->{addr_info}) if $args->{addr_info};
      $options{Blocking} = 0;
      $options{LocalAddr} = $args->{local_address} if $args->{local_address};
      return $self->emit(error => "Can't connect: $@")
        unless $self->{handle} = $handle = IO::Socket::IP->new(%options);
    }
    $handle->blocking(0);
  
    $self->_wait($handle, $args);
  }
  
  sub _port { $_[0]{socks_port} || $_[0]{port} || ($_[0]{tls} ? 443 : 80) }
  
  sub _ready {
    my ($self, $args) = @_;
  
    # Socket changes in between attempts and needs to be re-added for epoll/kqueue
    my $handle = $self->{handle};
    if ($handle->isa('IO::Socket::IP') && !$handle->connect) {
      return $self->emit(error => $!) unless $! == EINPROGRESS;
      $self->reactor->remove($handle);
      return $self->_wait($handle, $args);
    }
  
    return $self->emit(error => $! || 'Not connected') unless $handle->connected;
  
    # Disable Nagle's algorithm
    setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;
  
    $self->_try_socks($args);
  }
  
  sub _socks {
    my ($self, $args) = @_;
  
    # Connected
    my $handle = $self->{handle};
    return $self->_try_tls($args) if $handle->ready;
  
    # Switch between reading and writing
    my $err = $IO::Socket::Socks::SOCKS_ERROR;
    if    ($err == SOCKS_READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == SOCKS_WRITE) { $self->reactor->watch($handle, 1, 1) }
    else                        { $self->emit(error => $err) }
  }
  
  sub _tls {
    my $self = shift;
  
    # Connected
    my $handle = $self->{handle};
    return $self->_cleanup->emit(connect => $handle) if $handle->connect_SSL;
  
    # Switch between reading and writing
    my $err = $IO::Socket::SSL::SSL_ERROR;
    if    ($err == TLS_READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == TLS_WRITE) { $self->reactor->watch($handle, 1, 1) }
  }
  
  sub _try_socks {
    my ($self, $args) = @_;
  
    my $handle = $self->{handle};
    return $self->_try_tls($args) unless $args->{socks_address};
    return $self->emit(
      error => 'IO::Socket::Socks 0.64+ required for SOCKS support')
      unless SOCKS;
  
    my %options = (ConnectAddr => $args->{address}, ConnectPort => $args->{port});
    @options{qw(AuthType Username Password)}
      = ('userpass', @$args{qw(socks_user socks_pass)})
      if $args->{socks_user};
    my $reactor = $self->reactor;
    $reactor->remove($handle);
    return $self->emit(error => 'SOCKS upgrade failed')
      unless IO::Socket::Socks->start_SOCKS($handle, %options);
    weaken $self;
    $reactor->io($handle => sub { $self->_socks($args) })->watch($handle, 0, 1);
  }
  
  sub _try_tls {
    my ($self, $args) = @_;
  
    my $handle = $self->{handle};
    return $self->_cleanup->emit(connect => $handle) unless $args->{tls};
    return $self->emit(error => 'IO::Socket::SSL 1.94+ required for TLS support')
      unless TLS;
  
    # Upgrade
    weaken $self;
    my %options = (
      SSL_ca_file => $args->{tls_ca}
        && -T $args->{tls_ca} ? $args->{tls_ca} : undef,
      SSL_cert_file  => $args->{tls_cert},
      SSL_error_trap => sub { $self->emit(error => $_[1]) },
      SSL_hostname   => IO::Socket::SSL->can_client_sni ? $args->{address} : '',
      SSL_key_file   => $args->{tls_key},
      SSL_startHandshake  => 0,
      SSL_verify_mode     => $args->{tls_ca} ? 0x01 : 0x00,
      SSL_verifycn_name   => $args->{address},
      SSL_verifycn_scheme => $args->{tls_ca} ? 'http' : undef
    );
    my $reactor = $self->reactor;
    $reactor->remove($handle);
    return $self->emit(error => 'TLS upgrade failed')
      unless IO::Socket::SSL->start_SSL($handle, %options);
    $reactor->io($handle => sub { $self->_tls })->watch($handle, 0, 1);
  }
  
  sub _wait {
    my ($self, $handle, $args) = @_;
    weaken $self;
    $self->reactor->io($handle => sub { $self->_ready($args) })
      ->watch($handle, 0, 1);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Client - Non-blocking TCP client
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Client;
  
    # Create socket connection
    my $client = Mojo::IOLoop::Client->new;
    $client->on(connect => sub {
      my ($client, $handle) = @_;
      ...
    });
    $client->on(error => sub {
      my ($client, $err) = @_;
      ...
    });
    $client->connect(address => 'example.com', port => 80);
  
    # Start reactor if necessary
    $client->reactor->start unless $client->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Client> opens TCP connections for L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Client> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 connect
  
    $client->on(connect => sub {
      my ($client, $handle) = @_;
      ...
    });
  
  Emitted once the connection is established.
  
  =head2 error
  
    $client->on(error => sub {
      my ($client, $err) = @_;
      ...
    });
  
  Emitted if an error occurs on the connection, fatal if unhandled.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Client> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $client->reactor;
    $client     = $client->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Client> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 connect
  
    $client->connect(address => '127.0.0.1', port => 3000);
  
  Open a socket connection to a remote host. Note that non-blocking name
  resolution depends on L<Net::DNS::Native> (0.15+), SOCKS5 support on
  L<IO::Socket::Socks> (0.64), and TLS support on L<IO::Socket::SSL> (1.94+).
  
  These options are currently available:
  
  =over 2
  
  =item address
  
    address => 'mojolicious.org'
  
  Address or host name of the peer to connect to, defaults to C<127.0.0.1>.
  
  =item handle
  
    handle => $handle
  
  Use an already prepared L<IO::Socket::IP> object.
  
  =item local_address
  
    local_address => '127.0.0.1'
  
  Local address to bind to.
  
  =item port
  
    port => 80
  
  Port to connect to, defaults to C<80> or C<443> with C<tls> option.
  
  =item socks_address
  
    socks_address => '127.0.0.1'
  
  Address or host name of SOCKS5 proxy server to use for connection.
  
  =item socks_pass
  
    socks_pass => 'secr3t'
  
  Password to use for SOCKS5 authentication.
  
  =item socks_port
  
    socks_port => 9050
  
  Port of SOCKS5 proxy server to use for connection.
  
  =item socks_user
  
    socks_user => 'sri'
  
  Username to use for SOCKS5 authentication.
  
  =item timeout
  
    timeout => 15
  
  Maximum amount of time in seconds establishing connection may take before
  getting canceled, defaults to C<10>.
  
  =item tls
  
    tls => 1
  
  Enable TLS.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file. Also activates hostname verification.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/client.crt'
  
  Path to the TLS certificate file.
  
  =item tls_key
  
    tls_key => '/etc/tls/client.key'
  
  Path to the TLS key file.
  
  =back
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_CLIENT

$fatpacked{"Mojo/IOLoop/Delay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_DELAY';
  package Mojo::IOLoop::Delay;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::IOLoop;
  use Mojo::Util;
  
  has ioloop    => sub { Mojo::IOLoop->singleton };
  has remaining => sub { [] };
  
  sub begin {
    my ($self, $offset, $len) = @_;
    $self->{pending}++;
    my $id = $self->{counter}++;
    return sub { $self->_step($id, $offset // 1, $len, @_) };
  }
  
  sub data { Mojo::Util::_stash(data => @_) }
  
  sub pass { $_[0]->begin->(@_) }
  
  sub steps {
    my $self = shift->remaining([@_]);
    $self->ioloop->next_tick($self->begin);
    return $self;
  }
  
  sub wait {
    my $self = shift;
    return if $self->ioloop->is_running;
    $self->once(error => \&_die);
    $self->once(finish => sub { shift->ioloop->stop });
    $self->ioloop->start;
  }
  
  sub _die { $_[0]->has_subscribers('error') ? $_[0]->ioloop->stop : die $_[1] }
  
  sub _step {
    my ($self, $id, $offset, $len) = (shift, shift, shift, shift);
  
    $self->{args}[$id]
      = [@_ ? defined $len ? splice @_, $offset, $len : splice @_, $offset : ()];
    return $self if $self->{fail} || --$self->{pending} || $self->{lock};
    local $self->{lock} = 1;
    my @args = map {@$_} @{delete $self->{args}};
  
    $self->{counter} = 0;
    if (my $cb = shift @{$self->remaining}) {
      eval { $self->$cb(@args); 1 }
        or (++$self->{fail} and return $self->remaining([])->emit(error => $@));
    }
  
    return $self->remaining([])->emit(finish => @args) unless $self->{counter};
    $self->ioloop->next_tick($self->begin) unless $self->{pending};
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Delay - Manage callbacks and control the flow of events
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Delay;
  
    # Synchronize multiple non-blocking operations
    my $delay = Mojo::IOLoop::Delay->new;
    $delay->steps(sub { say 'BOOM!' });
    for my $i (1 .. 10) {
      my $end = $delay->begin;
      Mojo::IOLoop->timer($i => sub {
        say 10 - $i;
        $end->();
      });
    }
    $delay->wait;
  
    # Sequentialize multiple non-blocking operations
    Mojo::IOLoop::Delay->new->steps(
  
      # First step (simple timer)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(2 => $delay->begin);
        say 'Second step in 2 seconds.';
      },
  
      # Second step (concurrent timers)
      sub {
        my ($delay, @args) = @_;
        Mojo::IOLoop->timer(1 => $delay->begin);
        Mojo::IOLoop->timer(3 => $delay->begin);
        say 'Third step in 3 seconds.';
      },
  
      # Third step (the end)
      sub {
        my ($delay, @args) = @_;
        say 'And done after 5 seconds total.';
      }
    )->wait;
  
    # Handle exceptions in all steps
    Mojo::IOLoop::Delay->new->steps(
      sub {
        my $delay = shift;
        die 'Intentional error';
      },
      sub {
        my ($delay, @args) = @_;
        say 'Never actually reached.';
      }
    )->catch(sub {
      my ($delay, $err) = @_;
      say "Something went wrong: $err";
    })->wait;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Delay> manages callbacks and controls the flow of events for
  L<Mojo::IOLoop>, which can help you avoid deep nested closures that often
  result from continuation-passing style.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Delay> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 error
  
    $delay->on(error => sub {
      my ($delay, $err) = @_;
      ...
    });
  
  Emitted if an exception gets thrown in one of the steps, breaking the chain,
  fatal if unhandled.
  
  =head2 finish
  
    $delay->on(finish => sub {
      my ($delay, @args) = @_;
      ...
    });
  
  Emitted once the event counter reaches zero and there are no more steps.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Delay> implements the following attributes.
  
  =head2 ioloop
  
    my $loop = $delay->ioloop;
    $delay   = $delay->ioloop(Mojo::IOLoop->new);
  
  Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton.
  
  =head2 remaining
  
    my $remaining = $delay->remaining;
    $delay        = $delay->remaining([sub {...}]);
  
  Remaining L</"steps"> in chain.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Delay> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 begin
  
    my $cb = $delay->begin;
    my $cb = $delay->begin($offset);
    my $cb = $delay->begin($offset, $len);
  
  Indicate an active event by incrementing the event counter, the returned
  callback needs to be executed when the event has completed, to decrement the
  event counter again. When all callbacks have been executed and the event counter
  reached zero, L</"steps"> will continue.
  
    # Capture all arguments except for the first one (invocant)
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $err, $stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin);
    $delay->wait;
  
  Arguments passed to the returned callback are spliced with the given offset and
  length, defaulting to an offset of C<1> with no default length. The arguments
  are then combined in the same order L</"begin"> was called, and passed together
  to the next step or L</"finish"> event.
  
    # Capture all arguments
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $loop, $err, $stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin(0));
    $delay->wait;
  
    # Capture only the second argument
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $err) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin(1, 1));
    $delay->wait;
  
    # Capture and combine arguments
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $three_err, $three_stream, $four_err, $four_stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin);
    Mojo::IOLoop->client({port => 4000} => $delay->begin);
    $delay->wait;
  
  =head2 data
  
    my $hash = $delay->data;
    my $foo  = $delay->data('foo');
    $delay   = $delay->data({foo => 'bar', baz => 23});
    $delay   = $delay->data(foo => 'bar', baz => 23);
  
  Data shared between all L</"steps">.
  
    # Remove value
    my $foo = delete $delay->data->{foo};
  
    # Assign multiple values at once
    $delay->data(foo => 'test', bar => 23);
  
  =head2 pass
  
    $delay = $delay->pass;
    $delay = $delay->pass(@args);
  
  Increment event counter and decrement it again right away to pass values to the
  next step.
  
    # Longer version
    $delay->begin(0)->(@args);
  
  =head2 steps
  
    $delay = $delay->steps(sub {...}, sub {...});
  
  Sequentialize multiple events, every time the event counter reaches zero a
  callback will run, the first one automatically runs during the next reactor tick
  unless it is delayed by incrementing the event counter. This chain will continue
  until there are no L</"remaining"> callbacks, a callback does not increment the
  event counter or an exception gets thrown in a callback.
  
  =head2 wait
  
    $delay->wait;
  
  Start L</"ioloop"> and stop it again once an L</"error"> or L</"finish"> event
  gets emitted, does nothing when L</"ioloop"> is already running.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_DELAY

$fatpacked{"Mojo/IOLoop/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_SERVER';
  package Mojo::IOLoop::Server;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use File::Basename 'dirname';
  use File::Spec::Functions 'catfile';
  use IO::Socket::IP;
  use Mojo::IOLoop;
  use Scalar::Util 'weaken';
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  # TLS support requires IO::Socket::SSL
  use constant TLS => $ENV{MOJO_NO_TLS}
    ? 0
    : eval 'use IO::Socket::SSL 1.94 (); 1';
  use constant TLS_READ  => TLS ? IO::Socket::SSL::SSL_WANT_READ()  : 0;
  use constant TLS_WRITE => TLS ? IO::Socket::SSL::SSL_WANT_WRITE() : 0;
  
  # To regenerate the certificate run this command (18.04.2012)
  # openssl req -new -x509 -keyout server.key -out server.crt -nodes -days 7300
  my $CERT = catfile dirname(__FILE__), 'resources', 'server.crt';
  my $KEY  = catfile dirname(__FILE__), 'resources', 'server.key';
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY {
    my $self = shift;
    $ENV{MOJO_REUSE} =~ s/(?:^|\,)\Q$self->{reuse}\E// if $self->{reuse};
    return unless my $reactor = $self->reactor;
    $self->stop if $self->{handle};
    $reactor->remove($_) for values %{$self->{handles}};
  }
  
  sub generate_port {
    IO::Socket::IP->new(Listen => 5, LocalAddr => '127.0.0.1')->sockport;
  }
  
  sub handle { shift->{handle} }
  
  sub is_accepting { !!shift->{active} }
  
  sub listen {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Look for reusable file descriptor
    my $address = $args->{address} || '0.0.0.0';
    my $port = $args->{port};
    $ENV{MOJO_REUSE} ||= '';
    my $fd;
    $fd = $1 if $port && $ENV{MOJO_REUSE} =~ /(?:^|\,)\Q$address:$port\E:(\d+)/;
  
    # Allow file descriptor inheritance
    local $^F = 1023;
  
    # Reuse file descriptor
    my $handle;
    if (defined $fd) {
      $handle = IO::Socket::IP->new_from_fd($fd, 'r')
        or croak "Can't open file descriptor $fd: $!";
    }
  
    # New socket
    else {
      my %options = (
        Listen => $args->{backlog} // SOMAXCONN,
        LocalAddr => $address,
        ReuseAddr => 1,
        ReusePort => $args->{reuse},
        Type      => SOCK_STREAM
      );
      $options{LocalPort} = $port if $port;
      $options{LocalAddr} =~ s/[\[\]]//g;
      $handle = IO::Socket::IP->new(%options)
        or croak "Can't create listen socket: $@";
      $fd = fileno $handle;
      my $reuse = $self->{reuse} = join ':', $address, $handle->sockport, $fd;
      $ENV{MOJO_REUSE} .= length $ENV{MOJO_REUSE} ? ",$reuse" : "$reuse";
    }
    $handle->blocking(0);
    @$self{qw(handle single_accept)} = ($handle, $args->{single_accept});
  
    return unless $args->{tls};
    croak "IO::Socket::SSL 1.94+ required for TLS support" unless TLS;
  
    weaken $self;
    my $tls = $self->{tls} = {
      SSL_cert_file => $args->{tls_cert} || $CERT,
      SSL_error_trap => sub {
        return unless my $handle = delete $self->{handles}{shift()};
        $self->reactor->remove($handle);
        close $handle;
      },
      SSL_honor_cipher_order => 1,
      SSL_key_file           => $args->{tls_key} || $KEY,
      SSL_startHandshake     => 0,
      SSL_verify_mode => $args->{tls_verify} // ($args->{tls_ca} ? 0x03 : 0x00)
    };
    $tls->{SSL_ca_file} = $args->{tls_ca}
      if $args->{tls_ca} && -T $args->{tls_ca};
    $tls->{SSL_cipher_list} = $args->{tls_ciphers} if $args->{tls_ciphers};
    $tls->{SSL_version}     = $args->{tls_version} if $args->{tls_version};
  }
  
  sub port { shift->{handle}->sockport }
  
  sub start {
    my $self = shift;
    weaken $self;
    ++$self->{active}
      and $self->reactor->io($self->{handle} => sub { $self->_accept });
  }
  
  sub stop { delete($_[0]{active}) and $_[0]->reactor->remove($_[0]{handle}) }
  
  sub _accept {
    my $self = shift;
  
    # Greedy accept
    my $accepted = 0;
    while ($self->{active} && !($self->{single_accept} && $accepted++)) {
      return unless my $handle = $self->{handle}->accept;
      $handle->blocking(0);
  
      # Disable Nagle's algorithm
      setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;
  
      # Start TLS handshake
      $self->emit(accept => $handle) and next unless my $tls = $self->{tls};
      $self->_handshake($self->{handles}{$handle} = $handle)
        if $handle = IO::Socket::SSL->start_SSL($handle, %$tls, SSL_server => 1);
    }
  }
  
  sub _handshake {
    my ($self, $handle) = @_;
    weaken $self;
    $self->reactor->io($handle => sub { $self->_tls($handle) });
  }
  
  sub _tls {
    my ($self, $handle) = @_;
  
    # Accepted
    if ($handle->accept_SSL) {
      $self->reactor->remove($handle);
      return $self->emit(accept => delete $self->{handles}{$handle});
    }
  
    # Switch between reading and writing
    my $err = $IO::Socket::SSL::SSL_ERROR;
    if    ($err == TLS_READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == TLS_WRITE) { $self->reactor->watch($handle, 1, 1) }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Server - Non-blocking TCP server
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Server;
  
    # Create listen socket
    my $server = Mojo::IOLoop::Server->new;
    $server->on(accept => sub {
      my ($server, $handle) = @_;
      ...
    });
    $server->listen(port => 3000);
  
    # Start and stop accepting connections
    $server->start;
    $server->stop;
  
    # Start reactor if necessary
    $server->reactor->start unless $server->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Server> accepts TCP connections for L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Server> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 accept
  
    $server->on(accept => sub {
      my ($server, $handle) = @_;
      ...
    });
  
  Emitted for each accepted connection.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Server> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $server->reactor;
    $server     = $server->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Server> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 generate_port
  
    my $port = $server->generate_port;
  
  Find a free TCP port, primarily used for tests.
  
  =head2 handle
  
    my $handle = $server->handle;
  
  Get handle for server, usually an L<IO::Socket::IP> object.
  
  =head2 is_accepting
  
    my $bool = $server->is_accepting;
  
  Check if connections are currently being accepted.
  
  =head2 listen
  
    $server->listen(port => 3000);
  
  Create a new listen socket. Note that TLS support depends on L<IO::Socket::SSL>
  (1.94+).
  
  These options are currently available:
  
  =over 2
  
  =item address
  
    address => '127.0.0.1'
  
  Local address to listen on, defaults to C<0.0.0.0>.
  
  =item backlog
  
    backlog => 128
  
  Maximum backlog size, defaults to C<SOMAXCONN>.
  
  =item port
  
    port => 80
  
  Port to listen on, defaults to a random port.
  
  =item reuse
  
    reuse => 1
  
  Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket
  option.
  
  =item single_accept
  
    single_accept => 1
  
  Only accept one connection at a time.
  
  =item tls
  
    tls => 1
  
  Enable TLS.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/server.crt'
    tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}
  
  Path to the TLS cert file, defaults to a built-in test certificate.
  
  =item tls_ciphers
  
    tls_ciphers => 'AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH'
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item tls_key
  
    tls_key => '/etc/tls/server.key'
    tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}
  
  Path to the TLS key file, defaults to a built-in test key.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode, defaults to C<0x03>.
  
  =item tls_version
  
    tls_version => 'TLSv1_2'
  
  TLS protocol version.
  
  =back
  
  =head2 port
  
    my $port = $server->port;
  
  Get port this server is listening on.
  
  =head2 start
  
    $server->start;
  
  Start or resume accepting connections.
  
  =head2 stop
  
    $server->stop;
  
  Stop accepting connections.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_SERVER

$fatpacked{"Mojo/IOLoop/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM';
  package Mojo::IOLoop::Stream;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Errno qw(EAGAIN ECONNRESET EINTR EWOULDBLOCK);
  use Mojo::IOLoop;
  use Mojo::Util;
  use Scalar::Util 'weaken';
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY { Mojo::Util::_global_destruction() or shift->close }
  
  sub close {
    my $self = shift;
    return unless my $reactor = $self->reactor;
    return unless my $handle  = delete $self->timeout(0)->{handle};
    $reactor->remove($handle);
    $self->emit('close');
  }
  
  sub close_gracefully { $_[0]->is_writing ? $_[0]{graceful}++ : $_[0]->close }
  
  sub handle { shift->{handle} }
  
  sub is_readable {
    my $self = shift;
    $self->_again;
    return $self->{handle} && Mojo::Util::_readable(0, fileno $self->{handle});
  }
  
  sub is_writing {
    my $self = shift;
    return undef unless $self->{handle};
    return !!length($self->{buffer}) || $self->has_subscribers('drain');
  }
  
  sub new { shift->SUPER::new(handle => shift, buffer => '', timeout => 15) }
  
  sub start {
    my $self = shift;
  
    # Resume
    my $reactor = $self->reactor;
    return $reactor->watch($self->{handle}, 1, $self->is_writing)
      if delete $self->{paused};
  
    weaken $self;
    my $cb = sub { pop() ? $self->_write : $self->_read };
    $reactor->io($self->timeout($self->{timeout})->{handle} => $cb);
  }
  
  sub steal_handle {
    my $self = shift;
    $self->reactor->remove($self->{handle});
    return delete $self->{handle};
  }
  
  sub stop {
    my $self = shift;
    $self->reactor->watch($self->{handle}, 0, $self->is_writing)
      unless $self->{paused}++;
  }
  
  sub timeout {
    my $self = shift;
  
    return $self->{timeout} unless @_;
  
    my $reactor = $self->reactor;
    $reactor->remove(delete $self->{timer}) if $self->{timer};
    return $self unless my $timeout = $self->{timeout} = shift;
    weaken $self;
    $self->{timer}
      = $reactor->timer($timeout => sub { $self->emit('timeout')->close });
  
    return $self;
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
  
    $self->{buffer} .= $chunk;
    if ($cb) { $self->once(drain => $cb) }
    elsif (!length $self->{buffer}) { return $self }
    $self->reactor->watch($self->{handle}, !$self->{paused}, 1)
      if $self->{handle};
  
    return $self;
  }
  
  sub _again { $_[0]->reactor->again($_[0]{timer}) if $_[0]{timer} }
  
  sub _read {
    my $self = shift;
  
    my $read = $self->{handle}->sysread(my $buffer, 131072, 0);
    return $read == 0 ? $self->close : $self->emit(read => $buffer)->_again
      if defined $read;
  
    # Retry
    return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
  
    # Closed (maybe real error)
    $! == ECONNRESET ? $self->close : $self->emit(error => $!)->close;
  }
  
  sub _write {
    my $self = shift;
  
    # Handle errors only when reading (to avoid timing problems)
    my $handle = $self->{handle};
    if (length $self->{buffer}) {
      return unless defined(my $written = $handle->syswrite($self->{buffer}));
      $self->emit(write => substr($self->{buffer}, 0, $written, ''))->_again;
    }
  
    $self->emit('drain') unless length $self->{buffer};
    return if $self->is_writing;
    return $self->close if $self->{graceful};
    $self->reactor->watch($handle, !$self->{paused}, 0) if $self->{handle};
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream - Non-blocking I/O stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Stream;
  
    # Create stream
    my $stream = Mojo::IOLoop::Stream->new($handle);
    $stream->on(read => sub {
      my ($stream, $bytes) = @_;
      ...
    });
    $stream->on(close => sub {
      my $stream = shift;
      ...
    });
    $stream->on(error => sub {
      my ($stream, $err) = @_;
      ...
    });
  
    # Start and stop watching for new data
    $stream->start;
    $stream->stop;
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream> is a container for I/O streams used by L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 close
  
    $stream->on(close => sub {
      my $stream = shift;
      ...
    });
  
  Emitted if the stream gets closed.
  
  =head2 drain
  
    $stream->on(drain => sub {
      my $stream = shift;
      ...
    });
  
  Emitted once all data has been written.
  
  =head2 error
  
    $stream->on(error => sub {
      my ($stream, $err) = @_;
      ...
    });
  
  Emitted if an error occurs on the stream, fatal if unhandled.
  
  =head2 read
  
    $stream->on(read => sub {
      my ($stream, $bytes) = @_;
      ...
    });
  
  Emitted if new data arrives on the stream.
  
  =head2 timeout
  
    $stream->on(timeout => sub {
      my $stream = shift;
      ...
    });
  
  Emitted if the stream has been inactive for too long and will get closed
  automatically.
  
  =head2 write
  
    $stream->on(write => sub {
      my ($stream, $bytes) = @_;
      ...
    });
  
  Emitted if new data has been written to the stream.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $stream->reactor;
    $stream     = $stream->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 close
  
    $stream->close;
  
  Close stream immediately.
  
  =head2 close_gracefully
  
    $stream->close_gracefully;
  
  Close stream gracefully.
  
  =head2 handle
  
    my $handle = $stream->handle;
  
  Get handle for stream, usually an L<IO::Socket::IP> or L<IO::Socket::SSL>
  object.
  
  =head2 is_readable
  
    my $bool = $stream->is_readable;
  
  Quick non-blocking check if stream is readable, useful for identifying tainted
  sockets.
  
  =head2 is_writing
  
    my $bool = $stream->is_writing;
  
  Check if stream is writing.
  
  =head2 new
  
    my $stream = Mojo::IOLoop::Stream->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream> object.
  
  =head2 start
  
    $stream->start;
  
  Start or resume watching for new data on the stream.
  
  =head2 steal_handle
  
    my $handle = $stream->steal_handle;
  
  Steal L</"handle"> and prevent it from getting closed automatically.
  
  =head2 stop
  
    $stream->stop;
  
  Stop watching for new data on the stream.
  
  =head2 timeout
  
    my $timeout = $stream->timeout;
    $stream     = $stream->timeout(45);
  
  Maximum amount of time in seconds stream can be inactive before getting closed
  automatically, defaults to C<15>. Setting the value to C<0> will allow this
  stream to be inactive indefinitely.
  
  =head2 write
  
    $stream = $stream->write($bytes);
    $stream = $stream->write($bytes => sub {...});
  
  Write data to stream, the optional drain callback will be executed once all data
  has been written.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_STREAM

$fatpacked{"Mojo/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON';
  package Mojo::JSON;
  use Mojo::Base -strict;
  
  use Carp 'croak';
  use Exporter 'import';
  use JSON::PP ();
  use Mojo::Util;
  use Scalar::Util 'blessed';
  
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Escaped special character map (with u2028 and u2029)
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  for (0x00 .. 0x1f) { $REVERSE{pack 'C', $_} //= sprintf '\u%.4X', $_ }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { Mojo::Util::encode 'UTF-8', _encode_value(shift) }
  
  sub false () {JSON::PP::false}
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json($_[0]) if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return eval { decode_json($_[0]) };
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {JSON::PP::true}
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length(local $_ = shift);
  
      # UTF-8
      $_ = Mojo::Util::decode 'UTF-8', $_ unless shift;
      die "Input is not UTF-8 encoded\n" unless defined;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      /\G[\x20\x09\x0a\x0d]*\z/gc or _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if /\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if /\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      /\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      /\G[\x20\x09\x0a\x0d]*:/gc or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if /\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if /\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
  
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc;
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if /\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ /\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ /\G\\u([Dd][C-Fc-f]..)/gc
            or pos = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos($str), length($str);
  }
  
  sub _decode_value {
  
    # Leading whitespace
    /\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if /\G"/gc;
  
    # Object
    return _decode_object() if /\G\{/gc;
  
    # Array
    return _decode_array() if /\G\[/gc;
  
    # Number
    return 0 + $1
      if /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
  
    # True
    return true() if /\Gtrue/gc;
  
    # False
    return false() if /\Gfalse/gc;
  
    # Null
    return undef if /\Gnull/gc;
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::PP::Boolean';
  
      # Everything else
      return _encode_string($value)
        unless blessed $value && (my $sub = $value->can('TO_JSON'));
      return _encode_value($value->$sub);
    }
  
    # Null
    return 'null' unless defined $value;
  
    # Number
    no warnings 'numeric';
    return $value
      if length((my $dummy = '') & $value)
      && 0 + $value eq $value
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    /\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::JSON - Minimalistic JSON
  
  =head1 SYNOPSIS
  
    use Mojo::JSON qw(decode_json encode_json);
  
    my $bytes = encode_json {foo => [1, 2], bar => 'hello!', baz => \1};
    my $hash  = decode_json $bytes;
  
  =head1 DESCRIPTION
  
  L<Mojo::JSON> is a minimalistic and possibly the fastest pure-Perl
  implementation of L<RFC 7159|http://tools.ietf.org/html/rfc7159>.
  
  It supports normal Perl data types like scalar, array reference, hash reference
  and will try to call the C<TO_JSON> method on blessed references, or stringify
  them if it doesn't exist. Differentiating between strings and numbers in Perl
  is hard, depending on how it has been used, a scalar can be both at the same
  time. The string value has a higher precedence unless both representations are
  equivalent.
  
    [1, -2, 3]     -> [1, -2, 3]
    {"foo": "bar"} -> {foo => 'bar'}
  
  Literal names will be translated to and from L<Mojo::JSON> constants or a
  similar native Perl value.
  
    true  -> Mojo::JSON->true
    false -> Mojo::JSON->false
    null  -> undef
  
  In addition scalar references will be used to generate booleans, based on if
  their values are true or false.
  
    \1 -> true
    \0 -> false
  
  The two Unicode whitespace characters C<u2028> and C<u2029> will always be
  escaped to make JSONP easier, and the character C</> to prevent XSS attacks.
  
    "\x{2028}\x{2029}</script>" -> "\u2028\u2029<\/script>"
  
  =head1 FUNCTIONS
  
  L<Mojo::JSON> implements the following functions, which can be imported
  individually.
  
  =head2 decode_json
  
    my $value = decode_json $bytes;
  
  Decode JSON to Perl value and die if decoding fails.
  
  =head2 encode_json
  
    my $bytes = encode_json {i => '♥ mojolicious'};
  
  Encode Perl value to JSON.
  
  =head2 false
  
    my $false = false;
  
  False value, used because Perl has no native equivalent.
  
  =head2 from_json
  
    my $value = from_json $chars;
  
  Decode JSON text that is not C<UTF-8> encoded to Perl value and die if decoding
  fails.
  
  =head2 j
  
    my $bytes = j [1, 2, 3];
    my $bytes = j {i => '♥ mojolicious'};
    my $value = j $bytes;
  
  Encode Perl data structure (which may only be an array reference or hash
  reference) or decode JSON, an C<undef> return value indicates a bare C<null> or
  that decoding failed.
  
  =head2 to_json
  
    my $chars = to_json {i => '♥ mojolicious'};
  
  Encode Perl value to JSON text without C<UTF-8> encoding it.
  
  =head2 true
  
    my $true = true;
  
  True value, used because Perl has no native equivalent.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_JSON

$fatpacked{"Mojo/JSON/Pointer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON_POINTER';
  package Mojo::JSON::Pointer;
  use Mojo::Base -base;
  
  has 'data';
  
  sub contains { shift->_pointer(1, @_) }
  sub get      { shift->_pointer(0, @_) }
  
  sub new { @_ > 1 ? shift->SUPER::new(data => shift) : shift->SUPER::new }
  
  sub _pointer {
    my ($self, $contains, $pointer) = @_;
  
    my $data = $self->data;
    return $contains ? 1 : $data unless $pointer =~ s!^/!!;
    for my $p (length $pointer ? (split '/', $pointer, -1) : ($pointer)) {
      $p =~ s!~1!/!g;
      $p =~ s/~0/~/g;
  
      # Hash
      if (ref $data eq 'HASH' && exists $data->{$p}) { $data = $data->{$p} }
  
      # Array
      elsif (ref $data eq 'ARRAY' && $p =~ /^\d+$/ && @$data > $p) {
        $data = $data->[$p];
      }
  
      # Nothing
      else { return undef }
    }
  
    return $contains ? 1 : $data;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::JSON::Pointer - JSON Pointers
  
  =head1 SYNOPSIS
  
    use Mojo::JSON::Pointer;
  
    my $pointer = Mojo::JSON::Pointer->new({foo => [23, 'bar']});
    say $pointer->get('/foo/1');
    say 'Contains "/foo".' if $pointer->contains('/foo');
  
  =head1 DESCRIPTION
  
  L<Mojo::JSON::Pointer> is a relaxed implementation of
  L<RFC 6901|http://tools.ietf.org/html/rfc6901>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::JSON::Pointer> implements the following attributes.
  
  =head2 data
  
    my $data = $pointer->data;
    $pointer = $pointer->data({foo => 'bar'});
  
  Data structure to be processed.
  
  =head1 METHODS
  
  L<Mojo::JSON::Pointer> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 contains
  
    my $bool = $pointer->contains('/foo/1');
  
  Check if L</"data"> contains a value that can be identified with the given JSON
  Pointer.
  
    # True
    Mojo::JSON::Pointer->new('just a string')->contains('');
    Mojo::JSON::Pointer->new({'♥' => 'mojolicious'})->contains('/♥');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/foo');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/1');
  
    # False
    Mojo::JSON::Pointer->new({'♥' => 'mojolicious'})->contains('/☃');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/bar');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/9');
  
  =head2 get
  
    my $value = $pointer->get('/foo/bar');
  
  Extract value from L</"data"> identified by the given JSON Pointer.
  
    # "just a string"
    Mojo::JSON::Pointer->new('just a string')->get('');
  
    # "mojolicious"
    Mojo::JSON::Pointer->new({'♥' => 'mojolicious'})->get('/♥');
  
    # "bar"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/foo');
  
    # "4"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/0');
  
    # "6"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/2');
  
  =head2 new
  
    my $pointer = Mojo::JSON::Pointer->new;
    my $pointer = Mojo::JSON::Pointer->new({foo => 'bar'});
  
  Build new L<Mojo::JSON::Pointer> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_JSON_POINTER

$fatpacked{"Mojo/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOADER';
  package Mojo::Loader;
  use Mojo::Base -strict;
  
  use Exporter 'import';
  use File::Basename 'fileparse';
  use File::Spec::Functions qw(catdir catfile splitdir);
  use Mojo::Exception;
  use Mojo::Util qw(b64_decode class_to_path);
  
  our @EXPORT_OK
    = qw(data_section file_is_binary find_modules find_packages load_class);
  
  my (%BIN, %CACHE);
  
  sub data_section { $_[0] ? $_[1] ? _all($_[0])->{$_[1]} : _all($_[0]) : undef }
  
  sub file_is_binary { keys %{_all($_[0])} ? !!$BIN{$_[0]}{$_[1]} : undef }
  
  sub find_modules {
    my $ns = shift;
  
    my %modules;
    for my $directory (@INC) {
      next unless -d (my $path = catdir $directory, split(/::|'/, $ns));
  
      # List "*.pm" files in directory
      opendir(my $dir, $path);
      for my $file (grep /\.pm$/, readdir $dir) {
        next if -d catfile splitdir($path), $file;
        $modules{"${ns}::" . fileparse $file, qr/\.pm/}++;
      }
    }
  
    return sort keys %modules;
  }
  
  sub find_packages {
    my $ns = shift;
    no strict 'refs';
    return sort map { /^(.+)::$/ ? "${ns}::$1" : () } keys %{"${ns}::"};
  }
  
  sub load_class {
    my $class = shift;
  
    # Invalid class name
    return 1 if ($class || '') !~ /^\w(?:[\w:']*\w)?$/;
  
    # Already loaded
    return undef if $class->can('new');
  
    # Success
    eval "require $class; 1" ? return undef : Mojo::Util::_teardown($class);
  
    # Does not exist
    return 1 if $@ =~ /^Can't locate \Q@{[class_to_path $class]}\E in \@INC/;
  
    # Real error
    return Mojo::Exception->new($@)->inspect;
  }
  
  sub _all {
    my $class = shift;
  
    return $CACHE{$class} if $CACHE{$class};
    my $handle = do { no strict 'refs'; \*{"${class}::DATA"} };
    return {} unless fileno $handle;
    seek $handle, 0, 0;
    my $data = join '', <$handle>;
  
    # Ignore everything before __DATA__ (some versions seek to start of file)
    $data =~ s/^.*\n__DATA__\r?\n/\n/s;
  
    # Ignore everything after __END__
    $data =~ s/\n__END__\r?\n.*$/\n/s;
  
    # Split files
    (undef, my @files) = split /^@@\s*(.+?)\s*\r?\n/m, $data;
  
    # Find data
    my $all = $CACHE{$class} = {};
    while (@files) {
      my ($name, $data) = splice @files, 0, 2;
      $all->{$name} = $name =~ s/\s*\(\s*base64\s*\)$//
        && ++$BIN{$class}{$name} ? b64_decode $data : $data;
    }
  
    return $all;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Loader - Load all kinds of things
  
  =head1 SYNOPSIS
  
    use Mojo::Loader qw(data_section find_modules load_class);
  
    # Find modules in a namespace
    for my $module (find_modules 'Some::Namespace') {
  
      # Load them safely
      my $e = load_class $module;
      warn qq{Loading "$module" failed: $e} and next if ref $e;
  
      # And extract files from the DATA section
      say data_section($module, 'some_file.txt');
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Loader> is a class loader and plugin framework. Aside from finding
  modules and loading classes, it allows multiple files to be stored in the
  C<DATA> section of a class, which can then be accessed individually.
  
    package Foo;
  
    1;
    __DATA__
  
    @@ test.txt
    This is the first file.
  
    @@ test2.html (base64)
    VGhpcyBpcyB0aGUgc2Vjb25kIGZpbGUu
  
    @@ test
    This is the
    third file.
  
  Each file has a header starting with C<@@>, followed by the file name and
  optional instructions for decoding its content. Currently only the Base64
  encoding is supported, which can be quite convenient for the storage of binary
  data.
  
  =head1 FUNCTIONS
  
  L<Mojo::Loader> implements the following functions, which can be imported
  individually.
  
  =head2 data_section
  
    my $all   = data_section 'Foo::Bar';
    my $index = data_section 'Foo::Bar', 'index.html';
  
  Extract embedded file from the C<DATA> section of a class, all files will be
  cached once they have been accessed for the first time.
  
    # List embedded files
    say for keys %{data_section 'Foo::Bar'};
  
  =head2 file_is_binary
  
    my $bool = file_is_binary 'Foo::Bar', 'test.png';
  
  Check if embedded file from the C<DATA> section of a class was Base64 encoded.
  
  =head2 find_packages
  
    my @pkgs = find_packages 'MyApp::Namespace';
  
  Search for packages in a namespace non-recursively.
  
  =head2 find_modules
  
    my @modules = find_modules 'MyApp::Namespace';
  
  Search for modules in a namespace non-recursively.
  
  =head2 load_class
  
    my $e = load_class 'Foo::Bar';
  
  Load a class and catch exceptions, returns a false value if loading was
  successful, a true value if the class has already been loaded, or a
  L<Mojo::Exception> object if loading failed. Note that classes are checked for a
  C<new> method to see if they are already loaded.
  
    # Handle exceptions
    if (my $e = load_class 'Foo::Bar') {
      die ref $e ? "Exception: $e" : 'Not found!';
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_LOADER

$fatpacked{"Mojo/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOG';
  package Mojo::Log;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Fcntl ':flock';
  use Mojo::Util qw(encode monkey_patch);
  
  has format => sub { \&_format };
  has handle => sub {
  
    # STDERR
    return \*STDERR unless my $path = shift->path;
  
    # File
    croak qq{Can't open log file "$path": $!} unless open my $file, '>>', $path;
    return $file;
  };
  has history => sub { [] };
  has level => 'debug';
  has max_history_size => 10;
  has 'path';
  
  # Supported log levels
  my %LEVEL = (debug => 1, info => 2, warn => 3, error => 4, fatal => 5);
  
  sub append {
    my ($self, $msg) = @_;
  
    return unless my $handle = $self->handle;
    flock $handle, LOCK_EX;
    $handle->print(encode('UTF-8', $msg)) or croak "Can't write to log: $!";
    flock $handle, LOCK_UN;
  }
  
  sub debug { shift->_log(debug => @_) }
  sub error { shift->_log(error => @_) }
  sub fatal { shift->_log(fatal => @_) }
  sub info  { shift->_log(info  => @_) }
  
  sub is_level { $LEVEL{pop()} >= $LEVEL{$ENV{MOJO_LOG_LEVEL} || shift->level} }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(message => \&_message);
    return $self;
  }
  
  sub warn { shift->_log(warn => @_) }
  
  sub _format {
    '[' . localtime(shift) . '] [' . shift() . '] ' . join "\n", @_, '';
  }
  
  sub _log { shift->emit('message', shift, @_) }
  
  sub _message {
    my ($self, $level) = (shift, shift);
  
    return unless $self->is_level($level);
  
    my $max     = $self->max_history_size;
    my $history = $self->history;
    push @$history, my $msg = [time, $level, @_];
    shift @$history while @$history > $max;
  
    $self->append($self->format->(@$msg));
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Log - Simple logger
  
  =head1 SYNOPSIS
  
    use Mojo::Log;
  
    # Log to STDERR
    my $log = Mojo::Log->new;
  
    # Customize log file location and minimum log level
    my $log = Mojo::Log->new(path => '/var/log/mojo.log', level => 'warn');
  
    # Log messages
    $log->debug('Not sure what is happening here');
    $log->info('FYI: it happened again');
    $log->warn('This might be a problem');
    $log->error('Garden variety error');
    $log->fatal('Boom');
  
  =head1 DESCRIPTION
  
  L<Mojo::Log> is a simple logger for L<Mojo> projects.
  
  =head1 EVENTS
  
  L<Mojo::Log> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 message
  
    $log->on(message => sub {
      my ($log, $level, @lines) = @_;
      ...
    });
  
  Emitted when a new message gets logged.
  
    $log->unsubscribe('message')->on(message => sub {
      my ($log, $level, @lines) = @_;
      say "$level: ", @lines;
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Log> implements the following attributes.
  
  =head2 format
  
    my $cb = $log->format;
    $log   = $log->format(sub {...});
  
  A callback for formatting log messages.
  
    $log->format(sub {
      my ($time, $level, @lines) = @_;
      return "[Thu May 15 17:47:04 2014] [info] I ♥ Mojolicious\n";
    });
  
  =head2 handle
  
    my $handle = $log->handle;
    $log       = $log->handle(IO::Handle->new);
  
  Log filehandle used by default L</"message"> event, defaults to opening
  L</"path"> or C<STDERR>.
  
  =head2 history
  
    my $history = $log->history;
    $log        = $log->history([[time, 'debug', 'That went wrong']]);
  
  The last few logged messages.
  
  =head2 level
  
    my $level = $log->level;
    $log      = $log->level('debug');
  
  Active log level, defaults to C<debug>. Available log levels are C<debug>,
  C<info>, C<warn>, C<error> and C<fatal>, in that order. Note that the
  C<MOJO_LOG_LEVEL> environment variable can override this value.
  
  =head2 max_history_size
  
    my $size = $log->max_history_size;
    $log     = $log->max_history_size(5);
  
  Maximum number of logged messages to store in L</"history">, defaults to C<10>.
  
  =head2 path
  
    my $path = $log->path
    $log     = $log->path('/var/log/mojo.log');
  
  Log file path used by L</"handle">.
  
  =head1 METHODS
  
  L<Mojo::Log> inherits all methods from L<Mojo::EventEmitter> and implements the
  following new ones.
  
  =head2 append
  
    $log->append("[Thu May 15 17:47:04 2014] [info] I ♥ Mojolicious\n");
  
  Append message to L</"handle">.
  
  =head2 debug
  
    $log = $log->debug('You screwed up, but that is ok');
    $log = $log->debug('All', 'cool');
  
  Emit L</"message"> event and log C<debug> message.
  
  =head2 error
  
    $log = $log->error('You really screwed up this time');
    $log = $log->error('Wow', 'seriously');
  
  Emit L</"message"> event and log C<error> message.
  
  =head2 fatal
  
    $log = $log->fatal('Its over...');
    $log = $log->fatal('Bye', 'bye');
  
  Emit L</"message"> event and log C<fatal> message.
  
  =head2 info
  
    $log = $log->info('You are bad, but you prolly know already');
    $log = $log->info('Ok', 'then');
  
  Emit L</"message"> event and log C<info> message.
  
  =head2 is_level
  
    my $bool = $log->is_level('debug');
  
  Check active log L</"level">.
  
    # True
    $log->level('debug')->is_level('debug');
    $log->level('debug')->is_level('info');
  
    # False
    $log->level('info')->is_level('debug');
    $log->level('fatal')->is_level('warn');
  
  =head2 new
  
    my $log = Mojo::Log->new;
  
  Construct a new L<Mojo::Log> object and subscribe to L</"message"> event with
  default logger.
  
  =head2 warn
  
    $log = $log->warn('Dont do that Dave...');
    $log = $log->warn('No', 'really');
  
  Emit L</"message"> event and log C<warn> message.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_LOG

$fatpacked{"Mojo/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE';
  package Mojo::Message;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::Asset::Memory;
  use Mojo::Content::Single;
  use Mojo::DOM;
  use Mojo::JSON 'j';
  use Mojo::JSON::Pointer;
  use Mojo::Parameters;
  use Mojo::Upload;
  use Mojo::Util 'decode';
  
  has content => sub { Mojo::Content::Single->new };
  has default_charset  => 'UTF-8';
  has max_line_size    => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
  has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 16777216 };
  has version          => '1.1';
  
  sub body {
    my $self = shift;
  
    # Get
    my $content = $self->content;
    return $content->is_multipart ? '' : $content->asset->slurp unless @_;
  
    # Set (multipart content needs to be downgraded)
    $content = $self->content(Mojo::Content::Single->new)->content
      if $content->is_multipart;
    $content->asset(Mojo::Asset::Memory->new->add_chunk(@_));
  
    return $self;
  }
  
  sub body_params {
    my $self = shift;
  
    return $self->{body_params} if $self->{body_params};
    my $params = $self->{body_params} = Mojo::Parameters->new;
    $params->charset($self->content->charset || $self->default_charset);
  
    # "application/x-www-form-urlencoded"
    my $type = $self->headers->content_type // '';
    if ($type =~ m!application/x-www-form-urlencoded!i) {
      $params->parse($self->content->asset->slurp);
    }
  
    # "multipart/form-data"
    elsif ($type =~ m!multipart/form-data!i) {
      $params->append(@$_[0, 1]) for @{$self->_parse_formdata};
    }
  
    return $params;
  }
  
  sub body_size { shift->content->body_size }
  
  sub build_body       { shift->_build('get_body_chunk') }
  sub build_headers    { shift->_build('get_header_chunk') }
  sub build_start_line { shift->_build('get_start_line_chunk') }
  
  sub cookie { shift->_cache('cookies', 0, @_) }
  
  sub cookies { croak 'Method "cookies" not implemented by subclass' }
  
  sub dom {
    my $self = shift;
    return undef if $self->content->is_multipart;
    my $dom = $self->{dom} ||= Mojo::DOM->new($self->text);
    return @_ ? $dom->find(@_) : $dom;
  }
  
  sub error {
    my $self = shift;
    return $self->{error} unless @_;
    $self->{error} = shift;
    return $self->finish;
  }
  
  sub every_cookie { shift->_cache('cookies', 1, @_) }
  sub every_upload { shift->_cache('uploads', 1, @_) }
  
  sub extract_start_line {
    croak 'Method "extract_start_line" not implemented by subclass';
  }
  
  sub finish {
    my $self = shift;
    $self->{state} = 'finished';
    return $self->{finished}++ ? $self : $self->emit('finish');
  }
  
  sub fix_headers {
    my $self = shift;
    return $self if $self->{fix}++;
  
    # Content-Length or Connection (unless chunked transfer encoding is used)
    my $content = $self->content;
    my $headers = $content->headers;
    if ($content->is_multipart) { $headers->remove('Content-Length') }
    elsif ($content->is_chunked || $headers->content_length) { return $self }
    if   ($content->is_dynamic) { $headers->connection('close') }
    else                        { $headers->content_length($self->body_size) }
  
    return $self;
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
  
    $self->emit('progress', 'body', $offset);
    my $chunk = $self->content->get_body_chunk($offset);
    return $chunk if !defined $chunk || length $chunk;
    $self->finish;
  
    return $chunk;
  }
  
  sub get_header_chunk {
    my ($self, $offset) = @_;
    $self->emit('progress', 'headers', $offset);
    return $self->fix_headers->content->get_header_chunk($offset);
  }
  
  sub get_start_line_chunk {
    croak 'Method "get_start_line_chunk" not implemented by subclass';
  }
  
  sub header_size { shift->fix_headers->content->header_size }
  
  sub headers { shift->content->headers }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub json {
    my ($self, $pointer) = @_;
    return undef if $self->content->is_multipart;
    my $data = $self->{json} //= j($self->body);
    return $pointer ? Mojo::JSON::Pointer->new($data)->get($pointer) : $data;
  }
  
  sub parse {
    my ($self, $chunk) = @_;
  
    return $self if $self->{error};
    $self->{raw_size} += length $chunk;
    $self->{buffer} .= $chunk;
  
    # Start-line
    unless ($self->{state}) {
  
      # Check start-line size
      my $len = index $self->{buffer}, "\x0a";
      $len = length $self->{buffer} if $len < 0;
      return $self->_limit('Maximum start-line size exceeded')
        if $len > $self->max_line_size;
  
      $self->{state} = 'content' if $self->extract_start_line(\$self->{buffer});
    }
  
    # Content
    my $state = $self->{state} // '';
    $self->content($self->content->parse(delete $self->{buffer}))
      if $state eq 'content' || $state eq 'finished';
  
    # Check message size
    my $max = $self->max_message_size;
    return $self->_limit('Maximum message size exceeded')
      if $max && $max < $self->{raw_size};
  
    # Check header size
    return $self->_limit('Maximum header size exceeded')
      if $self->headers->is_limit_exceeded;
  
    # Check buffer size
    return $self->_limit('Maximum buffer size exceeded')
      if $self->content->is_limit_exceeded;
  
    return $self->emit('progress')->content->is_finished ? $self->finish : $self;
  }
  
  sub start_line_size {
    croak 'Method "start_line_size" not implemented by subclass';
  }
  
  sub text {
    my $self    = shift;
    my $body    = $self->body;
    my $charset = $self->content->charset || $self->default_charset;
    return $charset ? decode($charset, $body) // $body : $body;
  }
  
  sub to_string {
    my $self = shift;
    return $self->build_start_line . $self->build_headers . $self->build_body;
  }
  
  sub upload { shift->_cache('uploads', 0, @_) }
  
  sub uploads {
    my $self = shift;
  
    my @uploads;
    for my $data (@{$self->_parse_formdata(1)}) {
      my $upload = Mojo::Upload->new(
        name     => $data->[0],
        filename => $data->[2],
        asset    => $data->[1]->asset,
        headers  => $data->[1]->headers
      );
      push @uploads, $upload;
    }
  
    return \@uploads;
  }
  
  sub _build {
    my ($self, $method) = @_;
  
    my ($buffer, $offset) = ('', 0);
    while (1) {
  
      # No chunk yet, try again
      next unless defined(my $chunk = $self->$method($offset));
  
      # End of part
      last unless my $len = length $chunk;
  
      $offset += $len;
      $buffer .= $chunk;
    }
  
    return $buffer;
  }
  
  sub _cache {
    my ($self, $method, $all, $name) = @_;
  
    # Cache objects by name
    unless ($self->{$method}) {
      $self->{$method} = {};
      push @{$self->{$method}{$_->name}}, $_ for @{$self->$method};
    }
  
    my $objects = $self->{$method}{$name} || [];
    return $all ? $objects : $objects->[-1];
  }
  
  sub _limit { ++$_[0]{limit} and return $_[0]->error({message => $_[1]}) }
  
  sub _parse_formdata {
    my ($self, $upload) = @_;
  
    my @formdata;
    my $content = $self->content;
    return \@formdata unless $content->is_multipart;
    my $charset = $content->charset || $self->default_charset;
  
    # Check all parts recursively
    my @parts = ($content);
    while (my $part = shift @parts) {
  
      if ($part->is_multipart) {
        unshift @parts, @{$part->parts};
        next;
      }
  
      next unless my $disposition = $part->headers->content_disposition;
      my ($filename) = $disposition =~ /[; ]filename="((?:\\"|[^"])*)"/;
      next if $upload && !defined $filename || !$upload && defined $filename;
      my ($name) = $disposition =~ /[; ]name="((?:\\"|[^;"])*)"/;
      $part = $part->asset->slurp unless $upload;
  
      if ($charset) {
        $name     = decode($charset, $name)     // $name     if $name;
        $filename = decode($charset, $filename) // $filename if $filename;
        $part = decode($charset, $part) // $part unless $upload;
      }
  
      push @formdata, [$name, $part, $filename];
    }
  
    return \@formdata;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message - HTTP message base class
  
  =head1 SYNOPSIS
  
    package Mojo::Message::MyMessage;
    use Mojo::Base 'Mojo::Message';
  
    sub cookies              {...}
    sub extract_start_line   {...}
    sub get_start_line_chunk {...}
    sub start_line_size      {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Message> is an abstract base class for HTTP message containers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 2388|http://tools.ietf.org/html/rfc2388>, like L<Mojo::Message::Request>
  and L<Mojo::Message::Response>.
  
  =head1 EVENTS
  
  L<Mojo::Message> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 finish
  
    $msg->on(finish => sub {
      my $msg = shift;
      ...
    });
  
  Emitted after message building or parsing is finished.
  
    my $before = time;
    $msg->on(finish => sub {
      my $msg = shift;
      $msg->headers->header('X-Parser-Time' => time - $before);
    });
  
  =head2 progress
  
    $msg->on(progress => sub {
      my $msg = shift;
      ...
    });
  
  Emitted when message building or parsing makes progress.
  
    # Building
    $msg->on(progress => sub {
      my ($msg, $state, $offset) = @_;
      say qq{Building "$state" at offset $offset};
    });
  
    # Parsing
    $msg->on(progress => sub {
      my $msg = shift;
      return unless my $len = $msg->headers->content_length;
      my $size = $msg->content->progress;
      say 'Progress: ', $size == $len ? 100 : int($size / ($len / 100)), '%';
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message> implements the following attributes.
  
  =head2 content
  
    my $msg = $msg->content;
    $msg    = $msg->content(Mojo::Content::Single->new);
  
  Message content, defaults to a L<Mojo::Content::Single> object.
  
  =head2 default_charset
  
    my $charset = $msg->default_charset;
    $msg        = $msg->default_charset('UTF-8');
  
  Default charset used by L</"text"> and to extract data from
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body,
  defaults to C<UTF-8>.
  
  =head2 max_line_size
  
    my $size = $msg->max_line_size;
    $msg     = $msg->max_line_size(1024);
  
  Maximum start-line size in bytes, defaults to the value of the
  C<MOJO_MAX_LINE_SIZE> environment variable or C<8192> (8KB).
  
  =head2 max_message_size
  
    my $size = $msg->max_message_size;
    $msg     = $msg->max_message_size(1024);
  
  Maximum message size in bytes, defaults to the value of the
  C<MOJO_MAX_MESSAGE_SIZE> environment variable or C<16777216> (16MB). Setting
  the value to C<0> will allow messages of indefinite size. Note that increasing
  this value can also drastically increase memory usage, should you for example,
  attempt to parse an excessively large message body with the L</"body_params">,
  L</"dom"> or L</"json"> methods.
  
  =head2 version
  
    my $version = $msg->version;
    $msg        = $msg->version('1.1');
  
  HTTP version of message, defaults to C<1.1>.
  
  =head1 METHODS
  
  L<Mojo::Message> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 body
  
    my $bytes = $msg->body;
    $msg      = $msg->body('Hello!');
  
  Slurp or replace L</"content">, L<Mojo::Content::MultiPart> will be
  automatically downgraded to L<Mojo::Content::Single>.
  
  =head2 body_params
  
    my $params = $msg->body_params;
  
  C<POST> parameters extracted from C<application/x-www-form-urlencoded> or
  C<multipart/form-data> message body, usually a L<Mojo::Parameters> object. Note
  that this method caches all data, so it should not be called before the entire
  message body has been received. Parts of the message body need to be loaded
  into memory to parse C<POST> parameters, so you have to make sure it is not
  excessively large, there's a 16MB limit by default.
  
    # Get POST parameter names and values
    my $hash = $msg->body_params->to_hash;
  
  =head2 body_size
  
    my $size = $msg->body_size;
  
  Content size in bytes.
  
  =head2 build_body
  
    my $bytes = $msg->build_body;
  
  Render whole body with L</"get_body_chunk">.
  
  =head2 build_headers
  
    my $bytes = $msg->build_headers;
  
  Render all headers with L</"get_header_chunk">.
  
  =head2 build_start_line
  
    my $bytes = $msg->build_start_line;
  
  Render start-line with L</"get_start_line_chunk">.
  
  =head2 cookie
  
    my $cookie = $msg->cookie('foo');
  
  Access message cookies, usually L<Mojo::Cookie::Request> or
  L<Mojo::Cookie::Response> objects. If there are multiple cookies sharing the
  same name, and you want to access more than just the last one, you can use
  L</"every_cookie">. Note that this method caches all data, so it should not be
  called before all headers have been received.
  
    # Get cookie value
    say $msg->cookie('foo')->value;
  
  =head2 cookies
  
    my $cookies = $msg->cookies;
  
  Access message cookies. Meant to be overloaded in a subclass.
  
  =head2 dom
  
    my $dom        = $msg->dom;
    my $collection = $msg->dom('a[href]');
  
  Retrieve message body from L</"text"> and turn it into a L<Mojo::DOM> object,
  an optional selector can be used to call the method L<Mojo::DOM/"find"> on it
  right away, which then returns a L<Mojo::Collection> object. Note that this
  method caches all data, so it should not be called before the entire message
  body has been received. The whole message body needs to be loaded into memory
  to parse it, so you have to make sure it is not excessively large, there's a
  16MB limit by default.
  
    # Perform "find" right away
    say $msg->dom('h1, h2, h3')->map('text')->join("\n");
  
    # Use everything else Mojo::DOM has to offer
    say $msg->dom->at('title')->text;
    say $msg->dom->at('body')->children->map('tag')->uniq->join("\n");
  
  =head2 error
  
    my $err = $msg->error;
    $msg    = $msg->error({message => 'Parser error'});
  
  Get or set message error, an C<undef> return value indicates that there is no
  error.
  
    # Connection or parser error
    $msg->error({message => 'Connection refused'});
  
    # 4xx/5xx response
    $msg->error({message => 'Internal Server Error', code => 500});
  
  =head2 every_cookie
  
    my $cookies = $msg->every_cookie('foo');
  
  Similar to L</"cookie">, but returns all message cookies sharing the same name
  as an array reference.
  
    # Get first cookie value
    say $msg->every_cookie('foo')->[0]->value;
  
  =head2 every_upload
  
    my $uploads = $msg->every_upload('foo');
  
  Similar to L</"upload">, but returns all file uploads sharing the same name as
  an array reference.
  
    # Get content of first uploaded file
    say $msg->every_upload('foo')->[0]->asset->slurp;
  
  =head2 extract_start_line
  
    my $bool = $msg->extract_start_line(\$str);
  
  Extract start-line from string. Meant to be overloaded in a subclass.
  
  =head2 finish
  
    $msg = $msg->finish;
  
  Finish message parser/generator.
  
  =head2 fix_headers
  
    $msg = $msg->fix_headers;
  
  Make sure message has all required headers.
  
  =head2 get_body_chunk
  
    my $bytes = $msg->get_body_chunk($offset);
  
  Get a chunk of body data starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 get_header_chunk
  
    my $bytes = $msg->get_header_chunk($offset);
  
  Get a chunk of header data, starting from a specific position. Note that this
  method finalizes the message.
  
  =head2 get_start_line_chunk
  
    my $bytes = $msg->get_start_line_chunk($offset);
  
  Get a chunk of start-line data starting from a specific position. Meant to be
  overloaded in a subclass.
  
  =head2 header_size
  
    my $size = $msg->header_size;
  
  Size of headers in bytes. Note that this method finalizes the message.
  
  =head2 headers
  
    my $headers = $msg->headers;
  
  Message headers, usually a L<Mojo::Headers> object.
  
    # Longer version
    my $headers = $msg->content->headers;
  
  =head2 is_finished
  
    my $bool = $msg->is_finished;
  
  Check if message parser/generator is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $msg->is_limit_exceeded;
  
  Check if message has exceeded L</"max_line_size">, L</"max_message_size">,
  L<Mojo::Content/"max_buffer_size"> or L<Mojo::Headers/"max_line_size">.
  
  =head2 json
  
    my $value = $msg->json;
    my $value = $msg->json('/foo/bar');
  
  Decode JSON message body directly using L<Mojo::JSON> if possible, an C<undef>
  return value indicates a bare C<null> or that decoding failed. An optional JSON
  Pointer can be used to extract a specific value with L<Mojo::JSON::Pointer>.
  Note that this method caches all data, so it should not be called before the
  entire message body has been received. The whole message body needs to be
  loaded into memory to parse it, so you have to make sure it is not excessively
  large, there's a 16MB limit by default.
  
    # Extract JSON values
    say $msg->json->{foo}{bar}[23];
    say $msg->json('/foo/bar/23');
  
  =head2 parse
  
    $msg = $msg->parse('HTTP/1.1 200 OK...');
  
  Parse message chunk.
  
  =head2 start_line_size
  
    my $size = $msg->start_line_size;
  
  Size of the start-line in bytes. Meant to be overloaded in a subclass.
  
  =head2 text
  
    my $str = $msg->text;
  
  Retrieve L</"body"> and try to decode it with L<Mojo::Content/"charset"> or
  L</"default_charset">.
  
  =head2 to_string
  
    my $str = $msg->to_string;
  
  Render whole message. Note that this method finalizes the message, and that it
  might not be possible to render the same message twice if content was generated
  dynamically.
  
  =head2 upload
  
    my $upload = $msg->upload('foo');
  
  Access C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects. If
  there are multiple uploads sharing the same name, and you want to access more
  than just the last one, you can use L</"every_upload">. Note that this method
  caches all data, so it should not be called before the entire message body has
  been received.
  
    # Get content of uploaded file
    say $msg->upload('foo')->asset->slurp;
  
  =head2 uploads
  
    my $uploads = $msg->uploads;
  
  All C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects.
  
    # Names of all uploads
    say $_->name for @{$msg->uploads};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_MESSAGE

$fatpacked{"Mojo/Message/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_REQUEST';
  package Mojo::Message::Request;
  use Mojo::Base 'Mojo::Message';
  
  use Mojo::Cookie::Request;
  use Mojo::Util qw(b64_encode b64_decode);
  use Mojo::URL;
  
  has env => sub { {} };
  has method => 'GET';
  has [qw(proxy reverse_proxy)];
  has url => sub { Mojo::URL->new };
  has via_proxy => 1;
  
  sub clone {
    my $self = shift;
  
    # Dynamic requests cannot be cloned
    return undef unless my $content = $self->content->clone;
    my $clone = $self->new(
      content => $content,
      method  => $self->method,
      url     => $self->url->clone,
      version => $self->version
    );
    $clone->{proxy} = $self->{proxy}->clone if $self->{proxy};
  
    return $clone;
  }
  
  sub cookies {
    my $self = shift;
  
    # Parse cookies
    my $headers = $self->headers;
    return [map { @{Mojo::Cookie::Request->parse($_)} } $headers->cookie]
      unless @_;
  
    # Add cookies
    my @cookies = map { ref $_ eq 'HASH' ? Mojo::Cookie::Request->new($_) : $_ }
      $headers->cookie || (), @_;
    $headers->cookie(join '; ', @cookies);
  
    return $self;
  }
  
  sub every_param { shift->params->every_param(@_) }
  
  sub extract_start_line {
    my ($self, $bufref) = @_;
  
    # Ignore any leading empty lines
    return undef unless $$bufref =~ s/^\s*(.*?)\x0d?\x0a//;
  
    # We have a (hopefully) full request-line
    return !$self->error({message => 'Bad request start-line'})
      unless $1 =~ /^(\S+)\s+(\S+)\s+HTTP\/(\d\.\d)$/;
    my $url = $self->method($1)->version($3)->url;
    return !!($1 eq 'CONNECT' ? $url->authority($2) : $url->parse($2));
  }
  
  sub fix_headers {
    my $self = shift;
    $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);
  
    # Host
    my $url     = $self->url;
    my $headers = $self->headers;
    $headers->host($url->host_port) unless $headers->host;
  
    # Basic authentication
    if ((my $info = $url->userinfo) && !$headers->authorization) {
      $headers->authorization('Basic ' . b64_encode($info, ''));
    }
  
    # Basic proxy authentication
    return $self unless (my $proxy = $self->proxy) && $self->via_proxy;
    return $self unless my $info = $proxy->userinfo;
    $headers->proxy_authorization('Basic ' . b64_encode($info, ''))
      unless $headers->proxy_authorization;
    return $self;
  }
  
  sub get_start_line_chunk {
    my ($self, $offset) = @_;
    $self->_start_line->emit(progress => 'start_line', $offset);
    return substr $self->{start_buffer}, $offset, 131072;
  }
  
  sub is_handshake { lc($_[0]->headers->upgrade // '') eq 'websocket' }
  
  sub is_secure {
    my $url = shift->url;
    return ($url->protocol || $url->base->protocol) eq 'https';
  }
  
  sub is_xhr {
    (shift->headers->header('X-Requested-With') // '') =~ /XMLHttpRequest/i;
  }
  
  sub param { shift->params->param(@_) }
  
  sub params {
    my $self = shift;
    return $self->{params}
      ||= $self->body_params->clone->append($self->query_params);
  }
  
  sub parse {
    my $self = shift;
    my ($env, $chunk) = ref $_[0] ? (shift, '') : (undef, shift);
  
    # Parse CGI environment
    $self->env($env)->_parse_env($env) if $env;
  
    # Parse normal message
    if (($self->{state} // '') ne 'cgi') { $self->SUPER::parse($chunk) }
  
    # Parse CGI content
    else { $self->content($self->content->parse_body($chunk))->SUPER::parse('') }
  
    # Check if we can fix things that require all headers
    return $self unless $self->is_finished;
  
    # Base URL
    my $base = $self->url->base;
    $base->scheme('http') unless $base->scheme;
    my $headers = $self->headers;
    if (!$base->host && (my $host = $headers->host)) { $base->authority($host) }
  
    # Basic authentication
    if (my $basic = _basic($headers->authorization)) { $base->userinfo($basic) }
  
    # Basic proxy authentication
    my $basic = _basic($headers->proxy_authorization);
    $self->proxy(Mojo::URL->new->userinfo($basic)) if $basic;
  
    # "X-Forwarded-Proto"
    $base->scheme('https')
      if $self->reverse_proxy
      && ($headers->header('X-Forwarded-Proto') // '') eq 'https';
  
    return $self;
  }
  
  sub query_params { shift->url->query }
  
  sub start_line_size { length shift->_start_line->{start_buffer} }
  
  sub _basic { $_[0] && $_[0] =~ /Basic (.+)$/ ? b64_decode $1 : undef }
  
  sub _parse_env {
    my ($self, $env) = @_;
  
    # Bypass normal message parser
    $self->{state} = 'cgi';
  
    # Extract headers
    my $headers = $self->headers;
    my $url     = $self->url;
    my $base    = $url->base;
    for my $name (keys %$env) {
      my $value = $env->{$name};
      next unless $name =~ s/^HTTP_//i;
      $name =~ y/_/-/;
      $headers->header($name => $value);
  
      # Host/Port
      $value =~ s/:(\d+)$// ? $base->host($value)->port($1) : $base->host($value)
        if $name eq 'HOST';
    }
  
    # Content-Type is a special case on some servers
    $headers->content_type($env->{CONTENT_TYPE}) if $env->{CONTENT_TYPE};
  
    # Content-Length is a special case on some servers
    $headers->content_length($env->{CONTENT_LENGTH}) if $env->{CONTENT_LENGTH};
  
    # Query
    $url->query->parse($env->{QUERY_STRING}) if $env->{QUERY_STRING};
  
    # Method
    $self->method($env->{REQUEST_METHOD}) if $env->{REQUEST_METHOD};
  
    # Scheme/Version
    $base->scheme($1) and $self->version($2)
      if ($env->{SERVER_PROTOCOL} // '') =~ m!^([^/]+)/([^/]+)$!;
  
    # HTTPS
    $base->scheme('https') if uc($env->{HTTPS} // '') eq 'ON';
  
    # Path
    my $path = $url->path->parse($env->{PATH_INFO} ? $env->{PATH_INFO} : '');
  
    # Base path
    if (my $value = $env->{SCRIPT_NAME}) {
  
      # Make sure there is a trailing slash (important for merging)
      $base->path->parse($value =~ m!/$! ? $value : "$value/");
  
      # Remove SCRIPT_NAME prefix if necessary
      my $buffer = $path->to_string;
      $value =~ s!^/|/$!!g;
      $buffer =~ s!^/?\Q$value\E/?!!;
      $buffer =~ s!^/!!;
      $path->parse($buffer);
    }
  }
  
  sub _start_line {
    my $self = shift;
  
    return $self if defined $self->{start_buffer};
  
    # Path
    my $url  = $self->url;
    my $path = $url->path_query;
    $path = "/$path" unless $path =~ m!^/!;
  
    # CONNECT
    my $method = uc $self->method;
    if ($method eq 'CONNECT') {
      my $port = $url->port || ($url->protocol eq 'https' ? '443' : '80');
      $path = $url->ihost . ":$port";
    }
  
    # Proxy
    elsif ($self->proxy && $self->via_proxy && $url->protocol ne 'https') {
      $path = $url->clone->userinfo(undef) unless $self->is_handshake;
    }
  
    $self->{start_buffer} = "$method $path HTTP/@{[$self->version]}\x0d\x0a";
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message::Request - HTTP request
  
  =head1 SYNOPSIS
  
    use Mojo::Message::Request;
  
    # Parse
    my $req = Mojo::Message::Request->new;
    $req->parse("GET /foo HTTP/1.0\x0d\x0a");
    $req->parse("Content-Length: 12\x0d\x0a");
    $req->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
    $req->parse('Hello World!');
    say $req->method;
    say $req->headers->content_type;
    say $req->body;
  
    # Build
    my $req = Mojo::Message::Request->new;
    $req->url->parse('http://127.0.0.1/foo/bar');
    $req->method('GET');
    say $req->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Message::Request> is a container for HTTP requests, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>,
  L<RFC 7235|http://tools.ietf.org/html/rfc7235> and
  L<RFC 2817|http://tools.ietf.org/html/rfc2817>.
  
  =head1 EVENTS
  
  L<Mojo::Message::Request> inherits all events from L<Mojo::Message>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message::Request> inherits all attributes from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 env
  
    my $env = $req->env;
    $req    = $req->env({PATH_INFO => '/'});
  
  Direct access to the C<CGI> or C<PSGI> environment hash if available.
  
    # Check CGI version
    my $version = $req->env->{GATEWAY_INTERFACE};
  
    # Check PSGI version
    my $version = $req->env->{'psgi.version'};
  
  =head2 method
  
    my $method = $req->method;
    $req       = $req->method('POST');
  
  HTTP request method, defaults to C<GET>.
  
  =head2 proxy
  
    my $url = $req->proxy;
    $req    = $req->proxy(Mojo::URL->new('http://127.0.0.1:3000'));
  
  Proxy URL for request.
  
  =head2 reverse_proxy
  
    my $bool = $req->reverse_proxy;
    $req     = $req->reverse_proxy($bool);
  
  Request has been performed through a reverse proxy.
  
  =head2 url
  
    my $url = $req->url;
    $req    = $req->url(Mojo::URL->new);
  
  HTTP request URL, defaults to a L<Mojo::URL> object.
  
    # Get request information
    my $info = $req->url->to_abs->userinfo;
    my $host = $req->url->to_abs->host;
    my $path = $req->url->to_abs->path;
  
  =head2 via_proxy
  
    my $bool = $req->via_proxy;
    $req     = $req->via_proxy($bool);
  
  Request can be performed through a proxy server.
  
  =head1 METHODS
  
  L<Mojo::Message::Request> inherits all methods from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 clone
  
    my $clone = $req->clone;
  
  Clone request if possible, otherwise return C<undef>.
  
  =head2 cookies
  
    my $cookies = $req->cookies;
    $req        = $req->cookies(Mojo::Cookie::Request->new);
    $req        = $req->cookies({name => 'foo', value => 'bar'});
  
  Access request cookies, usually L<Mojo::Cookie::Request> objects.
  
    # Names of all cookies
    say $_->name for @{$req->cookies};
  
  =head2 every_param
  
    my $values = $req->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    say $req->every_param('foo')->[0];
  
  =head2 extract_start_line
  
    my $bool = $req->extract_start_line(\$str);
  
  Extract request-line from string.
  
  =head2 fix_headers
  
    $req = $req->fix_headers;
  
  Make sure request has all required headers.
  
  =head2 get_start_line_chunk
  
    my $bytes = $req->get_start_line_chunk($offset);
  
  Get a chunk of request-line data starting from a specific position. Note that
  this method finalizes the request.
  
  =head2 is_handshake
  
    my $bool = $req->is_handshake;
  
  Check C<Upgrade> header for C<websocket> value.
  
  =head2 is_secure
  
    my $bool = $req->is_secure;
  
  Check if connection is secure.
  
  =head2 is_xhr
  
    my $bool = $req->is_xhr;
  
  Check C<X-Requested-With> header for C<XMLHttpRequest> value.
  
  =head2 param
  
    my $value = $req->param('foo');
  
  Access C<GET> and C<POST> parameters extracted from the query string and
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body. If
  there are multiple values sharing the same name, and you want to access more
  than just the last one, you can use L</"every_param">. Note that this method
  caches all data, so it should not be called before the entire request body has
  been received. Parts of the request body need to be loaded into memory to parse
  C<POST> parameters, so you have to make sure it is not excessively large,
  there's a 16MB limit by default.
  
  =head2 params
  
    my $params = $req->params;
  
  All C<GET> and C<POST> parameters extracted from the query string and
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body,
  usually a L<Mojo::Parameters> object. Note that this method caches all data, so
  it should not be called before the entire request body has been received. Parts
  of the request body need to be loaded into memory to parse C<POST> parameters,
  so you have to make sure it is not excessively large, there's a 16MB limit by
  default.
  
    # Get parameter names and values
    my $hash = $req->params->to_hash;
  
  =head2 parse
  
    $req = $req->parse('GET /foo/bar HTTP/1.1');
    $req = $req->parse({PATH_INFO => '/'});
  
  Parse HTTP request chunks or environment hash.
  
  =head2 query_params
  
    my $params = $req->query_params;
  
  All C<GET> parameters, usually a L<Mojo::Parameters> object.
  
    # Turn GET parameters to hash and extract value
    say $req->query_params->to_hash->{foo};
  
  =head2 start_line_size
  
    my $size = $req->start_line_size;
  
  Size of the request-line in bytes. Note that this method finalizes the request.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_MESSAGE_REQUEST

$fatpacked{"Mojo/Message/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_RESPONSE';
  package Mojo::Message::Response;
  use Mojo::Base 'Mojo::Message';
  
  use Mojo::Cookie::Response;
  use Mojo::Date;
  
  has [qw(code message)];
  
  # Umarked codes are from RFC 7231
  my %MESSAGES = (
    100 => 'Continue',
    101 => 'Switching Protocols',
    102 => 'Processing',                         # RFC 2518 (WebDAV)
    200 => 'OK',
    201 => 'Created',
    202 => 'Accepted',
    203 => 'Non-Authoritative Information',
    204 => 'No Content',
    205 => 'Reset Content',
    206 => 'Partial Content',
    207 => 'Multi-Status',                       # RFC 2518 (WebDAV)
    208 => 'Already Reported',                   # RFC 5842
    226 => 'IM Used',                            # RFC 3229
    300 => 'Multiple Choices',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    304 => 'Not Modified',
    305 => 'Use Proxy',
    307 => 'Temporary Redirect',
    308 => 'Permanent Redirect',                 # RFC 7538
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Timeout',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Long',
    415 => 'Unsupported Media Type',
    416 => 'Request Range Not Satisfiable',
    417 => 'Expectation Failed',
    418 => "I'm a teapot",                       # RFC 2324 :)
    422 => 'Unprocessable Entity',               # RFC 2518 (WebDAV)
    423 => 'Locked',                             # RFC 2518 (WebDAV)
    424 => 'Failed Dependency',                  # RFC 2518 (WebDAV)
    425 => 'Unordered Colection',                # RFC 3648 (WebDAV)
    426 => 'Upgrade Required',                   # RFC 2817
    428 => 'Precondition Required',              # RFC 6585
    429 => 'Too Many Requests',                  # RFC 6585
    431 => 'Request Header Fields Too Large',    # RFC 6585
    451 => 'Unavailable For Legal Reasons',      # RFC 7725
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Timeout',
    505 => 'HTTP Version Not Supported',
    506 => 'Variant Also Negotiates',            # RFC 2295
    507 => 'Insufficient Storage',               # RFC 2518 (WebDAV)
    508 => 'Loop Detected',                      # RFC 5842
    509 => 'Bandwidth Limit Exceeded',           # Unofficial
    510 => 'Not Extended',                       # RFC 2774
    511 => 'Network Authentication Required'     # RFC 6585
  );
  
  sub cookies {
    my $self = shift;
  
    # Parse cookies
    my $headers = $self->headers;
    return [map { @{Mojo::Cookie::Response->parse($_)} } $headers->set_cookie]
      unless @_;
  
    # Add cookies
    $headers->add('Set-Cookie' => "$_")
      for map { ref $_ eq 'HASH' ? Mojo::Cookie::Response->new($_) : $_ } @_;
  
    return $self;
  }
  
  sub default_message { $MESSAGES{$_[1] || $_[0]->code // 404} || '' }
  
  sub extract_start_line {
    my ($self, $bufref) = @_;
  
    # We have a full response line
    return undef unless $$bufref =~ s/^(.*?)\x0d?\x0a//;
    return !$self->error({message => 'Bad response start-line'})
      unless $1 =~ m!^\s*HTTP/(\d\.\d)\s+(\d\d\d)\s*(.+)?$!;
  
    my $content = $self->content;
    $content->skip_body(1) if $self->code($2)->is_empty;
    defined $content->$_ or $content->$_(1) for qw(auto_decompress auto_relax);
    $content->expect_close(1) if $1 eq '1.0';
    return !!$self->version($1)->message($3);
  }
  
  sub fix_headers {
    my $self = shift;
    $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);
  
    # Date
    my $headers = $self->headers;
    $headers->date(Mojo::Date->new->to_string) unless $headers->date;
  
    return $self;
  }
  
  sub get_start_line_chunk {
    my ($self, $offset) = @_;
    $self->_start_line->emit(progress => 'start_line', $offset);
    return substr $self->{start_buffer}, $offset, 131072;
  }
  
  sub is_empty {
    my $self = shift;
    return undef unless my $code = $self->code;
    return $self->is_status_class(100) || $code == 204 || $code == 304;
  }
  
  sub is_status_class {
    my ($self, $class) = @_;
    return undef unless my $code = $self->code;
    return $code >= $class && $code < ($class + 100);
  }
  
  sub start_line_size { length shift->_start_line->{start_buffer} }
  
  sub _start_line {
    my $self = shift;
  
    return $self if defined $self->{start_buffer};
    my $code = $self->code    || 404;
    my $msg  = $self->message || $self->default_message;
    $self->{start_buffer} = "HTTP/@{[$self->version]} $code $msg\x0d\x0a";
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message::Response - HTTP response
  
  =head1 SYNOPSIS
  
    use Mojo::Message::Response;
  
    # Parse
    my $res = Mojo::Message::Response->new;
    $res->parse("HTTP/1.0 200 OK\x0d\x0a");
    $res->parse("Content-Length: 12\x0d\x0a");
    $res->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
    $res->parse('Hello World!');
    say $res->code;
    say $res->headers->content_type;
    say $res->body;
  
    # Build
    my $res = Mojo::Message::Response->new;
    $res->code(200);
    $res->headers->content_type('text/plain');
    $res->body('Hello World!');
    say $res->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Message::Response> is a container for HTTP responses, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Message::Response> inherits all events from L<Mojo::Message>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message::Response> inherits all attributes from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 code
  
    my $code = $res->code;
    $res     = $res->code(200);
  
  HTTP response status code.
  
  =head2 message
  
    my $msg = $res->message;
    $res    = $res->message('OK');
  
  HTTP response status message.
  
  =head1 METHODS
  
  L<Mojo::Message::Response> inherits all methods from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 cookies
  
    my $cookies = $res->cookies;
    $res        = $res->cookies(Mojo::Cookie::Response->new);
    $res        = $res->cookies({name => 'foo', value => 'bar'});
  
  Access response cookies, usually L<Mojo::Cookie::Response> objects.
  
    # Names of all cookies
    say $_->name for @{$res->cookies};
  
  =head2 default_message
  
    my $msg = $res->default_message;
    my $msg = $res->default_message(418);
  
  Generate default response message for status code, defaults to using
  L</"code">.
  
  =head2 extract_start_line
  
    my $bool = $res->extract_start_line(\$str);
  
  Extract status-line from string.
  
  =head2 fix_headers
  
    $res = $res->fix_headers;
  
  Make sure response has all required headers.
  
  =head2 get_start_line_chunk
  
    my $bytes = $res->get_start_line_chunk($offset);
  
  Get a chunk of status-line data starting from a specific position. Note that
  this method finalizes the response.
  
  =head2 is_empty
  
    my $bool = $res->is_empty;
  
  Check if this response has a C<1xx>, C<204> or C<304> status code.
  
  =head2 is_status_class
  
    my $bool = $res->is_status_class(200);
  
  Check response status class.
  
    # True
    Mojo::Message::Response->new->code(304)->is_status_class(300);
    Mojo::Message::Response->new->code(404)->is_status_class(400);
  
    # False
    Mojo::Message::Response->new->code(404)->is_status_class(300);
    Mojo::Message::Response->new->code(404)->is_status_class(200);
  
  =head2 start_line_size
  
    my $size = $req->start_line_size;
  
  Size of the status-line in bytes. Note that this method finalizes the response.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_MESSAGE_RESPONSE

$fatpacked{"Mojo/Parameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PARAMETERS';
  package Mojo::Parameters;
  use Mojo::Base -base;
  use overload
    '@{}'    => sub { shift->pairs },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  use Mojo::Util qw(decode encode url_escape url_unescape);
  
  has charset => 'UTF-8';
  
  sub append {
    my $self = shift;
  
    my $old = $self->pairs;
    my @new = @_ == 1 ? @{shift->pairs} : @_;
    while (my ($name, $value) = splice @new, 0, 2) {
  
      # Multiple values
      if (ref $value eq 'ARRAY') { push @$old, $name => $_ // '' for @$value }
  
      # Single value
      elsif (defined $value) { push @$old, $name => $value }
    }
  
    return $self;
  }
  
  sub clone {
    my $self = shift;
  
    my $clone = $self->new;
    if   (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
    if   (defined $self->{string}) { $clone->{string}  = $self->{string} }
    else                           { $clone->{pairs}   = [@{$self->pairs}] }
  
    return $clone;
  }
  
  sub every_param {
    my ($self, $name) = @_;
  
    my @values;
    my $pairs = $self->pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      push @values, $pairs->[$i + 1] if $pairs->[$i] eq $name;
    }
  
    return \@values;
  }
  
  sub merge {
    my $self = shift;
  
    my @pairs = @_ == 1 ? @{shift->pairs} : @_;
    while (my ($name, $value) = splice @pairs, 0, 2) {
      defined $value ? $self->param($name => $value) : $self->remove($name);
    }
  
    return $self;
  }
  
  sub names { [sort keys %{shift->to_hash}] }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub pairs {
    my $self = shift;
  
    # Replace parameters
    if (@_) {
      $self->{pairs} = shift;
      delete $self->{string};
      return $self;
    }
  
    # Parse string
    if (defined(my $str = delete $self->{string})) {
      my $pairs = $self->{pairs} = [];
      return $pairs unless length $str;
  
      my $charset = $self->charset;
      for my $pair (split '&', $str) {
        next unless $pair =~ /^([^=]+)(?:=(.*))?$/;
        my ($name, $value) = ($1, $2 // '');
  
        # Replace "+" with whitespace, unescape and decode
        s/\+/ /g for $name, $value;
        $name  = url_unescape $name;
        $name  = decode($charset, $name) // $name if $charset;
        $value = url_unescape $value;
        $value = decode($charset, $value) // $value if $charset;
  
        push @$pairs, $name, $value;
      }
    }
  
    return $self->{pairs} ||= [];
  }
  
  sub param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->remove($name);
    return $self->append($name => ref $_[0] eq 'ARRAY' ? $_[0] : [@_]);
  }
  
  sub parse {
    my $self = shift;
  
    # Pairs
    return $self->append(@_) if @_ > 1;
  
    # String
    $self->{string} = shift;
    return $self;
  }
  
  sub remove {
    my ($self, $name) = @_;
    my $pairs = $self->pairs;
    my $i     = 0;
    $pairs->[$i] eq $name ? splice @$pairs, $i, 2 : ($i += 2) while $i < @$pairs;
    return $self;
  }
  
  sub to_hash {
    my $self = shift;
  
    my %hash;
    my $pairs = $self->pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      my ($name, $value) = @{$pairs}[$i, $i + 1];
  
      # Array
      if (exists $hash{$name}) {
        $hash{$name} = [$hash{$name}] if ref $hash{$name} ne 'ARRAY';
        push @{$hash{$name}}, $value;
      }
  
      # String
      else { $hash{$name} = $value }
    }
  
    return \%hash;
  }
  
  sub to_string {
    my $self = shift;
  
    # String (RFC 3986)
    my $charset = $self->charset;
    if (defined(my $str = $self->{string})) {
      $str = encode $charset, $str if $charset;
      return url_escape $str, '^A-Za-z0-9\-._~%!$&\'()*+,;=:@/?';
    }
  
    # Build pairs (HTML Living Standard)
    my $pairs = $self->pairs;
    return '' unless @$pairs;
    my @pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      my ($name, $value) = @{$pairs}[$i, $i + 1];
  
      # Escape and replace whitespace with "+"
      $name  = encode $charset,   $name if $charset;
      $name  = url_escape $name,  '^*\-.0-9A-Z_a-z';
      $value = encode $charset,   $value if $charset;
      $value = url_escape $value, '^*\-.0-9A-Z_a-z';
      s/\%20/\+/g for $name, $value;
  
      push @pairs, "$name=$value";
    }
  
    return join '&', @pairs;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Parameters - Parameters
  
  =head1 SYNOPSIS
  
    use Mojo::Parameters;
  
    # Parse
    my $params = Mojo::Parameters->new('foo=bar&baz=23');
    say $params->param('baz');
  
    # Build
    my $params = Mojo::Parameters->new(foo => 'bar', baz => 23);
    push @$params, i => '♥ mojolicious';
    say "$params";
  
  =head1 DESCRIPTION
  
  L<Mojo::Parameters> is a container for form parameters used by L<Mojo::URL>,
  based on L<RFC 3986|http://tools.ietf.org/html/rfc3986> and the
  L<HTML Living Standard|https://html.spec.whatwg.org>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Parameters> implements the following attributes.
  
  =head2 charset
  
    my $charset = $params->charset;
    $params     = $params->charset('UTF-8');
  
  Charset used for encoding and decoding parameters, defaults to C<UTF-8>.
  
    # Disable encoding and decoding
    $params->charset(undef);
  
  =head1 METHODS
  
  L<Mojo::Parameters> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 append
  
    $params = $params->append(foo => 'ba&r');
    $params = $params->append(foo => ['ba&r', 'baz']);
    $params = $params->append(foo => ['bar', 'baz'], bar => 23);
    $params = $params->append(Mojo::Parameters->new);
  
  Append parameters. Note that this method will normalize the parameters.
  
    # "foo=bar&foo=baz"
    Mojo::Parameters->new('foo=bar')->append(Mojo::Parameters->new('foo=baz'));
  
    # "foo=bar&foo=baz"
    Mojo::Parameters->new('foo=bar')->append(foo => 'baz');
  
    # "foo=bar&foo=baz&foo=yada"
    Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada']);
  
    # "foo=bar&foo=baz&foo=yada&bar=23"
    Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada'], bar => 23);
  
  =head2 clone
  
    my $params2 = $params->clone;
  
  Clone parameters.
  
  =head2 every_param
  
    my $values = $params->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference. Note that this method will normalize the parameters.
  
    # Get first value
    say $params->every_param('foo')->[0];
  
  =head2 merge
  
    $params = $params->merge(foo => 'ba&r');
    $params = $params->merge(foo => ['ba&r', 'baz']);
    $params = $params->merge(foo => ['bar', 'baz'], bar => 23);
    $params = $params->merge(Mojo::Parameters->new);
  
  Merge parameters. Note that this method will normalize the parameters.
  
    # "foo=baz"
    Mojo::Parameters->new('foo=bar')->merge(Mojo::Parameters->new('foo=baz'));
  
    # "yada=yada&foo=baz"
    Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => 'baz');
  
    # "yada=yada"
    Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => undef);
  
  =head2 names
  
    my $names = $params->names;
  
  Return an array reference with all parameter names.
  
    # Names of all parameters
    say for @{$params->names};
  
  =head2 new
  
    my $params = Mojo::Parameters->new;
    my $params = Mojo::Parameters->new('foo=b%3Bar&baz=23');
    my $params = Mojo::Parameters->new(foo => 'b&ar');
    my $params = Mojo::Parameters->new(foo => ['ba&r', 'baz']);
    my $params = Mojo::Parameters->new(foo => ['bar', 'baz'], bar => 23);
  
  Construct a new L<Mojo::Parameters> object and L</"parse"> parameters if
  necessary.
  
  =head2 pairs
  
    my $array = $params->pairs;
    $params   = $params->pairs([foo => 'b&ar', baz => 23]);
  
  Parsed parameter pairs. Note that this method will normalize the parameters.
  
    # Remove all parameters
    $params->pairs([]);
  
  =head2 param
  
    my $value = $params->param('foo');
    $params   = $params->param(foo => 'ba&r');
    $params   = $params->param(foo => qw(ba&r baz));
    $params   = $params->param(foo => ['ba;r', 'baz']);
  
  Access parameter values. If there are multiple values sharing the same name,
  and you want to access more than just the last one, you can use
  L</"every_param">. Note that this method will normalize the parameters.
  
  =head2 parse
  
    $params = $params->parse('foo=b%3Bar&baz=23');
  
  Parse parameters.
  
  =head2 remove
  
    $params = $params->remove('foo');
  
  Remove parameters. Note that this method will normalize the parameters.
  
    # "bar=yada"
    Mojo::Parameters->new('foo=bar&foo=baz&bar=yada')->remove('foo');
  
  =head2 to_hash
  
    my $hash = $params->to_hash;
  
  Turn parameters into a hash reference. Note that this method will normalize the
  parameters.
  
    # "baz"
    Mojo::Parameters->new('foo=bar&foo=baz')->to_hash->{foo}[1];
  
  =head2 to_string
  
    my $str = $params->to_string;
  
  Turn parameters into a string.
  
    # "foo=bar&baz=23"
    Mojo::Parameters->new->pairs([foo => 'bar', baz => 23])->to_string;
  
  =head1 OPERATORS
  
  L<Mojo::Parameters> overloads the following operators.
  
  =head2 array
  
    my @pairs = @$params;
  
  Alias for L</"pairs">. Note that this will normalize the parameters.
  
    say $params->[0];
    say for @$params;
  
  =head2 bool
  
    my $bool = !!$params;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$params";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_PARAMETERS

$fatpacked{"Mojo/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PATH';
  package Mojo::Path;
  use Mojo::Base -base;
  use overload
    '@{}'    => sub { shift->parts },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  use Mojo::Util qw(decode encode url_escape url_unescape);
  
  has charset => 'UTF-8';
  
  sub canonicalize {
    my $self = shift;
  
    my $parts = $self->parts;
    for (my $i = 0; $i <= $#$parts;) {
      if (!length $parts->[$i] || $parts->[$i] eq '.' || $parts->[$i] eq '...') {
        splice @$parts, $i, 1;
      }
      elsif ($i < 1 || $parts->[$i] ne '..' || $parts->[$i - 1] eq '..') { $i++ }
      else { splice @$parts, --$i, 2 }
    }
  
    return @$parts ? $self : $self->trailing_slash(undef);
  }
  
  sub clone {
    my $self = shift;
  
    my $clone = $self->new;
    if (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
    if (my $parts = $self->{parts}) {
      $clone->{$_} = $self->{$_} for qw(leading_slash trailing_slash);
      $clone->{parts} = [@$parts];
    }
    else { $clone->{path} = $self->{path} }
  
    return $clone;
  }
  
  sub contains { $_[1] eq '/' || $_[0]->to_route =~ m!^\Q$_[1]\E(?:/|$)! }
  
  sub leading_slash { shift->_parse(leading_slash => @_) }
  
  sub merge {
    my ($self, $path) = @_;
  
    # Replace
    return $self->parse($path) if $path =~ m!^/!;
  
    # Merge
    pop @{$self->parts} unless $self->trailing_slash;
    $path = $self->new($path);
    push @{$self->parts}, @{$path->parts};
    return $self->trailing_slash($path->trailing_slash);
  }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my $self = shift;
    $self->{path} = shift;
    delete @$self{qw(leading_slash parts trailing_slash)};
    return $self;
  }
  
  sub parts { shift->_parse(parts => @_) }
  
  sub to_abs_string {
    my $path = shift->to_string;
    return $path =~ m!^/! ? $path : "/$path";
  }
  
  sub to_dir {
    my $clone = shift->clone;
    pop @{$clone->parts} unless $clone->trailing_slash;
    return $clone->trailing_slash(!!@{$clone->parts});
  }
  
  sub to_route {
    my $clone = shift->clone;
    return '/' . join '/', @{$clone->parts}, $clone->trailing_slash ? '' : ();
  }
  
  sub to_string {
    my $self = shift;
  
    # Path
    my $charset = $self->charset;
    if (defined(my $path = $self->{path})) {
      $path = encode $charset, $path if $charset;
      return url_escape $path, '^A-Za-z0-9\-._~!$&\'()*+,;=%:@/';
    }
  
    # Build path
    my @parts = @{$self->parts};
    @parts = map { encode $charset, $_ } @parts if $charset;
    my $path = join '/',
      map { url_escape $_, '^A-Za-z0-9\-._~!$&\'()*+,;=:@' } @parts;
    $path = "/$path" if $self->leading_slash;
    $path = "$path/" if $self->trailing_slash;
    return $path;
  }
  
  sub trailing_slash { shift->_parse(trailing_slash => @_) }
  
  sub _parse {
    my ($self, $name) = (shift, shift);
  
    unless ($self->{parts}) {
      my $path = url_unescape delete($self->{path}) // '';
      my $charset = $self->charset;
      $path = decode($charset, $path) // $path if $charset;
      $self->{leading_slash}  = $path =~ s!^/!!;
      $self->{trailing_slash} = $path =~ s!/$!!;
      $self->{parts}          = [split '/', $path, -1];
    }
  
    return $self->{$name} unless @_;
    $self->{$name} = shift;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Path - Path
  
  =head1 SYNOPSIS
  
    use Mojo::Path;
  
    # Parse
    my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
    say $path->[0];
  
    # Build
    my $path = Mojo::Path->new('/i/♥');
    push @$path, 'mojolicious';
    say "$path";
  
  =head1 DESCRIPTION
  
  L<Mojo::Path> is a container for paths used by L<Mojo::URL>, based on
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Path> implements the following attributes.
  
  =head2 charset
  
    my $charset = $path->charset;
    $path       = $path->charset('UTF-8');
  
  Charset used for encoding and decoding, defaults to C<UTF-8>.
  
    # Disable encoding and decoding
    $path->charset(undef);
  
  =head1 METHODS
  
  L<Mojo::Path> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 canonicalize
  
    $path = $path->canonicalize;
  
  Canonicalize path by resolving C<.> and C<..>, in addition C<...> will be
  treated as C<.> to protect from path traversal attacks.
  
    # "/foo/baz"
    Mojo::Path->new('/foo/./bar/../baz')->canonicalize;
  
    # "/../baz"
    Mojo::Path->new('/foo/../bar/../../baz')->canonicalize;
  
    # "/foo/bar"
    Mojo::Path->new('/foo/.../bar')->canonicalize;
  
  =head2 clone
  
    my $clone = $path->clone;
  
  Clone path.
  
  =head2 contains
  
    my $bool = $path->contains('/i/♥/mojolicious');
  
  Check if path contains given prefix.
  
    # True
    Mojo::Path->new('/foo/bar')->contains('/');
    Mojo::Path->new('/foo/bar')->contains('/foo');
    Mojo::Path->new('/foo/bar')->contains('/foo/bar');
  
    # False
    Mojo::Path->new('/foo/bar')->contains('/f');
    Mojo::Path->new('/foo/bar')->contains('/bar');
    Mojo::Path->new('/foo/bar')->contains('/whatever');
  
  =head2 leading_slash
  
    my $bool = $path->leading_slash;
    $path    = $path->leading_slash($bool);
  
  Path has a leading slash. Note that this method will normalize the path and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/foo/bar"
    Mojo::Path->new('foo/bar')->leading_slash(1);
  
    # "foo/bar"
    Mojo::Path->new('/foo/bar')->leading_slash(0);
  
  =head2 merge
  
    $path = $path->merge('/foo/bar');
    $path = $path->merge('foo/bar');
    $path = $path->merge(Mojo::Path->new);
  
  Merge paths. Note that this method will normalize both paths if necessary and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/baz/yada"
    Mojo::Path->new('/foo/bar')->merge('/baz/yada');
  
    # "/foo/baz/yada"
    Mojo::Path->new('/foo/bar')->merge('baz/yada');
  
    # "/foo/bar/baz/yada"
    Mojo::Path->new('/foo/bar/')->merge('baz/yada');
  
  =head2 new
  
    my $path = Mojo::Path->new;
    my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
  
  Construct a new L<Mojo::Path> object and L</"parse"> path if necessary.
  
  =head2 parse
  
    $path = $path->parse('/foo%2Fbar%3B/baz.html');
  
  Parse path.
  
  =head2 to_abs_string
  
    my $str = $path->to_abs_string;
  
  Turn path into an absolute string.
  
    # "/i/%E2%99%A5/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_abs_string;
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_abs_string;
  
  =head2 parts
  
    my $parts = $path->parts;
    $path     = $path->parts([qw(foo bar baz)]);
  
  The path parts. Note that this method will normalize the path and that C<%2F>
  will be treated as C</> for security reasons.
  
    # Part with slash
    push @{$path->parts}, 'foo/bar';
  
  =head2 to_dir
  
    my $dir = $route->to_dir;
  
  Clone path and remove everything after the right-most slash.
  
    # "/i/%E2%99%A5/"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
  
    # "i/%E2%99%A5/"
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
  
  =head2 to_route
  
    my $route = $path->to_route;
  
  Turn path into a route.
  
    # "/i/♥/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_route;
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_route;
  
  =head2 to_string
  
    my $str = $path->to_string;
  
  Turn path into a string.
  
    # "/i/%E2%99%A5/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_string;
  
    # "i/%E2%99%A5/mojolicious"
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_string;
  
  =head2 trailing_slash
  
    my $bool = $path->trailing_slash;
    $path    = $path->trailing_slash($bool);
  
  Path has a trailing slash. Note that this method will normalize the path and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/foo/bar/"
    Mojo::Path->new('/foo/bar')->trailing_slash(1);
  
    # "/foo/bar"
    Mojo::Path->new('/foo/bar/')->trailing_slash(0);
  
  =head1 OPERATORS
  
  L<Mojo::Path> overloads the following operators.
  
  =head2 array
  
    my @parts = @$path;
  
  Alias for L</"parts">. Note that this will normalize the path and that C<%2F>
  will be treated as C</> for security reasons.
  
    say $path->[0];
    say for @$path;
  
  =head2 bool
  
    my $bool = !!$path;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$path";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_PATH

$fatpacked{"Mojo/Reactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR';
  package Mojo::Reactor;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Config;
  use Mojo::Loader 'load_class';
  
  sub again { croak 'Method "again" not implemented by subclass' }
  
  sub detect {
    my $default = 'Mojo::Reactor::' . ($Config{d_pseudofork} ? 'Poll' : 'EV');
    my $try = $ENV{MOJO_REACTOR} || $default;
    return load_class($try) ? 'Mojo::Reactor::Poll' : $try;
  }
  
  sub io         { croak 'Method "io" not implemented by subclass' }
  sub is_running { croak 'Method "is_running" not implemented by subclass' }
  sub next_tick  { croak 'Method "next_tick" not implemented by subclass' }
  sub one_tick   { croak 'Method "one_tick" not implemented by subclass' }
  sub recurring  { croak 'Method "recurring" not implemented by subclass' }
  sub remove     { croak 'Method "remove" not implemented by subclass' }
  sub reset      { croak 'Method "reset" not implemented by subclass' }
  sub start      { croak 'Method "start" not implemented by subclass' }
  sub stop       { croak 'Method "stop" not implemented by subclass' }
  sub timer      { croak 'Method "timer" not implemented by subclass' }
  sub watch      { croak 'Method "watch" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor - Low-level event reactor base class
  
  =head1 SYNOPSIS
  
    package Mojo::Reactor::MyEventLoop;
    use Mojo::Base 'Mojo::Reactor';
  
    sub again      {...}
    sub io         {...}
    sub is_running {...}
    sub next_tick  {...}
    sub one_tick   {...}
    sub recurring  {...}
    sub remove     {...}
    sub reset      {...}
    sub start      {...}
    sub stop       {...}
    sub timer      {...}
    sub watch      {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor> is an abstract base class for low-level event reactors, like
  L<Mojo::Reactor::EV> and L<Mojo::Reactor::Poll>.
  
  =head1 EVENTS
  
  L<Mojo::Reactor> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 error
  
    $reactor->on(error => sub {
      my ($reactor, $err) = @_;
      ...
    });
  
  Emitted for exceptions caught in callbacks, fatal if unhandled. Note that if
  this event is unhandled or fails it might kill your program, so you need to be
  careful.
  
    $reactor->on(error => sub {
      my ($reactor, $err) = @_;
      say "Something very bad happened: $err";
    });
  
  =head1 METHODS
  
  L<Mojo::Reactor> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Meant to be overloaded in a subclass. Note that this method
  requires an active timer.
  
  =head2 detect
  
    my $class = Mojo::Reactor->detect;
  
  Detect and load the best reactor implementation available, will try the value
  of the C<MOJO_REACTOR> environment variable, L<Mojo::Reactor::EV> or
  L<Mojo::Reactor::Poll>.
  
    # Instantiate best reactor implementation available
    my $reactor = Mojo::Reactor->detect->new;
  
  =head2 io
  
    $reactor = $reactor->io($handle => sub {...});
  
  Watch handle for I/O events, invoking the callback whenever handle becomes
  readable or writable. Meant to be overloaded in a subclass.
  
    # Callback will be executed twice if handle becomes readable and writable
    $reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running. Meant to be overloaded in a subclass.
  
  =head2 next_tick
  
    my $undef = $reactor->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  Meant to be overloaded in a subclass.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs. Note that this method can recurse back into
  the reactor, so you need to be careful. Meant to be overloaded in a subclass.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds. Meant to be overloaded in a subclass.
  
  =head2 remove
  
    my $bool = $reactor->remove($handle);
    my $bool = $reactor->remove($id);
  
  Remove handle or timer. Meant to be overloaded in a subclass.
  
  =head2 reset
  
    $reactor->reset;
  
  Remove all handles and timers. Meant to be overloaded in a subclass.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called. Note that some reactors stop automatically if there are no events being
  watched anymore. Meant to be overloaded in a subclass.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events. Meant to be overloaded in a subclass.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds. Meant to be overloaded in a subclass.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Meant to be
  overloaded in a subclass. Note that this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_REACTOR

$fatpacked{"Mojo/Reactor/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_EV';
  package Mojo::Reactor::EV;
  use Mojo::Base 'Mojo::Reactor::Poll';
  
  use Carp 'croak';
  use EV 4.0;
  
  my $EV;
  
  sub DESTROY { undef $EV }
  
  sub again {
    croak 'Timer not active' unless my $timer = shift->{timers}{shift()};
    $timer->{watcher}->again;
  }
  
  sub is_running { !!EV::depth }
  
  # We have to fall back to Mojo::Reactor::Poll, since EV is unique
  sub new { $EV++ ? Mojo::Reactor::Poll->new : shift->SUPER::new }
  
  sub one_tick { EV::run(EV::RUN_ONCE) }
  
  sub recurring { shift->_timer(1, @_) }
  
  sub start {EV::run}
  
  sub stop { EV::break(EV::BREAK_ALL) }
  
  sub timer { shift->_timer(0, @_) }
  
  sub watch {
    my ($self, $handle, $read, $write) = @_;
  
    my $fd = fileno $handle;
    croak 'I/O watcher not active' unless my $io = $self->{io}{$fd};
  
    my $mode = 0;
    $mode |= EV::READ  if $read;
    $mode |= EV::WRITE if $write;
  
    if ($mode == 0) { delete $io->{watcher} }
    elsif (my $w = $io->{watcher}) { $w->events($mode) }
    else {
      my $cb = sub {
        my ($w, $revents) = @_;
        $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 0)
          if EV::READ & $revents;
        $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 1)
          if EV::WRITE & $revents && $self->{io}{$fd};
      };
      $io->{watcher} = EV::io($fd, $mode, $cb);
    }
  
    return $self;
  }
  
  sub _timer {
    my ($self, $recurring, $after, $cb) = @_;
    $after ||= 0.0001 if $recurring;
  
    my $id      = $self->_id;
    my $wrapper = sub {
      delete $self->{timers}{$id} unless $recurring;
      $self->_try('Timer', $cb);
    };
    EV::now_update() if $after > 0;
    $self->{timers}{$id}{watcher} = EV::timer($after, $after, $wrapper);
  
    return $id;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor::EV - Low-level event reactor with libev support
  
  =head1 SYNOPSIS
  
    use Mojo::Reactor::EV;
  
    # Watch if handle becomes readable or writable
    my $reactor = Mojo::Reactor::EV->new;
    $reactor->io($first => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'First handle is writable' : 'First handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $reactor->watch($first, 0, 1);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $second = IO::Handle->new_from_fd($fd, 'r');
    $reactor->io($second => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Second handle is writable' : 'Second handle is readable';
    })->watch($second, 1, 0);
  
    # Add a timer
    $reactor->timer(15 => sub {
      my $reactor = shift;
      $reactor->remove($first);
      $reactor->remove($second);
      say 'Timeout!';
    });
  
    # Start reactor if necessary
    $reactor->start unless $reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor::EV> is a low-level event reactor based on L<EV> (4.0+).
  
  =head1 EVENTS
  
  L<Mojo::Reactor::EV> inherits all events from L<Mojo::Reactor::Poll>.
  
  =head1 METHODS
  
  L<Mojo::Reactor::EV> inherits all methods from L<Mojo::Reactor::Poll> and
  implements the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Note that this method requires an active timer.
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running.
  
  =head2 new
  
    my $reactor = Mojo::Reactor::EV->new;
  
  Construct a new L<Mojo::Reactor::EV> object.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs or no events are being watched anymore. Note
  that this method can recurse back into the reactor, so you need to be careful.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called or no events are being watched anymore.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Note that
  this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_REACTOR_EV

$fatpacked{"Mojo/Reactor/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_POLL';
  package Mojo::Reactor::Poll;
  use Mojo::Base 'Mojo::Reactor';
  
  use Carp 'croak';
  use IO::Poll qw(POLLERR POLLHUP POLLIN POLLNVAL POLLOUT POLLPRI);
  use List::Util 'min';
  use Mojo::Util qw(md5_sum steady_time);
  use Time::HiRes 'usleep';
  
  sub again {
    croak 'Timer not active' unless my $timer = shift->{timers}{shift()};
    $timer->{time} = steady_time + $timer->{after};
  }
  
  sub io {
    my ($self, $handle, $cb) = @_;
    $self->{io}{fileno $handle} = {cb => $cb};
    return $self->watch($handle, 1, 1);
  }
  
  sub is_running { !!shift->{running} }
  
  sub next_tick {
    my ($self, $cb) = @_;
    push @{$self->{next_tick}}, $cb;
    $self->{next_timer} //= $self->timer(0 => \&_next);
    return undef;
  }
  
  sub one_tick {
    my $self = shift;
  
    # Just one tick
    local $self->{running} = 1 unless $self->{running};
  
    # Wait for one event
    my $i;
    until ($i || !$self->{running}) {
  
      # Stop automatically if there is nothing to watch
      return $self->stop unless keys %{$self->{timers}} || keys %{$self->{io}};
  
      # Calculate ideal timeout based on timers and round up to next millisecond
      my $min = min map { $_->{time} } values %{$self->{timers}};
      my $timeout = defined $min ? $min - steady_time : 0.5;
      $timeout = $timeout <= 0 ? 0 : int($timeout * 1000) + 1;
  
      # I/O
      if (keys %{$self->{io}}) {
        my @poll = map { $_ => $self->{io}{$_}{mode} } keys %{$self->{io}};
  
        # This may break in the future, but is worth it for performance
        if (IO::Poll::_poll($timeout, @poll) > 0) {
          while (my ($fd, $mode) = splice @poll, 0, 2) {
  
            if ($mode & (POLLIN | POLLPRI | POLLNVAL | POLLHUP | POLLERR)) {
              next unless my $io = $self->{io}{$fd};
              ++$i and $self->_try('I/O watcher', $io->{cb}, 0);
            }
            next unless $mode & POLLOUT && (my $io = $self->{io}{$fd});
            ++$i and $self->_try('I/O watcher', $io->{cb}, 1);
          }
        }
      }
  
      # Wait for timeout if poll can't be used
      elsif ($timeout) { usleep($timeout * 1000) }
  
      # Timers (time should not change in between timers)
      my $now = steady_time;
      for my $id (keys %{$self->{timers}}) {
        next unless my $t = $self->{timers}{$id};
        next unless $t->{time} <= $now;
  
        # Recurring timer
        if (exists $t->{recurring}) { $t->{time} = $now + $t->{recurring} }
  
        # Normal timer
        else { $self->remove($id) }
  
        ++$i and $self->_try('Timer', $t->{cb}) if $t->{cb};
      }
    }
  }
  
  sub recurring { shift->_timer(1, @_) }
  
  sub remove {
    my ($self, $remove) = @_;
    return !!delete $self->{timers}{$remove} unless ref $remove;
    return !!delete $self->{io}{fileno $remove};
  }
  
  sub reset { delete @{shift()}{qw(io next_tick next_timer timers)} }
  
  sub start {
    my $self = shift;
    $self->{running}++;
    $self->one_tick while $self->{running};
  }
  
  sub stop { delete shift->{running} }
  
  sub timer { shift->_timer(0, @_) }
  
  sub watch {
    my ($self, $handle, $read, $write) = @_;
  
    croak 'I/O watcher not active' unless my $io = $self->{io}{fileno $handle};
    $io->{mode} = 0;
    $io->{mode} |= POLLIN | POLLPRI if $read;
    $io->{mode} |= POLLOUT if $write;
  
    return $self;
  }
  
  sub _id {
    my $self = shift;
    my $id;
    do { $id = md5_sum 't' . steady_time . rand } while $self->{timers}{$id};
    return $id;
  }
  
  sub _next {
    my $self = shift;
    delete $self->{next_timer};
    while (my $cb = shift @{$self->{next_tick}}) { $self->$cb }
  }
  
  sub _timer {
    my ($self, $recurring, $after, $cb) = @_;
  
    my $id    = $self->_id;
    my $timer = $self->{timers}{$id}
      = {cb => $cb, after => $after, time => steady_time + $after};
    $timer->{recurring} = $after if $recurring;
  
    return $id;
  }
  
  sub _try {
    my ($self, $what, $cb) = (shift, shift, shift);
    eval { $self->$cb(@_); 1 } or $self->emit(error => "$what failed: $@");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor::Poll - Low-level event reactor with poll support
  
  =head1 SYNOPSIS
  
    use Mojo::Reactor::Poll;
  
    # Watch if handle becomes readable or writable
    my $reactor = Mojo::Reactor::Poll->new;
    $reactor->io($first => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'First handle is writable' : 'First handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $reactor->watch($first, 0, 1);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $second = IO::Handle->new_from_fd($fd, 'r');
    $reactor->io($second => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Second handle is writable' : 'Second handle is readable';
    })->watch($second, 1, 0);
  
    # Add a timer
    $reactor->timer(15 => sub {
      my $reactor = shift;
      $reactor->remove($first);
      $reactor->remove($second);
      say 'Timeout!';
    });
  
    # Start reactor if necessary
    $reactor->start unless $reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor::Poll> is a low-level event reactor based on L<IO::Poll>.
  
  =head1 EVENTS
  
  L<Mojo::Reactor::Poll> inherits all events from L<Mojo::Reactor>.
  
  =head1 METHODS
  
  L<Mojo::Reactor::Poll> inherits all methods from L<Mojo::Reactor> and
  implements the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Note that this method requires an active timer.
  
  =head2 io
  
    $reactor = $reactor->io($handle => sub {...});
  
  Watch handle for I/O events, invoking the callback whenever handle becomes
  readable or writable.
  
    # Callback will be executed twice if handle becomes readable and writable
    $reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running.
  
  =head2 next_tick
  
    my $undef = $reactor->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs or no events are being watched anymore. Note
  that this method can recurse back into the reactor, so you need to be careful.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
  =head2 remove
  
    my $bool = $reactor->remove($handle);
    my $bool = $reactor->remove($id);
  
  Remove handle or timer.
  
  =head2 reset
  
    $reactor->reset;
  
  Remove all handles and timers.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called or no events are being watched anymore.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Note that
  this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_REACTOR_POLL

$fatpacked{"Mojo/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER';
  package Mojo::Server;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Cwd 'abs_path';
  use Mojo::Loader 'load_class';
  use Mojo::Util 'md5_sum';
  use POSIX ();
  use Scalar::Util 'blessed';
  
  has app           => sub { shift->build_app('Mojo::HelloWorld') };
  has reverse_proxy => sub { $ENV{MOJO_REVERSE_PROXY} };
  
  sub build_app {
    my ($self, $app) = @_;
    local $ENV{MOJO_EXE};
    return $self->app($app->new)->app unless my $e = load_class $app;
    die ref $e ? $e : qq{Can't find application class "$app" in \@INC. (@INC)\n};
  }
  
  sub build_tx {
    my $self = shift;
    my $tx   = $self->app->build_tx;
    $tx->req->reverse_proxy(1) if $self->reverse_proxy;
    return $tx;
  }
  
  sub daemonize {
  
    # Fork and kill parent
    die "Can't fork: $!" unless defined(my $pid = fork);
    exit 0 if $pid;
    POSIX::setsid or die "Can't start a new session: $!";
  
    # Close filehandles
    open STDIN,  '</dev/null';
    open STDOUT, '>/dev/null';
    open STDERR, '>&STDOUT';
  }
  
  sub load_app {
    my ($self, $path) = @_;
  
    # Clean environment (reset FindBin defensively)
    {
      local $0 = $path = abs_path $path;
      require FindBin;
      FindBin->again;
      local $ENV{MOJO_APP_LOADER} = 1;
      local $ENV{MOJO_EXE};
  
      # Try to load application from script into sandbox
      delete $INC{$path};
      my $app = eval
        "package Mojo::Server::Sandbox::@{[md5_sum $path]}; require \$path";
      die qq{Can't load application from file "$path": $@} if $@;
      die qq{File "$path" did not return an application object.\n}
        unless blessed $app && $app->isa('Mojo');
      $self->app($app);
    };
    FindBin->again;
  
    return $self->app;
  }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(request => sub { shift->app->handler(shift) });
    return $self;
  }
  
  sub run { croak 'Method "run" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server - HTTP/WebSocket server base class
  
  =head1 SYNOPSIS
  
    package Mojo::Server::MyServer;
    use Mojo::Base 'Mojo::Server';
  
    sub run {
      my $self = shift;
  
      # Get a transaction
      my $tx = $self->build_tx;
  
      # Emit "request" event
      $self->emit(request => $tx);
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Server> is an abstract base class for HTTP/WebSocket servers and server
  interfaces, like L<Mojo::Server::CGI>, L<Mojo::Server::Daemon>,
  L<Mojo::Server::Hypnotoad>, L<Mojo::Server::Morbo>, L<Mojo::Server::Prefork>
  and L<Mojo::Server::PSGI>.
  
  =head1 EVENTS
  
  L<Mojo::Server> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 request
  
    $server->on(request => sub {
      my ($server, $tx) = @_;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $server->unsubscribe('request')->on(request => sub {
      my ($server, $tx) = @_;
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body('Hello World!');
      $tx->resume;
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server> implements the following attributes.
  
  =head2 app
  
    my $app = $server->app;
    $server = $server->app(MojoSubclass->new);
  
  Application this server handles, defaults to a L<Mojo::HelloWorld> object.
  
  =head2 reverse_proxy
  
    my $bool = $server->reverse_proxy;
    $server  = $server->reverse_proxy($bool);
  
  This server operates behind a reverse proxy, defaults to the value of the
  C<MOJO_REVERSE_PROXY> environment variable.
  
  =head1 METHODS
  
  L<Mojo::Server> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 build_app
  
    my $app = $server->build_app('MyApp');
  
  Build application from class and assign it to L</"app">.
  
  =head2 build_tx
  
    my $tx = $server->build_tx;
  
  Let application build a transaction.
  
  =head2 daemonize
  
    $server->daemonize;
  
  Daemonize server process.
  
  =head2 load_app
  
    my $app = $server->load_app('/home/sri/myapp.pl');
  
  Load application from script and assign it to L</"app">.
  
    say Mojo::Server->new->load_app('./myapp.pl')->home;
  
  =head2 new
  
    my $server = Mojo::Server->new;
    my $server = Mojo::Server->new(reverse_proxy => 1);
    my $server = Mojo::Server->new({reverse_proxy => 1});
  
  Construct a new L<Mojo::Server> object and subscribe to L</"request"> event
  with default request handling.
  
  =head2 run
  
    $server->run;
  
  Run server. Meant to be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER

$fatpacked{"Mojo/Server/CGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_CGI';
  package Mojo::Server::CGI;
  use Mojo::Base 'Mojo::Server';
  
  has 'nph';
  
  sub run {
    my $self = shift;
  
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse(\%ENV);
    $tx->local_port($ENV{SERVER_PORT})->remote_address($ENV{REMOTE_ADDR});
  
    # Request body (may block if we try to read too much)
    binmode STDIN;
    my $len = $req->headers->content_length;
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = STDIN->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
  
    $self->emit(request => $tx);
  
    # Response start-line
    STDOUT->autoflush(1);
    binmode STDOUT;
    my $res = $tx->res->fix_headers;
    return undef if $self->nph && !_write($res, 'get_start_line_chunk');
  
    # Response headers
    my $code = $res->code    || 404;
    my $msg  = $res->message || $res->default_message;
    $res->headers->status("$code $msg") unless $self->nph;
    return undef unless _write($res, 'get_header_chunk');
  
    # Response body
    return undef unless $tx->is_empty || _write($res, 'get_body_chunk');
  
    # Finish transaction
    $tx->closed;
  
    return $res->code;
  }
  
  sub _write {
    my ($res, $method) = @_;
  
    my $offset = 0;
    while (1) {
  
      # No chunk yet, try again
      sleep 1 and next unless defined(my $chunk = $res->$method($offset));
  
      # End of part
      last unless my $len = length $chunk;
  
      # Make sure we can still write
      $offset += $len;
      return undef unless STDOUT->opened;
      print STDOUT $chunk;
    }
  
    return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::CGI - CGI server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::CGI;
  
    my $cgi = Mojo::Server::CGI->new;
    $cgi->unsubscribe('request')->on(request => sub {
      my ($cgi, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $cgi->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::CGI> is a simple and portable implementation of
  L<RFC 3875|http://tools.ietf.org/html/rfc3875>.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::Server::CGI> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::CGI> inherits all attributes from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 nph
  
    my $bool = $cgi->nph;
    $cgi     = $cgi->nph($bool);
  
  Activate non-parsed header mode.
  
  =head1 METHODS
  
  L<Mojo::Server::CGI> inherits all methods from L<Mojo::Server> and implements
  the following new ones.
  
  =head2 run
  
    my $status = $cgi->run;
  
  Run CGI.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_CGI

$fatpacked{"Mojo/Server/Daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_DAEMON';
  package Mojo::Server::Daemon;
  use Mojo::Base 'Mojo::Server';
  
  use Carp 'croak';
  use Mojo::IOLoop;
  use Mojo::Transaction::WebSocket;
  use Mojo::URL;
  use Mojo::Util 'term_escape';
  use Mojo::WebSocket 'server_handshake';
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_DAEMON_DEBUG} || 0;
  
  has acceptors => sub { [] };
  has [qw(backlog max_clients silent)];
  has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 15 };
  has ioloop => sub { Mojo::IOLoop->singleton };
  has listen => sub { [split ',', $ENV{MOJO_LISTEN} || 'http://*:3000'] };
  has max_requests => 100;
  
  sub DESTROY {
    return if Mojo::Util::_global_destruction();
    my $self = shift;
    $self->_remove($_) for keys %{$self->{connections} || {}};
    my $loop = $self->ioloop;
    $loop->remove($_) for @{$self->acceptors};
  }
  
  sub run {
    my $self = shift;
  
    # Make sure the event loop can be stopped in regular intervals
    my $loop = $self->ioloop;
    my $int = $loop->recurring(1 => sub { });
    local $SIG{INT} = local $SIG{TERM} = sub { $loop->stop };
    $self->start->ioloop->start;
    $loop->remove($int);
  }
  
  sub start {
    my $self = shift;
  
    my $loop = $self->ioloop;
    if (my $max = $self->max_clients) { $loop->max_connections($max) }
  
    # Resume accepting connections
    if (my $servers = $self->{servers}) {
      push @{$self->acceptors}, $loop->acceptor(delete $servers->{$_})
        for keys %$servers;
    }
  
    # Start listening
    elsif (!@{$self->acceptors}) { $self->_listen($_) for @{$self->listen} }
  
    return $self;
  }
  
  sub stop {
    my $self = shift;
  
    # Suspend accepting connections but keep listen sockets open
    my $loop = $self->ioloop;
    while (my $id = shift @{$self->acceptors}) {
      my $server = $self->{servers}{$id} = $loop->acceptor($id);
      $loop->remove($id);
      $server->stop;
    }
  
    return $self;
  }
  
  sub _build_tx {
    my ($self, $id, $c) = @_;
  
    my $tx = $self->build_tx->connection($id);
    $tx->res->headers->server('Mojolicious (Perl)');
    my $handle = $self->ioloop->stream($id)->handle;
    $tx->local_address($handle->sockhost)->local_port($handle->sockport);
    $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
    $tx->req->url->base->scheme('https') if $c->{tls};
  
    weaken $self;
    $tx->on(
      request => sub {
        my $tx = shift;
  
        # WebSocket
        if ($tx->req->is_handshake) {
          my $ws = $self->{connections}{$id}{next}
            = Mojo::Transaction::WebSocket->new(handshake => $tx);
          $self->emit(request => server_handshake $ws);
        }
  
        # HTTP
        else { $self->emit(request => $tx) }
  
        # Last keep-alive request or corrupted connection
        my $c = $self->{connections}{$id};
        $tx->res->headers->connection('close')
          if $c->{requests} >= $self->max_requests || $tx->req->error;
  
        $tx->on(resume => sub { $self->_write($id) });
        $self->_write($id);
      }
    );
  
    # Kept alive if we have more than one request on the connection
    return ++$c->{requests} > 1 ? $tx->kept_alive(1) : $tx;
  }
  
  sub _close {
    my ($self, $id) = @_;
    if (my $tx = $self->{connections}{$id}{tx}) { $tx->closed }
    delete $self->{connections}{$id};
  }
  
  sub _debug { $_[0]->app->log->debug($_[2]) if $_[0]{connections}{$_[1]}{tx} }
  
  sub _finish {
    my ($self, $id) = @_;
  
    # Always remove connection for WebSockets
    my $c = $self->{connections}{$id};
    return unless my $tx = $c->{tx};
    return $self->_remove($id) if $tx->is_websocket;
  
    # Finish transaction
    delete($c->{tx})->closed;
  
    # Upgrade connection to WebSocket
    if (my $ws = delete $c->{next}) {
  
      # Successful upgrade
      if ($ws->handshake->res->code == 101) {
        $c->{tx} = $ws->established(1);
        weaken $self;
        $ws->on(resume => sub { $self->_write($id) });
        $self->_write($id);
      }
  
      # Failed upgrade
      else { $ws->closed }
    }
  
    # Close connection if necessary
    return $self->_remove($id) if $tx->error || !$tx->keep_alive;
  
    # Build new transaction for leftovers
    return unless length(my $leftovers = $tx->req->content->leftovers);
    $tx = $c->{tx} = $self->_build_tx($id, $c);
    $tx->server_read($leftovers);
  }
  
  sub _listen {
    my ($self, $listen) = @_;
  
    my $url   = Mojo::URL->new($listen);
    my $proto = $url->protocol;
    croak qq{Invalid listen location "$listen"} unless $proto =~ /^https?$/;
  
    my $query   = $url->query;
    my $options = {
      address       => $url->host,
      backlog       => $self->backlog,
      single_accept => $query->param('single_accept'),
      reuse         => $query->param('reuse')
    };
    if (my $port = $url->port) { $options->{port} = $port }
    $options->{"tls_$_"} = $query->param($_) for qw(ca ciphers version);
    /^(.*)_(cert|key)$/ and $options->{"tls_$2"}{$1} = $query->param($_)
      for @{$query->names};
    if (my $cert = $query->param('cert')) { $options->{'tls_cert'}{''} = $cert }
    if (my $key  = $query->param('key'))  { $options->{'tls_key'}{''}  = $key }
    my $verify = $query->param('verify');
    $options->{tls_verify} = hex $verify if defined $verify;
    delete $options->{address} if $options->{address} eq '*';
    my $tls = $options->{tls} = $proto eq 'https';
  
    weaken $self;
    push @{$self->acceptors}, $self->ioloop->server(
      $options => sub {
        my ($loop, $stream, $id) = @_;
  
        $self->{connections}{$id} = {tls => $tls};
        warn "-- Accept $id (@{[$stream->handle->peerhost]})\n" if DEBUG;
        $stream->timeout($self->inactivity_timeout);
  
        $stream->on(close => sub { $self && $self->_close($id) });
        $stream->on(error =>
            sub { $self && $self->app->log->error(pop) && $self->_close($id) });
        $stream->on(read => sub { $self->_read($id => pop) });
        $stream->on(timeout => sub { $self->_debug($id, 'Inactivity timeout') });
      }
    );
  
    return if $self->silent;
    $self->app->log->info(qq{Listening at "$url"});
    $query->pairs([]);
    $url->host('127.0.0.1') if $url->host eq '*';
    say "Server available at $url";
  }
  
  sub _read {
    my ($self, $id, $chunk) = @_;
  
    # Make sure we have a transaction
    my $c = $self->{connections}{$id};
    my $tx = $c->{tx} ||= $self->_build_tx($id, $c);
    warn term_escape "-- Server <<< Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    $tx->server_read($chunk);
  }
  
  sub _remove {
    my ($self, $id) = @_;
    $self->ioloop->remove($id);
    $self->_close($id);
  }
  
  sub _url { shift->req->url->to_abs }
  
  sub _write {
    my ($self, $id) = @_;
  
    # Protect from resume event recursion
    my $c = $self->{connections}{$id};
    return if !(my $tx = $c->{tx}) || $c->{writing};
    local $c->{writing} = 1;
    my $chunk = $tx->server_write;
    warn term_escape "-- Server >>> Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    my $next = $tx->is_finished ? '_finish' : length $chunk ? '_write' : undef;
    return $self->ioloop->stream($id)->write($chunk) unless $next;
    weaken $self;
    $self->ioloop->stream($id)->write($chunk => sub { $self->$next($id) });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Daemon - Non-blocking I/O HTTP and WebSocket server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Daemon;
  
    my $daemon = Mojo::Server::Daemon->new(listen => ['http://*:8080']);
    $daemon->unsubscribe('request')->on(request => sub {
      my ($daemon, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $daemon->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Daemon> is a full featured, highly portable non-blocking I/O
  HTTP and WebSocket server, with IPv6, TLS, SNI, Comet (long polling), keep-alive
  and multiple event loop support.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NDN>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 SIGNALS
  
  The L<Mojo::Server::Daemon> process can be controlled at runtime with the
  following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head1 EVENTS
  
  L<Mojo::Server::Daemon> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Daemon> inherits all attributes from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 acceptors
  
    my $acceptors = $daemon->acceptors;
    $daemon       = $daemon->acceptors(['6be0c140ef00a389c5d039536b56d139']);
  
  Active acceptor ids.
  
    # Check port
    mu $port = $daemon->ioloop->acceptor($daemon->acceptors->[0])->port;
  
  =head2 backlog
  
    my $backlog = $daemon->backlog;
    $daemon     = $daemon->backlog(128);
  
  Listen backlog size, defaults to C<SOMAXCONN>.
  
  =head2 inactivity_timeout
  
    my $timeout = $daemon->inactivity_timeout;
    $daemon     = $daemon->inactivity_timeout(5);
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment
  variable or C<15>. Setting the value to C<0> will allow connections to be
  inactive indefinitely.
  
  =head2 ioloop
  
    my $loop = $daemon->ioloop;
    $daemon  = $daemon->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for I/O operations, defaults to the global
  L<Mojo::IOLoop> singleton.
  
  =head2 listen
  
    my $listen = $daemon->listen;
    $daemon    = $daemon->listen(['https://127.0.0.1:8080']);
  
  Array reference with one or more locations to listen on, defaults to the value
  of the C<MOJO_LISTEN> environment variable or C<http://*:3000> (shortcut for
  C<http://0.0.0.0:3000>).
  
    # Listen on all IPv4 interfaces
    $daemon->listen(['http://*:3000']);
  
    # Listen on all IPv4 and IPv6 interfaces
    $daemon->listen(['http://[::]:3000']);
  
    # Listen on IPv6 interface
    $daemon->listen(['http://[::1]:4000']);
  
    # Listen on IPv4 and IPv6 interfaces
    $daemon->listen(['http://127.0.0.1:3000', 'http://[::1]:3000']);
  
    # Allow multiple servers to use the same port (SO_REUSEPORT)
    $daemon->listen(['http://*:8080?reuse=1']);
  
    # Listen on two ports with HTTP and HTTPS at the same time
    $daemon->listen(['http://*:3000', 'https://*:4000']);
  
    # Use a custom certificate and key
    $daemon->listen(['https://*:3000?cert=/x/server.crt&key=/y/server.key']);
  
    # Domain specific certificates and keys (SNI)
    $daemon->listen(
      ['https://*:3000?example.com_cert=/x/my.crt&example.com_key=/y/my.key']);
  
    # Or even a custom certificate authority
    $daemon->listen(
      ['https://*:3000?cert=/x/server.crt&key=/y/server.key&ca=/z/ca.crt']);
  
  These parameters are currently available:
  
  =over 2
  
  =item ca
  
    ca=/etc/tls/ca.crt
  
  Path to TLS certificate authority file used to verify the peer certificate.
  
  =item cert
  
    cert=/etc/tls/server.crt
    mojolicious.org_cert=/etc/tls/mojo.crt
  
  Path to the TLS cert file, defaults to a built-in test certificate.
  
  =item ciphers
  
    ciphers=AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item key
  
    key=/etc/tls/server.key
    mojolicious.org_key=/etc/tls/mojo.key
  
  Path to the TLS key file, defaults to a built-in test key.
  
  =item reuse
  
    reuse=1
  
  Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket
  option.
  
  =item single_accept
  
    single_accept=1
  
  Only accept one connection at a time.
  
  =item verify
  
    verify=0x00
  
  TLS verification mode, defaults to C<0x03>.
  
  =item version
  
    version=TLSv1_2
  
  TLS protocol version.
  
  =back
  
  =head2 max_clients
  
    my $max = $daemon->max_clients;
    $daemon = $daemon->max_clients(100);
  
  Maximum number of accepted connections this server is allowed to handle
  concurrently, before stopping to accept new incoming connections, passed along
  to L<Mojo::IOLoop/"max_connections">.
  
  =head2 max_requests
  
    my $max = $daemon->max_requests;
    $daemon = $daemon->max_requests(250);
  
  Maximum number of keep-alive requests per connection, defaults to C<100>.
  
  =head2 silent
  
    my $bool = $daemon->silent;
    $daemon  = $daemon->silent($bool);
  
  Disable console messages.
  
  =head1 METHODS
  
  L<Mojo::Server::Daemon> inherits all methods from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 run
  
    $daemon->run;
  
  Run server and wait for L</"SIGNALS">.
  
  =head2 start
  
    $daemon = $daemon->start;
  
  Start or resume accepting connections through L</"ioloop">.
  
    # Listen on random port
    my $id   = $daemon->listen(['http://127.0.0.1'])->start->acceptors->[0];
    my $port = $daemon->ioloop->acceptor($id)->port;
  
    # Run multiple web servers concurrently
    my $daemon1 = Mojo::Server::Daemon->new(listen => ['http://*:3000'])->start;
    my $daemon2 = Mojo::Server::Daemon->new(listen => ['http://*:4000'])->start;
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 stop
  
    $daemon = $daemon->stop;
  
  Stop accepting connections through L</"ioloop">.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_DAEMON_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_DAEMON_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_DAEMON

$fatpacked{"Mojo/Server/Hypnotoad.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_HYPNOTOAD';
  package Mojo::Server::Hypnotoad;
  use Mojo::Base -base;
  
  # "Bender: I was God once.
  #  God: Yes, I saw. You were doing well, until everyone died."
  use Config;
  use Cwd 'abs_path';
  use File::Basename 'dirname';
  use File::Spec::Functions 'catfile';
  use Mojo::Server::Prefork;
  use Mojo::Util qw(steady_time);
  use Scalar::Util 'weaken';
  
  has prefork => sub { Mojo::Server::Prefork->new(listen => ['http://*:8080']) };
  has upgrade_timeout => 60;
  
  sub configure {
    my ($self, $name) = @_;
  
    # Hypnotoad settings
    my $prefork = $self->prefork;
    my $c = $prefork->app->config($name) || {};
    $self->upgrade_timeout($c->{upgrade_timeout}) if $c->{upgrade_timeout};
  
    # Prefork settings
    $prefork->reverse_proxy($c->{proxy})   if defined $c->{proxy};
    $prefork->max_clients($c->{clients})   if $c->{clients};
    $prefork->max_requests($c->{requests}) if $c->{requests};
    defined $c->{$_} and $prefork->$_($c->{$_})
      for qw(accepts backlog graceful_timeout heartbeat_interval),
      qw(heartbeat_timeout inactivity_timeout listen pid_file workers);
  }
  
  sub run {
    my ($self, $app) = @_;
  
    # No fork emulation support
    _exit('Hypnotoad does not support fork emulation.') if $Config{d_pseudofork};
  
    # Remember executable and application for later
    $ENV{HYPNOTOAD_EXE} ||= $0;
    $0 = $ENV{HYPNOTOAD_APP} ||= abs_path $app;
  
    # This is a production server
    $ENV{MOJO_MODE} ||= 'production';
  
    # Clean start (to make sure everything works)
    die "Can't exec: $!"
      if !$ENV{HYPNOTOAD_REV}++ && !exec $^X, $ENV{HYPNOTOAD_EXE};
  
    # Preload application and configure server
    my $prefork = $self->prefork->cleanup(0);
    $prefork->load_app($app)->config->{hypnotoad}{pid_file}
      //= catfile dirname($ENV{HYPNOTOAD_APP}), 'hypnotoad.pid';
    $self->configure('hypnotoad');
    weaken $self;
    $prefork->on(wait   => sub { $self->_manage });
    $prefork->on(reap   => sub { $self->_cleanup(pop) });
    $prefork->on(finish => sub { $self->{finished} = 1 });
  
    # Testing
    _exit('Everything looks good!') if $ENV{HYPNOTOAD_TEST};
  
    # Stop running server
    $self->_stop if $ENV{HYPNOTOAD_STOP};
  
    # Initiate hot deployment
    $self->_hot_deploy unless $ENV{HYPNOTOAD_PID};
  
    # Daemonize as early as possible (but not for restarts)
    $prefork->start;
    $prefork->daemonize if !$ENV{HYPNOTOAD_FOREGROUND} && $ENV{HYPNOTOAD_REV} < 3;
  
    # Start accepting connections
    local $SIG{USR2} = sub { $self->{upgrade} ||= steady_time };
    $prefork->cleanup(1)->run;
  }
  
  sub _cleanup {
    my ($self, $pid) = @_;
  
    # Clean up failed upgrade
    return unless ($self->{new} || '') eq $pid;
    $self->prefork->app->log->error('Zero downtime software upgrade failed');
    delete @$self{qw(new upgrade)};
  }
  
  sub _exit { say shift and exit 0 }
  
  sub _hot_deploy {
  
    # Make sure server is running
    return unless my $pid = shift->prefork->check_pid;
  
    # Start hot deployment
    kill 'USR2', $pid;
    _exit("Starting hot deployment for Hypnotoad server $pid.");
  }
  
  sub _manage {
    my $self = shift;
  
    # Upgraded (wait for all workers to send a heartbeat)
    my $prefork = $self->prefork;
    my $log     = $prefork->app->log;
    if ($ENV{HYPNOTOAD_PID} && $ENV{HYPNOTOAD_PID} ne $$) {
      return unless $prefork->healthy == $prefork->workers;
      $log->info("Upgrade successful, stopping $ENV{HYPNOTOAD_PID}");
      kill 'QUIT', $ENV{HYPNOTOAD_PID};
    }
    $ENV{HYPNOTOAD_PID} = $$ unless ($ENV{HYPNOTOAD_PID} // '') eq $$;
  
    # Upgrade
    if ($self->{upgrade} && !$self->{finished}) {
  
      # Fresh start
      unless ($self->{new}) {
        $log->info('Starting zero downtime software upgrade');
        die "Can't fork: $!" unless defined(my $pid = $self->{new} = fork);
        exec $^X, $ENV{HYPNOTOAD_EXE} or die "Can't exec: $!" unless $pid;
      }
  
      # Timeout
      kill 'KILL', $self->{new}
        if $self->{upgrade} + $self->upgrade_timeout <= steady_time;
    }
  }
  
  sub _stop {
    _exit('Hypnotoad server not running.')
      unless my $pid = shift->prefork->check_pid;
    kill 'QUIT', $pid;
    _exit("Stopping Hypnotoad server $pid gracefully.");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Hypnotoad - A production web serv...ALL GLORY TO THE HYPNOTOAD!
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Hypnotoad;
  
    my $hypnotoad = Mojo::Server::Hypnotoad->new;
    $hypnotoad->run('/home/sri/myapp.pl');
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Hypnotoad> is a full featured, UNIX optimized, preforking
  non-blocking I/O HTTP and WebSocket server, built around the very well tested
  and reliable L<Mojo::Server::Prefork>, with IPv6, TLS, SNI, Comet (long
  polling), keep-alive, multiple event loop and hot deployment support that just
  works. Note that the server uses signals for process management, so you should
  avoid modifying signal handlers in your applications.
  
  To start applications with it you can use the L<hypnotoad> script, which
  listens on port C<8080>, automatically daemonizes the server process and
  defaults to C<production> mode for L<Mojolicious> and L<Mojolicious::Lite>
  applications.
  
    $ hypnotoad ./myapp.pl
  
  You can run the same command again for automatic hot deployment.
  
    $ hypnotoad ./myapp.pl
    Starting hot deployment for Hypnotoad server 31841.
  
  This second invocation will load the application again, detect the process id
  file with it, and send a L</"USR2"> signal to the already running server.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NDN>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 MANAGER SIGNALS
  
  The L<Mojo::Server::Hypnotoad> manager process can be controlled at runtime
  with the following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head2 QUIT
  
  Shut down server gracefully.
  
  =head2 TTIN
  
  Increase worker pool by one.
  
  =head2 TTOU
  
  Decrease worker pool by one.
  
  =head2 USR2
  
  Attempt zero downtime software upgrade (hot deployment) without losing any
  incoming connections.
  
    Manager (old)
    |- Worker [1]
    |- Worker [2]
    |- Worker [3]
    |- Worker [4]
    +- Manager (new)
       |- Worker [1]
       |- Worker [2]
       |- Worker [3]
       +- Worker [4]
  
  The new manager will automatically send a L</"QUIT"> signal to the old manager
  and take over serving requests after starting up successfully.
  
  =head1 WORKER SIGNALS
  
  L<Mojo::Server::Hypnotoad> worker processes can be controlled at runtime with
  the following signals.
  
  =head2 QUIT
  
  Stop worker gracefully.
  
  =head1 SETTINGS
  
  L<Mojo::Server::Hypnotoad> can be configured with the following settings, see
  L<Mojolicious::Guides::Cookbook/"Hypnotoad"> for examples.
  
  =head2 accepts
  
    accepts => 100
  
  Maximum number of connections a worker is allowed to accept, before stopping
  gracefully and then getting replaced with a newly started worker, defaults to
  the value of L<Mojo::Server::Prefork/"accepts">. Setting the value to C<0> will
  allow workers to accept new connections indefinitely. Note that up to half of
  this value can be subtracted randomly to improve load balancing.
  
  =head2 backlog
  
    backlog => 128
  
  Listen backlog size, defaults to the value of
  L<Mojo::Server::Daemon/"backlog">.
  
  =head2 clients
  
    clients => 100
  
  Maximum number of accepted connections each worker process is allowed to handle
  concurrently, before stopping to accept new incoming connections, defaults to
  the value of L<Mojo::IOLoop/"max_connections">. Note that high concurrency works
  best with applications that perform mostly non-blocking operations, to optimize
  for blocking operations you can decrease this value and increase L</"workers">
  instead for better performance.
  
  =head2 graceful_timeout
  
    graceful_timeout => 15
  
  Maximum amount of time in seconds stopping a worker gracefully may take before
  being forced, defaults to the value of
  L<Mojo::Server::Prefork/"graceful_timeout">.
  
  =head2 heartbeat_interval
  
    heartbeat_interval => 3
  
  Heartbeat interval in seconds, defaults to the value of
  L<Mojo::Server::Prefork/"heartbeat_interval">.
  
  =head2 heartbeat_timeout
  
    heartbeat_timeout => 2
  
  Maximum amount of time in seconds before a worker without a heartbeat will be
  stopped gracefully, defaults to the value of
  L<Mojo::Server::Prefork/"heartbeat_timeout">.
  
  =head2 inactivity_timeout
  
    inactivity_timeout => 10
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of L<Mojo::Server::Daemon/"inactivity_timeout">.
  Setting the value to C<0> will allow connections to be inactive indefinitely.
  
  =head2 listen
  
    listen => ['http://*:80']
  
  Array reference with one or more locations to listen on, defaults to
  C<http://*:8080>. See also L<Mojo::Server::Daemon/"listen"> for more examples.
  
  =head2 pid_file
  
    pid_file => '/var/run/hypnotoad.pid'
  
  Full path to process id file, defaults to C<hypnotoad.pid> in the same
  directory as the application. Note that this value can only be changed after
  the server has been stopped.
  
  =head2 proxy
  
    proxy => 1
  
  Activate reverse proxy support, which allows for the C<X-Forwarded-For> and
  C<X-Forwarded-Proto> headers to be picked up automatically, defaults to the
  value of L<Mojo::Server/"reverse_proxy">.
  
  =head2 requests
  
    requests => 50
  
  Number of keep-alive requests per connection, defaults to the value of
  L<Mojo::Server::Daemon/"max_requests">.
  
  =head2 upgrade_timeout
  
    upgrade_timeout => 45
  
  Maximum amount of time in seconds a zero downtime software upgrade may take
  before getting canceled, defaults to C<60>.
  
  =head2 workers
  
    workers => 10
  
  Number of worker processes, defaults to the value of
  L<Mojo::Server::Prefork/"workers">. A good rule of thumb is two worker
  processes per CPU core for applications that perform mostly non-blocking
  operations, blocking operations often require more and benefit from decreasing
  concurrency with L</"clients"> (often as low as C<1>). Note that during zero
  downtime software upgrades there will be twice as many workers active for a
  short amount of time.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Hypnotoad> implements the following attributes.
  
  =head2 prefork
  
    my $prefork = $hypnotoad->prefork;
    $hypnotoad  = $hypnotoad->prefork(Mojo::Server::Prefork->new);
  
  L<Mojo::Server::Prefork> object this server manages.
  
  =head2 upgrade_timeout
  
    my $timeout = $hypnotoad->upgrade_timeout;
    $hypnotoad  = $hypnotoad->upgrade_timeout(15);
  
  Maximum amount of time in seconds a zero downtime software upgrade may take
  before getting canceled, defaults to C<60>.
  
  =head1 METHODS
  
  L<Mojo::Server::Hypnotoad> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 configure
  
    $hypnotoad->configure('hypnotoad');
  
  Configure server from application settings.
  
  =head2 run
  
    $hypnotoad->run('script/my_app');
  
  Run server for application and wait for L</"MANAGER SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_HYPNOTOAD

$fatpacked{"Mojo/Server/Morbo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO';
  package Mojo::Server::Morbo;
  use Mojo::Base -base;
  
  # "Linda: With Haley's Comet out of ice, Earth is experiencing the devastating
  #         effects of sudden, intense global warming.
  #  Morbo: Morbo is pleased but sticky."
  use Mojo::Server::Daemon;
  use Mojo::Util 'files';
  use POSIX 'WNOHANG';
  
  has daemon => sub { Mojo::Server::Daemon->new };
  has watch  => sub { [qw(lib templates)] };
  
  sub modified_files {
    my $self = shift;
  
    my $cache = $self->{cache} ||= {};
    my @files;
    for my $file (map { -f $_ && -r _ ? $_ : files $_ } @{$self->watch}) {
      my ($size, $mtime) = (stat $file)[7, 9];
      my $stats = $cache->{$file} ||= [$^T, $size];
      next if $mtime <= $stats->[0] && $size == $stats->[1];
      @$stats = ($mtime, $size);
      push @files, $file;
    }
  
    return \@files;
  }
  
  sub run {
    my ($self, $app) = @_;
  
    # Clean manager environment
    local $SIG{INT} = local $SIG{TERM} = sub {
      $self->{finished} = 1;
      kill 'TERM', $self->{worker} if $self->{worker};
    };
    unshift @{$self->watch}, $0 = $app;
    $self->{modified} = 1;
  
    # Prepare and cache listen sockets for smooth restarting
    $self->daemon->start->stop;
  
    $self->_manage until $self->{finished} && !$self->{worker};
    exit 0;
  }
  
  sub _manage {
    my $self = shift;
  
    if (my @files = @{$self->modified_files}) {
      say @files == 1
        ? qq{File "@{[$files[0]]}" changed, restarting.}
        : qq{@{[scalar @files]} files changed, restarting.}
        if $ENV{MORBO_VERBOSE};
      kill 'TERM', $self->{worker} if $self->{worker};
      $self->{modified} = 1;
    }
  
    if (my $pid = $self->{worker}) {
      delete $self->{worker} if waitpid($pid, WNOHANG) == $pid;
    }
  
    $self->_spawn if !$self->{worker} && delete $self->{modified};
    sleep 1;
  }
  
  sub _spawn {
    my $self = shift;
  
    # Manager
    my $manager = $$;
    die "Can't fork: $!" unless defined(my $pid = $self->{worker} = fork);
    return if $pid;
  
    # Worker
    my $daemon = $self->daemon;
    $daemon->load_app($self->watch->[0]);
    $daemon->ioloop->recurring(1 => sub { shift->stop unless kill 0, $manager });
    $daemon->run;
    exit 0;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo - Tonight at 11...DOOOOOOOOOOOOOOOM!
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Morbo;
  
    my $morbo = Mojo::Server::Morbo->new;
    $morbo->run('/home/sri/myapp.pl');
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo> is a full featured, self-restart capable non-blocking
  I/O HTTP and WebSocket server, built around the very well tested and reliable
  L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, Comet (long polling), keep-alive
  and multiple event loop support. Note that the server uses signals for process
  management, so you should avoid modifying signal handlers in your applications.
  
  To start applications with it you can use the L<morbo> script.
  
    $ morbo ./myapp.pl
    Server available at http://127.0.0.1:3000
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NDN>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 SIGNALS
  
  The L<Mojo::Server::Morbo> process can be controlled at runtime with the
  following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo> implements the following attributes.
  
  =head2 daemon
  
    my $daemon = $morbo->daemon;
    $morbo     = $morbo->daemon(Mojo::Server::Daemon->new);
  
  L<Mojo::Server::Daemon> object this server manages.
  
  =head2 watch
  
    my $watch = $morbo->watch;
    $morbo    = $morbo->watch(['/home/sri/my_app']);
  
  Files and directories to watch for changes, defaults to the application script
  as well as the C<lib> and C<templates> directories in the current working
  directory.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 modified_files
  
    my $files = $morbo->modified_files;
  
  Check if files from L</"watch"> have been modified since the last check and
  return an array reference with the results.
  
    # All files that have been modified
    say for @{$morbo->modified_files};
  
  =head2 run
  
    $morbo->run('script/my_app');
  
  Run server for application and wait for L</"SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO

$fatpacked{"Mojo/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PSGI';
  package Mojo::Server::PSGI;
  use Mojo::Base 'Mojo::Server';
  
  sub run {
    my ($self, $env) = @_;
  
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse($env);
    $tx->local_port($env->{SERVER_PORT})->remote_address($env->{REMOTE_ADDR});
  
    # Request body (may block if we try to read too much)
    my $len = $env->{CONTENT_LENGTH};
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = $env->{'psgi.input'}->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
  
    $self->emit(request => $tx);
  
    # Response headers
    my $res  = $tx->res->fix_headers;
    my $hash = $res->headers->to_hash(1);
    my @headers;
    for my $name (keys %$hash) { push @headers, $name, $_ for @{$hash->{$name}} }
  
    # PSGI response
    my $io = Mojo::Server::PSGI::_IO->new(tx => $tx, empty => $tx->is_empty);
    return [$res->code // 404, \@headers, $io];
  }
  
  sub to_psgi_app {
    my $self = shift;
  
    # Preload application and wrap it
    $self->app;
    return sub { $self->run(@_) }
  }
  
  package Mojo::Server::PSGI::_IO;
  use Mojo::Base -base;
  
  # Finish transaction
  sub close { shift->{tx}->closed }
  
  sub getline {
    my $self = shift;
  
    # Empty
    return undef if $self->{empty};
  
    # No content yet, try again later
    my $chunk = $self->{tx}->res->get_body_chunk($self->{offset} //= 0);
    return '' unless defined $chunk;
  
    # End of content
    return undef unless length $chunk;
  
    $self->{offset} += length $chunk;
    return $chunk;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::PSGI - PSGI server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::PSGI;
  
    my $psgi = Mojo::Server::PSGI->new;
    $psgi->unsubscribe('request')->on(request => sub {
      my ($psgi, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    my $app = $psgi->to_psgi_app;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::PSGI> allows L<Mojolicious> applications to run on all L<PSGI>
  compatible servers.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::Server::PSGI> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::PSGI> inherits all attributes from L<Mojo::Server>.
  
  =head1 METHODS
  
  L<Mojo::Server::PSGI> inherits all methods from L<Mojo::Server> and implements
  the following new ones.
  
  =head2 run
  
    my $res = $psgi->run($env);
  
  Run L<PSGI>.
  
  =head2 to_psgi_app
  
    my $app = $psgi->to_psgi_app;
  
  Turn L<Mojo> application into L<PSGI> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_PSGI

$fatpacked{"Mojo/Server/Prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PREFORK';
  package Mojo::Server::Prefork;
  use Mojo::Base 'Mojo::Server::Daemon';
  
  use Config;
  use File::Spec::Functions qw(catfile tmpdir);
  use Mojo::Util 'steady_time';
  use POSIX 'WNOHANG';
  use Scalar::Util 'weaken';
  
  has accepts => 10000;
  has cleanup => 1;
  has [qw(graceful_timeout heartbeat_timeout)] => 20;
  has heartbeat_interval => 5;
  has pid_file           => sub { catfile tmpdir, 'prefork.pid' };
  has workers            => 4;
  
  sub DESTROY {
    my $self = shift;
  
    # Worker
    return unless $self->cleanup;
  
    # Manager
    if (my $file = $self->pid_file) { unlink $file if -w $file }
  }
  
  sub check_pid {
    my $file = shift->pid_file;
    return undef unless open my $handle, '<', $file;
    my $pid = <$handle>;
    chomp $pid;
  
    # Running
    return $pid if $pid && kill 0, $pid;
  
    # Not running
    unlink $file if -w $file;
    return undef;
  }
  
  sub ensure_pid_file {
    my $self = shift;
  
    # Check if PID file already exists
    return if -e (my $file = $self->pid_file);
  
    # Create PID file
    $self->app->log->error(qq{Can't create process id file "$file": $!})
      and die qq{Can't create process id file "$file": $!}
      unless open my $handle, '>', $file;
    $self->app->log->info(qq{Creating process id file "$file"});
    chmod 0644, $handle;
    print $handle $$;
  }
  
  sub healthy {
    scalar grep { $_->{healthy} } values %{shift->{pool}};
  }
  
  sub run {
    my $self = shift;
  
    # No fork emulation support
    say 'Preforking does not support fork emulation.' and exit 0
      if $Config{d_pseudofork};
  
    # Pipe for worker communication
    pipe($self->{reader}, $self->{writer}) or die "Can't create pipe: $!";
  
    # Clean manager environment
    local $SIG{CHLD} = sub {
      while ((my $pid = waitpid -1, WNOHANG) > 0) {
        $self->emit(reap => $pid)->_stopped($pid);
      }
    };
    local $SIG{INT} = local $SIG{TERM} = sub { $self->_term };
    local $SIG{QUIT} = sub { $self->_term(1) };
    local $SIG{TTIN} = sub { $self->workers($self->workers + 1) };
    local $SIG{TTOU} = sub {
      $self->workers > 0 ? $self->workers($self->workers - 1) : return;
      for my $w (values %{$self->{pool}}) {
        ($w->{graceful} = steady_time) and last unless $w->{graceful};
      }
    };
  
    # Preload application before starting workers
    $self->start->app->log->info("Manager $$ started");
    $self->ioloop->max_accepts($self->accepts);
    $self->{running} = 1;
    $self->_manage while $self->{running};
    $self->app->log->info("Manager $$ stopped");
  }
  
  sub _heartbeat { shift->{writer}->syswrite("$$:$_[0]\n") or exit 0 }
  
  sub _manage {
    my $self = shift;
  
    # Spawn more workers if necessary and check PID file
    if (!$self->{finished}) {
      $self->_spawn while keys %{$self->{pool}} < $self->workers;
      $self->ensure_pid_file;
    }
  
    # Shutdown
    elsif (!keys %{$self->{pool}}) { return delete $self->{running} }
  
    # Wait for heartbeats
    $self->_wait;
  
    my $interval = $self->heartbeat_interval;
    my $ht       = $self->heartbeat_timeout;
    my $gt       = $self->graceful_timeout;
    my $log      = $self->app->log;
    my $time     = steady_time;
  
    for my $pid (keys %{$self->{pool}}) {
      next unless my $w = $self->{pool}{$pid};
  
      # No heartbeat (graceful stop)
      $log->error("Worker $pid has no heartbeat, restarting")
        and $w->{graceful} = $time
        if !$w->{graceful} && ($w->{time} + $interval + $ht <= $time);
  
      # Graceful stop with timeout
      my $graceful = $w->{graceful} ||= $self->{graceful} ? $time : undef;
      $log->debug("Stopping worker $pid gracefully")
        and (kill 'QUIT', $pid or $self->_stopped($pid))
        if $graceful && !$w->{quit}++;
      $w->{force} = 1 if $graceful && $graceful + $gt <= $time;
  
      # Normal stop
      $log->debug("Stopping worker $pid")
        and (kill 'KILL', $pid or $self->_stopped($pid))
        if $w->{force} || ($self->{finished} && !$graceful);
    }
  }
  
  sub _spawn {
    my $self = shift;
  
    # Manager
    die "Can't fork: $!" unless defined(my $pid = fork);
    return $self->emit(spawn => $pid)->{pool}{$pid} = {time => steady_time}
      if $pid;
  
    # Heartbeat messages
    my $loop     = $self->cleanup(0)->ioloop;
    my $finished = 0;
    $loop->on(finish => sub { $finished = 1 });
    weaken $self;
    my $cb = sub { $self->_heartbeat($finished) };
    $loop->next_tick($cb);
    $loop->recurring($self->heartbeat_interval => $cb);
  
    # Clean worker environment
    $SIG{$_} = 'DEFAULT' for qw(CHLD INT TERM TTIN TTOU);
    $SIG{QUIT} = sub { $loop->stop_gracefully };
    delete $self->{reader};
    srand;
  
    $self->app->log->debug("Worker $$ started");
    $loop->start;
    exit 0;
  }
  
  sub _stopped {
    my ($self, $pid) = @_;
  
    return unless my $w = delete $self->{pool}{$pid};
  
    my $log = $self->app->log;
    $log->debug("Worker $pid stopped");
    $log->error("Worker $pid stopped too early, shutting down") and $self->_term
      unless $w->{healthy};
  }
  
  sub _term {
    my ($self, $graceful) = @_;
    @{$self->emit(finish => $graceful)}{qw(finished graceful)} = (1, $graceful);
  }
  
  sub _wait {
    my $self = shift;
  
    # Poll for heartbeats
    my $reader = $self->emit('wait')->{reader};
    return unless Mojo::Util::_readable(1000, fileno($reader));
    return unless $reader->sysread(my $chunk, 4194304);
  
    # Update heartbeats (and stop gracefully if necessary)
    my $time = steady_time;
    while ($chunk =~ /(\d+):(\d)\n/g) {
      next unless my $w = $self->{pool}{$1};
      @$w{qw(healthy time)} = (1, $time) and $self->emit(heartbeat => $1);
      $w->{graceful} ||= $time if $2;
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Prefork - Preforking non-blocking I/O HTTP and WebSocket server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Prefork;
  
    my $prefork = Mojo::Server::Prefork->new(listen => ['http://*:8080']);
    $prefork->unsubscribe('request')->on(request => sub {
      my ($prefork, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $prefork->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Prefork> is a full featured, UNIX optimized, preforking
  non-blocking I/O HTTP and WebSocket server, built around the very well tested
  and reliable L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, Comet (long polling),
  keep-alive and multiple event loop support. Note that the server uses signals
  for process management, so you should avoid modifying signal handlers in your
  applications.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.84+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NDN>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 MANAGER SIGNALS
  
  The L<Mojo::Server::Prefork> manager process can be controlled at runtime with
  the following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head2 QUIT
  
  Shut down server gracefully.
  
  =head2 TTIN
  
  Increase worker pool by one.
  
  =head2 TTOU
  
  Decrease worker pool by one.
  
  =head1 WORKER SIGNALS
  
  L<Mojo::Server::Prefork> worker processes can be controlled at runtime with the
  following signals.
  
  =head2 QUIT
  
  Stop worker gracefully.
  
  =head1 EVENTS
  
  L<Mojo::Server::Prefork> inherits all events from L<Mojo::Server::Daemon> and
  can emit the following new ones.
  
  =head2 finish
  
    $prefork->on(finish => sub {
      my ($prefork, $graceful) = @_;
      ...
    });
  
  Emitted when the server shuts down.
  
    $prefork->on(finish => sub {
      my ($prefork, $graceful) = @_;
      say $graceful ? 'Graceful server shutdown' : 'Server shutdown';
    });
  
  =head2 heartbeat
  
    $prefork->on(heartbeat => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a heartbeat message has been received from a worker.
  
    $prefork->on(heartbeat => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid has a heartbeat";
    });
  
  =head2 reap
  
    $prefork->on(reap => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a child process dies.
  
    $prefork->on(reap => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid stopped";
    });
  
  =head2 spawn
  
    $prefork->on(spawn => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a worker process is spawned.
  
    $prefork->on(spawn => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid started";
    });
  
  =head2 wait
  
    $prefork->on(wait => sub {
      my $prefork = shift;
      ...
    });
  
  Emitted when the manager starts waiting for new heartbeat messages.
  
    $prefork->on(wait => sub {
      my $prefork = shift;
      my $workers = $prefork->workers;
      say "Waiting for heartbeat messages from $workers workers";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Prefork> inherits all attributes from L<Mojo::Server::Daemon>
  and implements the following new ones.
  
  =head2 accepts
  
    my $accepts = $prefork->accepts;
    $prefork    = $prefork->accepts(100);
  
  Maximum number of connections a worker is allowed to accept, before stopping
  gracefully and then getting replaced with a newly started worker, passed along
  to L<Mojo::IOLoop/"max_accepts">, defaults to C<10000>. Setting the value to
  C<0> will allow workers to accept new connections indefinitely. Note that up to
  half of this value can be subtracted randomly to improve load balancing.
  
  =head2 cleanup
  
    my $bool = $prefork->cleanup;
    $prefork = $prefork->cleanup($bool);
  
  Delete L</"pid_file"> automatically once it is not needed anymore, defaults to
  a true value.
  
  =head2 graceful_timeout
  
    my $timeout = $prefork->graceful_timeout;
    $prefork    = $prefork->graceful_timeout(15);
  
  Maximum amount of time in seconds stopping a worker gracefully may take before
  being forced, defaults to C<20>.
  
  =head2 heartbeat_interval
  
    my $interval = $prefork->heartbeat_interval;
    $prefork     = $prefork->heartbeat_interval(3);
  
  Heartbeat interval in seconds, defaults to C<5>.
  
  =head2 heartbeat_timeout
  
    my $timeout = $prefork->heartbeat_timeout;
    $prefork    = $prefork->heartbeat_timeout(2);
  
  Maximum amount of time in seconds before a worker without a heartbeat will be
  stopped gracefully, defaults to C<20>.
  
  =head2 pid_file
  
    my $file = $prefork->pid_file;
    $prefork = $prefork->pid_file('/tmp/prefork.pid');
  
  Full path of process id file, defaults to C<prefork.pid> in a temporary
  directory.
  
  =head2 workers
  
    my $workers = $prefork->workers;
    $prefork    = $prefork->workers(10);
  
  Number of worker processes, defaults to C<4>. A good rule of thumb is two
  worker processes per CPU core for applications that perform mostly non-blocking
  operations, blocking operations often require more and benefit from decreasing
  concurrency with L<Mojo::Server::Daemon/"clients"> (often as low as C<1>).
  
  =head1 METHODS
  
  L<Mojo::Server::Prefork> inherits all methods from L<Mojo::Server::Daemon> and
  implements the following new ones.
  
  =head2 check_pid
  
    my $pid = $prefork->check_pid;
  
  Get process id for running server from L</"pid_file"> or delete it if server is
  not running.
  
    say 'Server is not running' unless $prefork->check_pid;
  
  =head2 ensure_pid_file
  
    $prefork->ensure_pid_file;
  
  Ensure L</"pid_file"> exists.
  
  =head2 healthy
  
    my $healthy = $prefork->healthy;
  
  Number of currently active worker processes with a heartbeat.
  
  =head2 run
  
    $prefork->run;
  
  Run server and wait for L</"MANAGER SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_SERVER_PREFORK

$fatpacked{"Mojo/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TEMPLATE';
  package Mojo::Template;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::ByteStream;
  use Mojo::Exception;
  use Mojo::Util qw(decode encode monkey_patch slurp);
  
  use constant DEBUG => $ENV{MOJO_TEMPLATE_DEBUG} || 0;
  
  has [qw(append code prepend unparsed)] => '';
  has [qw(auto_escape compiled vars)];
  has capture_end   => 'end';
  has capture_start => 'begin';
  has comment_mark  => '#';
  has encoding      => 'UTF-8';
  has escape        => sub { \&Mojo::Util::xml_escape };
  has [qw(escape_mark expression_mark trim_mark)] => '=';
  has [qw(line_start replace_mark)] => '%';
  has name      => 'template';
  has namespace => 'Mojo::Template::SandBox';
  has tag_start => '<%';
  has tag_end   => '%>';
  has tree      => sub { [] };
  
  sub parse {
    my ($self, $template) = @_;
  
    # Clean start
    $self->unparsed($template)->tree(\my @tree)->compiled(undef);
  
    my $tag     = $self->tag_start;
    my $replace = $self->replace_mark;
    my $expr    = $self->expression_mark;
    my $escp    = $self->escape_mark;
    my $cpen    = $self->capture_end;
    my $cmnt    = $self->comment_mark;
    my $cpst    = $self->capture_start;
    my $trim    = $self->trim_mark;
    my $end     = $self->tag_end;
    my $start   = $self->line_start;
  
    my $line_re
      = qr/^(\s*)\Q$start\E(?:(\Q$replace\E)|(\Q$cmnt\E)|(\Q$expr\E))?(.*)$/;
    my $token_re = qr/
      (
        \Q$tag\E(?:\Q$replace\E|\Q$cmnt\E)                   # Replace
      |
        \Q$tag$expr\E(?:\Q$escp\E)?(?:\s*\Q$cpen\E(?!\w))?   # Expression
      |
        \Q$tag\E(?:\s*\Q$cpen\E(?!\w))?                      # Code
      |
        (?:(?<!\w)\Q$cpst\E\s*)?(?:\Q$trim\E)?\Q$end\E       # End
      )
    /x;
    my $cpen_re = qr/^\Q$tag\E(?:\Q$expr\E)?(?:\Q$escp\E)?\s*\Q$cpen\E(.*)$/;
    my $end_re  = qr/^(?:(\Q$cpst\E)\s*)?(\Q$trim\E)?\Q$end\E$/;
  
    # Split lines
    my $op = 'text';
    my ($trimming, $capture);
    for my $line (split "\n", $template) {
  
      # Turn Perl line into mixed line
      if ($op eq 'text' && $line =~ $line_re) {
  
        # Escaped start
        if ($2) { $line = "$1$start$5" }
  
        # Comment
        elsif ($3) { $line = "$tag$3 $trim$end" }
  
        # Expression or code
        else { $line = $4 ? "$1$tag$4$5 $end" : "$tag$5 $trim$end" }
      }
  
      # Escaped line ending
      $line .= "\n" if $line !~ s/\\\\$/\\\n/ && $line !~ s/\\$//;
  
      # Mixed line
      for my $token (split $token_re, $line) {
  
        # Capture end
        ($token, $capture) = ("$tag$1", 1) if $token =~ $cpen_re;
  
        # End
        if ($op ne 'text' && $token =~ $end_re) {
  
          # Capture start
          splice @tree, -1, 0, ['cpst'] if $1;
  
          # Trim left side
          _trim(\@tree) if ($trimming = $2) && @tree > 1;
  
          # Hint at end
          push @tree, [$op = 'text', ''];
        }
  
        # Code
        elsif ($token eq $tag) { $op = 'code' }
  
        # Expression
        elsif ($token eq "$tag$expr") { $op = 'expr' }
  
        # Expression that needs to be escaped
        elsif ($token eq "$tag$expr$escp") { $op = 'escp' }
  
        # Comment
        elsif ($token eq "$tag$cmnt") { $op = 'cmnt' }
  
        # Text (comments are just ignored)
        elsif ($op ne 'cmnt') {
  
          # Replace
          $token = $tag if $token eq "$tag$replace";
  
          # Trim right side (convert whitespace to line noise)
          if ($trimming && $token =~ s/^(\s+)//) {
            push @tree, ['code', $1];
            $trimming = 0;
          }
  
          # Token (with optional capture end)
          push @tree, $capture ? ['cpen'] : (), [$op, $token];
          $capture = 0;
        }
      }
  
      # Optimize successive text lines separated by a newline
      push @tree, ['line'] and next
        if $tree[-4] && $tree[-4][0] ne 'line'
        || (!$tree[-3] || $tree[-3][0] ne 'text' || $tree[-3][1] !~ /\n$/)
        || ($tree[-2][0] ne 'line' || $tree[-1][0] ne 'text');
      $tree[-3][1] .= pop(@tree)->[1];
    }
  
    return $self;
  }
  
  sub process {
    my $self = shift;
  
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
      my $code = $self->_compile->code;
      monkey_patch $self->namespace, '_escape', $self->escape;
      return Mojo::Exception->new($@)->inspect($self->unparsed, $code)
        ->trace->verbose(1)
        unless $compiled = eval $self->_wrap($code, @_);
      $self->compiled($compiled);
    }
  
    # Use a real stack trace for normal exceptions
    local $SIG{__DIE__} = sub {
      CORE::die $_[0] if ref $_[0];
      CORE::die Mojo::Exception->new(shift)
        ->trace->inspect($self->unparsed, $self->code)->verbose(1);
    };
  
    my $output;
    return eval { $output = $compiled->(@_); 1 } ? $output : $@;
  }
  
  sub render { shift->parse(shift)->process(@_) }
  
  sub render_file {
    my ($self, $path) = (shift, shift);
  
    $self->name($path) unless defined $self->{name};
    my $template = slurp $path;
    my $encoding = $self->encoding;
    croak qq{Template "$path" has invalid encoding}
      if $encoding && !defined($template = decode $encoding, $template);
  
    return $self->render($template, @_);
  }
  
  sub _compile {
    my $self = shift;
  
    my $tree   = $self->tree;
    my $escape = $self->auto_escape;
  
    my @blocks = ('');
    my ($i, $capture, $multi);
    while (++$i <= @$tree && (my $next = $tree->[$i])) {
      my ($op, $value) = @{$tree->[$i - 1]};
      push @blocks, '' and next if $op eq 'line';
      my $newline = chomp($value //= '');
  
      # Text (quote and fix line ending)
      if ($op eq 'text') {
        $value = join "\n", map { quotemeta $_ } split("\n", $value, -1);
        $value .= '\n' if $newline;
        $blocks[-1] .= "\$_O .= \"" . $value . "\";" if length $value;
      }
  
      # Code or multi-line expression
      elsif ($op eq 'code' || $multi) { $blocks[-1] .= $value }
  
      # Capture end
      elsif ($op eq 'cpen') {
        $blocks[-1] .= 'return Mojo::ByteStream->new($_O) }';
  
        # No following code
        $blocks[-1] .= ';' if ($next->[1] // '') =~ /^\s*$/;
      }
  
      # Expression
      if ($op eq 'expr' || $op eq 'escp') {
  
        # Escaped
        if (!$multi && ($op eq 'escp' && !$escape || $op eq 'expr' && $escape)) {
          $blocks[-1] .= "\$_O .= _escape scalar + $value";
        }
  
        # Raw
        elsif (!$multi) { $blocks[-1] .= "\$_O .= scalar + $value" }
  
        # Multi-line
        $multi = !$next || $next->[0] ne 'text';
  
        # Append semicolon
        $blocks[-1] .= ';' unless $multi || $capture;
      }
  
      # Capture start
      if ($op eq 'cpst') { $capture = 1 }
      elsif ($capture) {
        $blocks[-1] .= "sub { my \$_O = ''; ";
        $capture = 0;
      }
    }
  
    return $self->code(join "\n", @blocks)->tree([]);
  }
  
  sub _line {
    my $name = shift->name;
    $name =~ y/"//d;
    return qq{#line @{[shift]} "$name"};
  }
  
  sub _trim {
    my $tree = shift;
  
    # Skip captures
    my $i = $tree->[-2][0] eq 'cpst' || $tree->[-2][0] eq 'cpen' ? -3 : -2;
  
    # Only trim text
    return unless $tree->[$i][0] eq 'text';
  
    # Convert whitespace text to line noise
    splice @$tree, $i, 0, ['code', $1] if $tree->[$i][1] =~ s/(\s+)$//;
  }
  
  sub _wrap {
    my ($self, $body, $vars) = @_;
  
    # Variables
    my $args = '';
    if ($self->vars && (my @vars = grep {/^\w+$/} keys %$vars)) {
      $args = 'my (' . join(',', map {"\$$_"} @vars) . ')';
      $args .= '= @{shift()}{qw(' . join(' ', @vars) . ')};';
    }
  
    # Wrap lines
    my $num = () = $body =~ /\n/g;
    my $code = $self->_line(1) . "\npackage @{[$self->namespace]};";
    $code .= "use Mojo::Base -strict; no warnings 'ambiguous';";
    $code .= "sub { my \$_O = ''; @{[$self->prepend]};{ $args { $body\n";
    $code .= $self->_line($num + 1) . "\n;}@{[$self->append]}; } \$_O };";
  
    warn "-- Code for @{[$self->name]}\n@{[encode 'UTF-8', $code]}\n\n" if DEBUG;
    return $code;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Template - Perl-ish templates
  
  =head1 SYNOPSIS
  
    use Mojo::Template;
  
    # Use Perl modules
    my $mt = Mojo::Template->new;
    say $mt->render(<<'EOF');
    % use Time::Piece;
    <div>
      % my $now = localtime;
      Time: <%= $now->hms %>
    </div>
    EOF
  
    # Render with arguments
    say $mt->render(<<'EOF', [1 .. 13], 'Hello World!');
    % my ($numbers, $title) = @_;
    <div>
      <h1><%= $title %></h1>
      % for my $i (@$numbers) {
        Test <%= $i %>
      % }
    </div>
    EOF
  
    # Render with named variables
    say $mt->vars(1)->render(<<'EOF', {title => 'Hello World!'});
    <div>
      <h1><%= $title %></h1>
      %= 5 + 5
    </div>
    EOF
  
  =head1 DESCRIPTION
  
  L<Mojo::Template> is a minimalistic, fast, and very Perl-ish template engine,
  designed specifically for all those small tasks that come up during big
  projects. Like preprocessing a configuration file, generating text from heredocs
  and stuff like that.
  
  See L<Mojolicious::Guides::Rendering> for information on how to generate
  content with the L<Mojolicious> renderer.
  
  =head1 SYNTAX
  
  For all templates L<strict>, L<warnings>, L<utf8> and Perl 5.10
  L<features|feature> are automatically enabled.
  
    <% Perl code %>
    <%= Perl expression, replaced with result %>
    <%== Perl expression, replaced with XML escaped result %>
    <%# Comment, useful for debugging %>
    <%% Replaced with "<%", useful for generating templates %>
    % Perl code line, treated as "<% line =%>" (explained later)
    %= Perl expression line, treated as "<%= line %>"
    %== Perl expression line, treated as "<%== line %>"
    %# Comment line, useful for debugging
    %% Replaced with "%", useful for generating templates
  
  Escaping behavior can be reversed with the L</"auto_escape"> attribute, this is
  the default in L<Mojolicious> C<.ep> templates, for example.
  
    <%= Perl expression, replaced with XML escaped result %>
    <%== Perl expression, replaced with result %>
  
  L<Mojo::ByteStream> objects are always excluded from automatic escaping.
  
    % use Mojo::ByteStream 'b';
    <%= b('<div>excluded!</div>') %>
  
  Whitespace characters around tags can be trimmed by adding an additional equal
  sign to the end of a tag.
  
    <% for (1 .. 3) { %>
      <%= 'Trim all whitespace characters around this expression' =%>
    <% } %>
  
  Newline characters can be escaped with a backslash.
  
    This is <%= 1 + 1 %> a\
    single line
  
  And a backslash in front of a newline character can be escaped with another
  backslash.
  
    This will <%= 1 + 1 %> result\\
    in multiple\\
    lines
  
  You can capture whole template blocks for reuse later with the C<begin> and
  C<end> keywords. Just be aware that both keywords are part of the surrounding
  tag and not actual Perl code, so there can only be whitespace after C<begin>
  and before C<end>.
  
    <% my $block = begin %>
      <% my $name = shift; =%>
      Hello <%= $name %>.
    <% end %>
    <%= $block->('Baerbel') %>
    <%= $block->('Wolfgang') %>
  
  Perl lines can also be indented freely.
  
    % my $block = begin
      % my $name = shift;
      Hello <%= $name %>.
    % end
    %= $block->('Baerbel')
    %= $block->('Wolfgang')
  
  L<Mojo::Template> templates get compiled to a Perl subroutine, that means you
  can access arguments simply via C<@_>.
  
    % my ($foo, $bar) = @_;
    % my $x = shift;
    test 123 <%= $foo %>
  
  The compilation of templates to Perl code can make debugging a bit tricky, but
  L<Mojo::Template> will return L<Mojo::Exception> objects that stringify to
  error messages with context.
  
    Bareword "xx" not allowed while "strict subs" in use at template line 4.
    2: </head>
    3: <body>
    4: % my $i = 2; xx
    5: %= $i * 2
    6: </body>
  
  =head1 ATTRIBUTES
  
  L<Mojo::Template> implements the following attributes.
  
  =head2 auto_escape
  
    my $bool = $mt->auto_escape;
    $mt      = $mt->auto_escape($bool);
  
  Activate automatic escaping.
  
    # "&lt;html&gt;"
    Mojo::Template->new(auto_escape => 1)->render("<%= '<html>' %>");
  
  =head2 append
  
    my $code = $mt->append;
    $mt      = $mt->append('warn "Processed template"');
  
  Append Perl code to compiled template. Note that this code should not contain
  newline characters, or line numbers in error messages might end up being wrong.
  
  =head2 capture_end
  
    my $end = $mt->capture_end;
    $mt     = $mt->capture_end('end');
  
  Keyword indicating the end of a capture block, defaults to C<end>.
  
    <% my $block = begin %>
      Some data!
    <% end %>
  
  =head2 capture_start
  
    my $start = $mt->capture_start;
    $mt       = $mt->capture_start('begin');
  
  Keyword indicating the start of a capture block, defaults to C<begin>.
  
    <% my $block = begin %>
      Some data!
    <% end %>
  
  =head2 code
  
    my $code = $mt->code;
    $mt      = $mt->code($code);
  
  Perl code for template if available.
  
  =head2 comment_mark
  
    my $mark = $mt->comment_mark;
    $mt      = $mt->comment_mark('#');
  
  Character indicating the start of a comment, defaults to C<#>.
  
    <%# This is a comment %>
  
  =head2 compiled
  
    my $compiled = $mt->compiled;
    $mt          = $mt->compiled($compiled);
  
  Compiled template code if available.
  
  =head2 encoding
  
    my $encoding = $mt->encoding;
    $mt          = $mt->encoding('UTF-8');
  
  Encoding used for template files, defaults to C<UTF-8>.
  
  =head2 escape
  
    my $cb = $mt->escape;
    $mt    = $mt->escape(sub {...});
  
  A callback used to escape the results of escaped expressions, defaults to
  L<Mojo::Util/"xml_escape">.
  
    $mt->escape(sub {
      my $str = shift;
      return reverse $str;
    });
  
  =head2 escape_mark
  
    my $mark = $mt->escape_mark;
    $mt      = $mt->escape_mark('=');
  
  Character indicating the start of an escaped expression, defaults to C<=>.
  
    <%== $foo %>
  
  =head2 expression_mark
  
    my $mark = $mt->expression_mark;
    $mt      = $mt->expression_mark('=');
  
  Character indicating the start of an expression, defaults to C<=>.
  
    <%= $foo %>
  
  =head2 line_start
  
    my $start = $mt->line_start;
    $mt       = $mt->line_start('%');
  
  Character indicating the start of a code line, defaults to C<%>.
  
    % $foo = 23;
  
  =head2 name
  
    my $name = $mt->name;
    $mt      = $mt->name('foo.mt');
  
  Name of template currently being processed, defaults to C<template>. Note that
  this value should not contain quotes or newline characters, or error messages
  might end up being wrong.
  
  =head2 namespace
  
    my $namespace = $mt->namespace;
    $mt           = $mt->namespace('main');
  
  Namespace used to compile templates, defaults to C<Mojo::Template::SandBox>.
  Note that namespaces should only be shared very carefully between templates,
  since functions and global variables will not be cleared automatically.
  
  =head2 prepend
  
    my $code = $mt->prepend;
    $mt      = $mt->prepend('my $self = shift;');
  
  Prepend Perl code to compiled template. Note that this code should not contain
  newline characters, or line numbers in error messages might end up being wrong.
  
  =head2 replace_mark
  
    my $mark = $mt->replace_mark;
    $mt      = $mt->replace_mark('%');
  
  Character used for escaping the start of a tag or line, defaults to C<%>.
  
    <%% my $foo = 23; %>
  
  =head2 tag_start
  
    my $start = $mt->tag_start;
    $mt       = $mt->tag_start('<%');
  
  Characters indicating the start of a tag, defaults to C<E<lt>%>.
  
    <% $foo = 23; %>
  
  =head2 tag_end
  
    my $end = $mt->tag_end;
    $mt     = $mt->tag_end('%>');
  
  Characters indicating the end of a tag, defaults to C<%E<gt>>.
  
    <%= $foo %>
  
  =head2 tree
  
    my $tree = $mt->tree;
    $mt      = $mt->tree([['text', 'foo'], ['line']]);
  
  Template in parsed form if available. Note that this structure should only be
  used very carefully since it is very dynamic.
  
  =head2 trim_mark
  
    my $mark = $mt->trim_mark;
    $mt      = $mt->trim_mark('-');
  
  Character activating automatic whitespace trimming, defaults to C<=>.
  
    <%= $foo =%>
  
  =head2 unparsed
  
    my $unparsed = $mt->unparsed;
    $mt          = $mt->unparsed('<%= 1 + 1 %>');
  
  Raw unparsed template if available.
  
  =head2 vars
  
    my $bool = $mt->vars;
    $mt      = $mt->vars($bool);
  
  Instead of a list of values, use a hash reference with named variables to pass
  data to templates.
  
    # "works!"
    Mojo::Template->new(vars => 1)->render('<%= $test %>!', {test => 'works'});
  
  =head1 METHODS
  
  L<Mojo::Template> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    $mt = $mt->parse('<%= 1 + 1 %>');
  
  Parse template into L</"tree">.
  
  =head2 process
  
    my $output = $mt->process;
    my $output = $mt->process(@args);
    my $output = $mt->process({foo => 'bar'});
  
  Process previously parsed template and return the result, or a
  L<Mojo::Exception> object if rendering failed.
  
    # Parse and process
    say Mojo::Template->new->parse('Hello <%= $_[0] %>')->process('Bender');
  
    # Reuse template (for much better performance)
    my $mt = Mojo::Template->new;
    say $mt->render('Hello <%= $_[0] %>!', 'Bender');
    say $mt->process('Fry');
    say $mt->process('Leela');
  
  =head2 render
  
    my $output = $mt->render('<%= 1 + 1 %>');
    my $output = $mt->render('<%= shift() + shift() %>', @args);
    my $output = $mt->render('<%= $foo %>', {foo => 'bar'});
  
  Render template and return the result, or a L<Mojo::Exception> object if
  rendering failed.
  
    # Longer version
    my $output = $mt->parse('<%= 1 + 1 %>')->process;
  
    # Render with arguments
    say Mojo::Template->new->render('<%= $_[0] %>', 'bar');
  
    # Render with named variables
    say Mojo::Template->new(vars => 1)->render('<%= $foo %>', {foo => 'bar'});
  
  =head2 render_file
  
    my $output = $mt->render_file('/tmp/foo.mt');
    my $output = $mt->render_file('/tmp/foo.mt', @args);
    my $output = $mt->render_file('/tmp/bar.mt', {foo => 'bar'});
  
  Same as L</"render">, but renders a template file.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_TEMPLATE_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_TEMPLATE_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_TEMPLATE

$fatpacked{"Mojo/Transaction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION';
  package Mojo::Transaction;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::Message::Request;
  use Mojo::Message::Response;
  
  has [
    qw(kept_alive local_address local_port original_remote_address remote_port)];
  has req => sub { Mojo::Message::Request->new };
  has res => sub { Mojo::Message::Response->new };
  
  sub client_read  { croak 'Method "client_read" not implemented by subclass' }
  sub client_write { croak 'Method "client_write" not implemented by subclass' }
  
  sub closed { shift->completed->emit('finish') }
  
  sub completed { ++$_[0]{completed} and return $_[0] }
  
  sub connection {
    my $self = shift;
    return $self->emit(connection => $self->{connection} = shift) if @_;
    return $self->{connection};
  }
  
  sub error { $_[0]->req->error || $_[0]->res->error }
  
  sub is_finished { !!shift->{completed} }
  
  sub is_websocket {undef}
  
  sub remote_address {
    my $self = shift;
  
    return $self->original_remote_address(@_) if @_;
    return $self->original_remote_address unless $self->req->reverse_proxy;
  
    # Reverse proxy
    return ($self->req->headers->header('X-Forwarded-For') // '') =~ /([^,\s]+)$/
      ? $1
      : $self->original_remote_address;
  }
  
  sub server_read  { croak 'Method "server_read" not implemented by subclass' }
  sub server_write { croak 'Method "server_write" not implemented by subclass' }
  
  sub success { $_[0]->error ? undef : $_[0]->res }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction - Transaction base class
  
  =head1 SYNOPSIS
  
    package Mojo::Transaction::MyTransaction;
    use Mojo::Base 'Mojo::Transaction';
  
    sub client_read  {...}
    sub client_write {...}
    sub server_read  {...}
    sub server_write {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction> is an abstract base class for transactions, like
  L<Mojo::Transaction::HTTP> and L<Mojo::Transaction::WebSocket>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 connection
  
    $tx->on(connection => sub {
      my ($tx, $connection) = @_;
      ...
    });
  
  Emitted when a connection has been assigned to transaction.
  
  =head2 finish
  
    $tx->on(finish => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is finished.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction> implements the following attributes.
  
  =head2 kept_alive
  
    my $bool = $tx->kept_alive;
    $tx      = $tx->kept_alive($bool);
  
  Connection has been kept alive.
  
  =head2 local_address
  
    my $address = $tx->local_address;
    $tx         = $tx->local_address('127.0.0.1');
  
  Local interface address.
  
  =head2 local_port
  
    my $port = $tx->local_port;
    $tx      = $tx->local_port(8080);
  
  Local interface port.
  
  =head2 original_remote_address
  
    my $address = $tx->original_remote_address;
    $tx         = $tx->original_remote_address('127.0.0.1');
  
  Remote interface address.
  
  =head2 remote_port
  
    my $port = $tx->remote_port;
    $tx      = $tx->remote_port(8081);
  
  Remote interface port.
  
  =head2 req
  
    my $req = $tx->req;
    $tx     = $tx->req(Mojo::Message::Request->new);
  
  HTTP request, defaults to a L<Mojo::Message::Request> object.
  
  =head2 res
  
    my $res = $tx->res;
    $tx     = $tx->res(Mojo::Message::Response->new);
  
  HTTP response, defaults to a L<Mojo::Message::Response> object.
  
  =head1 METHODS
  
  L<Mojo::Transaction> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 client_read
  
    $tx->client_read($bytes);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  Meant to be overloaded in a subclass.
  
  =head2 client_write
  
    my $bytes = $tx->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>. Meant to be overloaded in a subclass.
  
  =head2 closed
  
    $tx = $tx->closed;
  
  Same as L</"completed">, but also indicates that all transaction data has been
  sent.
  
  =head2 completed
  
    $tx = $tx->completed;
  
  Low-level method to finalize transaction.
  
  =head2 connection
  
    my $id = $tx->connection;
    $tx    = $tx->connection($id);
  
  Connection identifier.
  
  =head2 error
  
    my $err = $tx->error;
  
  Get request or response error and return C<undef> if there is no error,
  commonly used together with L</"success">.
  
    # Longer version
    my $err = $tx->req->error || $tx->res->error;
  
    # Check for different kinds of errors
    if (my $err = $tx->error) {
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
  =head2 is_finished
  
    my $bool = $tx->is_finished;
  
  Check if transaction is finished.
  
  =head2 is_websocket
  
    my $bool = $tx->is_websocket;
  
  False, this is not a L<Mojo::Transaction::WebSocket> object.
  
  =head2 remote_address
  
    my $address = $tx->remote_address;
    $tx         = $tx->remote_address('127.0.0.1');
  
  Same as L</"original_remote_address"> or the last value of the
  C<X-Forwarded-For> header if L</"req"> has been performed through a reverse
  proxy.
  
  =head2 server_read
  
    $tx->server_read($bytes);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>. Meant to be overloaded in a subclass.
  
  =head2 server_write
  
    my $bytes = $tx->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>. Meant to be overloaded in a subclass.
  
  =head2 success
  
    my $res = $tx->success;
  
  Returns the L<Mojo::Message::Response> object from L</"res"> if transaction was
  successful or C<undef> otherwise. Connection and parser errors have only a
  message in L</"error">, C<400> and C<500> responses also a code.
  
    # Sensible exception handling
    if (my $res = $tx->success) { say $res->body }
    else {
      my $err = $tx->error;
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION

$fatpacked{"Mojo/Transaction/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_HTTP';
  package Mojo::Transaction::HTTP;
  use Mojo::Base 'Mojo::Transaction';
  
  has 'previous';
  
  sub client_read {
    my ($self, $chunk) = @_;
  
    # Skip body for HEAD request
    my $res = $self->res;
    $res->content->skip_body(1) if uc $self->req->method eq 'HEAD';
    return unless $res->parse($chunk)->is_finished;
  
    # Unexpected 1xx response
    return $self->completed
      if !$res->is_status_class(100) || $res->headers->upgrade;
    $self->res($res->new)->emit(unexpected => $res);
    return unless length(my $leftovers = $res->content->leftovers);
    $self->client_read($leftovers);
  }
  
  sub client_write { shift->_write(0) }
  
  sub is_empty { !!(uc $_[0]->req->method eq 'HEAD' || $_[0]->res->is_empty) }
  
  sub keep_alive {
    my $self = shift;
  
    # Close
    my $req      = $self->req;
    my $res      = $self->res;
    my $req_conn = lc($req->headers->connection // '');
    my $res_conn = lc($res->headers->connection // '');
    return undef if $req_conn eq 'close' || $res_conn eq 'close';
  
    # Keep-alive is optional for 1.0
    return $res_conn eq 'keep-alive' if $res->version eq '1.0';
    return $req_conn eq 'keep-alive' if $req->version eq '1.0';
  
    # Keep-alive is the default for 1.1
    return 1;
  }
  
  sub redirects {
    my $previous = shift;
    my @redirects;
    unshift @redirects, $previous while $previous = $previous->previous;
    return \@redirects;
  }
  
  sub resume { ++$_[0]{writing} and return $_[0]->emit('resume') }
  
  sub server_read {
    my ($self, $chunk) = @_;
  
    # Parse request
    my $req = $self->req;
    $req->parse($chunk) unless $req->error;
  
    # Generate response
    $self->emit('request') if $req->is_finished && !$self->{handled}++;
  }
  
  sub server_write { shift->_write(1) }
  
  sub _body {
    my ($self, $msg, $finish) = @_;
  
    # Prepare body chunk
    my $buffer = $msg->get_body_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} = $msg->content->is_dynamic ? 1 : ($self->{write} - $written);
    $self->{offset} += $written;
  
    # Delayed
    $self->{writing} = 0 unless defined $buffer;
  
    # Finished
    $finish ? $self->completed : ($self->{writing} = 0)
      if $self->{write} <= 0 || defined $buffer && !length $buffer;
  
    return $buffer // '';
  }
  
  sub _headers {
    my ($self, $msg, $head) = @_;
  
    # Prepare header chunk
    my $buffer = $msg->get_header_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} -= $written;
    $self->{offset} += $written;
  
    # Switch to body
    if ($self->{write} <= 0) {
      $self->{offset} = 0;
  
      # Response without body
      if ($head && $self->is_empty) { $self->completed }
  
      # Body
      else {
        $self->{http_state} = 'body';
        $self->{write} = $msg->content->is_dynamic ? 1 : $msg->body_size;
      }
    }
  
    return $buffer;
  }
  
  sub _start_line {
    my ($self, $msg) = @_;
  
    # Prepare start-line chunk
    my $buffer = $msg->get_start_line_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} -= $written;
    $self->{offset} += $written;
  
    # Switch to headers
    @$self{qw(http_state write offset)} = ('headers', $msg->header_size, 0)
      if $self->{write} <= 0;
  
    return $buffer;
  }
  
  sub _write {
    my ($self, $server) = @_;
  
    # Client starts writing right away
    return '' unless $server ? $self->{writing} : ($self->{writing} //= 1);
  
    # Nothing written yet
    $self->{$_} ||= 0 for qw(offset write);
    my $msg = $server ? $self->res : $self->req;
    @$self{qw(http_state write)} = ('start_line', $msg->start_line_size)
      unless $self->{http_state};
  
    # Start-line
    my $chunk = '';
    $chunk .= $self->_start_line($msg) if $self->{http_state} eq 'start_line';
  
    # Headers
    $chunk .= $self->_headers($msg, $server) if $self->{http_state} eq 'headers';
  
    # Body
    $chunk .= $self->_body($msg, $server) if $self->{http_state} eq 'body';
  
    return $chunk;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction::HTTP - HTTP transaction
  
  =head1 SYNOPSIS
  
    use Mojo::Transaction::HTTP;
  
    # Client
    my $tx = Mojo::Transaction::HTTP->new;
    $tx->req->method('GET');
    $tx->req->url->parse('http://example.com');
    $tx->req->headers->accept('application/json');
    say $tx->res->code;
    say $tx->res->headers->content_type;
    say $tx->res->body;
    say $tx->remote_address;
  
    # Server
    my $tx = Mojo::Transaction::HTTP->new;
    say $tx->req->method;
    say $tx->req->url->to_abs;
    say $tx->req->headers->accept;
    say $tx->remote_address;
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body('Hello World!');
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction::HTTP> is a container for HTTP transactions, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction::HTTP> inherits all events from L<Mojo::Transaction> and
  can emit the following new ones.
  
  =head2 request
  
    $tx->on(request => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $tx->on(request => sub {
      my $tx = shift;
      $tx->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    });
  
  =head2 resume
  
    $tx->on(resume => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is resumed.
  
  =head2 unexpected
  
    $tx->on(unexpected => sub {
      my ($tx, $res) = @_;
      ...
    });
  
  Emitted for unexpected C<1xx> responses that will be ignored.
  
    $tx->on(unexpected => sub {
      my $tx = shift;
      $tx->res->on(finish => sub { say 'Follow-up response is finished.' });
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction::HTTP> inherits all attributes from L<Mojo::Transaction>
  and implements the following new ones.
  
  =head2 previous
  
    my $previous = $tx->previous;
    $tx          = $tx->previous(Mojo::Transaction::HTTP->new);
  
  Previous transaction that triggered this follow-up transaction, usually a
  L<Mojo::Transaction::HTTP> object.
  
    # Paths of previous requests
    say $tx->previous->previous->req->url->path;
    say $tx->previous->req->url->path;
  
  =head1 METHODS
  
  L<Mojo::Transaction::HTTP> inherits all methods from L<Mojo::Transaction> and
  implements the following new ones.
  
  =head2 client_read
  
    $tx->client_read($bytes);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  
  =head2 client_write
  
    my $bytes = $tx->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>.
  
  =head2 is_empty
  
    my $bool = $tx->is_empty;
  
  Check transaction for C<HEAD> request and C<1xx>, C<204> or C<304> response.
  
  =head2 keep_alive
  
    my $bool = $tx->keep_alive;
  
  Check if connection can be kept alive.
  
  =head2 redirects
  
    my $redirects = $tx->redirects;
  
  Return an array reference with all previous transactions that preceded this
  follow-up transaction.
  
    # Paths of all previous requests
    say $_->req->url->path for @{$tx->redirects};
  
  =head2 resume
  
    $tx = $tx->resume;
  
  Resume transaction.
  
  =head2 server_read
  
    $tx->server_read($bytes);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 server_write
  
    my $bytes = $tx->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION_HTTP

$fatpacked{"Mojo/Transaction/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_WEBSOCKET';
  package Mojo::Transaction::WebSocket;
  use Mojo::Base 'Mojo::Transaction';
  
  use Compress::Raw::Zlib 'Z_SYNC_FLUSH';
  use List::Util 'first';
  use Mojo::JSON qw(encode_json j);
  use Mojo::Util qw(decode encode trim);
  use Mojo::WebSocket
    qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT);
  
  has [qw(compressed established handshake masked)];
  has max_websocket_size => sub { $ENV{MOJO_MAX_WEBSOCKET_SIZE} || 262144 };
  
  sub build_message {
    my ($self, $frame) = @_;
  
    # Text
    $frame = {text => encode('UTF-8', $frame)} if ref $frame ne 'HASH';
  
    # JSON
    $frame->{text} = encode_json($frame->{json}) if exists $frame->{json};
  
    # Raw text or binary
    if (exists $frame->{text}) { $frame = [1, 0, 0, 0, WS_TEXT, $frame->{text}] }
    else { $frame = [1, 0, 0, 0, WS_BINARY, $frame->{binary}] }
  
    # "permessage-deflate" extension
    return $frame unless $self->compressed;
    my $deflate = $self->{deflate} ||= Compress::Raw::Zlib::Deflate->new(
      AppendOutput => 1,
      MemLevel     => 8,
      WindowBits   => -15
    );
    $deflate->deflate($frame->[5], my $out);
    $deflate->flush($out, Z_SYNC_FLUSH);
    @$frame[1, 5] = (1, substr($out, 0, length($out) - 4));
  
    return $frame;
  }
  
  sub client_read  { shift->server_read(@_) }
  sub client_write { shift->server_write(@_) }
  
  sub closed {
    my $self = shift->completed;
    return $self->emit(finish => $self->{close} ? (@{$self->{close}}) : 1006);
  }
  
  sub connection { shift->handshake->connection }
  
  sub finish {
    my $self = shift;
  
    my $close = $self->{close} = [@_];
    my $payload = $close->[0] ? pack('n', $close->[0]) : '';
    $payload .= encode 'UTF-8', $close->[1] if defined $close->[1];
    $close->[0] //= 1005;
    $self->send([1, 0, 0, 0, WS_CLOSE, $payload])->{closing} = 1;
  
    return $self;
  }
  
  sub is_websocket {1}
  
  sub kept_alive    { shift->handshake->kept_alive }
  sub local_address { shift->handshake->local_address }
  sub local_port    { shift->handshake->local_port }
  
  sub parse_message {
    my ($self, $frame) = @_;
  
    $self->emit(frame => $frame);
  
    # Ping/Pong
    my $op = $frame->[4];
    return $self->send([1, 0, 0, 0, WS_PONG, $frame->[5]]) if $op == WS_PING;
    return if $op == WS_PONG;
  
    # Close
    if ($op == WS_CLOSE) {
      return $self->finish unless length $frame->[5] >= 2;
      return $self->finish(unpack('n', substr($frame->[5], 0, 2, '')),
        decode('UTF-8', $frame->[5]));
    }
  
    # Append chunk and check message size
    $self->{op} = $op unless exists $self->{op};
    $self->{message} .= $frame->[5];
    my $max = $self->max_websocket_size;
    return $self->finish(1009) if length $self->{message} > $max;
  
    # No FIN bit (Continuation)
    return unless $frame->[0];
  
    # "permessage-deflate" extension (handshake and RSV1)
    my $msg = delete $self->{message};
    if ($self->compressed && $frame->[1]) {
      my $inflate = $self->{inflate} ||= Compress::Raw::Zlib::Inflate->new(
        Bufsize     => $max,
        LimitOutput => 1,
        WindowBits  => -15
      );
      $inflate->inflate(($msg .= "\x00\x00\xff\xff"), my $out);
      return $self->finish(1009) if length $msg;
      $msg = $out;
    }
  
    $self->emit(json => j($msg)) if $self->has_subscribers('json');
    $op = delete $self->{op};
    $self->emit($op == WS_TEXT ? 'text' : 'binary' => $msg);
    $self->emit(message => $op == WS_TEXT ? decode 'UTF-8', $msg : $msg)
      if $self->has_subscribers('message');
  }
  
  sub protocol { shift->res->headers->sec_websocket_protocol }
  
  sub remote_address { shift->handshake->remote_address }
  sub remote_port    { shift->handshake->remote_port }
  sub req            { shift->handshake->req }
  sub res            { shift->handshake->res }
  
  sub resume { $_[0]->handshake->resume and return $_[0] }
  
  sub send {
    my ($self, $msg, $cb) = @_;
    $self->once(drain => $cb) if $cb;
    $msg = $self->build_message($msg) unless ref $msg eq 'ARRAY';
    $self->{write} .= Mojo::WebSocket::build_frame($self->masked, @$msg);
    return $self->emit('resume');
  }
  
  sub server_read {
    my ($self, $chunk) = @_;
  
    $self->{read} .= $chunk;
    my $max = $self->max_websocket_size;
    while (my $frame = Mojo::WebSocket::parse_frame(\$self->{read}, $max)) {
      $self->finish(1009) and last unless ref $frame;
      $self->parse_message($frame);
    }
  
    $self->emit('resume');
  }
  
  sub server_write {
    my $self = shift;
    $self->emit('drain') unless length($self->{write} //= '');
    $self->completed if !length $self->{write} && $self->{closing};
    return delete $self->{write};
  }
  
  sub with_compression {
    my $self = shift;
  
    # "permessage-deflate" extension
    $self->compressed(1)
      and $self->res->headers->sec_websocket_extensions('permessage-deflate')
      if ($self->req->headers->sec_websocket_extensions // '')
      =~ /permessage-deflate/;
  }
  
  sub with_protocols {
    my $self = shift;
  
    my %protos = map { trim($_) => 1 } split ',',
      $self->req->headers->sec_websocket_protocol // '';
    return undef unless defined(my $proto = first { $protos{$_} } @_);
  
    $self->res->headers->sec_websocket_protocol($proto);
    return $proto;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction::WebSocket - WebSocket transaction
  
  =head1 SYNOPSIS
  
    use Mojo::Transaction::WebSocket;
  
    # Send and receive WebSocket messages
    my $ws = Mojo::Transaction::WebSocket->new;
    $ws->send('Hello World!');
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
    $ws->on(finish => sub {
      my ($ws, $code, $reason) = @_;
      say "WebSocket closed with status $code.";
    });
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction::WebSocket> is a container for WebSocket transactions, based
  on L<RFC 6455|http://tools.ietf.org/html/rfc6455> and
  L<RFC 7692|http://tools.ietf.org/html/rfc7692>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction::WebSocket> inherits all events from L<Mojo::Transaction>
  and can emit the following new ones.
  
  =head2 binary
  
    $ws->on(binary => sub {
      my ($ws, $bytes) = @_;
      ...
    });
  
  Emitted when a complete WebSocket binary message has been received.
  
    $ws->on(binary => sub {
      my ($ws, $bytes) = @_;
      say "Binary: $bytes";
    });
  
  =head2 drain
  
    $ws->on(drain => sub {
      my $ws = shift;
      ...
    });
  
  Emitted once all data has been sent.
  
    $ws->on(drain => sub {
      my $ws = shift;
      $ws->send(time);
    });
  
  =head2 finish
  
    $ws->on(finish => sub {
      my ($ws, $code, $reason) = @_;
      ...
    });
  
  Emitted when the WebSocket connection has been closed.
  
  =head2 frame
  
    $ws->on(frame => sub {
      my ($ws, $frame) = @_;
      ...
    });
  
  Emitted when a WebSocket frame has been received.
  
    $ws->on(frame => sub {
      my ($ws, $frame) = @_;
      say "FIN: $frame->[0]";
      say "RSV1: $frame->[1]";
      say "RSV2: $frame->[2]";
      say "RSV3: $frame->[3]";
      say "Opcode: $frame->[4]";
      say "Payload: $frame->[5]";
    });
  
  =head2 json
  
    $ws->on(json => sub {
      my ($ws, $json) = @_;
      ...
    });
  
  Emitted when a complete WebSocket message has been received, all text and
  binary messages will be automatically JSON decoded. Note that this event only
  gets emitted when it has at least one subscriber.
  
    $ws->on(json => sub {
      my ($ws, $hash) = @_;
      say "Message: $hash->{msg}";
    });
  
  =head2 message
  
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      ...
    });
  
  Emitted when a complete WebSocket message has been received, text messages will
  be automatically decoded. Note that this event only gets emitted when it has at
  least one subscriber.
  
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
  
  =head2 resume
  
    $tx->on(resume => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is resumed.
  
  =head2 text
  
    $ws->on(text => sub {
      my ($ws, $bytes) = @_;
      ...
    });
  
  Emitted when a complete WebSocket text message has been received.
  
    $ws->on(text => sub {
      my ($ws, $bytes) = @_;
      say "Text: $bytes";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction::WebSocket> inherits all attributes from
  L<Mojo::Transaction> and implements the following new ones.
  
  =head2 compressed
  
    my $bool = $ws->compressed;
    $ws      = $ws->compressed($bool);
  
  Compress messages with C<permessage-deflate> extension.
  
  =head2 established
  
    my $bool = $ws->established;
    $ws      = $ws->established($bool);
  
  WebSocket connection established.
  
  =head2 handshake
  
    my $handshake = $ws->handshake;
    $ws           = $ws->handshake(Mojo::Transaction::HTTP->new);
  
  The original handshake transaction, usually a L<Mojo::Transaction::HTTP> object.
  
  =head2 masked
  
    my $bool = $ws->masked;
    $ws      = $ws->masked($bool);
  
  Mask outgoing frames with XOR cipher and a random 32-bit key.
  
  =head2 max_websocket_size
  
    my $size = $ws->max_websocket_size;
    $ws      = $ws->max_websocket_size(1024);
  
  Maximum WebSocket message size in bytes, defaults to the value of the
  C<MOJO_MAX_WEBSOCKET_SIZE> environment variable or C<262144> (256KB).
  
  =head1 METHODS
  
  L<Mojo::Transaction::WebSocket> inherits all methods from L<Mojo::Transaction>
  and implements the following new ones.
  
  =head2 build_message
  
    my $frame = $ws->build_message({binary => $bytes});
    my $frame = $ws->build_message({text   => $bytes});
    my $frame = $ws->build_message({json   => {test => [1, 2, 3]}});
    my $frame = $ws->build_message($chars);
  
  Build WebSocket message.
  
  =head2 client_read
  
    $ws->client_read($data);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  
  =head2 client_write
  
    my $bytes = $ws->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>.
  
  =head2 closed
  
    $tx = $tx->closed;
  
  Same as L<Mojo::Transaction/"completed">, but also indicates that all
  transaction data has been sent.
  
  =head2 connection
  
    my $id = $ws->connection;
  
  Connection identifier.
  
  =head2 finish
  
    $ws = $ws->finish;
    $ws = $ws->finish(1000);
    $ws = $ws->finish(1003 => 'Cannot accept data!');
  
  Close WebSocket connection gracefully.
  
  =head2 is_websocket
  
    my $bool = $ws->is_websocket;
  
  True, this is a L<Mojo::Transaction::WebSocket> object.
  
  =head2 kept_alive
  
    my $bool = $ws->kept_alive;
  
  Connection has been kept alive.
  
  =head2 local_address
  
    my $address = $ws->local_address;
  
  Local interface address.
  
  =head2 local_port
  
    my $port = $ws->local_port;
  
  Local interface port.
  
  =head2 parse_message
  
    $ws->parse_message([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
  
  Parse WebSocket message.
  
  =head2 protocol
  
    my $proto = $ws->protocol;
  
  Return negotiated subprotocol or C<undef>.
  
  =head2 remote_address
  
    my $address = $ws->remote_address;
  
  Remote interface address.
  
  =head2 remote_port
  
    my $port = $ws->remote_port;
  
  Remote interface port.
  
  =head2 req
  
    my $req = $ws->req;
  
  Handshake request, usually a L<Mojo::Message::Request> object.
  
  =head2 res
  
    my $res = $ws->res;
  
  Handshake response, usually a L<Mojo::Message::Response> object.
  
  =head2 resume
  
    $ws = $ws->resume;
  
  Resume L</"handshake"> transaction.
  
  =head2 send
  
    $ws = $ws->send({binary => $bytes});
    $ws = $ws->send({text   => $bytes});
    $ws = $ws->send({json   => {test => [1, 2, 3]}});
    $ws = $ws->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $ws = $ws->send($chars);
    $ws = $ws->send($chars => sub {...});
  
  Send message or frame non-blocking via WebSocket, the optional drain callback
  will be executed once all data has been written.
  
    # Send "Ping" frame
    use Mojo::WebSocket 'WS_PING';
    $ws->send([1, 0, 0, 0, WS_PING, 'Hello World!']);
  
  =head2 server_read
  
    $ws->server_read($data);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 server_write
  
    my $bytes = $ws->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 with_compression
  
    $ws->with_compression;
  
  Negotiate C<permessage-deflate> extension for this WebSocket connection.
  
  =head2 with_protocols
  
    my $proto = $ws->with_protocols('v2.proto', 'v1.proto');
  
  Negotiate subprotocol for this WebSocket connection.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION_WEBSOCKET

$fatpacked{"Mojo/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_URL';
  package Mojo::URL;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Mojo::Parameters;
  use Mojo::Path;
  use Mojo::Util
    qw(decode encode punycode_decode punycode_encode url_escape url_unescape);
  
  has base => sub { Mojo::URL->new };
  has [qw(fragment host port scheme userinfo)];
  
  sub authority {
    my $self = shift;
  
    # New authority
    if (@_) {
      return $self unless defined(my $authority = shift);
  
      # Userinfo
      $self->userinfo(_decode(url_unescape $1)) if $authority =~ s/^([^\@]+)\@//;
  
      # Port
      $self->port($1) if $authority =~ s/:(\d+)$//;
  
      # Host
      my $host = url_unescape $authority;
      return $host =~ /[^\x00-\x7f]/ ? $self->ihost($host) : $self->host($host);
    }
  
    # Build authority
    return undef      unless defined(my $authority = $self->host_port);
    return $authority unless defined(my $info      = $self->userinfo);
    return _encode($info, '^A-Za-z0-9\-._~!$&\'()*+,;=:') . '@' . $authority;
  }
  
  sub clone {
    my $self  = shift;
    my $clone = $self->new;
    @$clone{keys %$self} = values %$self;
    $clone->{$_} && ($clone->{$_} = $clone->{$_}->clone) for qw(base path query);
    return $clone;
  }
  
  sub host_port {
    my $self = shift;
    return undef unless defined(my $host = $self->ihost);
    return $host unless my $port = $self->port;
    return "$host:$port";
  }
  
  sub ihost {
    my $self = shift;
  
    # Decode
    return $self->host(join '.',
      map { /^xn--(.+)$/ ? punycode_decode $1 : $_ } split(/\./, shift, -1))
      if @_;
  
    # Check if host needs to be encoded
    return undef unless defined(my $host = $self->host);
    return lc $host unless $host =~ /[^\x00-\x7f]/;
  
    # Encode
    return lc join '.',
      map { /[^\x00-\x7f]/ ? ('xn--' . punycode_encode $_) : $_ }
      split(/\./, $host, -1);
  }
  
  sub is_abs { !!shift->scheme }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my ($self, $url) = @_;
  
    # Official regex from RFC 3986
    $url =~ m!^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?!;
    $self->scheme($2)                         if defined $2;
    $self->authority($4)                      if defined $4;
    $self->path($5)                           if defined $5;
    $self->query($7)                          if defined $7;
    $self->fragment(_decode(url_unescape $9)) if defined $9;
  
    return $self;
  }
  
  sub password { (shift->userinfo // '') =~ /:(.*)$/ ? $1 : undef }
  
  sub path {
    my $self = shift;
  
    # Old path
    $self->{path} ||= Mojo::Path->new;
    return $self->{path} unless @_;
  
    # New path
    $self->{path} = ref $_[0] ? $_[0] : $self->{path}->merge($_[0]);
  
    return $self;
  }
  
  sub path_query {
    my $self  = shift;
    my $query = $self->query->to_string;
    return $self->path->to_string . (length $query ? "?$query" : '');
  }
  
  sub protocol { lc(shift->scheme // '') }
  
  sub query {
    my $self = shift;
  
    # Old parameters
    my $q = $self->{query} ||= Mojo::Parameters->new;
    return $q unless @_;
  
    # Replace with list
    if (@_ > 1) { $q->pairs([])->parse(@_) }
  
    # Merge with array
    elsif (ref $_[0] eq 'ARRAY') { $q->merge(@{$_[0]}) }
  
    # Append hash
    elsif (ref $_[0] eq 'HASH') { $q->append(%{$_[0]}) }
  
    # New parameters
    else { $self->{query} = ref $_[0] ? $_[0] : $q->parse($_[0]) }
  
    return $self;
  }
  
  sub to_abs {
    my $self = shift;
  
    my $abs = $self->clone;
    return $abs if $abs->is_abs;
  
    # Scheme
    my $base = shift || $abs->base;
    $abs->base($base)->scheme($base->scheme);
  
    # Authority
    return $abs if $abs->authority;
    $abs->authority($base->authority);
  
    # Absolute path
    my $path = $abs->path;
    return $abs if $path->leading_slash;
  
    # Inherit path
    my $base_path = $base->path;
    if (!@{$path->parts}) {
      $path
        = $abs->path($base_path->clone)->path->trailing_slash(0)->canonicalize;
  
      # Query
      return $abs if length $abs->query->to_string;
      $abs->query($base->query->clone);
    }
  
    # Merge paths
    else { $abs->path($base_path->clone->merge($path)->canonicalize) }
  
    return $abs;
  }
  
  sub to_string {
    my $self = shift;
  
    # Scheme
    my $url = '';
    if (my $proto = $self->protocol) { $url .= "$proto:" }
  
    # Authority
    my $authority = $self->authority;
    $url .= "//$authority" if defined $authority;
  
    # Path and query
    my $path = $self->path_query;
    $url .= !$authority || !length $path || $path =~ m!^[/?]! ? $path : "/$path";
  
    # Fragment
    return $url unless defined(my $fragment = $self->fragment);
    return $url . '#' . _encode($fragment, '^A-Za-z0-9\-._~!$&\'()*+,;=%:@/?');
  }
  
  sub username { (shift->userinfo // '') =~ /^([^:]+)/ ? $1 : undef }
  
  sub _decode { decode('UTF-8', $_[0]) // $_[0] }
  
  sub _encode { url_escape encode('UTF-8', $_[0]), $_[1] }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::URL - Uniform Resource Locator
  
  =head1 SYNOPSIS
  
    use Mojo::URL;
  
    # Parse
    my $url = Mojo::URL->new('http://sri:foo@example.com:3000/foo?foo=bar#23');
    say $url->scheme;
    say $url->userinfo;
    say $url->host;
    say $url->port;
    say $url->path;
    say $url->query;
    say $url->fragment;
  
    # Build
    my $url = Mojo::URL->new;
    $url->scheme('http');
    $url->userinfo('sri:foobar');
    $url->host('example.com');
    $url->port(3000);
    $url->path('/foo/bar');
    $url->query(foo => 'bar');
    $url->fragment(23);
    say "$url";
  
  =head1 DESCRIPTION
  
  L<Mojo::URL> implements a subset of
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>,
  L<RFC 3987|http://tools.ietf.org/html/rfc3987> and the
  L<URL Living Standard|https://url.spec.whatwg.org> for Uniform Resource
  Locators with support for IDNA and IRIs.
  
  =head1 ATTRIBUTES
  
  L<Mojo::URL> implements the following attributes.
  
  =head2 base
  
    my $base = $url->base;
    $url     = $url->base(Mojo::URL->new);
  
  Base of this URL, defaults to a L<Mojo::URL> object.
  
    "http://example.com/a/b?c"
    Mojo::URL->new("/a/b?c")->base(Mojo::URL->new("http://example.com"))->to_abs;
  
  =head2 fragment
  
    my $fragment = $url->fragment;
    $url         = $url->fragment('♥mojolicious♥');
  
  Fragment part of this URL.
  
    # "yada"
    Mojo::URL->new('http://example.com/foo?bar=baz#yada')->fragment;
  
  =head2 host
  
    my $host = $url->host;
    $url     = $url->host('127.0.0.1');
  
  Host part of this URL.
  
    # "example.com"
    Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->host;
  
  =head2 port
  
    my $port = $url->port;
    $url     = $url->port(8080);
  
  Port part of this URL.
  
    # "8080"
    Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->port;
  
  =head2 scheme
  
    my $scheme = $url->scheme;
    $url       = $url->scheme('http');
  
  Scheme part of this URL.
  
    # "http"
    Mojo::URL->new('http://example.com/foo')->scheme;
  
  =head2 userinfo
  
    my $info = $url->userinfo;
    $url     = $url->userinfo('root:♥');
  
  Userinfo part of this URL.
  
    # "sri:t3st"
    Mojo::URL->new('https://sri:t3st@example.com/foo')->userinfo;
  
  =head1 METHODS
  
  L<Mojo::URL> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 authority
  
    my $authority = $url->authority;
    $url          = $url->authority('root:%E2%99%A5@localhost:8080');
  
  Authority part of this URL.
  
    # "root:%E2%99%A5@xn--n3h.net:8080"
    Mojo::URL->new('http://root:♥@☃.net:8080/test')->authority;
  
    # "root@example.com"
    Mojo::URL->new('http://root@example.com/test')->authority;
  
  =head2 clone
  
    my $url2 = $url->clone;
  
  Clone this URL.
  
  =head2 host_port
  
    my $host_port = $url->host_port;
  
  Normalized version of L</"host"> and L</"port">.
  
    # "xn--n3h.net:8080"
    Mojo::URL->new('http://☃.net:8080/test')->host_port;
  
    # "example.com"
    Mojo::URL->new('http://example.com/test')->host_port;
  
  =head2 ihost
  
    my $ihost = $url->ihost;
    $url      = $url->ihost('xn--bcher-kva.ch');
  
  Host part of this URL in punycode format.
  
    # "xn--n3h.net"
    Mojo::URL->new('http://☃.net')->ihost;
  
    # "example.com"
    Mojo::URL->new('http://example.com')->ihost;
  
  =head2 is_abs
  
    my $bool = $url->is_abs;
  
  Check if URL is absolute.
  
    # True
    Mojo::URL->new('http://example.com')->is_abs;
    Mojo::URL->new('http://example.com/test/index.html')->is_abs;
  
    # False
    Mojo::URL->new('test/index.html')->is_abs;
    Mojo::URL->new('/test/index.html')->is_abs;
    Mojo::URL->new('//example.com/test/index.html')->is_abs;
  
  =head2 new
  
    my $url = Mojo::URL->new;
    my $url = Mojo::URL->new('http://127.0.0.1:3000/foo?f=b&baz=2#foo');
  
  Construct a new L<Mojo::URL> object and L</"parse"> URL if necessary.
  
  =head2 parse
  
    $url = $url->parse('http://127.0.0.1:3000/foo/bar?fo=o&baz=23#foo');
  
  Parse relative or absolute URL.
  
    # "/test/123"
    $url->parse('/test/123?foo=bar')->path;
  
    # "example.com"
    $url->parse('http://example.com/test/123?foo=bar')->host;
  
    # "sri@example.com"
    $url->parse('mailto:sri@example.com')->path;
  
  =head2 password
  
    my $password = $url->password;
  
  Password part of L</"userinfo">.
  
    # "s3cret"
    Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->password;
  
    # "s:3:c:r:e:t"
    Mojo::URL->new('http://isabel:s:3:c:r:e:t@mojolicious.org')->password;
  
  =head2 path
  
    my $path = $url->path;
    $url     = $url->path('foo/bar');
    $url     = $url->path('/foo/bar');
    $url     = $url->path(Mojo::Path->new);
  
  Path part of this URL, relative paths will be merged with
  L<Mojo::Path/"merge">, defaults to a L<Mojo::Path> object.
  
    # "perldoc"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path->parts->[0];
  
    # "/perldoc/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path->merge('DOM/HTML');
  
    # "http://example.com/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path('/DOM/HTML');
  
    # "http://example.com/perldoc/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path('DOM/HTML');
  
    # "http://example.com/perldoc/Mojo/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo/')->path('DOM/HTML');
  
  =head2 path_query
  
    my $path_query = $url->path_query;
  
  Normalized version of L</"path"> and L</"query">.
  
    # "/test?a=1&b=2"
    Mojo::URL->new('http://example.com/test?a=1&b=2')->path_query;
  
    # "/"
    Mojo::URL->new('http://example.com/')->path_query;
  
  =head2 protocol
  
    my $proto = $url->protocol;
  
  Normalized version of L</"scheme">.
  
    # "http"
    Mojo::URL->new('HtTp://example.com')->protocol;
  
  =head2 query
  
    my $query = $url->query;
    $url      = $url->query([merge => 'with']);
    $url      = $url->query({append => 'to'});
    $url      = $url->query(replace => 'with');
    $url      = $url->query('a=1&b=2');
    $url      = $url->query(Mojo::Parameters->new);
  
  Query part of this URL, key/value pairs in an array reference will be merged
  with L<Mojo::Parameters/"merge">, and key/value pairs in a hash reference
  appended with L<Mojo::Parameters/"append">, defaults to a L<Mojo::Parameters>
  object.
  
    # "2"
    Mojo::URL->new('http://example.com?a=1&b=2')->query->param('b');
  
    # "a=2&b=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query->merge(a => 2, c => 3);
  
    # "http://example.com?a=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query(a => 2, c => 3);
  
    # "http://example.com?a=2&a=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query(a => [2, 3]);
  
    # "http://example.com?a=2&b=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query([a => 2, c => 3]);
  
    # "http://example.com?b=2"
    Mojo::URL->new('http://example.com?a=1&b=2')->query([a => undef]);
  
    # "http://example.com?a=1&b=2&a=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query({a => 2, c => 3});
  
  =head2 to_abs
  
    my $abs = $url->to_abs;
    my $abs = $url->to_abs(Mojo::URL->new('http://example.com/foo'));
  
  Clone relative URL and turn it into an absolute one using L</"base"> or
  provided base URL.
  
    # "http://example.com/foo/baz.xml?test=123"
    Mojo::URL->new('baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
    # "http://example.com/baz.xml?test=123"
    Mojo::URL->new('/baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
    # "http://example.com/foo/baz.xml?test=123"
    Mojo::URL->new('//example.com/foo/baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
  =head2 to_string
  
    my $str = $url->to_string;
  
  Turn URL into a string.
  
    # "http://mojolicious.org"
    Mojo::URL->new->scheme('http')->host('mojolicious.org')->to_string;
  
  =head2 username
  
    my $username = $url->username;
  
  Username part of L</"userinfo">.
  
    # "isabel"
    Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->username;
  
  =head1 OPERATORS
  
  L<Mojo::URL> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$url;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$url";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_URL

$fatpacked{"Mojo/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UPLOAD';
  package Mojo::Upload;
  use Mojo::Base -base;
  
  has [qw(asset filename headers name)];
  
  sub move_to { $_[0]->asset->move_to($_[1]) and return $_[0] }
  
  sub size  { shift->asset->size }
  sub slurp { shift->asset->slurp }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Upload - Upload
  
  =head1 SYNOPSIS
  
    use Mojo::Upload;
  
    my $upload = Mojo::Upload->new;
    say $upload->filename;
    $upload->move_to('/home/sri/foo.txt');
  
  =head1 DESCRIPTION
  
  L<Mojo::Upload> is a container for uploaded files.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Upload> implements the following attributes.
  
  =head2 asset
  
    my $asset = $upload->asset;
    $upload   = $upload->asset(Mojo::Asset::File->new);
  
  Asset containing the uploaded data, usually a L<Mojo::Asset::File> or
  L<Mojo::Asset::Memory> object.
  
  =head2 filename
  
    my $filename = $upload->filename;
    $upload      = $upload->filename('foo.txt');
  
  Name of the uploaded file.
  
  =head2 headers
  
    my $headers = $upload->headers;
    $upload     = $upload->headers(Mojo::Headers->new);
  
  Headers for upload, usually a L<Mojo::Headers> object.
  
  =head2 name
  
    my $name = $upload->name;
    $upload  = $upload->name('foo');
  
  Name of the upload.
  
  =head1 METHODS
  
  L<Mojo::Upload> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 move_to
  
    $upload = $upload->move_to('/home/sri/foo.txt');
  
  Move uploaded data into a specific file.
  
  =head2 size
  
    my $size = $upload->size;
  
  Size of uploaded data in bytes.
  
  =head2 slurp
  
    my $bytes = $upload->slurp;
  
  Read all uploaded data at once.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_UPLOAD

$fatpacked{"Mojo/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT';
  package Mojo::UserAgent;
  use Mojo::Base 'Mojo::EventEmitter';
  
  # "Fry: Since when is the Internet about robbing people of their privacy?
  #  Bender: August 6, 1991."
  use Mojo::IOLoop;
  use Mojo::Util qw(monkey_patch term_escape);
  use Mojo::UserAgent::CookieJar;
  use Mojo::UserAgent::Proxy;
  use Mojo::UserAgent::Server;
  use Mojo::UserAgent::Transactor;
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_USERAGENT_DEBUG} || 0;
  
  has ca              => sub { $ENV{MOJO_CA_FILE} };
  has cert            => sub { $ENV{MOJO_CERT_FILE} };
  has connect_timeout => sub { $ENV{MOJO_CONNECT_TIMEOUT} || 10 };
  has cookie_jar      => sub { Mojo::UserAgent::CookieJar->new };
  has 'local_address';
  has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 20 };
  has ioloop             => sub { Mojo::IOLoop->new };
  has key                => sub { $ENV{MOJO_KEY_FILE} };
  has max_connections    => 5;
  has max_redirects => sub { $ENV{MOJO_MAX_REDIRECTS} || 0 };
  has proxy => sub { Mojo::UserAgent::Proxy->new };
  has request_timeout => sub { $ENV{MOJO_REQUEST_TIMEOUT} // 0 };
  has server => sub { Mojo::UserAgent::Server->new(ioloop => shift->ioloop) };
  has transactor => sub { Mojo::UserAgent::Transactor->new };
  
  # Common HTTP methods
  for my $name (qw(DELETE GET HEAD OPTIONS PATCH POST PUT)) {
    monkey_patch __PACKAGE__, lc $name, sub {
      my $self = shift;
      my $cb = ref $_[-1] eq 'CODE' ? pop : undef;
      return $self->start($self->build_tx($name, @_), $cb);
    };
  }
  
  sub DESTROY { Mojo::Util::_global_destruction() or shift->_cleanup }
  
  sub build_tx           { shift->transactor->tx(@_) }
  sub build_websocket_tx { shift->transactor->websocket(@_) }
  
  sub start {
    my ($self, $tx, $cb) = @_;
  
    # Fork-safety
    $self->_cleanup->server->restart unless ($self->{pid} //= $$) eq $$;
  
    # Non-blocking
    if ($cb) {
      warn "-- Non-blocking request (@{[_url($tx)]})\n" if DEBUG;
      return $self->_start(Mojo::IOLoop->singleton, $tx, $cb);
    }
  
    # Blocking
    warn "-- Blocking request (@{[_url($tx)]})\n" if DEBUG;
    $self->_start($self->ioloop, $tx => sub { shift->ioloop->stop; $tx = shift });
    $self->ioloop->start;
  
    return $tx;
  }
  
  sub websocket {
    my ($self, $cb) = (shift, pop);
    $self->start($self->build_websocket_tx(@_), $cb);
  }
  
  sub _cleanup {
    my $self = shift;
    delete $self->{pid};
    $self->_finish($_, 1) for keys %{$self->{connections} || {}};
    return $self;
  }
  
  sub _connect {
    my ($self, $loop, $peer, $tx, $handle, $cb) = @_;
  
    my $t = $self->transactor;
    my ($proto, $host, $port) = $peer ? $t->peer($tx) : $t->endpoint($tx);
    my %options
      = (address => $host, port => $port, timeout => $self->connect_timeout);
    if (my $local = $self->local_address) { $options{local_address} = $local }
    $options{handle} = $handle if $handle;
  
    # SOCKS
    if ($proto eq 'socks') {
      @options{qw(socks_address socks_port)} = @options{qw(address port)};
      ($proto, @options{qw(address port)}) = $t->endpoint($tx);
      my $userinfo = $tx->req->via_proxy(0)->proxy->userinfo;
      @options{qw(socks_user socks_pass)} = split ':', $userinfo if $userinfo;
    }
  
    # TLS
    map { $options{"tls_$_"} = $self->$_ } qw(ca cert key)
      if ($options{tls} = $proto eq 'https');
  
    weaken $self;
    my $id;
    return $id = $loop->client(
      %options => sub {
        my ($loop, $err, $stream) = @_;
  
        # Connection error
        return unless $self;
        return $self->_error($id, $err) if $err;
  
        # Connection established
        $stream->on(timeout => sub { $self->_error($id, 'Inactivity timeout') });
        $stream->on(close => sub { $self && $self->_finish($id, 1) });
        $stream->on(error => sub { $self && $self->_error($id, pop) });
        $stream->on(read => sub { $self->_read($id, pop) });
        $self->$cb($id);
      }
    );
  }
  
  sub _connect_proxy {
    my ($self, $loop, $old, $cb) = @_;
  
    # Start CONNECT request
    return undef unless my $new = $self->transactor->proxy_connect($old);
    return $self->_start(
      ($loop, $new) => sub {
        my ($self, $tx) = @_;
  
        # CONNECT failed (connection needs to be kept alive)
        $old->res->error({message => 'Proxy connection failed'})
          and return $self->$cb($old)
          if $tx->error || !$tx->res->is_status_class(200) || !$tx->keep_alive;
  
        # Start real transaction
        $old->req->via_proxy(0);
        my $id = $tx->connection;
        return $self->_start($loop, $old->connection($id), $cb)
          unless $tx->req->url->protocol eq 'https';
  
        # TLS upgrade
        my $handle = $loop->stream($id)->steal_handle;
        $self->_remove($id);
        $id = $self->_connect($loop, 0, $old, $handle,
          sub { shift->_start($loop, $old->connection($id), $cb) });
        $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $old};
      }
    );
  }
  
  sub _connected {
    my ($self, $id) = @_;
  
    my $c      = $self->{connections}{$id};
    my $stream = $c->{ioloop}->stream($id)->timeout($self->inactivity_timeout);
    my $tx     = $c->{tx}->connection($id);
    my $handle = $stream->handle;
    $tx->local_address($handle->sockhost)->local_port($handle->sockport);
    $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
  
    weaken $self;
    $tx->on(resume => sub { $self->_write($id) });
    $self->_write($id);
  }
  
  sub _connection {
    my ($self, $loop, $tx, $cb) = @_;
  
    # Reuse connection
    my ($proto, $host, $port) = $self->transactor->endpoint($tx);
    my $id = $tx->connection || $self->_dequeue($loop, "$proto:$host:$port", 1);
    if ($id) {
      warn "-- Reusing connection $id ($proto://$host:$port)\n" if DEBUG;
      @{$self->{connections}{$id}}{qw(cb tx)} = ($cb, $tx);
      $tx->kept_alive(1) unless $tx->connection;
      $self->_connected($id);
      return $id;
    }
  
    # CONNECT request to proxy required
    if (my $id = $self->_connect_proxy($loop, $tx, $cb)) { return $id }
  
    # New connection
    $id = $self->_connect($loop, 1, $tx, undef, \&_connected);
    warn "-- Connect $id ($proto://$host:$port)\n" if DEBUG;
    $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $tx};
  
    return $id;
  }
  
  sub _dequeue {
    my ($self, $loop, $name, $test) = @_;
  
    my $old = $self->{queue}{$loop} ||= [];
    my ($found, @new);
    for my $queued (@$old) {
      push @new, $queued and next if $found || !grep { $_ eq $name } @$queued;
  
      # Search for id/name and sort out corrupted connections if necessary
      next unless my $stream = $loop->stream($queued->[1]);
      $test && $stream->is_readable ? $stream->close : ($found = $queued->[1]);
    }
    @$old = @new;
  
    return $found;
  }
  
  sub _error {
    my ($self, $id, $err) = @_;
    my $tx = $self->{connections}{$id}{tx};
    $tx->res->error({message => $err}) if $tx;
    $self->_finish($id, 1);
  }
  
  sub _finish {
    my ($self, $id, $close) = @_;
  
    # Remove request timeout and finish transaction
    return unless my $c = $self->{connections}{$id};
    $c->{ioloop}->remove($c->{timeout}) if $c->{timeout};
    return $self->_reuse($id, $close) unless my $old = $c->{tx};
  
    # Premature connection close
    my $res = $old->closed->res->finish;
    if ($close && !$res->code && !$res->error) {
      $res->error({message => 'Premature connection close'});
    }
  
    # Always remove connection for WebSockets
    return $self->_remove($id) if $old->is_websocket;
  
    $self->cookie_jar->collect($old);
  
    # Upgrade connection to WebSocket
    if (my $new = $self->transactor->upgrade($old)) {
      weaken $self;
      $new->on(resume => sub { $self->_write($id) });
      $c->{cb}($self, $c->{tx} = $new);
      return $new->client_read($old->res->content->leftovers);
    }
  
    $self->_reuse($id, $close);
    if ($res->is_status_class(400) || $res->is_status_class(500)) {
      $res->error({message => $res->message, code => $res->code});
    }
    $c->{cb}($self, $old) unless $self->_redirect($c, $old);
  }
  
  sub _read {
    my ($self, $id, $chunk) = @_;
  
    # Corrupted connection
    return $self->_remove($id) unless my $tx = $self->{connections}{$id}{tx};
  
    warn term_escape "-- Client <<< Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    $tx->client_read($chunk);
    $self->_finish($id) if $tx->is_finished;
  }
  
  sub _redirect {
    my ($self, $c, $old) = @_;
    return undef unless my $new = $self->transactor->redirect($old);
    return undef unless @{$old->redirects} < $self->max_redirects;
    return $self->_start($c->{ioloop}, $new, delete $c->{cb});
  }
  
  sub _remove {
    my ($self, $id) = @_;
    my $c = delete $self->{connections}{$id};
    $self->_dequeue($c->{ioloop}, $id);
    $c->{ioloop}->remove($id);
  }
  
  sub _reuse {
    my ($self, $id, $close) = @_;
  
    # Connection close
    my $c   = $self->{connections}{$id};
    my $tx  = delete $c->{tx};
    my $max = $self->max_connections;
    return $self->_remove($id)
      if $close || !$tx || !$max || !$tx->keep_alive || $tx->error;
  
    # Keep connection alive
    my $queue = $self->{queue}{$c->{ioloop}} ||= [];
    $self->_remove(shift(@$queue)->[1]) while @$queue && @$queue >= $max;
    push @$queue, [join(':', $self->transactor->endpoint($tx)), $id];
  }
  
  sub _start {
    my ($self, $loop, $tx, $cb) = @_;
  
    # Application server
    my $url = $tx->req->url;
    unless ($url->is_abs) {
      my $base
        = $loop == $self->ioloop ? $self->server->url : $self->server->nb_url;
      $url->scheme($base->scheme)->authority($base->authority);
    }
  
    $_->prepare($tx) for $self->proxy, $self->cookie_jar;
  
    # Connect and add request timeout if necessary
    my $id = $self->emit(start => $tx)->_connection($loop, $tx, $cb);
    if (my $timeout = $self->request_timeout) {
      weaken $self;
      $self->{connections}{$id}{timeout}
        = $loop->timer($timeout => sub { $self->_error($id, 'Request timeout') });
    }
  
    return $id;
  }
  
  sub _url { shift->req->url->to_abs }
  
  sub _write {
    my ($self, $id) = @_;
  
    # Protect from resume event recursion
    my $c = $self->{connections}{$id};
    return if !(my $tx = $c->{tx}) || $c->{writing};
    local $c->{writing} = 1;
    my $chunk = $tx->client_write;
    warn term_escape "-- Client >>> Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    return unless length $chunk;
    weaken $self;
    $c->{ioloop}->stream($id)->write($chunk => sub { $self->_write($id) });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent - Non-blocking I/O HTTP and WebSocket user agent
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent;
  
    # Say hello to the Unicode snowman and include an Accept header
    my $ua = Mojo::UserAgent->new;
    say $ua->get('www.☃.net?hello=there' => {Accept => '*/*'})->res->body;
  
    # Form POST (application/x-www-form-urlencoded) with exception handling
    my $tx = $ua->post('https://metacpan.org/search' => form => {q => 'mojo'});
    if (my $res = $tx->success) { say $res->body }
    else {
      my $err = $tx->error;
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
    # Extract data from HTML and XML resources with CSS selectors
    say $ua->get('www.perl.org')->res->dom->at('title')->text;
  
    # Scrape the latest headlines from a news site
    say $ua->get('blogs.perl.org')
      ->res->dom->find('h2 > a')->map('text')->join("\n");
  
    # IPv6 PUT request with Content-Type header and content
    my $tx = $ua->put('[::1]:3000' => {'Content-Type' => 'text/plain'} => 'Hi!');
  
    # Quick JSON API request with Basic authentication
    my $value = $ua->get('https://sri:s3cret@example.com/test.json')->res->json;
  
    # JSON POST (application/json) with TLS certificate authentication
    my $tx = $ua->cert('tls.crt')->key('tls.key')
      ->post('https://example.com' => json => {top => 'secret'});
  
    # Search DuckDuckGo anonymously through Tor
    $ua->proxy->http('socks://127.0.0.1:9050');
    say $ua->get('api.3g2upl4pq6kufc4m.onion/?q=mojolicious&format=json')
      ->res->json('/Abstract');
  
    # Follow redirects to download Mojolicious from GitHub
    $ua->max_redirects(5)
      ->get('https://www.github.com/kraih/mojo/tarball/master')
      ->res->content->asset->move_to('/home/sri/mojo.tar.gz');
  
    # Non-blocking request
    $ua->get('mojolicious.org' => sub {
      my ($ua, $tx) = @_;
      say $tx->res->dom->at('title')->text;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
    # Concurrent non-blocking requests (synchronized with a delay)
    Mojo::IOLoop->delay(
      sub {
        my $delay = shift;
        $ua->get('mojolicious.org' => $delay->begin);
        $ua->get('cpan.org'        => $delay->begin);
      },
      sub {
        my ($delay, $mojo, $cpan) = @_;
        say $mojo->res->dom->at('title')->text;
        say $cpan->res->dom->at('title')->text;
      }
    )->wait;
  
    # WebSocket connection sending and receiving JSON messages
    $ua->websocket('ws://example.com/echo.json' => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      $tx->on(json => sub {
        my ($tx, $hash) = @_;
        say "WebSocket message via JSON: $hash->{msg}";
        $tx->finish;
      });
      $tx->send({json => {msg => 'Hello World!'}});
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent> is a full featured non-blocking I/O HTTP and WebSocket user
  agent, with IPv6, TLS, SNI, IDNA, HTTP/SOCKS5 proxy, Comet (long polling),
  keep-alive, connection pooling, timeout, cookie, multipart, gzip compression
  and multiple event loop support.
  
  All connections will be reset automatically if a new process has been forked,
  this allows multiple processes to share the same L<Mojo::UserAgent> object
  safely.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.94+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NDN>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"USER AGENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::UserAgent> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 start
  
    $ua->on(start => sub {
      my ($ua, $tx) = @_;
      ...
    });
  
  Emitted whenever a new transaction is about to start, this includes
  automatically prepared proxy C<CONNECT> requests and followed redirects.
  
    $ua->on(start => sub {
      my ($ua, $tx) = @_;
      $tx->req->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent> implements the following attributes.
  
  =head2 ca
  
    my $ca = $ua->ca;
    $ua    = $ua->ca('/etc/tls/ca.crt');
  
  Path to TLS certificate authority file used to verify the peer certificate,
  defaults to the value of the C<MOJO_CA_FILE> environment variable. Also
  activates hostname verification.
  
    # Show certificate authorities for debugging
    IO::Socket::SSL::set_defaults(
      SSL_verify_callback => sub { say "Authority: $_[2]" and return $_[0] });
  
  =head2 cert
  
    my $cert = $ua->cert;
    $ua      = $ua->cert('/etc/tls/client.crt');
  
  Path to TLS certificate file, defaults to the value of the C<MOJO_CERT_FILE>
  environment variable.
  
  =head2 connect_timeout
  
    my $timeout = $ua->connect_timeout;
    $ua         = $ua->connect_timeout(5);
  
  Maximum amount of time in seconds establishing a connection may take before
  getting canceled, defaults to the value of the C<MOJO_CONNECT_TIMEOUT>
  environment variable or C<10>.
  
  =head2 cookie_jar
  
    my $cookie_jar = $ua->cookie_jar;
    $ua            = $ua->cookie_jar(Mojo::UserAgent::CookieJar->new);
  
  Cookie jar to use for requests performed by this user agent, defaults to a
  L<Mojo::UserAgent::CookieJar> object.
  
    # Ignore all cookies
    $ua->cookie_jar->ignore(sub { 1 });
  
    # Ignore cookies for public suffixes
    my $ps = IO::Socket::SSL::PublicSuffix->default;
    $ua->cookie_jar->ignore(sub {
      my $cookie = shift;
      return undef unless my $domain = $cookie->domain;
      return ($ps->public_suffix($domain))[0] eq '';
    });
  
    # Add custom cookie to the jar
    $ua->cookie_jar->add(
      Mojo::Cookie::Response->new(
        name   => 'foo',
        value  => 'bar',
        domain => 'mojolicious.org',
        path   => '/perldoc'
      )
    );
  
  =head2 inactivity_timeout
  
    my $timeout = $ua->inactivity_timeout;
    $ua         = $ua->inactivity_timeout(15);
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment
  variable or C<20>. Setting the value to C<0> will allow connections to be
  inactive indefinitely.
  
  =head2 ioloop
  
    my $loop = $ua->ioloop;
    $ua      = $ua->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for blocking I/O operations, defaults to a
  L<Mojo::IOLoop> object.
  
  =head2 key
  
    my $key = $ua->key;
    $ua     = $ua->key('/etc/tls/client.crt');
  
  Path to TLS key file, defaults to the value of the C<MOJO_KEY_FILE> environment
  variable.
  
  =head2 local_address
  
    my $address = $ua->local_address;
    $ua         = $ua->local_address('127.0.0.1');
  
  Local address to bind to.
  
  =head2 max_connections
  
    my $max = $ua->max_connections;
    $ua     = $ua->max_connections(5);
  
  Maximum number of keep-alive connections that the user agent will retain before
  it starts closing the oldest ones, defaults to C<5>. Setting the value to C<0>
  will prevent any connections from being kept alive.
  
  =head2 max_redirects
  
    my $max = $ua->max_redirects;
    $ua     = $ua->max_redirects(3);
  
  Maximum number of redirects the user agent will follow before it fails,
  defaults to the value of the C<MOJO_MAX_REDIRECTS> environment variable or
  C<0>.
  
  =head2 proxy
  
    my $proxy = $ua->proxy;
    $ua       = $ua->proxy(Mojo::UserAgent::Proxy->new);
  
  Proxy manager, defaults to a L<Mojo::UserAgent::Proxy> object.
  
    # Detect proxy servers from environment
    $ua->proxy->detect;
  
    # Manually configure HTTP proxy (using CONNECT for HTTPS)
    $ua->proxy->http('http://127.0.0.1:8080')->https('http://127.0.0.1:8080');
  
    # Manually configure Tor (SOCKS5)
    $ua->proxy->http('socks://127.0.0.1:9050')->https('socks://127.0.0.1:9050');
  
  =head2 request_timeout
  
    my $timeout = $ua->request_timeout;
    $ua         = $ua->request_timeout(5);
  
  Maximum amount of time in seconds establishing a connection, sending the
  request and receiving a whole response may take before getting canceled,
  defaults to the value of the C<MOJO_REQUEST_TIMEOUT> environment variable or
  C<0>. Setting the value to C<0> will allow the user agent to wait indefinitely.
  The timeout will reset for every followed redirect.
  
    # Total limit of 5 seconds, of which 3 seconds may be spent connecting
    $ua->max_redirects(0)->connect_timeout(3)->request_timeout(5);
  
  =head2 server
  
    my $server = $ua->server;
    $ua        = $ua->server(Mojo::UserAgent::Server->new);
  
  Application server relative URLs will be processed with, defaults to a
  L<Mojo::UserAgent::Server> object.
  
    # Mock web service
    $ua->server->app(Mojolicious->new);
    $ua->server->app->routes->get('/time' => sub {
      my $c = shift;
      $c->render(json => {now => time});
    });
    my $time = $ua->get('/time')->res->json->{now};
  
    # Change log level
    $ua->server->app->log->level('fatal');
  
    # Port currently used for processing relative URLs blocking
    say $ua->server->url->port;
  
    # Port currently used for processing relative URLs non-blocking
    say $ua->server->nb_url->port;
  
  =head2 transactor
  
    my $t = $ua->transactor;
    $ua   = $ua->transactor(Mojo::UserAgent::Transactor->new);
  
  Transaction builder, defaults to a L<Mojo::UserAgent::Transactor> object.
  
    # Change name of user agent
    $ua->transactor->name('MyUA 1.0');
  
  =head1 METHODS
  
  L<Mojo::UserAgent> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 build_tx
  
    my $tx = $ua->build_tx(GET => 'example.com');
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Generate L<Mojo::Transaction::HTTP> object with
  L<Mojo::UserAgent::Transactor/"tx">.
  
    # Request with custom cookie
    my $tx = $ua->build_tx(GET => 'https://example.com/account');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $tx = $ua->start($tx);
  
    # Deactivate gzip compression
    my $tx = $ua->build_tx(GET => 'example.com');
    $tx->req->headers->remove('Accept-Encoding');
    $tx = $ua->start($tx);
  
    # Interrupt response by raising an error
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $tx->res->on(progress => sub {
      my $res = shift;
      return unless my $server = $res->headers->server;
      $res->error({message => 'Oh noes, it is IIS!'}) if $server =~ /IIS/;
    });
    $tx = $ua->start($tx);
  
  =head2 build_websocket_tx
  
    my $tx = $ua->build_websocket_tx('ws://example.com');
    my $tx = $ua->build_websocket_tx(
      'ws://example.com' => {DNT => 1} => ['v1.proto']);
  
  Generate L<Mojo::Transaction::HTTP> object with
  L<Mojo::UserAgent::Transactor/"websocket">.
  
    # Custom WebSocket handshake with cookie
    my $tx = $ua->build_websocket_tx('wss://example.com/echo');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $ua->start($tx => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 delete
  
    my $tx = $ua->delete('example.com');
    my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $ua->delete(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->delete(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<DELETE> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<DELETE> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->delete('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->res->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 get
  
    my $tx = $ua->get('example.com');
    my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $ua->get(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->get(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<GET> request and return resulting L<Mojo::Transaction::HTTP>
  object, takes the same arguments as L<Mojo::UserAgent::Transactor/"tx"> (except
  for the C<GET> method, which is implied). You can also append a callback to
  perform requests non-blocking.
  
    $ua->get('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->res->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 head
  
    my $tx = $ua->head('example.com');
    my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $ua->head(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->head(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<HEAD> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<HEAD> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->head('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->res->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 options
  
    my $tx = $ua->options('example.com');
    my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $ua->options(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->options(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<OPTIONS> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<OPTIONS> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->options('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->res->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 patch
  
    my $tx = $ua->patch('example.com');
    my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $ua->patch(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->patch(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<PATCH> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<PATCH> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->patch('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->res->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 post
  
    my $tx = $ua->post('example.com');
    my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $ua->post(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->post(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<POST> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<POST> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->post('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->res->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 put
  
    my $tx = $ua->put('example.com');
    my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $ua->put(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->put(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<PUT> request and return resulting L<Mojo::Transaction::HTTP>
  object, takes the same arguments as L<Mojo::UserAgent::Transactor/"tx"> (except
  for the C<PUT> method, which is implied). You can also append a callback to
  perform requests non-blocking.
  
    $ua->put('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->res->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 start
  
    my $tx = $ua->start(Mojo::Transaction::HTTP->new);
  
  Perform blocking request for a custom L<Mojo::Transaction::HTTP> object, which
  can be prepared manually or with L</"build_tx">. You can also append a callback
  to perform requests non-blocking.
  
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $ua->start($tx => sub {
      my ($ua, $tx) = @_;
      say $tx->res->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 websocket
  
    $ua->websocket('ws://example.com' => sub {...});
    $ua->websocket(
      'ws://example.com' => {DNT => 1} => ['v1.proto'] => sub {...});
  
  Open a non-blocking WebSocket connection with transparent handshake, takes the
  same arguments as L<Mojo::UserAgent::Transactor/"websocket">. The callback will
  receive either a L<Mojo::Transaction::WebSocket> or L<Mojo::Transaction::HTTP>
  object, depending on if the handshake was successful.
  
    $ua->websocket('wss://example.com/echo' => ['v1.proto'] => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      say 'Subprotocol negotiation failed!' and return unless $tx->protocol;
      $tx->on(finish => sub {
        my ($tx, $code, $reason) = @_;
        say "WebSocket closed with status $code.";
      });
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  You can activate C<permessage-deflate> compression by setting the
  C<Sec-WebSocket-Extensions> header, this can result in much better performance,
  but also increases memory usage by up to 300KB per connection.
  
    $ua->websocket('ws://example.com/foo' => {
      'Sec-WebSocket-Extensions' => 'permessage-deflate'
    } => sub {...});
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_USERAGENT_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_USERAGENT_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT

$fatpacked{"Mojo/UserAgent/CookieJar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_COOKIEJAR';
  package Mojo::UserAgent::CookieJar;
  use Mojo::Base -base;
  
  use Mojo::Cookie::Request;
  use Mojo::Path;
  use Scalar::Util 'looks_like_number';
  
  has 'ignore';
  has max_cookie_size => 4096;
  
  sub add {
    my ($self, @cookies) = @_;
  
    my $size = $self->max_cookie_size;
    for my $cookie (@cookies) {
  
      # Convert max age to expires
      my $age = $cookie->max_age;
      $cookie->expires($age <= 0 ? 0 : $age + time) if looks_like_number $age;
  
      # Check cookie size
      next if length($cookie->value // '') > $size;
  
      # Replace cookie
      my $origin = $cookie->origin // '';
      next unless my $domain = lc($cookie->domain // $origin);
      next unless my $path = $cookie->path;
      next unless length(my $name = $cookie->name // '');
      my $jar = $self->{jar}{$domain} ||= [];
      @$jar = (grep({ _compare($_, $path, $name, $origin) } @$jar), $cookie);
    }
  
    return $self;
  }
  
  sub all {
    my $jar = shift->{jar};
    return [map { @{$jar->{$_}} } sort keys %$jar];
  }
  
  sub collect {
    my ($self, $tx) = @_;
  
    my $url = $tx->req->url;
    for my $cookie (@{$tx->res->cookies}) {
  
      # Validate domain
      my $host = $url->ihost;
      my $domain = lc($cookie->domain // $cookie->origin($host)->origin);
      if (my $cb = $self->ignore) { next if $cb->($cookie) }
      next if $host ne $domain && ($host !~ /\Q.$domain\E$/ || $host =~ /\.\d+$/);
  
      # Validate path
      my $path = $cookie->path // $url->path->to_dir->to_abs_string;
      $path = Mojo::Path->new($path)->trailing_slash(0)->to_abs_string;
      next unless _path($path, $url->path->to_abs_string);
      $self->add($cookie->path($path));
    }
  }
  
  sub empty { delete shift->{jar} }
  
  sub find {
    my ($self, $url) = @_;
  
    my @found;
    return \@found unless my $domain = my $host = $url->ihost;
    my $path = $url->path->to_abs_string;
    while ($domain) {
      next unless my $old = $self->{jar}{$domain};
  
      # Grab cookies
      my $new = $self->{jar}{$domain} = [];
      for my $cookie (@$old) {
        next unless $cookie->domain || $host eq $cookie->origin;
  
        # Check if cookie has expired
        if (defined(my $expires = $cookie->expires)) { next if time > $expires }
        push @$new, $cookie;
  
        # Taste cookie
        next if $cookie->secure && $url->protocol ne 'https';
        next unless _path($cookie->path, $path);
        my $name  = $cookie->name;
        my $value = $cookie->value;
        push @found, Mojo::Cookie::Request->new(name => $name, value => $value);
      }
    }
  
    # Remove another part
    continue { $domain =~ s/^[^.]*\.*// }
  
    return \@found;
  }
  
  sub prepare {
    my ($self, $tx) = @_;
    return unless keys %{$self->{jar}};
    my $req = $tx->req;
    $req->cookies(@{$self->find($req->url)});
  }
  
  sub _compare {
    my ($cookie, $path, $name, $origin) = @_;
    return 1 if $cookie->path ne $path || $cookie->name ne $name;
    return ($cookie->origin // '') ne $origin;
  }
  
  sub _path { $_[0] eq '/' || $_[0] eq $_[1] || index($_[1], "$_[0]/") == 0 }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::CookieJar - Cookie jar for HTTP user agents
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::CookieJar;
  
    # Add response cookies
    my $jar = Mojo::UserAgent::CookieJar->new;
    $jar->add(
      Mojo::Cookie::Response->new(
        name   => 'foo',
        value  => 'bar',
        domain => 'localhost',
        path   => '/test'
      )
    );
  
    # Find request cookies
    for my $cookie (@{$jar->find(Mojo::URL->new('http://localhost/test'))}) {
      say $cookie->name;
      say $cookie->value;
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::CookieJar> is a minimalistic and relaxed cookie jar used by
  L<Mojo::UserAgent>, based on L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::CookieJar> implements the following attributes.
  
  =head2 ignore
  
    my $ignore = $jar->ignore;
    $jar       = $jar->ignore(sub {...});
  
  A callback used to decide if a cookie should be ignored by L</"collect">.
  
    # Ignore all cookies
    $jar->ignore(sub { 1 });
  
    # Ignore cookies for domains "com", "net" and "org"
    $jar->ignore(sub {
      my $cookie = shift;
      return undef unless my $domain = $cookie->domain;
      return $domain eq 'com' || $domain eq 'net' || $domain eq 'org';
    });
  
  =head2 max_cookie_size
  
    my $size = $jar->max_cookie_size;
    $jar     = $jar->max_cookie_size(4096);
  
  Maximum cookie size in bytes, defaults to C<4096> (4KB).
  
  =head1 METHODS
  
  L<Mojo::UserAgent::CookieJar> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add
  
    $jar = $jar->add(@cookies);
  
  Add multiple L<Mojo::Cookie::Response> objects to the jar.
  
  =head2 all
  
    my $cookies = $jar->all;
  
  Return all L<Mojo::Cookie::Response> objects that are currently stored in the
  jar.
  
    # Names of all cookies
    say $_->name for @{$jar->all};
  
  =head2 collect
  
    $jar->collect(Mojo::Transaction::HTTP->new);
  
  Collect response cookies from transaction.
  
  =head2 empty
  
    $jar->empty;
  
  Empty the jar.
  
  =head2 find
  
    my $cookies = $jar->find(Mojo::URL->new);
  
  Find L<Mojo::Cookie::Request> objects in the jar for L<Mojo::URL> object.
  
    # Names of all cookies found
    say $_->name for @{$jar->find(Mojo::URL->new('http://example.com/foo'))};
  
  =head2 prepare
  
    $jar->prepare(Mojo::Transaction::HTTP->new);
  
  Prepare request cookies for transaction.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_COOKIEJAR

$fatpacked{"Mojo/UserAgent/Proxy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_PROXY';
  package Mojo::UserAgent::Proxy;
  use Mojo::Base -base;
  
  use Mojo::URL;
  
  has [qw(http https not)];
  
  sub detect {
    my $self = shift;
    $self->http($ENV{HTTP_PROXY}   || $ENV{http_proxy});
    $self->https($ENV{HTTPS_PROXY} || $ENV{https_proxy});
    return $self->not([split ',', $ENV{NO_PROXY} || $ENV{no_proxy} || '']);
  }
  
  sub is_needed {
    !grep { $_[1] =~ /\Q$_\E$/ } @{$_[0]->not || []};
  }
  
  sub prepare {
    my ($self, $tx) = @_;
  
    $self->detect if $ENV{MOJO_PROXY};
    my $req = $tx->req;
    my $url = $req->url;
    return unless $self->is_needed($url->host);
  
    # HTTP proxy
    my $proto = $url->protocol;
    my $http  = $self->http;
    $req->proxy(Mojo::URL->new($http)) if $http && $proto eq 'http';
  
    # HTTPS proxy
    my $https = $self->https;
    $req->proxy(Mojo::URL->new($https)) if $https && $proto eq 'https';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Proxy - User agent proxy manager
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Proxy;
  
    my $proxy = Mojo::UserAgent::Proxy->new;
    $proxy->detect;
    say $proxy->http;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Proxy> manages proxy servers for L<Mojo::UserAgent>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Proxy> implements the following attributes.
  
  =head2 http
  
    my $http = $proxy->http;
    $proxy   = $proxy->http('socks://sri:secret@127.0.0.1:8080');
  
  Proxy server to use for HTTP and WebSocket requests.
  
  =head2 https
  
    my $https = $proxy->https;
    $proxy    = $proxy->https('http://sri:secret@127.0.0.1:8080');
  
  Proxy server to use for HTTPS and WebSocket requests.
  
  =head2 not
  
    my $not = $proxy->not;
    $proxy  = $proxy->not(['localhost', 'intranet.mojolicious.org']);
  
  Domains that don't require a proxy server to be used.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Proxy> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 detect
  
    $proxy = $proxy->detect;
  
  Check environment variables C<HTTP_PROXY>, C<http_proxy>, C<HTTPS_PROXY>,
  C<https_proxy>, C<NO_PROXY> and C<no_proxy> for proxy information. Automatic
  proxy detection can be enabled with the C<MOJO_PROXY> environment variable.
  
  =head2 is_needed
  
    my $bool = $proxy->is_needed('intranet.example.com');
  
  Check if request for domain would use a proxy server.
  
  =head2 prepare
  
    $proxy->prepare(Mojo::Transaction::HTTP->new);
  
  Prepare proxy server information for transaction.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_PROXY

$fatpacked{"Mojo/UserAgent/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_SERVER';
  package Mojo::UserAgent::Server;
  use Mojo::Base -base;
  
  use Mojo::IOLoop;
  use Mojo::Server::Daemon;
  use Scalar::Util 'weaken';
  
  has ioloop => sub { Mojo::IOLoop->singleton };
  
  sub app {
    my ($self, $app) = @_;
  
    # Singleton application
    state $singleton;
    return $singleton = $app ? $app : $singleton unless ref $self;
  
    # Default to singleton application
    return $self->{app} || $singleton unless $app;
    $self->{app} = $app;
    return $self;
  }
  
  sub nb_url { shift->_url(1, @_) }
  
  sub restart { shift->_restart(1) }
  
  sub url { shift->_url(0, @_) }
  
  sub _restart {
    my ($self, $full, $proto) = @_;
    delete @{$self}{qw(nb_port port)} if $full;
  
    $self->{proto} = $proto ||= 'http';
  
    # Blocking
    my $server = $self->{server}
      = Mojo::Server::Daemon->new(ioloop => $self->ioloop, silent => 1);
    weaken $server->app($self->app)->{app};
    my $port = $self->{port} ? ":$self->{port}" : '';
    $self->{port} = $server->listen(["$proto://127.0.0.1$port"])
      ->start->ioloop->acceptor($server->acceptors->[0])->port;
  
    # Non-blocking
    $server = $self->{nb_server} = Mojo::Server::Daemon->new(silent => 1);
    weaken $server->app($self->app)->{app};
    $port = $self->{nb_port} ? ":$self->{nb_port}" : '';
    $self->{nb_port} = $server->listen(["$proto://127.0.0.1$port"])
      ->start->ioloop->acceptor($server->acceptors->[0])->port;
  }
  
  sub _url {
    my ($self, $nb) = (shift, shift);
    $self->_restart(0, @_) if !$self->{server} || @_;
    my $port = $nb ? $self->{nb_port} : $self->{port};
    return Mojo::URL->new("$self->{proto}://127.0.0.1:$port/");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Server - Application server
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Server;
  
    my $server = Mojo::UserAgent::Server->new;
    say $server->url;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Server> is an embedded web server based on
  L<Mojo::Server::Daemon> that processes requests for L<Mojo::UserAgent>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Server> implements the following attributes.
  
  =head2 ioloop
  
    my $loop = $server->ioloop;
    $server  = $server->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for I/O operations, defaults to the global
  L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Server> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 app
  
    my $app = Mojo::UserAgent::Server->app;
              Mojo::UserAgent::Server->app(Mojolicious->new);
    my $app = $server->app;
    $server = $server->app(Mojolicious->new);
  
  Application this server handles, instance specific applications override the
  global default.
  
    # Change application behavior
    $server->app->defaults(testing => 'oh yea!');
  
  =head2 nb_url
  
    my $url = $ua->nb_url;
    my $url = $ua->nb_url('http');
    my $url = $ua->nb_url('https');
  
  Get absolute L<Mojo::URL> object for server processing non-blocking requests
  with L</"app"> and switch protocol if necessary.
  
  =head2 restart
  
    $server->restart;
  
  Restart server with new port.
  
  =head2 url
  
    my $url = $ua->url;
    my $url = $ua->url('http');
    my $url = $ua->url('https');
  
  Get absolute L<Mojo::URL> object for server processing blocking requests with
  L</"app"> and switch protocol if necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_SERVER

$fatpacked{"Mojo/UserAgent/Transactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_TRANSACTOR';
  package Mojo::UserAgent::Transactor;
  use Mojo::Base -base;
  
  use File::Basename 'basename';
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Content::MultiPart;
  use Mojo::Content::Single;
  use Mojo::JSON 'encode_json';
  use Mojo::Parameters;
  use Mojo::Transaction::HTTP;
  use Mojo::Transaction::WebSocket;
  use Mojo::URL;
  use Mojo::Util qw(encode url_escape);
  use Mojo::WebSocket qw(challenge client_handshake);
  
  has generators => sub { {form => \&_form, json => \&_json} };
  has name => 'Mojolicious (Perl)';
  
  sub add_generator { $_[0]->generators->{$_[1]} = $_[2] and return $_[0] }
  
  sub endpoint {
    my ($self, $tx) = @_;
  
    # Basic endpoint
    my $req   = $tx->req;
    my $url   = $req->url;
    my $proto = $url->protocol || 'http';
    my $host  = $url->ihost;
    my $port  = $url->port || ($proto eq 'https' ? 443 : 80);
  
    # Proxy for normal HTTP requests
    my $socks;
    if (my $proxy = $req->proxy) { $socks = $proxy->protocol eq 'socks' }
    return $self->_proxy($tx, $proto, $host, $port)
      if $proto eq 'http' && !$req->is_handshake && !$socks;
  
    return $proto, $host, $port;
  }
  
  sub peer { $_[0]->_proxy($_[1], $_[0]->endpoint($_[1])) }
  
  sub proxy_connect {
    my ($self, $old) = @_;
  
    # Already a CONNECT request
    my $req = $old->req;
    return undef if uc $req->method eq 'CONNECT';
  
    # No proxy
    return undef unless (my $proxy = $req->proxy) && $req->via_proxy;
    return undef if $proxy->protocol eq 'socks';
  
    # WebSocket and/or HTTPS
    my $url = $req->url;
    return undef unless $req->is_handshake || $url->protocol eq 'https';
  
    # CONNECT request (expect a bad response)
    my $new = $self->tx(CONNECT => $url->clone->userinfo(undef));
    $new->req->proxy($proxy);
    $new->res->content->auto_relax(0)->headers->connection('keep-alive');
  
    return $new;
  }
  
  sub redirect {
    my ($self, $old) = @_;
  
    # Commonly used codes
    my $res = $old->res;
    my $code = $res->code // 0;
    return undef unless grep { $_ == $code } 301, 302, 303, 307, 308;
  
    # Fix location without authority and/or scheme
    return undef unless my $location = $res->headers->location;
    $location = Mojo::URL->new($location);
    $location = $location->base($old->req->url)->to_abs unless $location->is_abs;
    my $proto = $location->protocol;
    return undef if ($proto ne 'http' && $proto ne 'https') || !$location->host;
  
    # Clone request if necessary
    my $new = Mojo::Transaction::HTTP->new;
    my $req = $old->req;
    if ($code == 307 || $code == 308) {
      return undef unless my $clone = $req->clone;
      $new->req($clone);
    }
    else {
      my $method = uc $req->method;
      my $headers = $new->req->method($method eq 'POST' ? 'GET' : $method)
        ->content->headers($req->headers->clone)->headers;
      $headers->remove($_) for grep {/^content-/i} @{$headers->names};
    }
    my $headers = $new->req->url($location)->headers;
    $headers->remove($_) for qw(Authorization Cookie Host Referer);
    return $new->previous($old);
  }
  
  sub tx {
    my $self = shift;
  
    # Method and URL
    my $tx  = Mojo::Transaction::HTTP->new;
    my $req = $tx->req->method(shift);
    my $url = shift;
    $url = "http://$url" unless $url =~ m!^/|://!;
    ref $url ? $req->url($url) : $req->url->parse($url);
  
    # Headers (we identify ourselves and accept gzip compression)
    my $headers = $req->headers;
    $headers->from_hash(shift) if ref $_[0] eq 'HASH';
    $headers->user_agent($self->name) unless $headers->user_agent;
    $headers->accept_encoding('gzip') unless $headers->accept_encoding;
  
    # Generator
    if (@_ > 1) {
      my $cb = $self->generators->{shift()};
      $self->$cb($tx, @_);
    }
  
    # Body
    elsif (@_) { $req->body(shift) }
  
    return $tx;
  }
  
  sub upgrade {
    my ($self, $tx) = @_;
    my $code = $tx->res->code // 0;
    return undef unless $tx->req->is_handshake && $code == 101;
    my $ws = Mojo::Transaction::WebSocket->new(handshake => $tx, masked => 1);
    return challenge($ws) ? $ws->established(1) : undef;
  }
  
  sub websocket {
    my $self = shift;
  
    # New WebSocket transaction
    my $sub = ref $_[-1] eq 'ARRAY' ? pop : [];
    my $tx = $self->tx(GET => @_);
    my $req = $tx->req;
    $req->headers->sec_websocket_protocol(join ', ', @$sub) if @$sub;
    my $url   = $req->url;
    my $proto = $url->protocol;
    $url->scheme($proto eq 'wss' ? 'https' : 'http') if $proto;
  
    # Handshake
    return client_handshake $tx;
  }
  
  sub _form {
    my ($self, $tx, $form, %options) = @_;
    $options{charset} = 'UTF-8' unless exists $options{charset};
  
    # Check for uploads and force multipart if necessary
    my $req       = $tx->req;
    my $headers   = $req->headers;
    my $multipart = ($headers->content_type // '') =~ m!multipart/form-data!i;
    for my $value (map { ref $_ eq 'ARRAY' ? @$_ : $_ } values %$form) {
      ++$multipart and last if ref $value eq 'HASH';
    }
  
    # Multipart
    if ($multipart) {
      my $parts = $self->_multipart($options{charset}, $form);
      $req->content(
        Mojo::Content::MultiPart->new(headers => $headers, parts => $parts));
      _type($headers, 'multipart/form-data');
      return $tx;
    }
  
    # Query parameters or urlencoded
    my $method = uc $req->method;
    my @form = map { $_ => $form->{$_} } sort keys %$form;
    if ($method eq 'GET' || $method eq 'HEAD') { $req->url->query->merge(@form) }
    else {
      $req->body(
        Mojo::Parameters->new(@form)->charset($options{charset})->to_string);
      _type($headers, 'application/x-www-form-urlencoded');
    }
    return $tx;
  }
  
  sub _json {
    my ($self, $tx, $data) = @_;
    _type($tx->req->body(encode_json $data)->headers, 'application/json');
    return $tx;
  }
  
  sub _multipart {
    my ($self, $charset, $form) = @_;
  
    my @parts;
    for my $name (sort keys %$form) {
      next unless defined(my $values = $form->{$name});
      for my $value (ref $values eq 'ARRAY' ? @$values : ($values)) {
        push @parts, my $part = Mojo::Content::Single->new;
  
        # Upload
        my $filename;
        my $headers = $part->headers;
        if (ref $value eq 'HASH') {
  
          # File
          if (my $file = delete $value->{file}) {
            $file = Mojo::Asset::File->new(path => $file) unless ref $file;
            $part->asset($file);
            $value->{filename} //= basename $file->path
              if $file->isa('Mojo::Asset::File');
          }
  
          # Memory
          elsif (defined(my $content = delete $value->{content})) {
            $part->asset(Mojo::Asset::Memory->new->add_chunk($content));
          }
  
          # Filename and headers
          $filename = url_escape delete $value->{filename} // $name, '"';
          $filename = encode $charset, $filename if $charset;
          $headers->from_hash($value);
        }
  
        # Field
        else {
          $value = encode $charset, $value if $charset;
          $part->asset(Mojo::Asset::Memory->new->add_chunk($value));
        }
  
        # Content-Disposition
        $name = url_escape $name, '"';
        $name = encode $charset, $name if $charset;
        my $disposition = qq{form-data; name="$name"};
        $disposition .= qq{; filename="$filename"} if defined $filename;
        $headers->content_disposition($disposition);
      }
    }
  
    return \@parts;
  }
  
  sub _proxy {
    my ($self, $tx, $proto, $host, $port) = @_;
  
    my $req = $tx->req;
    if ($req->via_proxy && (my $proxy = $req->proxy)) {
      return $proxy->protocol, $proxy->ihost,
        $proxy->port || ($proto eq 'https' ? 443 : 80);
    }
  
    return $proto, $host, $port;
  }
  
  sub _type { $_[0]->content_type($_[1]) unless $_[0]->content_type }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Transactor - User agent transactor
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Transactor;
  
    # GET request with Accept header
    my $t = Mojo::UserAgent::Transactor->new;
    say $t->tx(GET => 'http://example.com' => {Accept => '*/*'})->req->to_string;
  
    # POST request with form-data
    say $t->tx(POST => 'example.com' => form => {a => 'b'})->req->to_string;
  
    # PUT request with JSON data
    say $t->tx(PUT => 'example.com' => json => {a => 'b'})->req->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Transactor> is the transaction building and manipulation
  framework used by L<Mojo::UserAgent>.
  
  =head1 GENERATORS
  
  These content generators are available by default.
  
  =head2 form
  
    $t->tx(POST => 'http://example.com' => form => {a => 'b'});
  
  Generate query string, C<application/x-www-form-urlencoded> or
  C<multipart/form-data> content.
  
  =head2 json
  
    $t->tx(PATCH => 'http://example.com' => json => {a => 'b'});
  
  Generate JSON content with L<Mojo::JSON>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Transactor> implements the following attributes.
  
  =head2 generators
  
    my $generators = $t->generators;
    $t             = $t->generators({foo => sub {...}});
  
  Registered content generators, by default only C<form> and C<json> are already
  defined.
  
  =head2 name
  
    my $name = $t->name;
    $t       = $t->name('Mojolicious');
  
  Value for C<User-Agent> request header of generated transactions, defaults to
  C<Mojolicious (Perl)>.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Transactor> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_generator
  
    $t = $t->add_generator(foo => sub {...});
  
  Register a content generator.
  
    $t->add_generator(foo => sub {
      my ($t, $tx, @args) = @_;
      ...
    });
  
  =head2 endpoint
  
    my ($proto, $host, $port) = $t->endpoint(Mojo::Transaction::HTTP->new);
  
  Actual endpoint for transaction.
  
  =head2 peer
  
    my ($proto, $host, $port) = $t->peer(Mojo::Transaction::HTTP->new);
  
  Actual peer for transaction.
  
  =head2 proxy_connect
  
    my $tx = $t->proxy_connect(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::HTTP> proxy C<CONNECT> request for transaction if
  possible.
  
  =head2 redirect
  
    my $tx = $t->redirect(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::HTTP> follow-up request for C<301>, C<302>, C<303>,
  C<307> or C<308> redirect response if possible.
  
  =head2 tx
  
    my $tx = $t->tx(GET  => 'example.com');
    my $tx = $t->tx(POST => 'http://example.com');
    my $tx = $t->tx(GET  => 'http://example.com' => {Accept => '*/*'});
    my $tx = $t->tx(PUT  => 'http://example.com' => 'Hi!');
    my $tx = $t->tx(PUT  => 'http://example.com' => form => {a => 'b'});
    my $tx = $t->tx(PUT  => 'http://example.com' => json => {a => 'b'});
    my $tx = $t->tx(POST => 'http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $tx = $t->tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $t->tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Versatile general purpose L<Mojo::Transaction::HTTP> transaction builder for
  requests, with support for L</"GENERATORS">.
  
    # Generate and inspect custom GET request with DNT header and content
    say $t->tx(GET => 'example.com' => {DNT => 1} => 'Bye!')->req->to_string;
  
    # Stream response content to STDOUT
    my $tx = $t->tx(GET => 'http://example.com');
    $tx->res->content->unsubscribe('read')->on(read => sub { say $_[1] });
  
    # PUT request with content streamed from file
    my $tx = $t->tx(PUT => 'http://example.com');
    $tx->req->content->asset(Mojo::Asset::File->new(path => '/foo.txt'));
  
  The C<json> content generator uses L<Mojo::JSON> for encoding and sets the
  content type to C<application/json>.
  
    # POST request with "application/json" content
    my $tx = $t->tx(
      POST => 'http://example.com' => json => {a => 'b', c => [1, 2, 3]});
  
  The C<form> content generator will automatically use query parameters for
  C<GET> and C<HEAD> requests.
  
    # GET request with query parameters
    my $tx = $t->tx(GET => 'http://example.com' => form => {a => 'b'});
  
  For all other request methods the C<application/x-www-form-urlencoded> content
  type is used.
  
    # POST request with "application/x-www-form-urlencoded" content
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {a => 'b', c => 'd'});
  
  Parameters may be encoded with the C<charset> option.
  
    # PUT request with Shift_JIS encoded form values
    my $tx = $t->tx(
      PUT => 'example.com' => form => {a => 'b'} => charset => 'Shift_JIS');
  
  An array reference can be used for multiple form values sharing the same name.
  
    # POST request with form values sharing the same name
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {a => ['b', 'c', 'd']});
  
  A hash reference with a C<content> or C<file> value can be used to switch to
  the C<multipart/form-data> content type for file uploads.
  
    # POST request with "multipart/form-data" content
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {mytext => {content => 'lala'}});
  
    # POST request with multiple files sharing the same name
    my $tx = $t->tx(POST => 'http://example.com' =>
      form => {mytext => [{content => 'first'}, {content => 'second'}]});
  
  The C<file> value should contain the path to the file you want to upload or an
  asset object, like L<Mojo::Asset::File> or L<Mojo::Asset::Memory>.
  
    # POST request with upload streamed from file
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {mytext => {file => '/foo.txt'}});
  
    # POST request with upload streamed from asset
    my $asset = Mojo::Asset::Memory->new->add_chunk('lalala');
    my $tx    = $t->tx(
      POST => 'http://example.com' => form => {mytext => {file => $asset}});
  
  A C<filename> value will be generated automatically, but can also be set
  manually if necessary. All remaining values in the hash reference get merged
  into the C<multipart/form-data> content as headers.
  
    # POST request with form values and customized upload (filename and header)
    my $tx = $t->tx(POST => 'http://example.com' => form => {
      a      => 'b',
      c      => 'd',
      mytext => {
        content        => 'lalala',
        filename       => 'foo.txt',
        'Content-Type' => 'text/plain'
      }
    });
  
  The C<multipart/form-data> content type can also be enforced by setting the
  C<Content-Type> header manually.
  
    # Force "multipart/form-data"
    my $headers = {'Content-Type' => 'multipart/form-data'};
    my $tx = $t->tx(POST => 'example.com' => $headers => form => {a => 'b'});
  
  =head2 upgrade
  
    my $tx = $t->upgrade(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::WebSocket> follow-up transaction for WebSocket
  handshake if possible.
  
  =head2 websocket
  
    my $tx = $t->websocket('ws://example.com');
    my $tx = $t->websocket('ws://example.com' => {DNT => 1} => ['v1.proto']);
  
  Versatile L<Mojo::Transaction::HTTP> transaction builder for WebSocket
  handshake requests.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_TRANSACTOR

$fatpacked{"Mojo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UTIL';
  package Mojo::Util;
  use Mojo::Base -strict;
  
  use Carp qw(carp croak);
  use Data::Dumper ();
  use Digest::MD5 qw(md5 md5_hex);
  use Digest::SHA qw(hmac_sha1_hex sha1 sha1_hex);
  use Encode 'find_encoding';
  use Exporter 'import';
  use File::Find 'find';
  use IO::Poll qw(POLLIN POLLPRI);
  use List::Util 'min';
  use MIME::Base64 qw(decode_base64 encode_base64);
  use Symbol 'delete_package';
  use Time::HiRes ();
  
  # Check for monotonic clock support
  use constant MONOTONIC =>
    eval { !!Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) };
  
  # Punycode bootstring parameters
  use constant {
    PC_BASE         => 36,
    PC_TMIN         => 1,
    PC_TMAX         => 26,
    PC_SKEW         => 38,
    PC_DAMP         => 700,
    PC_INITIAL_BIAS => 72,
    PC_INITIAL_N    => 128
  };
  
  # To generate a new HTML entity table run this command
  # perl examples/entities.pl
  my %ENTITIES;
  for my $line (split "\n", join('', <DATA>)) {
    next unless $line =~ /^(\S+)\s+U\+(\S+)(?:\s+U\+(\S+))?/;
    $ENTITIES{$1} = defined $3 ? (chr(hex $2) . chr(hex $3)) : chr(hex $2);
  }
  
  # Characters that should be escaped in XML
  my %XML = (
    '&'  => '&amp;',
    '<'  => '&lt;',
    '>'  => '&gt;',
    '"'  => '&quot;',
    '\'' => '&#39;'
  );
  
  # "Sun, 06 Nov 1994 08:49:37 GMT" and "Sunday, 06-Nov-94 08:49:37 GMT"
  my $EXPIRES_RE = qr/(\w+\W+\d+\W+\w+\W+\d+\W+\d+:\d+:\d+\W*\w+)/;
  
  # Encoding cache
  my %CACHE;
  
  our @EXPORT_OK = (
    qw(b64_decode b64_encode camelize class_to_file class_to_path decamelize),
    qw(decode deprecated dumper encode files hmac_sha1_sum html_unescape),
    qw(md5_bytes md5_sum monkey_patch punycode_decode punycode_encode quote),
    qw(secure_compare sha1_bytes sha1_sum slurp split_cookie_header),
    qw(split_header spurt squish steady_time tablify term_escape trim unindent),
    qw(unquote url_escape url_unescape xml_escape xor_encode)
  );
  
  # Aliases
  monkey_patch(__PACKAGE__, 'b64_decode',    \&decode_base64);
  monkey_patch(__PACKAGE__, 'b64_encode',    \&encode_base64);
  monkey_patch(__PACKAGE__, 'hmac_sha1_sum', \&hmac_sha1_hex);
  monkey_patch(__PACKAGE__, 'md5_bytes',     \&md5);
  monkey_patch(__PACKAGE__, 'md5_sum',       \&md5_hex);
  monkey_patch(__PACKAGE__, 'sha1_bytes',    \&sha1);
  monkey_patch(__PACKAGE__, 'sha1_sum',      \&sha1_hex);
  
  # Use a monotonic clock if possible
  monkey_patch(__PACKAGE__, 'steady_time',
    MONOTONIC
    ? sub () { Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) }
    : \&Time::HiRes::time);
  
  sub camelize {
    my $str = shift;
    return $str if $str =~ /^[A-Z]/;
  
    # CamelCase words
    return join '::', map {
      join('', map { ucfirst lc } split '_')
    } split '-', $str;
  }
  
  sub class_to_file {
    my $class = shift;
    $class =~ s/::|'//g;
    $class =~ s/([A-Z])([A-Z]*)/$1 . lc $2/ge;
    return decamelize($class);
  }
  
  sub class_to_path { join '.', join('/', split(/::|'/, shift)), 'pm' }
  
  sub decamelize {
    my $str = shift;
    return $str if $str !~ /^[A-Z]/;
  
    # snake_case words
    return join '-', map {
      join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)
    } split '::', $str;
  }
  
  sub decode {
    my ($encoding, $bytes) = @_;
    return undef
      unless eval { $bytes = _encoding($encoding)->decode("$bytes", 1); 1 };
    return $bytes;
  }
  
  sub deprecated {
    local $Carp::CarpLevel = 1;
    $ENV{MOJO_FATAL_DEPRECATIONS} ? croak @_ : carp @_;
  }
  
  sub dumper {
    Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump;
  }
  
  sub encode { _encoding($_[0])->encode("$_[1]") }
  
  sub files {
    my ($dir, $options) = (shift, shift // {});
  
    # This may break in the future, but is worth it for performance
    local $File::Find::skip_pattern = qr/^\./ unless $options->{hidden};
  
    my %files;
    my $want = sub { $files{$File::Find::name}++ };
    my $post = sub { delete $files{$File::Find::dir} };
    find {wanted => $want, postprocess => $post, no_chdir => 1}, $dir if -d $dir;
  
    return sort keys %files;
  }
  
  sub html_unescape {
    my $str = shift;
    $str
      =~ s/&(?:\#((?:[0-9]{1,7}|x[0-9a-fA-F]{1,6}));|(\w+;?))/_decode($1, $2)/ge;
    return $str;
  }
  
  # Declared in Mojo::Base to avoid circular require problems
  sub monkey_patch { Mojo::Base::_monkey_patch(@_) }
  
  # Direct translation of RFC 3492
  sub punycode_decode {
    my $input = shift;
    use integer;
  
    my ($n, $i, $bias, @output) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
  
    # Consume all code points before the last delimiter
    push @output, split('', $1) if $input =~ s/(.*)\x2d//s;
  
    while (length $input) {
      my ($oldi, $w) = ($i, 1);
  
      # Base to infinity in steps of base
      for (my $k = PC_BASE; 1; $k += PC_BASE) {
        my $digit = ord substr $input, 0, 1, '';
        $digit = $digit < 0x40 ? $digit + (26 - 0x30) : ($digit & 0x1f) - 1;
        $i += $digit * $w;
        my $t = $k - $bias;
        $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
        last if $digit < $t;
        $w *= PC_BASE - $t;
      }
  
      $bias = _adapt($i - $oldi, @output + 1, $oldi == 0);
      $n += $i / (@output + 1);
      $i = $i % (@output + 1);
      splice @output, $i++, 0, chr $n;
    }
  
    return join '', @output;
  }
  
  # Direct translation of RFC 3492
  sub punycode_encode {
    my $output = shift;
    use integer;
  
    my ($n, $delta, $bias) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
  
    # Extract basic code points
    my @input = map {ord} split '', $output;
    $output =~ s/[^\x00-\x7f]+//gs;
    my $h = my $basic = length $output;
    $output .= "\x2d" if $basic > 0;
  
    for my $m (sort grep { $_ >= PC_INITIAL_N } @input) {
      next if $m < $n;
      $delta += ($m - $n) * ($h + 1);
      $n = $m;
  
      for my $c (@input) {
  
        if ($c < $n) { $delta++ }
        elsif ($c == $n) {
          my $q = $delta;
  
          # Base to infinity in steps of base
          for (my $k = PC_BASE; 1; $k += PC_BASE) {
            my $t = $k - $bias;
            $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
            last if $q < $t;
            my $o = $t + (($q - $t) % (PC_BASE - $t));
            $output .= chr $o + ($o < 26 ? 0x61 : 0x30 - 26);
            $q = ($q - $t) / (PC_BASE - $t);
          }
  
          $output .= chr $q + ($q < 26 ? 0x61 : 0x30 - 26);
          $bias = _adapt($delta, $h + 1, $h == $basic);
          $delta = 0;
          $h++;
        }
      }
  
      $delta++;
      $n++;
    }
  
    return $output;
  }
  
  sub quote {
    my $str = shift;
    $str =~ s/(["\\])/\\$1/g;
    return qq{"$str"};
  }
  
  sub secure_compare {
    my ($one, $two) = @_;
    return undef if length $one != length $two;
    my $r = 0;
    $r |= ord(substr $one, $_) ^ ord(substr $two, $_) for 0 .. length($one) - 1;
    return $r == 0;
  }
  
  sub slurp {
    my $path = shift;
  
    open my $file, '<', $path or croak qq{Can't open file "$path": $!};
    my $ret = my $content = '';
    while ($ret = $file->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
    croak qq{Can't read from file "$path": $!} unless defined $ret;
  
    return $content;
  }
  
  sub split_cookie_header { _header(shift, 1) }
  sub split_header        { _header(shift, 0) }
  
  sub spurt {
    my ($content, $path) = @_;
    open my $file, '>', $path or croak qq{Can't open file "$path": $!};
    defined $file->syswrite($content)
      or croak qq{Can't write to file "$path": $!};
    return $content;
  }
  
  sub squish {
    my $str = trim(@_);
    $str =~ s/\s+/ /g;
    return $str;
  }
  
  sub tablify {
    my $rows = shift;
  
    my @spec;
    for my $row (@$rows) {
      for my $i (0 .. $#$row) {
        ($row->[$i] //= '') =~ s/[\r\n]//g;
        my $len = length $row->[$i];
        $spec[$i] = $len if $len >= ($spec[$i] // 0);
      }
    }
  
    my $format = join '  ', map({"\%-${_}s"} @spec[0 .. $#spec - 1]), '%s';
    return join '', map { sprintf "$format\n", @$_ } @$rows;
  }
  
  sub term_escape {
    my $str = shift;
    $str =~ s/([\x00-\x09\x0b-\x1f\x7f\x80-\x9f])/sprintf '\\x%02x', ord $1/ge;
    return $str;
  }
  
  sub trim {
    my $str = shift;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    return $str;
  }
  
  sub unindent {
    my $str = shift;
    my $min = min map { m/^([ \t]*)/; length $1 || () } split "\n", $str;
    $str =~ s/^[ \t]{0,$min}//gm if $min;
    return $str;
  }
  
  sub unquote {
    my $str = shift;
    return $str unless $str =~ s/^"(.*)"$/$1/g;
    $str =~ s/\\\\/\\/g;
    $str =~ s/\\"/"/g;
    return $str;
  }
  
  sub url_escape {
    my ($str, $pattern) = @_;
    if   ($pattern) { $str =~ s/([$pattern])/sprintf '%%%02X', ord $1/ge }
    else            { $str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge }
    return $str;
  }
  
  sub url_unescape {
    my $str = shift;
    $str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;
    return $str;
  }
  
  sub xml_escape {
    return $_[0] if ref $_[0] && ref $_[0] eq 'Mojo::ByteStream';
    my $str = shift // '';
    $str =~ s/([&<>"'])/$XML{$1}/ge;
    return $str;
  }
  
  sub xor_encode {
    my ($input, $key) = @_;
  
    # Encode with variable key length
    my $len = length $key;
    my $buffer = my $output = '';
    $output .= $buffer ^ $key
      while length($buffer = substr($input, 0, $len, '')) == $len;
    return $output .= $buffer ^ substr($key, 0, length $buffer, '');
  }
  
  sub _adapt {
    my ($delta, $numpoints, $firsttime) = @_;
    use integer;
  
    $delta = $firsttime ? $delta / PC_DAMP : $delta / 2;
    $delta += $delta / $numpoints;
    my $k = 0;
    while ($delta > ((PC_BASE - PC_TMIN) * PC_TMAX) / 2) {
      $delta /= PC_BASE - PC_TMIN;
      $k += PC_BASE;
    }
  
    return $k + (((PC_BASE - PC_TMIN + 1) * $delta) / ($delta + PC_SKEW));
  }
  
  sub _decode {
    my ($point, $name) = @_;
  
    # Code point
    return chr($point !~ /^x/ ? $point : hex $point) unless defined $name;
  
    # Named character reference
    my $rest = '';
    while (length $name) {
      return $ENTITIES{$name} . reverse $rest if exists $ENTITIES{$name};
      $rest .= chop $name;
    }
    return '&' . reverse $rest;
  }
  
  sub _encoding {
    $CACHE{$_[0]} //= find_encoding($_[0]) // croak "Unknown encoding '$_[0]'";
  }
  
  # Supported on Perl 5.14+
  sub _global_destruction {
    defined ${^GLOBAL_PHASE} && ${^GLOBAL_PHASE} eq 'DESTRUCT';
  }
  
  sub _header {
    my ($str, $cookie) = @_;
  
    my (@tree, @part);
    while ($str =~ /\G[,;\s]*([^=;, ]+)\s*/gc) {
      push @part, $1, undef;
      my $expires = $cookie && @part > 2 && lc $1 eq 'expires';
  
      # Special "expires" value
      if ($expires && $str =~ /\G=\s*$EXPIRES_RE/gco) { $part[-1] = $1 }
  
      # Quoted value
      elsif ($str =~ /\G=\s*("(?:\\\\|\\"|[^"])*")/gc) { $part[-1] = unquote $1 }
  
      # Unquoted value
      elsif ($str =~ /\G=\s*([^;, ]*)/gc) { $part[-1] = $1 }
  
      # Separator
      next unless $str =~ /\G[;\s]*,\s*/gc;
      push @tree, [@part];
      @part = ();
    }
  
    # Take care of final part
    return [@part ? (@tree, \@part) : @tree];
  }
  
  sub _options {
  
    # Hash or name (one)
    return ref $_[0] eq 'HASH' ? (undef, %{shift()}) : @_ if @_ == 1;
  
    # Name and values (odd)
    return shift, @_ if @_ % 2;
  
    # Name and hash or just values (even)
    return ref $_[1] eq 'HASH' ? (shift, %{shift()}) : (undef, @_);
  }
  
  # This may break in the future, but is worth it for performance
  sub _readable { !!(IO::Poll::_poll(@_[0, 1], my $m = POLLIN | POLLPRI) > 0) }
  
  sub _stash {
    my ($name, $object) = (shift, shift);
  
    # Hash
    return $object->{$name} ||= {} unless @_;
  
    # Get
    return $object->{$name}{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @{$object->{$name}}{keys %$values} = values %$values;
  
    return $object;
  }
  
  sub _teardown {
    return unless my $class = shift;
  
    # @ISA has to be cleared first because of circular references
    no strict 'refs';
    @{"${class}::ISA"} = ();
    delete_package $class;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Util - Portable utility functions
  
  =head1 SYNOPSIS
  
    use Mojo::Util qw(b64_encode url_escape url_unescape);
  
    my $str = 'test=23';
    my $escaped = url_escape $str;
    say url_unescape $escaped;
    say b64_encode $escaped, '';
  
  =head1 DESCRIPTION
  
  L<Mojo::Util> provides portable utility functions for L<Mojo>.
  
  =head1 FUNCTIONS
  
  L<Mojo::Util> implements the following functions, which can be imported
  individually.
  
  =head2 b64_decode
  
    my $bytes = b64_decode $b64;
  
  Base64 decode bytes.
  
  =head2 b64_encode
  
    my $b64 = b64_encode $bytes;
    my $b64 = b64_encode $bytes, "\n";
  
  Base64 encode bytes, the line ending defaults to a newline.
  
  =head2 camelize
  
    my $camelcase = camelize $snakecase;
  
  Convert C<snake_case> string to C<CamelCase> and replace C<-> with C<::>.
  
    # "FooBar"
    camelize 'foo_bar';
  
    # "FooBar::Baz"
    camelize 'foo_bar-baz';
  
    # "FooBar::Baz"
    camelize 'FooBar::Baz';
  
  =head2 class_to_file
  
    my $file = class_to_file 'Foo::Bar';
  
  Convert a class name to a file.
  
    # "foo_bar"
    class_to_file 'Foo::Bar';
  
    # "foobar"
    class_to_file 'FOO::Bar';
  
    # "foo_bar"
    class_to_file 'FooBar';
  
    # "foobar"
    class_to_file 'FOOBar';
  
  =head2 class_to_path
  
    my $path = class_to_path 'Foo::Bar';
  
  Convert class name to path.
  
    # "Foo/Bar.pm"
    class_to_path 'Foo::Bar';
  
    # "FooBar.pm"
    class_to_path 'FooBar';
  
  =head2 decamelize
  
    my $snakecase = decamelize $camelcase;
  
  Convert C<CamelCase> string to C<snake_case> and replace C<::> with C<->.
  
    # "foo_bar"
    decamelize 'FooBar';
  
    # "foo_bar-baz"
    decamelize 'FooBar::Baz';
  
    # "foo_bar-baz"
    decamelize 'foo_bar-baz';
  
  =head2 decode
  
    my $chars = decode 'UTF-8', $bytes;
  
  Decode bytes to characters, or return C<undef> if decoding failed.
  
  =head2 deprecated
  
    deprecated 'foo is DEPRECATED in favor of bar';
  
  Warn about deprecated feature from perspective of caller. You can also set the
  C<MOJO_FATAL_DEPRECATIONS> environment variable to make them die instead.
  
  =head2 dumper
  
    my $perl = dumper {some => 'data'};
  
  Dump a Perl data structure with L<Data::Dumper>.
  
  =head2 encode
  
    my $bytes = encode 'UTF-8', $chars;
  
  Encode characters to bytes.
  
  =head2 files
  
    my @files = files '/tmp/uploads';
    my @files = files '/tmp/uploads', {hidden => 1};
  
  List all files recursively in a directory.
  
    # List all templates
    say for files '/home/sri/myapp/templates';
  
  These options are currently available:
  
  =over 2
  
  =item hidden
  
    hidden => 1
  
  Include hidden files and directories.
  
  =back
  
  =head2 hmac_sha1_sum
  
    my $checksum = hmac_sha1_sum $bytes, 'passw0rd';
  
  Generate HMAC-SHA1 checksum for bytes.
  
    # "11cedfd5ec11adc0ec234466d8a0f2a83736aa68"
    hmac_sha1_sum 'foo', 'passw0rd';
  
  =head2 html_unescape
  
    my $str = html_unescape $escaped;
  
  Unescape all HTML entities in string.
  
    # "<div>"
    html_unescape '&lt;div&gt;';
  
  =head2 md5_bytes
  
    my $checksum = md5_bytes $bytes;
  
  Generate binary MD5 checksum for bytes.
  
  =head2 md5_sum
  
    my $checksum = md5_sum $bytes;
  
  Generate MD5 checksum for bytes.
  
    # "acbd18db4cc2f85cedef654fccc4a4d8"
    md5_sum 'foo';
  
  =head2 monkey_patch
  
    monkey_patch $package, foo => sub {...};
    monkey_patch $package, foo => sub {...}, bar => sub {...};
  
  Monkey patch functions into package.
  
    monkey_patch 'MyApp',
      one   => sub { say 'One!' },
      two   => sub { say 'Two!' },
      three => sub { say 'Three!' };
  
  =head2 punycode_decode
  
    my $str = punycode_decode $punycode;
  
  Punycode decode string as described in
  L<RFC 3492|http://tools.ietf.org/html/rfc3492>.
  
    # "bücher"
    punycode_decode 'bcher-kva';
  
  =head2 punycode_encode
  
    my $punycode = punycode_encode $str;
  
  Punycode encode string as described in
  L<RFC 3492|http://tools.ietf.org/html/rfc3492>.
  
    # "bcher-kva"
    punycode_encode 'bücher';
  
  =head2 quote
  
    my $quoted = quote $str;
  
  Quote string.
  
  =head2 secure_compare
  
    my $bool = secure_compare $str1, $str2;
  
  Constant time comparison algorithm to prevent timing attacks.
  
  =head2 sha1_bytes
  
    my $checksum = sha1_bytes $bytes;
  
  Generate binary SHA1 checksum for bytes.
  
  =head2 sha1_sum
  
    my $checksum = sha1_sum $bytes;
  
  Generate SHA1 checksum for bytes.
  
    # "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"
    sha1_sum 'foo';
  
  =head2 slurp
  
    my $bytes = slurp '/etc/passwd';
  
  Read all data at once from file.
  
  =head2 split_cookie_header
  
    my $tree = split_cookie_header 'a=b; expires=Thu, 07 Aug 2008 07:07:59 GMT';
  
  Same as L</"split_header">, but handles C<expires> values from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 split_header
  
     my $tree = split_header 'foo="bar baz"; test=123, yada';
  
  Split HTTP header value into key/value pairs, each comma separated part gets
  its own array reference, and keys without a value get C<undef> assigned.
  
    # "one"
    split_header('one; two="three four", five=six')->[0][0];
  
    # "two"
    split_header('one; two="three four", five=six')->[0][2];
  
    # "three four"
    split_header('one; two="three four", five=six')->[0][3];
  
    # "five"
    split_header('one; two="three four", five=six')->[1][0];
  
    # "six"
    split_header('one; two="three four", five=six')->[1][1];
  
  =head2 spurt
  
    $bytes = spurt $bytes, '/etc/passwd';
  
  Write all data at once to file.
  
  =head2 squish
  
    my $squished = squish $str;
  
  Trim whitespace characters from both ends of string and then change all
  consecutive groups of whitespace into one space each.
  
    # "foo bar"
    squish '  foo  bar  ';
  
  =head2 steady_time
  
    my $time = steady_time;
  
  High resolution time elapsed from an arbitrary fixed point in the past,
  resilient to time jumps if a monotonic clock is available through
  L<Time::HiRes>.
  
  =head2 tablify
  
    my $table = tablify [['foo', 'bar'], ['baz', 'yada']];
  
  Row-oriented generator for text tables.
  
    # "foo   bar\nyada  yada\nbaz   yada\n"
    tablify [['foo', 'bar'], ['yada', 'yada'], ['baz', 'yada']];
  
  =head2 term_escape
  
    my $escaped = term_escape $str;
  
  Escape all POSIX control characters except for C<\n>.
  
    # "foo\\x09bar\\x0d\n"
    term_escape "foo\tbar\r\n";
  
  =head2 trim
  
    my $trimmed = trim $str;
  
  Trim whitespace characters from both ends of string.
  
    # "foo bar"
    trim '  foo bar  ';
  
  =head2 unindent
  
    my $unindented = unindent $str;
  
  Unindent multi-line string.
  
    # "foo\nbar\nbaz\n"
    unindent "  foo\n  bar\n  baz\n";
  
  =head2 unquote
  
    my $str = unquote $quoted;
  
  Unquote string.
  
  =head2 url_escape
  
    my $escaped = url_escape $str;
    my $escaped = url_escape $str, '^A-Za-z0-9\-._~';
  
  Percent encode unsafe characters in string as described in
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>, the pattern used defaults to
  C<^A-Za-z0-9\-._~>.
  
    # "foo%3Bbar"
    url_escape 'foo;bar';
  
  =head2 url_unescape
  
    my $str = url_unescape $escaped;
  
  Decode percent encoded characters in string as described in
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>.
  
    # "foo;bar"
    url_unescape 'foo%3Bbar';
  
  =head2 xml_escape
  
    my $escaped = xml_escape $str;
  
  Escape unsafe characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in string, but
  do not escape L<Mojo::ByteStream> objects.
  
    # "&lt;div&gt;"
    xml_escape '<div>';
  
    # "<div>"
    use Mojo::ByteStream 'b';
    xml_escape b('<div>');
  
  =head2 xor_encode
  
    my $encoded = xor_encode $str, $key;
  
  XOR encode string with variable length key.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  Aacute; U+000C1
  Aacute U+000C1
  aacute; U+000E1
  aacute U+000E1
  Abreve; U+00102
  abreve; U+00103
  ac; U+0223E
  acd; U+0223F
  acE; U+0223E U+00333
  Acirc; U+000C2
  Acirc U+000C2
  acirc; U+000E2
  acirc U+000E2
  acute; U+000B4
  acute U+000B4
  Acy; U+00410
  acy; U+00430
  AElig; U+000C6
  AElig U+000C6
  aelig; U+000E6
  aelig U+000E6
  af; U+02061
  Afr; U+1D504
  afr; U+1D51E
  Agrave; U+000C0
  Agrave U+000C0
  agrave; U+000E0
  agrave U+000E0
  alefsym; U+02135
  aleph; U+02135
  Alpha; U+00391
  alpha; U+003B1
  Amacr; U+00100
  amacr; U+00101
  amalg; U+02A3F
  AMP; U+00026
  AMP U+00026
  amp; U+00026
  amp U+00026
  And; U+02A53
  and; U+02227
  andand; U+02A55
  andd; U+02A5C
  andslope; U+02A58
  andv; U+02A5A
  ang; U+02220
  ange; U+029A4
  angle; U+02220
  angmsd; U+02221
  angmsdaa; U+029A8
  angmsdab; U+029A9
  angmsdac; U+029AA
  angmsdad; U+029AB
  angmsdae; U+029AC
  angmsdaf; U+029AD
  angmsdag; U+029AE
  angmsdah; U+029AF
  angrt; U+0221F
  angrtvb; U+022BE
  angrtvbd; U+0299D
  angsph; U+02222
  angst; U+000C5
  angzarr; U+0237C
  Aogon; U+00104
  aogon; U+00105
  Aopf; U+1D538
  aopf; U+1D552
  ap; U+02248
  apacir; U+02A6F
  apE; U+02A70
  ape; U+0224A
  apid; U+0224B
  apos; U+00027
  ApplyFunction; U+02061
  approx; U+02248
  approxeq; U+0224A
  Aring; U+000C5
  Aring U+000C5
  aring; U+000E5
  aring U+000E5
  Ascr; U+1D49C
  ascr; U+1D4B6
  Assign; U+02254
  ast; U+0002A
  asymp; U+02248
  asympeq; U+0224D
  Atilde; U+000C3
  Atilde U+000C3
  atilde; U+000E3
  atilde U+000E3
  Auml; U+000C4
  Auml U+000C4
  auml; U+000E4
  auml U+000E4
  awconint; U+02233
  awint; U+02A11
  backcong; U+0224C
  backepsilon; U+003F6
  backprime; U+02035
  backsim; U+0223D
  backsimeq; U+022CD
  Backslash; U+02216
  Barv; U+02AE7
  barvee; U+022BD
  Barwed; U+02306
  barwed; U+02305
  barwedge; U+02305
  bbrk; U+023B5
  bbrktbrk; U+023B6
  bcong; U+0224C
  Bcy; U+00411
  bcy; U+00431
  bdquo; U+0201E
  becaus; U+02235
  Because; U+02235
  because; U+02235
  bemptyv; U+029B0
  bepsi; U+003F6
  bernou; U+0212C
  Bernoullis; U+0212C
  Beta; U+00392
  beta; U+003B2
  beth; U+02136
  between; U+0226C
  Bfr; U+1D505
  bfr; U+1D51F
  bigcap; U+022C2
  bigcirc; U+025EF
  bigcup; U+022C3
  bigodot; U+02A00
  bigoplus; U+02A01
  bigotimes; U+02A02
  bigsqcup; U+02A06
  bigstar; U+02605
  bigtriangledown; U+025BD
  bigtriangleup; U+025B3
  biguplus; U+02A04
  bigvee; U+022C1
  bigwedge; U+022C0
  bkarow; U+0290D
  blacklozenge; U+029EB
  blacksquare; U+025AA
  blacktriangle; U+025B4
  blacktriangledown; U+025BE
  blacktriangleleft; U+025C2
  blacktriangleright; U+025B8
  blank; U+02423
  blk12; U+02592
  blk14; U+02591
  blk34; U+02593
  block; U+02588
  bne; U+0003D U+020E5
  bnequiv; U+02261 U+020E5
  bNot; U+02AED
  bnot; U+02310
  Bopf; U+1D539
  bopf; U+1D553
  bot; U+022A5
  bottom; U+022A5
  bowtie; U+022C8
  boxbox; U+029C9
  boxDL; U+02557
  boxDl; U+02556
  boxdL; U+02555
  boxdl; U+02510
  boxDR; U+02554
  boxDr; U+02553
  boxdR; U+02552
  boxdr; U+0250C
  boxH; U+02550
  boxh; U+02500
  boxHD; U+02566
  boxHd; U+02564
  boxhD; U+02565
  boxhd; U+0252C
  boxHU; U+02569
  boxHu; U+02567
  boxhU; U+02568
  boxhu; U+02534
  boxminus; U+0229F
  boxplus; U+0229E
  boxtimes; U+022A0
  boxUL; U+0255D
  boxUl; U+0255C
  boxuL; U+0255B
  boxul; U+02518
  boxUR; U+0255A
  boxUr; U+02559
  boxuR; U+02558
  boxur; U+02514
  boxV; U+02551
  boxv; U+02502
  boxVH; U+0256C
  boxVh; U+0256B
  boxvH; U+0256A
  boxvh; U+0253C
  boxVL; U+02563
  boxVl; U+02562
  boxvL; U+02561
  boxvl; U+02524
  boxVR; U+02560
  boxVr; U+0255F
  boxvR; U+0255E
  boxvr; U+0251C
  bprime; U+02035
  Breve; U+002D8
  breve; U+002D8
  brvbar; U+000A6
  brvbar U+000A6
  Bscr; U+0212C
  bscr; U+1D4B7
  bsemi; U+0204F
  bsim; U+0223D
  bsime; U+022CD
  bsol; U+0005C
  bsolb; U+029C5
  bsolhsub; U+027C8
  bull; U+02022
  bullet; U+02022
  bump; U+0224E
  bumpE; U+02AAE
  bumpe; U+0224F
  Bumpeq; U+0224E
  bumpeq; U+0224F
  Cacute; U+00106
  cacute; U+00107
  Cap; U+022D2
  cap; U+02229
  capand; U+02A44
  capbrcup; U+02A49
  capcap; U+02A4B
  capcup; U+02A47
  capdot; U+02A40
  CapitalDifferentialD; U+02145
  caps; U+02229 U+0FE00
  caret; U+02041
  caron; U+002C7
  Cayleys; U+0212D
  ccaps; U+02A4D
  Ccaron; U+0010C
  ccaron; U+0010D
  Ccedil; U+000C7
  Ccedil U+000C7
  ccedil; U+000E7
  ccedil U+000E7
  Ccirc; U+00108
  ccirc; U+00109
  Cconint; U+02230
  ccups; U+02A4C
  ccupssm; U+02A50
  Cdot; U+0010A
  cdot; U+0010B
  cedil; U+000B8
  cedil U+000B8
  Cedilla; U+000B8
  cemptyv; U+029B2
  cent; U+000A2
  cent U+000A2
  CenterDot; U+000B7
  centerdot; U+000B7
  Cfr; U+0212D
  cfr; U+1D520
  CHcy; U+00427
  chcy; U+00447
  check; U+02713
  checkmark; U+02713
  Chi; U+003A7
  chi; U+003C7
  cir; U+025CB
  circ; U+002C6
  circeq; U+02257
  circlearrowleft; U+021BA
  circlearrowright; U+021BB
  circledast; U+0229B
  circledcirc; U+0229A
  circleddash; U+0229D
  CircleDot; U+02299
  circledR; U+000AE
  circledS; U+024C8
  CircleMinus; U+02296
  CirclePlus; U+02295
  CircleTimes; U+02297
  cirE; U+029C3
  cire; U+02257
  cirfnint; U+02A10
  cirmid; U+02AEF
  cirscir; U+029C2
  ClockwiseContourIntegral; U+02232
  CloseCurlyDoubleQuote; U+0201D
  CloseCurlyQuote; U+02019
  clubs; U+02663
  clubsuit; U+02663
  Colon; U+02237
  colon; U+0003A
  Colone; U+02A74
  colone; U+02254
  coloneq; U+02254
  comma; U+0002C
  commat; U+00040
  comp; U+02201
  compfn; U+02218
  complement; U+02201
  complexes; U+02102
  cong; U+02245
  congdot; U+02A6D
  Congruent; U+02261
  Conint; U+0222F
  conint; U+0222E
  ContourIntegral; U+0222E
  Copf; U+02102
  copf; U+1D554
  coprod; U+02210
  Coproduct; U+02210
  COPY; U+000A9
  COPY U+000A9
  copy; U+000A9
  copy U+000A9
  copysr; U+02117
  CounterClockwiseContourIntegral; U+02233
  crarr; U+021B5
  Cross; U+02A2F
  cross; U+02717
  Cscr; U+1D49E
  cscr; U+1D4B8
  csub; U+02ACF
  csube; U+02AD1
  csup; U+02AD0
  csupe; U+02AD2
  ctdot; U+022EF
  cudarrl; U+02938
  cudarrr; U+02935
  cuepr; U+022DE
  cuesc; U+022DF
  cularr; U+021B6
  cularrp; U+0293D
  Cup; U+022D3
  cup; U+0222A
  cupbrcap; U+02A48
  CupCap; U+0224D
  cupcap; U+02A46
  cupcup; U+02A4A
  cupdot; U+0228D
  cupor; U+02A45
  cups; U+0222A U+0FE00
  curarr; U+021B7
  curarrm; U+0293C
  curlyeqprec; U+022DE
  curlyeqsucc; U+022DF
  curlyvee; U+022CE
  curlywedge; U+022CF
  curren; U+000A4
  curren U+000A4
  curvearrowleft; U+021B6
  curvearrowright; U+021B7
  cuvee; U+022CE
  cuwed; U+022CF
  cwconint; U+02232
  cwint; U+02231
  cylcty; U+0232D
  Dagger; U+02021
  dagger; U+02020
  daleth; U+02138
  Darr; U+021A1
  dArr; U+021D3
  darr; U+02193
  dash; U+02010
  Dashv; U+02AE4
  dashv; U+022A3
  dbkarow; U+0290F
  dblac; U+002DD
  Dcaron; U+0010E
  dcaron; U+0010F
  Dcy; U+00414
  dcy; U+00434
  DD; U+02145
  dd; U+02146
  ddagger; U+02021
  ddarr; U+021CA
  DDotrahd; U+02911
  ddotseq; U+02A77
  deg; U+000B0
  deg U+000B0
  Del; U+02207
  Delta; U+00394
  delta; U+003B4
  demptyv; U+029B1
  dfisht; U+0297F
  Dfr; U+1D507
  dfr; U+1D521
  dHar; U+02965
  dharl; U+021C3
  dharr; U+021C2
  DiacriticalAcute; U+000B4
  DiacriticalDot; U+002D9
  DiacriticalDoubleAcute; U+002DD
  DiacriticalGrave; U+00060
  DiacriticalTilde; U+002DC
  diam; U+022C4
  Diamond; U+022C4
  diamond; U+022C4
  diamondsuit; U+02666
  diams; U+02666
  die; U+000A8
  DifferentialD; U+02146
  digamma; U+003DD
  disin; U+022F2
  div; U+000F7
  divide; U+000F7
  divide U+000F7
  divideontimes; U+022C7
  divonx; U+022C7
  DJcy; U+00402
  djcy; U+00452
  dlcorn; U+0231E
  dlcrop; U+0230D
  dollar; U+00024
  Dopf; U+1D53B
  dopf; U+1D555
  Dot; U+000A8
  dot; U+002D9
  DotDot; U+020DC
  doteq; U+02250
  doteqdot; U+02251
  DotEqual; U+02250
  dotminus; U+02238
  dotplus; U+02214
  dotsquare; U+022A1
  doublebarwedge; U+02306
  DoubleContourIntegral; U+0222F
  DoubleDot; U+000A8
  DoubleDownArrow; U+021D3
  DoubleLeftArrow; U+021D0
  DoubleLeftRightArrow; U+021D4
  DoubleLeftTee; U+02AE4
  DoubleLongLeftArrow; U+027F8
  DoubleLongLeftRightArrow; U+027FA
  DoubleLongRightArrow; U+027F9
  DoubleRightArrow; U+021D2
  DoubleRightTee; U+022A8
  DoubleUpArrow; U+021D1
  DoubleUpDownArrow; U+021D5
  DoubleVerticalBar; U+02225
  DownArrow; U+02193
  Downarrow; U+021D3
  downarrow; U+02193
  DownArrowBar; U+02913
  DownArrowUpArrow; U+021F5
  DownBreve; U+00311
  downdownarrows; U+021CA
  downharpoonleft; U+021C3
  downharpoonright; U+021C2
  DownLeftRightVector; U+02950
  DownLeftTeeVector; U+0295E
  DownLeftVector; U+021BD
  DownLeftVectorBar; U+02956
  DownRightTeeVector; U+0295F
  DownRightVector; U+021C1
  DownRightVectorBar; U+02957
  DownTee; U+022A4
  DownTeeArrow; U+021A7
  drbkarow; U+02910
  drcorn; U+0231F
  drcrop; U+0230C
  Dscr; U+1D49F
  dscr; U+1D4B9
  DScy; U+00405
  dscy; U+00455
  dsol; U+029F6
  Dstrok; U+00110
  dstrok; U+00111
  dtdot; U+022F1
  dtri; U+025BF
  dtrif; U+025BE
  duarr; U+021F5
  duhar; U+0296F
  dwangle; U+029A6
  DZcy; U+0040F
  dzcy; U+0045F
  dzigrarr; U+027FF
  Eacute; U+000C9
  Eacute U+000C9
  eacute; U+000E9
  eacute U+000E9
  easter; U+02A6E
  Ecaron; U+0011A
  ecaron; U+0011B
  ecir; U+02256
  Ecirc; U+000CA
  Ecirc U+000CA
  ecirc; U+000EA
  ecirc U+000EA
  ecolon; U+02255
  Ecy; U+0042D
  ecy; U+0044D
  eDDot; U+02A77
  Edot; U+00116
  eDot; U+02251
  edot; U+00117
  ee; U+02147
  efDot; U+02252
  Efr; U+1D508
  efr; U+1D522
  eg; U+02A9A
  Egrave; U+000C8
  Egrave U+000C8
  egrave; U+000E8
  egrave U+000E8
  egs; U+02A96
  egsdot; U+02A98
  el; U+02A99
  Element; U+02208
  elinters; U+023E7
  ell; U+02113
  els; U+02A95
  elsdot; U+02A97
  Emacr; U+00112
  emacr; U+00113
  empty; U+02205
  emptyset; U+02205
  EmptySmallSquare; U+025FB
  emptyv; U+02205
  EmptyVerySmallSquare; U+025AB
  emsp; U+02003
  emsp13; U+02004
  emsp14; U+02005
  ENG; U+0014A
  eng; U+0014B
  ensp; U+02002
  Eogon; U+00118
  eogon; U+00119
  Eopf; U+1D53C
  eopf; U+1D556
  epar; U+022D5
  eparsl; U+029E3
  eplus; U+02A71
  epsi; U+003B5
  Epsilon; U+00395
  epsilon; U+003B5
  epsiv; U+003F5
  eqcirc; U+02256
  eqcolon; U+02255
  eqsim; U+02242
  eqslantgtr; U+02A96
  eqslantless; U+02A95
  Equal; U+02A75
  equals; U+0003D
  EqualTilde; U+02242
  equest; U+0225F
  Equilibrium; U+021CC
  equiv; U+02261
  equivDD; U+02A78
  eqvparsl; U+029E5
  erarr; U+02971
  erDot; U+02253
  Escr; U+02130
  escr; U+0212F
  esdot; U+02250
  Esim; U+02A73
  esim; U+02242
  Eta; U+00397
  eta; U+003B7
  ETH; U+000D0
  ETH U+000D0
  eth; U+000F0
  eth U+000F0
  Euml; U+000CB
  Euml U+000CB
  euml; U+000EB
  euml U+000EB
  euro; U+020AC
  excl; U+00021
  exist; U+02203
  Exists; U+02203
  expectation; U+02130
  ExponentialE; U+02147
  exponentiale; U+02147
  fallingdotseq; U+02252
  Fcy; U+00424
  fcy; U+00444
  female; U+02640
  ffilig; U+0FB03
  fflig; U+0FB00
  ffllig; U+0FB04
  Ffr; U+1D509
  ffr; U+1D523
  filig; U+0FB01
  FilledSmallSquare; U+025FC
  FilledVerySmallSquare; U+025AA
  fjlig; U+00066 U+0006A
  flat; U+0266D
  fllig; U+0FB02
  fltns; U+025B1
  fnof; U+00192
  Fopf; U+1D53D
  fopf; U+1D557
  ForAll; U+02200
  forall; U+02200
  fork; U+022D4
  forkv; U+02AD9
  Fouriertrf; U+02131
  fpartint; U+02A0D
  frac12; U+000BD
  frac12 U+000BD
  frac13; U+02153
  frac14; U+000BC
  frac14 U+000BC
  frac15; U+02155
  frac16; U+02159
  frac18; U+0215B
  frac23; U+02154
  frac25; U+02156
  frac34; U+000BE
  frac34 U+000BE
  frac35; U+02157
  frac38; U+0215C
  frac45; U+02158
  frac56; U+0215A
  frac58; U+0215D
  frac78; U+0215E
  frasl; U+02044
  frown; U+02322
  Fscr; U+02131
  fscr; U+1D4BB
  gacute; U+001F5
  Gamma; U+00393
  gamma; U+003B3
  Gammad; U+003DC
  gammad; U+003DD
  gap; U+02A86
  Gbreve; U+0011E
  gbreve; U+0011F
  Gcedil; U+00122
  Gcirc; U+0011C
  gcirc; U+0011D
  Gcy; U+00413
  gcy; U+00433
  Gdot; U+00120
  gdot; U+00121
  gE; U+02267
  ge; U+02265
  gEl; U+02A8C
  gel; U+022DB
  geq; U+02265
  geqq; U+02267
  geqslant; U+02A7E
  ges; U+02A7E
  gescc; U+02AA9
  gesdot; U+02A80
  gesdoto; U+02A82
  gesdotol; U+02A84
  gesl; U+022DB U+0FE00
  gesles; U+02A94
  Gfr; U+1D50A
  gfr; U+1D524
  Gg; U+022D9
  gg; U+0226B
  ggg; U+022D9
  gimel; U+02137
  GJcy; U+00403
  gjcy; U+00453
  gl; U+02277
  gla; U+02AA5
  glE; U+02A92
  glj; U+02AA4
  gnap; U+02A8A
  gnapprox; U+02A8A
  gnE; U+02269
  gne; U+02A88
  gneq; U+02A88
  gneqq; U+02269
  gnsim; U+022E7
  Gopf; U+1D53E
  gopf; U+1D558
  grave; U+00060
  GreaterEqual; U+02265
  GreaterEqualLess; U+022DB
  GreaterFullEqual; U+02267
  GreaterGreater; U+02AA2
  GreaterLess; U+02277
  GreaterSlantEqual; U+02A7E
  GreaterTilde; U+02273
  Gscr; U+1D4A2
  gscr; U+0210A
  gsim; U+02273
  gsime; U+02A8E
  gsiml; U+02A90
  GT; U+0003E
  GT U+0003E
  Gt; U+0226B
  gt; U+0003E
  gt U+0003E
  gtcc; U+02AA7
  gtcir; U+02A7A
  gtdot; U+022D7
  gtlPar; U+02995
  gtquest; U+02A7C
  gtrapprox; U+02A86
  gtrarr; U+02978
  gtrdot; U+022D7
  gtreqless; U+022DB
  gtreqqless; U+02A8C
  gtrless; U+02277
  gtrsim; U+02273
  gvertneqq; U+02269 U+0FE00
  gvnE; U+02269 U+0FE00
  Hacek; U+002C7
  hairsp; U+0200A
  half; U+000BD
  hamilt; U+0210B
  HARDcy; U+0042A
  hardcy; U+0044A
  hArr; U+021D4
  harr; U+02194
  harrcir; U+02948
  harrw; U+021AD
  Hat; U+0005E
  hbar; U+0210F
  Hcirc; U+00124
  hcirc; U+00125
  hearts; U+02665
  heartsuit; U+02665
  hellip; U+02026
  hercon; U+022B9
  Hfr; U+0210C
  hfr; U+1D525
  HilbertSpace; U+0210B
  hksearow; U+02925
  hkswarow; U+02926
  hoarr; U+021FF
  homtht; U+0223B
  hookleftarrow; U+021A9
  hookrightarrow; U+021AA
  Hopf; U+0210D
  hopf; U+1D559
  horbar; U+02015
  HorizontalLine; U+02500
  Hscr; U+0210B
  hscr; U+1D4BD
  hslash; U+0210F
  Hstrok; U+00126
  hstrok; U+00127
  HumpDownHump; U+0224E
  HumpEqual; U+0224F
  hybull; U+02043
  hyphen; U+02010
  Iacute; U+000CD
  Iacute U+000CD
  iacute; U+000ED
  iacute U+000ED
  ic; U+02063
  Icirc; U+000CE
  Icirc U+000CE
  icirc; U+000EE
  icirc U+000EE
  Icy; U+00418
  icy; U+00438
  Idot; U+00130
  IEcy; U+00415
  iecy; U+00435
  iexcl; U+000A1
  iexcl U+000A1
  iff; U+021D4
  Ifr; U+02111
  ifr; U+1D526
  Igrave; U+000CC
  Igrave U+000CC
  igrave; U+000EC
  igrave U+000EC
  ii; U+02148
  iiiint; U+02A0C
  iiint; U+0222D
  iinfin; U+029DC
  iiota; U+02129
  IJlig; U+00132
  ijlig; U+00133
  Im; U+02111
  Imacr; U+0012A
  imacr; U+0012B
  image; U+02111
  ImaginaryI; U+02148
  imagline; U+02110
  imagpart; U+02111
  imath; U+00131
  imof; U+022B7
  imped; U+001B5
  Implies; U+021D2
  in; U+02208
  incare; U+02105
  infin; U+0221E
  infintie; U+029DD
  inodot; U+00131
  Int; U+0222C
  int; U+0222B
  intcal; U+022BA
  integers; U+02124
  Integral; U+0222B
  intercal; U+022BA
  Intersection; U+022C2
  intlarhk; U+02A17
  intprod; U+02A3C
  InvisibleComma; U+02063
  InvisibleTimes; U+02062
  IOcy; U+00401
  iocy; U+00451
  Iogon; U+0012E
  iogon; U+0012F
  Iopf; U+1D540
  iopf; U+1D55A
  Iota; U+00399
  iota; U+003B9
  iprod; U+02A3C
  iquest; U+000BF
  iquest U+000BF
  Iscr; U+02110
  iscr; U+1D4BE
  isin; U+02208
  isindot; U+022F5
  isinE; U+022F9
  isins; U+022F4
  isinsv; U+022F3
  isinv; U+02208
  it; U+02062
  Itilde; U+00128
  itilde; U+00129
  Iukcy; U+00406
  iukcy; U+00456
  Iuml; U+000CF
  Iuml U+000CF
  iuml; U+000EF
  iuml U+000EF
  Jcirc; U+00134
  jcirc; U+00135
  Jcy; U+00419
  jcy; U+00439
  Jfr; U+1D50D
  jfr; U+1D527
  jmath; U+00237
  Jopf; U+1D541
  jopf; U+1D55B
  Jscr; U+1D4A5
  jscr; U+1D4BF
  Jsercy; U+00408
  jsercy; U+00458
  Jukcy; U+00404
  jukcy; U+00454
  Kappa; U+0039A
  kappa; U+003BA
  kappav; U+003F0
  Kcedil; U+00136
  kcedil; U+00137
  Kcy; U+0041A
  kcy; U+0043A
  Kfr; U+1D50E
  kfr; U+1D528
  kgreen; U+00138
  KHcy; U+00425
  khcy; U+00445
  KJcy; U+0040C
  kjcy; U+0045C
  Kopf; U+1D542
  kopf; U+1D55C
  Kscr; U+1D4A6
  kscr; U+1D4C0
  lAarr; U+021DA
  Lacute; U+00139
  lacute; U+0013A
  laemptyv; U+029B4
  lagran; U+02112
  Lambda; U+0039B
  lambda; U+003BB
  Lang; U+027EA
  lang; U+027E8
  langd; U+02991
  langle; U+027E8
  lap; U+02A85
  Laplacetrf; U+02112
  laquo; U+000AB
  laquo U+000AB
  Larr; U+0219E
  lArr; U+021D0
  larr; U+02190
  larrb; U+021E4
  larrbfs; U+0291F
  larrfs; U+0291D
  larrhk; U+021A9
  larrlp; U+021AB
  larrpl; U+02939
  larrsim; U+02973
  larrtl; U+021A2
  lat; U+02AAB
  lAtail; U+0291B
  latail; U+02919
  late; U+02AAD
  lates; U+02AAD U+0FE00
  lBarr; U+0290E
  lbarr; U+0290C
  lbbrk; U+02772
  lbrace; U+0007B
  lbrack; U+0005B
  lbrke; U+0298B
  lbrksld; U+0298F
  lbrkslu; U+0298D
  Lcaron; U+0013D
  lcaron; U+0013E
  Lcedil; U+0013B
  lcedil; U+0013C
  lceil; U+02308
  lcub; U+0007B
  Lcy; U+0041B
  lcy; U+0043B
  ldca; U+02936
  ldquo; U+0201C
  ldquor; U+0201E
  ldrdhar; U+02967
  ldrushar; U+0294B
  ldsh; U+021B2
  lE; U+02266
  le; U+02264
  LeftAngleBracket; U+027E8
  LeftArrow; U+02190
  Leftarrow; U+021D0
  leftarrow; U+02190
  LeftArrowBar; U+021E4
  LeftArrowRightArrow; U+021C6
  leftarrowtail; U+021A2
  LeftCeiling; U+02308
  LeftDoubleBracket; U+027E6
  LeftDownTeeVector; U+02961
  LeftDownVector; U+021C3
  LeftDownVectorBar; U+02959
  LeftFloor; U+0230A
  leftharpoondown; U+021BD
  leftharpoonup; U+021BC
  leftleftarrows; U+021C7
  LeftRightArrow; U+02194
  Leftrightarrow; U+021D4
  leftrightarrow; U+02194
  leftrightarrows; U+021C6
  leftrightharpoons; U+021CB
  leftrightsquigarrow; U+021AD
  LeftRightVector; U+0294E
  LeftTee; U+022A3
  LeftTeeArrow; U+021A4
  LeftTeeVector; U+0295A
  leftthreetimes; U+022CB
  LeftTriangle; U+022B2
  LeftTriangleBar; U+029CF
  LeftTriangleEqual; U+022B4
  LeftUpDownVector; U+02951
  LeftUpTeeVector; U+02960
  LeftUpVector; U+021BF
  LeftUpVectorBar; U+02958
  LeftVector; U+021BC
  LeftVectorBar; U+02952
  lEg; U+02A8B
  leg; U+022DA
  leq; U+02264
  leqq; U+02266
  leqslant; U+02A7D
  les; U+02A7D
  lescc; U+02AA8
  lesdot; U+02A7F
  lesdoto; U+02A81
  lesdotor; U+02A83
  lesg; U+022DA U+0FE00
  lesges; U+02A93
  lessapprox; U+02A85
  lessdot; U+022D6
  lesseqgtr; U+022DA
  lesseqqgtr; U+02A8B
  LessEqualGreater; U+022DA
  LessFullEqual; U+02266
  LessGreater; U+02276
  lessgtr; U+02276
  LessLess; U+02AA1
  lesssim; U+02272
  LessSlantEqual; U+02A7D
  LessTilde; U+02272
  lfisht; U+0297C
  lfloor; U+0230A
  Lfr; U+1D50F
  lfr; U+1D529
  lg; U+02276
  lgE; U+02A91
  lHar; U+02962
  lhard; U+021BD
  lharu; U+021BC
  lharul; U+0296A
  lhblk; U+02584
  LJcy; U+00409
  ljcy; U+00459
  Ll; U+022D8
  ll; U+0226A
  llarr; U+021C7
  llcorner; U+0231E
  Lleftarrow; U+021DA
  llhard; U+0296B
  lltri; U+025FA
  Lmidot; U+0013F
  lmidot; U+00140
  lmoust; U+023B0
  lmoustache; U+023B0
  lnap; U+02A89
  lnapprox; U+02A89
  lnE; U+02268
  lne; U+02A87
  lneq; U+02A87
  lneqq; U+02268
  lnsim; U+022E6
  loang; U+027EC
  loarr; U+021FD
  lobrk; U+027E6
  LongLeftArrow; U+027F5
  Longleftarrow; U+027F8
  longleftarrow; U+027F5
  LongLeftRightArrow; U+027F7
  Longleftrightarrow; U+027FA
  longleftrightarrow; U+027F7
  longmapsto; U+027FC
  LongRightArrow; U+027F6
  Longrightarrow; U+027F9
  longrightarrow; U+027F6
  looparrowleft; U+021AB
  looparrowright; U+021AC
  lopar; U+02985
  Lopf; U+1D543
  lopf; U+1D55D
  loplus; U+02A2D
  lotimes; U+02A34
  lowast; U+02217
  lowbar; U+0005F
  LowerLeftArrow; U+02199
  LowerRightArrow; U+02198
  loz; U+025CA
  lozenge; U+025CA
  lozf; U+029EB
  lpar; U+00028
  lparlt; U+02993
  lrarr; U+021C6
  lrcorner; U+0231F
  lrhar; U+021CB
  lrhard; U+0296D
  lrm; U+0200E
  lrtri; U+022BF
  lsaquo; U+02039
  Lscr; U+02112
  lscr; U+1D4C1
  Lsh; U+021B0
  lsh; U+021B0
  lsim; U+02272
  lsime; U+02A8D
  lsimg; U+02A8F
  lsqb; U+0005B
  lsquo; U+02018
  lsquor; U+0201A
  Lstrok; U+00141
  lstrok; U+00142
  LT; U+0003C
  LT U+0003C
  Lt; U+0226A
  lt; U+0003C
  lt U+0003C
  ltcc; U+02AA6
  ltcir; U+02A79
  ltdot; U+022D6
  lthree; U+022CB
  ltimes; U+022C9
  ltlarr; U+02976
  ltquest; U+02A7B
  ltri; U+025C3
  ltrie; U+022B4
  ltrif; U+025C2
  ltrPar; U+02996
  lurdshar; U+0294A
  luruhar; U+02966
  lvertneqq; U+02268 U+0FE00
  lvnE; U+02268 U+0FE00
  macr; U+000AF
  macr U+000AF
  male; U+02642
  malt; U+02720
  maltese; U+02720
  Map; U+02905
  map; U+021A6
  mapsto; U+021A6
  mapstodown; U+021A7
  mapstoleft; U+021A4
  mapstoup; U+021A5
  marker; U+025AE
  mcomma; U+02A29
  Mcy; U+0041C
  mcy; U+0043C
  mdash; U+02014
  mDDot; U+0223A
  measuredangle; U+02221
  MediumSpace; U+0205F
  Mellintrf; U+02133
  Mfr; U+1D510
  mfr; U+1D52A
  mho; U+02127
  micro; U+000B5
  micro U+000B5
  mid; U+02223
  midast; U+0002A
  midcir; U+02AF0
  middot; U+000B7
  middot U+000B7
  minus; U+02212
  minusb; U+0229F
  minusd; U+02238
  minusdu; U+02A2A
  MinusPlus; U+02213
  mlcp; U+02ADB
  mldr; U+02026
  mnplus; U+02213
  models; U+022A7
  Mopf; U+1D544
  mopf; U+1D55E
  mp; U+02213
  Mscr; U+02133
  mscr; U+1D4C2
  mstpos; U+0223E
  Mu; U+0039C
  mu; U+003BC
  multimap; U+022B8
  mumap; U+022B8
  nabla; U+02207
  Nacute; U+00143
  nacute; U+00144
  nang; U+02220 U+020D2
  nap; U+02249
  napE; U+02A70 U+00338
  napid; U+0224B U+00338
  napos; U+00149
  napprox; U+02249
  natur; U+0266E
  natural; U+0266E
  naturals; U+02115
  nbsp; U+000A0
  nbsp U+000A0
  nbump; U+0224E U+00338
  nbumpe; U+0224F U+00338
  ncap; U+02A43
  Ncaron; U+00147
  ncaron; U+00148
  Ncedil; U+00145
  ncedil; U+00146
  ncong; U+02247
  ncongdot; U+02A6D U+00338
  ncup; U+02A42
  Ncy; U+0041D
  ncy; U+0043D
  ndash; U+02013
  ne; U+02260
  nearhk; U+02924
  neArr; U+021D7
  nearr; U+02197
  nearrow; U+02197
  nedot; U+02250 U+00338
  NegativeMediumSpace; U+0200B
  NegativeThickSpace; U+0200B
  NegativeThinSpace; U+0200B
  NegativeVeryThinSpace; U+0200B
  nequiv; U+02262
  nesear; U+02928
  nesim; U+02242 U+00338
  NestedGreaterGreater; U+0226B
  NestedLessLess; U+0226A
  NewLine; U+0000A
  nexist; U+02204
  nexists; U+02204
  Nfr; U+1D511
  nfr; U+1D52B
  ngE; U+02267 U+00338
  nge; U+02271
  ngeq; U+02271
  ngeqq; U+02267 U+00338
  ngeqslant; U+02A7E U+00338
  nges; U+02A7E U+00338
  nGg; U+022D9 U+00338
  ngsim; U+02275
  nGt; U+0226B U+020D2
  ngt; U+0226F
  ngtr; U+0226F
  nGtv; U+0226B U+00338
  nhArr; U+021CE
  nharr; U+021AE
  nhpar; U+02AF2
  ni; U+0220B
  nis; U+022FC
  nisd; U+022FA
  niv; U+0220B
  NJcy; U+0040A
  njcy; U+0045A
  nlArr; U+021CD
  nlarr; U+0219A
  nldr; U+02025
  nlE; U+02266 U+00338
  nle; U+02270
  nLeftarrow; U+021CD
  nleftarrow; U+0219A
  nLeftrightarrow; U+021CE
  nleftrightarrow; U+021AE
  nleq; U+02270
  nleqq; U+02266 U+00338
  nleqslant; U+02A7D U+00338
  nles; U+02A7D U+00338
  nless; U+0226E
  nLl; U+022D8 U+00338
  nlsim; U+02274
  nLt; U+0226A U+020D2
  nlt; U+0226E
  nltri; U+022EA
  nltrie; U+022EC
  nLtv; U+0226A U+00338
  nmid; U+02224
  NoBreak; U+02060
  NonBreakingSpace; U+000A0
  Nopf; U+02115
  nopf; U+1D55F
  Not; U+02AEC
  not; U+000AC
  not U+000AC
  NotCongruent; U+02262
  NotCupCap; U+0226D
  NotDoubleVerticalBar; U+02226
  NotElement; U+02209
  NotEqual; U+02260
  NotEqualTilde; U+02242 U+00338
  NotExists; U+02204
  NotGreater; U+0226F
  NotGreaterEqual; U+02271
  NotGreaterFullEqual; U+02267 U+00338
  NotGreaterGreater; U+0226B U+00338
  NotGreaterLess; U+02279
  NotGreaterSlantEqual; U+02A7E U+00338
  NotGreaterTilde; U+02275
  NotHumpDownHump; U+0224E U+00338
  NotHumpEqual; U+0224F U+00338
  notin; U+02209
  notindot; U+022F5 U+00338
  notinE; U+022F9 U+00338
  notinva; U+02209
  notinvb; U+022F7
  notinvc; U+022F6
  NotLeftTriangle; U+022EA
  NotLeftTriangleBar; U+029CF U+00338
  NotLeftTriangleEqual; U+022EC
  NotLess; U+0226E
  NotLessEqual; U+02270
  NotLessGreater; U+02278
  NotLessLess; U+0226A U+00338
  NotLessSlantEqual; U+02A7D U+00338
  NotLessTilde; U+02274
  NotNestedGreaterGreater; U+02AA2 U+00338
  NotNestedLessLess; U+02AA1 U+00338
  notni; U+0220C
  notniva; U+0220C
  notnivb; U+022FE
  notnivc; U+022FD
  NotPrecedes; U+02280
  NotPrecedesEqual; U+02AAF U+00338
  NotPrecedesSlantEqual; U+022E0
  NotReverseElement; U+0220C
  NotRightTriangle; U+022EB
  NotRightTriangleBar; U+029D0 U+00338
  NotRightTriangleEqual; U+022ED
  NotSquareSubset; U+0228F U+00338
  NotSquareSubsetEqual; U+022E2
  NotSquareSuperset; U+02290 U+00338
  NotSquareSupersetEqual; U+022E3
  NotSubset; U+02282 U+020D2
  NotSubsetEqual; U+02288
  NotSucceeds; U+02281
  NotSucceedsEqual; U+02AB0 U+00338
  NotSucceedsSlantEqual; U+022E1
  NotSucceedsTilde; U+0227F U+00338
  NotSuperset; U+02283 U+020D2
  NotSupersetEqual; U+02289
  NotTilde; U+02241
  NotTildeEqual; U+02244
  NotTildeFullEqual; U+02247
  NotTildeTilde; U+02249
  NotVerticalBar; U+02224
  npar; U+02226
  nparallel; U+02226
  nparsl; U+02AFD U+020E5
  npart; U+02202 U+00338
  npolint; U+02A14
  npr; U+02280
  nprcue; U+022E0
  npre; U+02AAF U+00338
  nprec; U+02280
  npreceq; U+02AAF U+00338
  nrArr; U+021CF
  nrarr; U+0219B
  nrarrc; U+02933 U+00338
  nrarrw; U+0219D U+00338
  nRightarrow; U+021CF
  nrightarrow; U+0219B
  nrtri; U+022EB
  nrtrie; U+022ED
  nsc; U+02281
  nsccue; U+022E1
  nsce; U+02AB0 U+00338
  Nscr; U+1D4A9
  nscr; U+1D4C3
  nshortmid; U+02224
  nshortparallel; U+02226
  nsim; U+02241
  nsime; U+02244
  nsimeq; U+02244
  nsmid; U+02224
  nspar; U+02226
  nsqsube; U+022E2
  nsqsupe; U+022E3
  nsub; U+02284
  nsubE; U+02AC5 U+00338
  nsube; U+02288
  nsubset; U+02282 U+020D2
  nsubseteq; U+02288
  nsubseteqq; U+02AC5 U+00338
  nsucc; U+02281
  nsucceq; U+02AB0 U+00338
  nsup; U+02285
  nsupE; U+02AC6 U+00338
  nsupe; U+02289
  nsupset; U+02283 U+020D2
  nsupseteq; U+02289
  nsupseteqq; U+02AC6 U+00338
  ntgl; U+02279
  Ntilde; U+000D1
  Ntilde U+000D1
  ntilde; U+000F1
  ntilde U+000F1
  ntlg; U+02278
  ntriangleleft; U+022EA
  ntrianglelefteq; U+022EC
  ntriangleright; U+022EB
  ntrianglerighteq; U+022ED
  Nu; U+0039D
  nu; U+003BD
  num; U+00023
  numero; U+02116
  numsp; U+02007
  nvap; U+0224D U+020D2
  nVDash; U+022AF
  nVdash; U+022AE
  nvDash; U+022AD
  nvdash; U+022AC
  nvge; U+02265 U+020D2
  nvgt; U+0003E U+020D2
  nvHarr; U+02904
  nvinfin; U+029DE
  nvlArr; U+02902
  nvle; U+02264 U+020D2
  nvlt; U+0003C U+020D2
  nvltrie; U+022B4 U+020D2
  nvrArr; U+02903
  nvrtrie; U+022B5 U+020D2
  nvsim; U+0223C U+020D2
  nwarhk; U+02923
  nwArr; U+021D6
  nwarr; U+02196
  nwarrow; U+02196
  nwnear; U+02927
  Oacute; U+000D3
  Oacute U+000D3
  oacute; U+000F3
  oacute U+000F3
  oast; U+0229B
  ocir; U+0229A
  Ocirc; U+000D4
  Ocirc U+000D4
  ocirc; U+000F4
  ocirc U+000F4
  Ocy; U+0041E
  ocy; U+0043E
  odash; U+0229D
  Odblac; U+00150
  odblac; U+00151
  odiv; U+02A38
  odot; U+02299
  odsold; U+029BC
  OElig; U+00152
  oelig; U+00153
  ofcir; U+029BF
  Ofr; U+1D512
  ofr; U+1D52C
  ogon; U+002DB
  Ograve; U+000D2
  Ograve U+000D2
  ograve; U+000F2
  ograve U+000F2
  ogt; U+029C1
  ohbar; U+029B5
  ohm; U+003A9
  oint; U+0222E
  olarr; U+021BA
  olcir; U+029BE
  olcross; U+029BB
  oline; U+0203E
  olt; U+029C0
  Omacr; U+0014C
  omacr; U+0014D
  Omega; U+003A9
  omega; U+003C9
  Omicron; U+0039F
  omicron; U+003BF
  omid; U+029B6
  ominus; U+02296
  Oopf; U+1D546
  oopf; U+1D560
  opar; U+029B7
  OpenCurlyDoubleQuote; U+0201C
  OpenCurlyQuote; U+02018
  operp; U+029B9
  oplus; U+02295
  Or; U+02A54
  or; U+02228
  orarr; U+021BB
  ord; U+02A5D
  order; U+02134
  orderof; U+02134
  ordf; U+000AA
  ordf U+000AA
  ordm; U+000BA
  ordm U+000BA
  origof; U+022B6
  oror; U+02A56
  orslope; U+02A57
  orv; U+02A5B
  oS; U+024C8
  Oscr; U+1D4AA
  oscr; U+02134
  Oslash; U+000D8
  Oslash U+000D8
  oslash; U+000F8
  oslash U+000F8
  osol; U+02298
  Otilde; U+000D5
  Otilde U+000D5
  otilde; U+000F5
  otilde U+000F5
  Otimes; U+02A37
  otimes; U+02297
  otimesas; U+02A36
  Ouml; U+000D6
  Ouml U+000D6
  ouml; U+000F6
  ouml U+000F6
  ovbar; U+0233D
  OverBar; U+0203E
  OverBrace; U+023DE
  OverBracket; U+023B4
  OverParenthesis; U+023DC
  par; U+02225
  para; U+000B6
  para U+000B6
  parallel; U+02225
  parsim; U+02AF3
  parsl; U+02AFD
  part; U+02202
  PartialD; U+02202
  Pcy; U+0041F
  pcy; U+0043F
  percnt; U+00025
  period; U+0002E
  permil; U+02030
  perp; U+022A5
  pertenk; U+02031
  Pfr; U+1D513
  pfr; U+1D52D
  Phi; U+003A6
  phi; U+003C6
  phiv; U+003D5
  phmmat; U+02133
  phone; U+0260E
  Pi; U+003A0
  pi; U+003C0
  pitchfork; U+022D4
  piv; U+003D6
  planck; U+0210F
  planckh; U+0210E
  plankv; U+0210F
  plus; U+0002B
  plusacir; U+02A23
  plusb; U+0229E
  pluscir; U+02A22
  plusdo; U+02214
  plusdu; U+02A25
  pluse; U+02A72
  PlusMinus; U+000B1
  plusmn; U+000B1
  plusmn U+000B1
  plussim; U+02A26
  plustwo; U+02A27
  pm; U+000B1
  Poincareplane; U+0210C
  pointint; U+02A15
  Popf; U+02119
  popf; U+1D561
  pound; U+000A3
  pound U+000A3
  Pr; U+02ABB
  pr; U+0227A
  prap; U+02AB7
  prcue; U+0227C
  prE; U+02AB3
  pre; U+02AAF
  prec; U+0227A
  precapprox; U+02AB7
  preccurlyeq; U+0227C
  Precedes; U+0227A
  PrecedesEqual; U+02AAF
  PrecedesSlantEqual; U+0227C
  PrecedesTilde; U+0227E
  preceq; U+02AAF
  precnapprox; U+02AB9
  precneqq; U+02AB5
  precnsim; U+022E8
  precsim; U+0227E
  Prime; U+02033
  prime; U+02032
  primes; U+02119
  prnap; U+02AB9
  prnE; U+02AB5
  prnsim; U+022E8
  prod; U+0220F
  Product; U+0220F
  profalar; U+0232E
  profline; U+02312
  profsurf; U+02313
  prop; U+0221D
  Proportion; U+02237
  Proportional; U+0221D
  propto; U+0221D
  prsim; U+0227E
  prurel; U+022B0
  Pscr; U+1D4AB
  pscr; U+1D4C5
  Psi; U+003A8
  psi; U+003C8
  puncsp; U+02008
  Qfr; U+1D514
  qfr; U+1D52E
  qint; U+02A0C
  Qopf; U+0211A
  qopf; U+1D562
  qprime; U+02057
  Qscr; U+1D4AC
  qscr; U+1D4C6
  quaternions; U+0210D
  quatint; U+02A16
  quest; U+0003F
  questeq; U+0225F
  QUOT; U+00022
  QUOT U+00022
  quot; U+00022
  quot U+00022
  rAarr; U+021DB
  race; U+0223D U+00331
  Racute; U+00154
  racute; U+00155
  radic; U+0221A
  raemptyv; U+029B3
  Rang; U+027EB
  rang; U+027E9
  rangd; U+02992
  range; U+029A5
  rangle; U+027E9
  raquo; U+000BB
  raquo U+000BB
  Rarr; U+021A0
  rArr; U+021D2
  rarr; U+02192
  rarrap; U+02975
  rarrb; U+021E5
  rarrbfs; U+02920
  rarrc; U+02933
  rarrfs; U+0291E
  rarrhk; U+021AA
  rarrlp; U+021AC
  rarrpl; U+02945
  rarrsim; U+02974
  Rarrtl; U+02916
  rarrtl; U+021A3
  rarrw; U+0219D
  rAtail; U+0291C
  ratail; U+0291A
  ratio; U+02236
  rationals; U+0211A
  RBarr; U+02910
  rBarr; U+0290F
  rbarr; U+0290D
  rbbrk; U+02773
  rbrace; U+0007D
  rbrack; U+0005D
  rbrke; U+0298C
  rbrksld; U+0298E
  rbrkslu; U+02990
  Rcaron; U+00158
  rcaron; U+00159
  Rcedil; U+00156
  rcedil; U+00157
  rceil; U+02309
  rcub; U+0007D
  Rcy; U+00420
  rcy; U+00440
  rdca; U+02937
  rdldhar; U+02969
  rdquo; U+0201D
  rdquor; U+0201D
  rdsh; U+021B3
  Re; U+0211C
  real; U+0211C
  realine; U+0211B
  realpart; U+0211C
  reals; U+0211D
  rect; U+025AD
  REG; U+000AE
  REG U+000AE
  reg; U+000AE
  reg U+000AE
  ReverseElement; U+0220B
  ReverseEquilibrium; U+021CB
  ReverseUpEquilibrium; U+0296F
  rfisht; U+0297D
  rfloor; U+0230B
  Rfr; U+0211C
  rfr; U+1D52F
  rHar; U+02964
  rhard; U+021C1
  rharu; U+021C0
  rharul; U+0296C
  Rho; U+003A1
  rho; U+003C1
  rhov; U+003F1
  RightAngleBracket; U+027E9
  RightArrow; U+02192
  Rightarrow; U+021D2
  rightarrow; U+02192
  RightArrowBar; U+021E5
  RightArrowLeftArrow; U+021C4
  rightarrowtail; U+021A3
  RightCeiling; U+02309
  RightDoubleBracket; U+027E7
  RightDownTeeVector; U+0295D
  RightDownVector; U+021C2
  RightDownVectorBar; U+02955
  RightFloor; U+0230B
  rightharpoondown; U+021C1
  rightharpoonup; U+021C0
  rightleftarrows; U+021C4
  rightleftharpoons; U+021CC
  rightrightarrows; U+021C9
  rightsquigarrow; U+0219D
  RightTee; U+022A2
  RightTeeArrow; U+021A6
  RightTeeVector; U+0295B
  rightthreetimes; U+022CC
  RightTriangle; U+022B3
  RightTriangleBar; U+029D0
  RightTriangleEqual; U+022B5
  RightUpDownVector; U+0294F
  RightUpTeeVector; U+0295C
  RightUpVector; U+021BE
  RightUpVectorBar; U+02954
  RightVector; U+021C0
  RightVectorBar; U+02953
  ring; U+002DA
  risingdotseq; U+02253
  rlarr; U+021C4
  rlhar; U+021CC
  rlm; U+0200F
  rmoust; U+023B1
  rmoustache; U+023B1
  rnmid; U+02AEE
  roang; U+027ED
  roarr; U+021FE
  robrk; U+027E7
  ropar; U+02986
  Ropf; U+0211D
  ropf; U+1D563
  roplus; U+02A2E
  rotimes; U+02A35
  RoundImplies; U+02970
  rpar; U+00029
  rpargt; U+02994
  rppolint; U+02A12
  rrarr; U+021C9
  Rrightarrow; U+021DB
  rsaquo; U+0203A
  Rscr; U+0211B
  rscr; U+1D4C7
  Rsh; U+021B1
  rsh; U+021B1
  rsqb; U+0005D
  rsquo; U+02019
  rsquor; U+02019
  rthree; U+022CC
  rtimes; U+022CA
  rtri; U+025B9
  rtrie; U+022B5
  rtrif; U+025B8
  rtriltri; U+029CE
  RuleDelayed; U+029F4
  ruluhar; U+02968
  rx; U+0211E
  Sacute; U+0015A
  sacute; U+0015B
  sbquo; U+0201A
  Sc; U+02ABC
  sc; U+0227B
  scap; U+02AB8
  Scaron; U+00160
  scaron; U+00161
  sccue; U+0227D
  scE; U+02AB4
  sce; U+02AB0
  Scedil; U+0015E
  scedil; U+0015F
  Scirc; U+0015C
  scirc; U+0015D
  scnap; U+02ABA
  scnE; U+02AB6
  scnsim; U+022E9
  scpolint; U+02A13
  scsim; U+0227F
  Scy; U+00421
  scy; U+00441
  sdot; U+022C5
  sdotb; U+022A1
  sdote; U+02A66
  searhk; U+02925
  seArr; U+021D8
  searr; U+02198
  searrow; U+02198
  sect; U+000A7
  sect U+000A7
  semi; U+0003B
  seswar; U+02929
  setminus; U+02216
  setmn; U+02216
  sext; U+02736
  Sfr; U+1D516
  sfr; U+1D530
  sfrown; U+02322
  sharp; U+0266F
  SHCHcy; U+00429
  shchcy; U+00449
  SHcy; U+00428
  shcy; U+00448
  ShortDownArrow; U+02193
  ShortLeftArrow; U+02190
  shortmid; U+02223
  shortparallel; U+02225
  ShortRightArrow; U+02192
  ShortUpArrow; U+02191
  shy; U+000AD
  shy U+000AD
  Sigma; U+003A3
  sigma; U+003C3
  sigmaf; U+003C2
  sigmav; U+003C2
  sim; U+0223C
  simdot; U+02A6A
  sime; U+02243
  simeq; U+02243
  simg; U+02A9E
  simgE; U+02AA0
  siml; U+02A9D
  simlE; U+02A9F
  simne; U+02246
  simplus; U+02A24
  simrarr; U+02972
  slarr; U+02190
  SmallCircle; U+02218
  smallsetminus; U+02216
  smashp; U+02A33
  smeparsl; U+029E4
  smid; U+02223
  smile; U+02323
  smt; U+02AAA
  smte; U+02AAC
  smtes; U+02AAC U+0FE00
  SOFTcy; U+0042C
  softcy; U+0044C
  sol; U+0002F
  solb; U+029C4
  solbar; U+0233F
  Sopf; U+1D54A
  sopf; U+1D564
  spades; U+02660
  spadesuit; U+02660
  spar; U+02225
  sqcap; U+02293
  sqcaps; U+02293 U+0FE00
  sqcup; U+02294
  sqcups; U+02294 U+0FE00
  Sqrt; U+0221A
  sqsub; U+0228F
  sqsube; U+02291
  sqsubset; U+0228F
  sqsubseteq; U+02291
  sqsup; U+02290
  sqsupe; U+02292
  sqsupset; U+02290
  sqsupseteq; U+02292
  squ; U+025A1
  Square; U+025A1
  square; U+025A1
  SquareIntersection; U+02293
  SquareSubset; U+0228F
  SquareSubsetEqual; U+02291
  SquareSuperset; U+02290
  SquareSupersetEqual; U+02292
  SquareUnion; U+02294
  squarf; U+025AA
  squf; U+025AA
  srarr; U+02192
  Sscr; U+1D4AE
  sscr; U+1D4C8
  ssetmn; U+02216
  ssmile; U+02323
  sstarf; U+022C6
  Star; U+022C6
  star; U+02606
  starf; U+02605
  straightepsilon; U+003F5
  straightphi; U+003D5
  strns; U+000AF
  Sub; U+022D0
  sub; U+02282
  subdot; U+02ABD
  subE; U+02AC5
  sube; U+02286
  subedot; U+02AC3
  submult; U+02AC1
  subnE; U+02ACB
  subne; U+0228A
  subplus; U+02ABF
  subrarr; U+02979
  Subset; U+022D0
  subset; U+02282
  subseteq; U+02286
  subseteqq; U+02AC5
  SubsetEqual; U+02286
  subsetneq; U+0228A
  subsetneqq; U+02ACB
  subsim; U+02AC7
  subsub; U+02AD5
  subsup; U+02AD3
  succ; U+0227B
  succapprox; U+02AB8
  succcurlyeq; U+0227D
  Succeeds; U+0227B
  SucceedsEqual; U+02AB0
  SucceedsSlantEqual; U+0227D
  SucceedsTilde; U+0227F
  succeq; U+02AB0
  succnapprox; U+02ABA
  succneqq; U+02AB6
  succnsim; U+022E9
  succsim; U+0227F
  SuchThat; U+0220B
  Sum; U+02211
  sum; U+02211
  sung; U+0266A
  Sup; U+022D1
  sup; U+02283
  sup1; U+000B9
  sup1 U+000B9
  sup2; U+000B2
  sup2 U+000B2
  sup3; U+000B3
  sup3 U+000B3
  supdot; U+02ABE
  supdsub; U+02AD8
  supE; U+02AC6
  supe; U+02287
  supedot; U+02AC4
  Superset; U+02283
  SupersetEqual; U+02287
  suphsol; U+027C9
  suphsub; U+02AD7
  suplarr; U+0297B
  supmult; U+02AC2
  supnE; U+02ACC
  supne; U+0228B
  supplus; U+02AC0
  Supset; U+022D1
  supset; U+02283
  supseteq; U+02287
  supseteqq; U+02AC6
  supsetneq; U+0228B
  supsetneqq; U+02ACC
  supsim; U+02AC8
  supsub; U+02AD4
  supsup; U+02AD6
  swarhk; U+02926
  swArr; U+021D9
  swarr; U+02199
  swarrow; U+02199
  swnwar; U+0292A
  szlig; U+000DF
  szlig U+000DF
  Tab; U+00009
  target; U+02316
  Tau; U+003A4
  tau; U+003C4
  tbrk; U+023B4
  Tcaron; U+00164
  tcaron; U+00165
  Tcedil; U+00162
  tcedil; U+00163
  Tcy; U+00422
  tcy; U+00442
  tdot; U+020DB
  telrec; U+02315
  Tfr; U+1D517
  tfr; U+1D531
  there4; U+02234
  Therefore; U+02234
  therefore; U+02234
  Theta; U+00398
  theta; U+003B8
  thetasym; U+003D1
  thetav; U+003D1
  thickapprox; U+02248
  thicksim; U+0223C
  ThickSpace; U+0205F U+0200A
  thinsp; U+02009
  ThinSpace; U+02009
  thkap; U+02248
  thksim; U+0223C
  THORN; U+000DE
  THORN U+000DE
  thorn; U+000FE
  thorn U+000FE
  Tilde; U+0223C
  tilde; U+002DC
  TildeEqual; U+02243
  TildeFullEqual; U+02245
  TildeTilde; U+02248
  times; U+000D7
  times U+000D7
  timesb; U+022A0
  timesbar; U+02A31
  timesd; U+02A30
  tint; U+0222D
  toea; U+02928
  top; U+022A4
  topbot; U+02336
  topcir; U+02AF1
  Topf; U+1D54B
  topf; U+1D565
  topfork; U+02ADA
  tosa; U+02929
  tprime; U+02034
  TRADE; U+02122
  trade; U+02122
  triangle; U+025B5
  triangledown; U+025BF
  triangleleft; U+025C3
  trianglelefteq; U+022B4
  triangleq; U+0225C
  triangleright; U+025B9
  trianglerighteq; U+022B5
  tridot; U+025EC
  trie; U+0225C
  triminus; U+02A3A
  TripleDot; U+020DB
  triplus; U+02A39
  trisb; U+029CD
  tritime; U+02A3B
  trpezium; U+023E2
  Tscr; U+1D4AF
  tscr; U+1D4C9
  TScy; U+00426
  tscy; U+00446
  TSHcy; U+0040B
  tshcy; U+0045B
  Tstrok; U+00166
  tstrok; U+00167
  twixt; U+0226C
  twoheadleftarrow; U+0219E
  twoheadrightarrow; U+021A0
  Uacute; U+000DA
  Uacute U+000DA
  uacute; U+000FA
  uacute U+000FA
  Uarr; U+0219F
  uArr; U+021D1
  uarr; U+02191
  Uarrocir; U+02949
  Ubrcy; U+0040E
  ubrcy; U+0045E
  Ubreve; U+0016C
  ubreve; U+0016D
  Ucirc; U+000DB
  Ucirc U+000DB
  ucirc; U+000FB
  ucirc U+000FB
  Ucy; U+00423
  ucy; U+00443
  udarr; U+021C5
  Udblac; U+00170
  udblac; U+00171
  udhar; U+0296E
  ufisht; U+0297E
  Ufr; U+1D518
  ufr; U+1D532
  Ugrave; U+000D9
  Ugrave U+000D9
  ugrave; U+000F9
  ugrave U+000F9
  uHar; U+02963
  uharl; U+021BF
  uharr; U+021BE
  uhblk; U+02580
  ulcorn; U+0231C
  ulcorner; U+0231C
  ulcrop; U+0230F
  ultri; U+025F8
  Umacr; U+0016A
  umacr; U+0016B
  uml; U+000A8
  uml U+000A8
  UnderBar; U+0005F
  UnderBrace; U+023DF
  UnderBracket; U+023B5
  UnderParenthesis; U+023DD
  Union; U+022C3
  UnionPlus; U+0228E
  Uogon; U+00172
  uogon; U+00173
  Uopf; U+1D54C
  uopf; U+1D566
  UpArrow; U+02191
  Uparrow; U+021D1
  uparrow; U+02191
  UpArrowBar; U+02912
  UpArrowDownArrow; U+021C5
  UpDownArrow; U+02195
  Updownarrow; U+021D5
  updownarrow; U+02195
  UpEquilibrium; U+0296E
  upharpoonleft; U+021BF
  upharpoonright; U+021BE
  uplus; U+0228E
  UpperLeftArrow; U+02196
  UpperRightArrow; U+02197
  Upsi; U+003D2
  upsi; U+003C5
  upsih; U+003D2
  Upsilon; U+003A5
  upsilon; U+003C5
  UpTee; U+022A5
  UpTeeArrow; U+021A5
  upuparrows; U+021C8
  urcorn; U+0231D
  urcorner; U+0231D
  urcrop; U+0230E
  Uring; U+0016E
  uring; U+0016F
  urtri; U+025F9
  Uscr; U+1D4B0
  uscr; U+1D4CA
  utdot; U+022F0
  Utilde; U+00168
  utilde; U+00169
  utri; U+025B5
  utrif; U+025B4
  uuarr; U+021C8
  Uuml; U+000DC
  Uuml U+000DC
  uuml; U+000FC
  uuml U+000FC
  uwangle; U+029A7
  vangrt; U+0299C
  varepsilon; U+003F5
  varkappa; U+003F0
  varnothing; U+02205
  varphi; U+003D5
  varpi; U+003D6
  varpropto; U+0221D
  vArr; U+021D5
  varr; U+02195
  varrho; U+003F1
  varsigma; U+003C2
  varsubsetneq; U+0228A U+0FE00
  varsubsetneqq; U+02ACB U+0FE00
  varsupsetneq; U+0228B U+0FE00
  varsupsetneqq; U+02ACC U+0FE00
  vartheta; U+003D1
  vartriangleleft; U+022B2
  vartriangleright; U+022B3
  Vbar; U+02AEB
  vBar; U+02AE8
  vBarv; U+02AE9
  Vcy; U+00412
  vcy; U+00432
  VDash; U+022AB
  Vdash; U+022A9
  vDash; U+022A8
  vdash; U+022A2
  Vdashl; U+02AE6
  Vee; U+022C1
  vee; U+02228
  veebar; U+022BB
  veeeq; U+0225A
  vellip; U+022EE
  Verbar; U+02016
  verbar; U+0007C
  Vert; U+02016
  vert; U+0007C
  VerticalBar; U+02223
  VerticalLine; U+0007C
  VerticalSeparator; U+02758
  VerticalTilde; U+02240
  VeryThinSpace; U+0200A
  Vfr; U+1D519
  vfr; U+1D533
  vltri; U+022B2
  vnsub; U+02282 U+020D2
  vnsup; U+02283 U+020D2
  Vopf; U+1D54D
  vopf; U+1D567
  vprop; U+0221D
  vrtri; U+022B3
  Vscr; U+1D4B1
  vscr; U+1D4CB
  vsubnE; U+02ACB U+0FE00
  vsubne; U+0228A U+0FE00
  vsupnE; U+02ACC U+0FE00
  vsupne; U+0228B U+0FE00
  Vvdash; U+022AA
  vzigzag; U+0299A
  Wcirc; U+00174
  wcirc; U+00175
  wedbar; U+02A5F
  Wedge; U+022C0
  wedge; U+02227
  wedgeq; U+02259
  weierp; U+02118
  Wfr; U+1D51A
  wfr; U+1D534
  Wopf; U+1D54E
  wopf; U+1D568
  wp; U+02118
  wr; U+02240
  wreath; U+02240
  Wscr; U+1D4B2
  wscr; U+1D4CC
  xcap; U+022C2
  xcirc; U+025EF
  xcup; U+022C3
  xdtri; U+025BD
  Xfr; U+1D51B
  xfr; U+1D535
  xhArr; U+027FA
  xharr; U+027F7
  Xi; U+0039E
  xi; U+003BE
  xlArr; U+027F8
  xlarr; U+027F5
  xmap; U+027FC
  xnis; U+022FB
  xodot; U+02A00
  Xopf; U+1D54F
  xopf; U+1D569
  xoplus; U+02A01
  xotime; U+02A02
  xrArr; U+027F9
  xrarr; U+027F6
  Xscr; U+1D4B3
  xscr; U+1D4CD
  xsqcup; U+02A06
  xuplus; U+02A04
  xutri; U+025B3
  xvee; U+022C1
  xwedge; U+022C0
  Yacute; U+000DD
  Yacute U+000DD
  yacute; U+000FD
  yacute U+000FD
  YAcy; U+0042F
  yacy; U+0044F
  Ycirc; U+00176
  ycirc; U+00177
  Ycy; U+0042B
  ycy; U+0044B
  yen; U+000A5
  yen U+000A5
  Yfr; U+1D51C
  yfr; U+1D536
  YIcy; U+00407
  yicy; U+00457
  Yopf; U+1D550
  yopf; U+1D56A
  Yscr; U+1D4B4
  yscr; U+1D4CE
  YUcy; U+0042E
  yucy; U+0044E
  Yuml; U+00178
  yuml; U+000FF
  yuml U+000FF
  Zacute; U+00179
  zacute; U+0017A
  Zcaron; U+0017D
  zcaron; U+0017E
  Zcy; U+00417
  zcy; U+00437
  Zdot; U+0017B
  zdot; U+0017C
  zeetrf; U+02128
  ZeroWidthSpace; U+0200B
  Zeta; U+00396
  zeta; U+003B6
  Zfr; U+02128
  zfr; U+1D537
  ZHcy; U+00416
  zhcy; U+00436
  zigrarr; U+021DD
  Zopf; U+02124
  zopf; U+1D56B
  Zscr; U+1D4B5
  zscr; U+1D4CF
  zwj; U+0200D
  zwnj; U+0200C
MOJO_UTIL

$fatpacked{"Mojo/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_WEBSOCKET';
  package Mojo::WebSocket;
  use Mojo::Base -strict;
  
  use Config;
  use Exporter 'import';
  use Mojo::Util qw(b64_encode dumper sha1_bytes xor_encode);
  
  use constant DEBUG => $ENV{MOJO_WEBSOCKET_DEBUG} || 0;
  
  # Unique value from RFC 6455
  use constant GUID => '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
  
  # Perl with support for quads
  use constant MODERN =>
    (($Config{use64bitint} // '') eq 'define' || $Config{longsize} >= 8);
  
  # Opcodes
  use constant {
    WS_CONTINUATION => 0x0,
    WS_TEXT         => 0x1,
    WS_BINARY       => 0x2,
    WS_CLOSE        => 0x8,
    WS_PING         => 0x9,
    WS_PONG         => 0xa
  };
  
  our @EXPORT_OK = (
    qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT),
    qw(build_frame challenge client_handshake parse_frame server_handshake)
  );
  
  sub build_frame {
    my ($masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload) = @_;
    warn "-- Building frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;
  
    # Head
    my $head = $op + ($fin ? 128 : 0);
    $head |= 0b01000000 if $rsv1;
    $head |= 0b00100000 if $rsv2;
    $head |= 0b00010000 if $rsv3;
    my $frame = pack 'C', $head;
  
    # Small payload
    my $len = length $payload;
    if ($len < 126) {
      warn "-- Small payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'C', $masked ? ($len | 128) : $len;
    }
  
    # Extended payload (16-bit)
    elsif ($len < 65536) {
      warn "-- Extended 16-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'Cn', $masked ? (126 | 128) : 126, $len;
    }
  
    # Extended payload (64-bit with 32-bit fallback)
    else {
      warn "-- Extended 64-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'C', $masked ? (127 | 128) : 127;
      $frame .= MODERN ? pack('Q>', $len) : pack('NN', 0, $len & 0xffffffff);
    }
  
    # Mask payload
    if ($masked) {
      my $mask = pack 'N', int(rand 9 x 7);
      $payload = $mask . xor_encode($payload, $mask x 128);
    }
  
    return $frame . $payload;
  }
  
  sub challenge {
    my $tx = shift;
  
    # "permessage-deflate" extension
    my $headers = $tx->res->headers;
    $tx->compressed(1)
      if ($headers->sec_websocket_extensions // '') =~ /permessage-deflate/;
  
    return _challenge($tx->req->headers->sec_websocket_key) eq
      $headers->sec_websocket_accept;
  }
  
  sub client_handshake {
    my $tx = shift;
  
    my $headers = $tx->req->headers;
    $headers->upgrade('websocket')      unless $headers->upgrade;
    $headers->connection('Upgrade')     unless $headers->connection;
    $headers->sec_websocket_version(13) unless $headers->sec_websocket_version;
  
    # Generate 16 byte WebSocket challenge
    my $challenge = b64_encode sprintf('%16u', int(rand 9 x 16)), '';
    $headers->sec_websocket_key($challenge) unless $headers->sec_websocket_key;
  
    return $tx;
  }
  
  sub parse_frame {
    my ($buffer, $max) = @_;
  
    # Head
    return undef unless length $$buffer >= 2;
    my ($first, $second) = unpack 'C*', substr($$buffer, 0, 2);
  
    # FIN
    my $fin = ($first & 0b10000000) == 0b10000000 ? 1 : 0;
  
    # RSV1-3
    my $rsv1 = ($first & 0b01000000) == 0b01000000 ? 1 : 0;
    my $rsv2 = ($first & 0b00100000) == 0b00100000 ? 1 : 0;
    my $rsv3 = ($first & 0b00010000) == 0b00010000 ? 1 : 0;
  
    # Opcode
    my $op = $first & 0b00001111;
    warn "-- Parsing frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;
  
    # Small payload
    my ($hlen, $len) = (2, $second & 0b01111111);
    if ($len < 126) { warn "-- Small payload ($len)\n" if DEBUG }
  
    # Extended payload (16-bit)
    elsif ($len == 126) {
      return undef unless length $$buffer > 4;
      $hlen = 4;
      $len = unpack 'n', substr($$buffer, 2, 2);
      warn "-- Extended 16-bit payload ($len)\n" if DEBUG;
    }
  
    # Extended payload (64-bit with 32-bit fallback)
    elsif ($len == 127) {
      return undef unless length $$buffer > 10;
      $hlen = 10;
      my $ext = substr $$buffer, 2, 8;
      $len = MODERN ? unpack('Q>', $ext) : unpack('N', substr($ext, 4, 4));
      warn "-- Extended 64-bit payload ($len)\n" if DEBUG;
    }
  
    # Check message size
    return 1 if $len > $max;
  
    # Check if whole packet has arrived
    $len += 4 if my $masked = $second & 0b10000000;
    return undef if length $$buffer < ($hlen + $len);
    substr $$buffer, 0, $hlen, '';
  
    # Payload
    my $payload = $len ? substr($$buffer, 0, $len, '') : '';
    $payload = xor_encode($payload, substr($payload, 0, 4, '') x 128) if $masked;
    warn dumper $payload if DEBUG;
  
    return [$fin, $rsv1, $rsv2, $rsv3, $op, $payload];
  }
  
  sub server_handshake {
    my $tx = shift;
  
    my $headers = $tx->res->headers;
    $headers->upgrade('websocket')->connection('Upgrade');
    $headers->sec_websocket_accept(
      _challenge($tx->req->headers->sec_websocket_key));
  
    return $tx;
  }
  
  sub _challenge { b64_encode(sha1_bytes(($_[0] || '') . GUID), '') }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::WebSocket - The WebSocket protocol
  
  =head1 SYNOPSIS
  
    use Mojo::WebSocket qw(WS_TEXT build_frame parse_frame);
  
    my $bytes = build_frame 0, 1, 0, 0, 0, WS_TEXT, 'Hello World!';
    my $frame = parse_frame \$bytes, 262144;
  
  =head1 DESCRIPTION
  
  L<Mojo::WebSocket> implements the WebSocket protocol as described in
  L<RFC 6455|http://tools.ietf.org/html/rfc6455>. Note that 64-bit frames require
  a Perl with support for quads or they are limited to 32-bit.
  
  =head1 FUNCTIONS
  
  L<Mojo::WebSocket> implements the following functions, which can be imported
  individually.
  
  =head2 build_frame
  
    my $bytes = build_frame $masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload;
  
  Build WebSocket frame.
  
    # Masked binary frame with FIN bit and payload
    say build_frame 1, 1, 0, 0, 0, WS_BINARY, 'Hello World!';
  
    # Text frame with payload but without FIN bit
    say build_frame 0, 0, 0, 0, 0, WS_TEXT, 'Hello ';
  
    # Continuation frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_CONTINUATION, 'World!';
  
    # Close frame with FIN bit and without payload
    say build_frame 0, 1, 0, 0, 0, WS_CLOSE, '';
  
    # Ping frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_PING, 'Test 123';
  
    # Pong frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_PONG, 'Test 123';
  
  =head2 challenge
  
    my $bool = challenge Mojo::Transaction::WebSocket->new;
  
  Check WebSocket handshake challenge.
  
  =head2 client_handshake
  
    my $tx = client_handshake Mojo::Transaction::HTTP->new;
  
  Perform WebSocket handshake client-side.
  
  =head2 parse_frame
  
    my $frame = parse_frame \$bytes, $limit;
  
  Parse WebSocket frame.
  
    # Parse single frame and remove it from buffer
    my $frame = parse_frame \$buffer, 262144;
    say "FIN: $frame->[0]";
    say "RSV1: $frame->[1]";
    say "RSV2: $frame->[2]";
    say "RSV3: $frame->[3]";
    say "Opcode: $frame->[4]";
    say "Payload: $frame->[5]";
  
  =head2 server_handshake
  
    my $tx = server_handshake Mojo::Transaction::HTTP->new;
  
  Perform WebSocket handshake server-side.
  
  =head1 CONSTANTS
  
  L<Mojo::WebSocket> implements the following constants, which can be imported
  individually.
  
  =head2 WS_BINARY
  
  Opcode for C<Binary> frames.
  
  =head2 WS_CLOSE
  
  Opcode for C<Close> frames.
  
  =head2 WS_CONTINUATION
  
  Opcode for C<Continuation> frames.
  
  =head2 WS_PING
  
  Opcode for C<Ping> frames.
  
  =head2 WS_PONG
  
  Opcode for C<Pong> frames.
  
  =head2 WS_TEXT
  
  Opcode for C<Text> frames.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJO_WEBSOCKET

$fatpacked{"Mojolicious.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS';
  package Mojolicious;
  use Mojo::Base 'Mojo';
  
  # "Fry: Shut up and take my money!"
  use Carp ();
  use Mojo::Exception;
  use Mojo::Util;
  use Mojolicious::Commands;
  use Mojolicious::Controller;
  use Mojolicious::Plugins;
  use Mojolicious::Renderer;
  use Mojolicious::Routes;
  use Mojolicious::Sessions;
  use Mojolicious::Static;
  use Mojolicious::Types;
  use Mojolicious::Validator;
  use Scalar::Util ();
  use Time::HiRes  ();
  
  has commands => sub {
    my $commands = Mojolicious::Commands->new(app => shift);
    Scalar::Util::weaken $commands->{app};
    return $commands;
  };
  has controller_class => 'Mojolicious::Controller';
  has mode => sub { $ENV{MOJO_MODE} || $ENV{PLACK_ENV} || 'development' };
  has moniker  => sub { Mojo::Util::decamelize ref shift };
  has plugins  => sub { Mojolicious::Plugins->new };
  has renderer => sub { Mojolicious::Renderer->new };
  has routes   => sub { Mojolicious::Routes->new };
  has secrets  => sub {
    my $self = shift;
  
    # Warn developers about insecure default
    $self->log->debug('Your secret passphrase needs to be changed');
  
    # Default to moniker
    return [$self->moniker];
  };
  has sessions  => sub { Mojolicious::Sessions->new };
  has static    => sub { Mojolicious::Static->new };
  has types     => sub { Mojolicious::Types->new };
  has validator => sub { Mojolicious::Validator->new };
  
  our $CODENAME = 'Clinking Beer Mugs';
  our $VERSION  = '6.65';
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call helper with fresh controller
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $helper = $self->renderer->get_helper($method);
    return $self->build_controller->$helper(@_);
  }
  
  sub build_controller {
    my ($self, $tx) = @_;
    $tx ||= $self->build_tx;
  
    # Embedded application
    my $stash = {};
    if (my $sub = $tx->can('stash')) { ($stash, $tx) = ($tx->$sub, $tx->tx) }
  
    # Build default controller
    my $defaults = $self->defaults;
    @$stash{keys %$defaults} = values %$defaults;
    my $c
      = $self->controller_class->new(app => $self, stash => $stash, tx => $tx);
    Scalar::Util::weaken $c->{app};
  
    return $c;
  }
  
  sub build_tx {
    my $self = shift;
    my $tx   = Mojo::Transaction::HTTP->new;
    $self->plugins->emit_hook(after_build_tx => $tx, $self);
    return $tx;
  }
  
  sub defaults { Mojo::Util::_stash(defaults => @_) }
  
  sub dispatch {
    my ($self, $c) = @_;
  
    my $plugins = $self->plugins->emit_hook(before_dispatch => $c);
  
    # Try to find a static file
    my $tx = $c->tx;
    $self->static->dispatch($c) and $plugins->emit_hook(after_static => $c)
      unless $tx->res->code;
  
    # Start timer (ignore static files)
    my $stash = $c->stash;
    unless ($stash->{'mojo.static'} || $stash->{'mojo.started'}) {
      my $req    = $c->req;
      my $method = $req->method;
      my $path   = $req->url->path->to_abs_string;
      $self->log->debug(qq{$method "$path"});
      $stash->{'mojo.started'} = [Time::HiRes::gettimeofday];
    }
  
    # Routes
    $plugins->emit_hook(before_routes => $c);
    $c->helpers->reply->not_found
      unless $tx->res->code || $self->routes->dispatch($c) || $tx->res->code;
  }
  
  sub handler {
    my $self = shift;
  
    # Dispatcher has to be last in the chain
    ++$self->{dispatch}
      and $self->hook(around_action   => sub { $_[2]($_[1]) })
      and $self->hook(around_dispatch => sub { $_[1]->app->dispatch($_[1]) })
      unless $self->{dispatch};
  
    # Process with chain
    my $c = $self->build_controller(@_);
    Scalar::Util::weaken $c->{tx};
    $self->plugins->emit_chain(around_dispatch => $c);
  
    # Delayed response
    $self->log->debug('Nothing has been rendered, expecting delayed response')
      unless $c->stash->{'mojo.rendered'};
  }
  
  sub helper { shift->renderer->add_helper(@_) }
  
  sub hook { shift->plugins->on(@_) }
  
  sub new {
    my $self = shift->SUPER::new(@_);
  
    my $home = $self->home;
    push @{$self->renderer->paths}, $home->rel_dir('templates');
    push @{$self->static->paths},   $home->rel_dir('public');
  
    # Default to controller and application namespace
    my $r = $self->routes->namespaces(["@{[ref $self]}::Controller", ref $self]);
  
    # Hide controller attributes/methods
    $r->hide(qw(app continue cookie every_cookie every_param));
    $r->hide(qw(every_signed_cookie finish flash helpers match on param));
    $r->hide(qw(redirect_to render render_later render_maybe render_to_string));
    $r->hide(qw(rendered req res respond_to send session signed_cookie stash));
    $r->hide(qw(tx url_for validation write write_chunk));
  
    # Check if we have a log directory that is writable
    my $mode = $self->mode;
    $self->log->path($home->rel_file("log/$mode.log"))
      if -d $home->rel_file('log') && -w _;
  
    $self->plugin($_)
      for qw(HeaderCondition DefaultHelpers TagHelpers EPLRenderer EPRenderer);
  
    # Exception handling should be first in chain
    $self->hook(around_dispatch => \&_exception);
  
    # Reduced log output outside of development mode
    $self->log->level('info') unless $mode eq 'development';
  
    $self->startup;
  
    return $self;
  }
  
  sub plugin {
    my $self = shift;
    $self->plugins->register_plugin(shift, $self, @_);
  }
  
  sub start {
    my $self = shift;
    $_->warmup for $self->static, $self->renderer;
    return $self->commands->run(@_ ? @_ : @ARGV);
  }
  
  sub startup { }
  
  sub _exception {
    my ($next, $c) = @_;
    local $SIG{__DIE__}
      = sub { ref $_[0] ? CORE::die $_[0] : Mojo::Exception->throw(shift) };
    $c->helpers->reply->exception($@) unless eval { $next->(); 1 };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious - Real-time web framework
  
  =head1 SYNOPSIS
  
    # Application
    package MyApp;
    use Mojo::Base 'Mojolicious';
  
    # Route
    sub startup {
      my $self = shift;
      $self->routes->get('/hello')->to('foo#hello');
    }
  
    # Controller
    package MyApp::Controller::Foo;
    use Mojo::Base 'Mojolicious::Controller';
  
    # Action
    sub hello {
      my $self = shift;
      $self->render(text => 'Hello World!');
    }
  
  =head1 DESCRIPTION
  
  Take a look at our excellent documentation in L<Mojolicious::Guides>!
  
  =head1 HOOKS
  
  L<Mojolicious> will emit the following hooks in the listed order.
  
  =head2 after_build_tx
  
  Emitted right after the transaction is built and before the HTTP request gets
  parsed.
  
    $app->hook(after_build_tx => sub {
      my ($tx, $app) = @_;
      ...
    });
  
  This is a very powerful hook and should not be used lightly, it makes some
  rather advanced features such as upload progress bars possible. Note that this
  hook will not work for embedded applications, because only the host application
  gets to build transactions. (Passed the transaction and application object)
  
  =head2 around_dispatch
  
  Emitted right after a new request has been received and wraps around the whole
  dispatch process, so you have to manually forward to the next hook if you want
  to continue the chain. Default exception handling with
  L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>exception"> is the first hook
  in the chain and a call to L</"dispatch"> the last, yours will be in between.
  
    $app->hook(around_dispatch => sub {
      my ($next, $c) = @_;
      ...
      $next->();
      ...
    });
  
  This is a very powerful hook and should not be used lightly, it allows you to,
  for example, customize application-wide exception handling, consider it the
  sledgehammer in your toolbox. (Passed a callback leading to the next hook and
  the default controller object)
  
  =head2 before_dispatch
  
  Emitted right before the static file server and router start their work.
  
    $app->hook(before_dispatch => sub {
      my $c = shift;
      ...
    });
  
  Very useful for rewriting incoming requests and other preprocessing tasks.
  (Passed the default controller object)
  
  =head2 after_static
  
  Emitted after a static file response has been generated by the static file
  server.
  
    $app->hook(after_static => sub {
      my $c = shift;
      ...
    });
  
  Mostly used for post-processing static file responses. (Passed the default
  controller object)
  
  =head2 before_routes
  
  Emitted after the static file server determined if a static file should be
  served and before the router starts its work.
  
    $app->hook(before_routes => sub {
      my $c = shift;
      ...
    });
  
  Mostly used for custom dispatchers and collecting metrics. (Passed the default
  controller object)
  
  =head2 around_action
  
  Emitted right before an action gets executed and wraps around it, so you have to
  manually forward to the next hook if you want to continue the chain. Default
  action dispatching is the last hook in the chain, yours will run before it.
  
    $app->hook(around_action => sub {
      my ($next, $c, $action, $last) = @_;
      ...
      return $next->();
    });
  
  This is a very powerful hook and should not be used lightly, it allows you for
  example to pass additional arguments to actions or handle return values
  differently. (Passed a callback leading to the next hook, the current
  controller object, the action callback and a flag indicating if this action is
  an endpoint)
  
  =head2 before_render
  
  Emitted before content is generated by the renderer. Note that this hook can
  trigger out of order due to its dynamic nature, and with embedded applications
  will only work for the application that is rendering.
  
    $app->hook(before_render => sub {
      my ($c, $args) = @_;
      ...
    });
  
  Mostly used for pre-processing arguments passed to the renderer. (Passed the
  current controller object and the render arguments)
  
  =head2 after_render
  
  Emitted after content has been generated by the renderer that will be assigned
  to the response. Note that this hook can trigger out of order due to its
  dynamic nature, and with embedded applications will only work for the
  application that is rendering.
  
    $app->hook(after_render => sub {
      my ($c, $output, $format) = @_;
      ...
    });
  
  Mostly used for post-processing dynamically generated content. (Passed the
  current controller object, a reference to the content and the format)
  
  =head2 after_dispatch
  
  Emitted in reverse order after a response has been generated. Note that this
  hook can trigger out of order due to its dynamic nature, and with embedded
  applications will only work for the application that is generating the response.
  
    $app->hook(after_dispatch => sub {
      my $c = shift;
      ...
    });
  
  Useful for rewriting outgoing responses and other post-processing tasks.
  (Passed the current controller object)
  
  =head1 ATTRIBUTES
  
  L<Mojolicious> inherits all attributes from L<Mojo> and implements the
  following new ones.
  
  =head2 commands
  
    my $commands = $app->commands;
    $app         = $app->commands(Mojolicious::Commands->new);
  
  Command line interface for your application, defaults to a
  L<Mojolicious::Commands> object.
  
    # Add another namespace to load commands from
    push @{$app->commands->namespaces}, 'MyApp::Command';
  
  =head2 controller_class
  
    my $class = $app->controller_class;
    $app      = $app->controller_class('Mojolicious::Controller');
  
  Class to be used for the default controller, defaults to
  L<Mojolicious::Controller>. Note that this class needs to have already been
  loaded before the first request arrives.
  
  =head2 mode
  
    my $mode = $app->mode;
    $app     = $app->mode('production');
  
  The operating mode for your application, defaults to a value from the
  C<MOJO_MODE> and C<PLACK_ENV> environment variables or C<development>. Right
  before calling L</"startup">, L<Mojolicious> will pick up the current mode,
  name the log file after it and raise the log level from C<debug> to C<info> if
  it has a value other than C<development>.
  
  =head2 moniker
  
    my $moniker = $app->moniker;
    $app        = $app->moniker('foo_bar');
  
  Moniker of this application, often used as default filename for configuration
  files and the like, defaults to decamelizing the application class with
  L<Mojo::Util/"decamelize">.
  
  =head2 plugins
  
    my $plugins = $app->plugins;
    $app        = $app->plugins(Mojolicious::Plugins->new);
  
  The plugin manager, defaults to a L<Mojolicious::Plugins> object. See the
  L</"plugin"> method below if you want to load a plugin.
  
    # Add another namespace to load plugins from
    push @{$app->plugins->namespaces}, 'MyApp::Plugin';
  
  =head2 renderer
  
    my $renderer = $app->renderer;
    $app         = $app->renderer(Mojolicious::Renderer->new);
  
  Used to render content, defaults to a L<Mojolicious::Renderer> object. For more
  information about how to generate content see
  L<Mojolicious::Guides::Rendering>.
  
    # Add another "templates" directory
    push @{$app->renderer->paths}, '/home/sri/templates';
  
    # Add another "templates" directory with higher precedence
    unshift @{$app->renderer->paths}, '/home/sri/themes/blue/templates';
  
    # Add another class with templates in DATA section
    push @{$app->renderer->classes}, 'Mojolicious::Plugin::Fun';
  
  =head2 routes
  
    my $routes = $app->routes;
    $app       = $app->routes(Mojolicious::Routes->new);
  
  The router, defaults to a L<Mojolicious::Routes> object. You use this in your
  startup method to define the url endpoints for your application.
  
    # Add routes
    my $r = $app->routes;
    $r->get('/foo/bar')->to('test#foo', title => 'Hello Mojo!');
    $r->post('/baz')->to('test#baz');
  
    # Add another namespace to load controllers from
    push @{$app->routes->namespaces}, 'MyApp::MyController';
  
  =head2 secrets
  
    my $secrets = $app->secrets;
    $app        = $app->secrets([$bytes]);
  
  Secret passphrases used for signed cookies and the like, defaults to the
  L</"moniker"> of this application, which is not very secure, so you should
  change it!!! As long as you are using the insecure default there will be debug
  messages in the log file reminding you to change your passphrase. Only the
  first passphrase is used to create new signatures, but all of them for
  verification. So you can increase security without invalidating all your
  existing signed cookies by rotating passphrases, just add new ones to the front
  and remove old ones from the back.
  
    # Rotate passphrases
    $app->secrets(['new_passw0rd', 'old_passw0rd', 'very_old_passw0rd']);
  
  =head2 sessions
  
    my $sessions = $app->sessions;
    $app         = $app->sessions(Mojolicious::Sessions->new);
  
  Signed cookie based session manager, defaults to a L<Mojolicious::Sessions>
  object. You can usually leave this alone, see
  L<Mojolicious::Controller/"session"> for more information about working with
  session data.
  
    # Change name of cookie used for all sessions
    $app->sessions->cookie_name('mysession');
  
  =head2 static
  
    my $static = $app->static;
    $app       = $app->static(Mojolicious::Static->new);
  
  For serving static files from your C<public> directories, defaults to a
  L<Mojolicious::Static> object.
  
    # Add another "public" directory
    push @{$app->static->paths}, '/home/sri/public';
  
    # Add another "public" directory with higher precedence
    unshift @{$app->static->paths}, '/home/sri/themes/blue/public';
  
    # Add another class with static files in DATA section
    push @{$app->static->classes}, 'Mojolicious::Plugin::Fun';
  
  =head2 types
  
    my $types = $app->types;
    $app      = $app->types(Mojolicious::Types->new);
  
  Responsible for connecting file extensions with MIME types, defaults to a
  L<Mojolicious::Types> object.
  
    # Add custom MIME type
    $app->types->type(twt => 'text/tweet');
  
  =head2 validator
  
    my $validator = $app->validator;
    $app          = $app->validator(Mojolicious::Validator->new);
  
  Validate values, defaults to a L<Mojolicious::Validator> object.
  
    # Add validation check
    $app->validator->add_check(foo => sub {
      my ($validation, $name, $value) = @_;
      return $value ne 'foo';
    });
  
    # Add validation filter
    $app->validator->add_filter(quotemeta => sub {
      my ($validation, $name, $value) = @_;
      return quotemeta $value;
    });
  
  =head1 METHODS
  
  L<Mojolicious> inherits all methods from L<Mojo> and implements the following
  new ones.
  
  =head2 build_controller
  
    my $c = $app->build_controller;
    my $c = $app->build_controller(Mojo::Transaction::HTTP->new);
    my $c = $app->build_controller(Mojolicious::Controller->new);
  
  Build default controller object with L</"controller_class">.
  
    # Render template from application
    my $foo = $app->build_controller->render_to_string(template => 'foo');
  
  =head2 build_tx
  
    my $tx = $app->build_tx;
  
  Build L<Mojo::Transaction::HTTP> object and emit L</"after_build_tx"> hook.
  
  =head2 defaults
  
    my $hash = $app->defaults;
    my $foo  = $app->defaults('foo');
    $app     = $app->defaults({foo => 'bar', baz => 23});
    $app     = $app->defaults(foo => 'bar', baz => 23);
  
  Default values for L<Mojolicious::Controller/"stash">, assigned for every new
  request.
  
    # Remove value
    my $foo = delete $app->defaults->{foo};
  
    # Assign multiple values at once
    $app->defaults(foo => 'test', bar => 23);
  
  =head2 dispatch
  
    $app->dispatch(Mojolicious::Controller->new);
  
  The heart of every L<Mojolicious> application, calls the L</"static"> and
  L</"routes"> dispatchers for every request and passes them a
  L<Mojolicious::Controller> object.
  
  =head2 handler
  
    $app->handler(Mojo::Transaction::HTTP->new);
    $app->handler(Mojolicious::Controller->new);
  
  Sets up the default controller and emits the L</"around_dispatch"> hook for
  every request.
  
  =head2 helper
  
    $app->helper(foo => sub {...});
  
  Add or replace a helper that will be available as a method of the controller
  object and the application object, as well as a function in C<ep> templates. For
  a full list of helpers that are available by default see
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  
    # Helper
    $app->helper(cache => sub { state $cache = {} });
  
    # Application
    $app->cache->{foo} = 'bar';
    my $result = $app->cache->{foo};
  
    # Controller
    $c->cache->{foo} = 'bar';
    my $result = $c->cache->{foo};
  
    # Template
    % cache->{foo} = 'bar';
    %= cache->{foo}
  
  =head2 hook
  
    $app->hook(after_dispatch => sub {...});
  
  Extend L<Mojolicious> with hooks, which allow code to be shared with all
  requests indiscriminately, for a full list of available hooks see L</"HOOKS">.
  
    # Dispatchers will not run if there's already a response code defined
    $app->hook(before_dispatch => sub {
      my $c = shift;
      $c->render(text => 'Skipped static file server and router!')
        if $c->req->url->path->to_route =~ /do_not_dispatch/;
    });
  
  =head2 new
  
    my $app = Mojolicious->new;
    my $app = Mojolicious->new(moniker => 'foo_bar');
    my $app = Mojolicious->new({moniker => 'foo_bar'});
  
  Construct a new L<Mojolicious> application and call L</"startup">. Will
  automatically detect your home directory and set up logging based on your
  current operating mode. Also sets up the renderer, static file server, a
  default set of plugins and an L</"around_dispatch"> hook with the default
  exception handling.
  
  =head2 plugin
  
    $app->plugin('some_thing');
    $app->plugin('some_thing', foo => 23);
    $app->plugin('some_thing', {foo => 23});
    $app->plugin('SomeThing');
    $app->plugin('SomeThing', foo => 23);
    $app->plugin('SomeThing', {foo => 23});
    $app->plugin('MyApp::Plugin::SomeThing');
    $app->plugin('MyApp::Plugin::SomeThing', foo => 23);
    $app->plugin('MyApp::Plugin::SomeThing', {foo => 23});
  
  Load a plugin, for a full list of example plugins included in the
  L<Mojolicious> distribution see L<Mojolicious::Plugins/"PLUGINS">.
  
  =head2 start
  
    $app->start;
    $app->start(@ARGV);
  
  Start the command line interface for your application. For a full list of
  commands that are available by default see L<Mojolicious::Commands/"COMMANDS">.
  Note that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
  shared by all commands, will be parsed from C<@ARGV> during compile time.
  
    # Always start daemon
    $app->start('daemon', '-l', 'http://*:8080');
  
  =head2 startup
  
    $app->startup;
  
  This is your main hook into the application, it will be called at application
  startup. Meant to be overloaded in a subclass.
  
    sub startup {
      my $self = shift;
      ...
    }
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  helpers on L<Mojolicious> objects. This includes all helpers from
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  Note that application helpers are always called with a new default controller
  object, so they can't depend on or change controller state, which includes
  request, response and stash.
  
    # Call helper
    say $app->dumper({foo => 'bar'});
  
    # Longer version
    say $app->build_controller->helpers->dumper({foo => 'bar'});
  
  =head1 BUNDLED FILES
  
  The L<Mojolicious> distribution includes a few files with different licenses
  that have been bundled for internal use.
  
  =head2 Mojolicious Artwork
  
    Copyright (C) 2010-2016, Sebastian Riedel.
  
  Licensed under the CC-SA License, Version 4.0
  L<http://creativecommons.org/licenses/by-sa/4.0>.
  
  =head2 jQuery
  
    Copyright (C) jQuery Foundation.
  
  Licensed under the MIT License, L<http://creativecommons.org/licenses/MIT>.
  
  =head2 prettify.js
  
    Copyright (C) 2006, 2013 Google Inc..
  
  Licensed under the Apache License, Version 2.0
  L<http://www.apache.org/licenses/LICENSE-2.0>.
  
  =head1 CODE NAMES
  
  Every major release of L<Mojolicious> has a code name, these are the ones that
  have been used in the past.
  
  6.0, C<Clinking Beer Mugs> (U+1F37B)
  
  5.0, C<Tiger Face> (U+1F42F)
  
  4.0, C<Top Hat> (U+1F3A9)
  
  3.0, C<Rainbow> (U+1F308)
  
  2.0, C<Leaf Fluttering In Wind> (U+1F343)
  
  1.4, C<Smiling Face With Sunglasses> (U+1F60E)
  
  1.3, C<Tropical Drink> (U+1F379)
  
  1.1, C<Smiling Cat Face With Heart-Shaped Eyes> (U+1F63B)
  
  1.0, C<Snowflake> (U+2744)
  
  =head1 SPONSORS
  
  Some of the work on this distribution has been sponsored by
  L<The Perl Foundation|http://www.perlfoundation.org>, thank you!
  
  =head1 PROJECT FOUNDER
  
  Sebastian Riedel, C<sri@cpan.org>
  
  =head1 CORE DEVELOPERS
  
  Current members of the core team in alphabetical order:
  
  =over 2
  
  Abhijit Menon-Sen, C<ams@cpan.org>
  
  Glen Hinkle, C<tempire@cpan.org>
  
  Jan Henning Thorsen, C<jhthorsen@cpan.org>
  
  Joel Berger, C<jberger@cpan.org>
  
  Marcus Ramberg, C<mramberg@cpan.org>
  
  =back
  
  =head1 CREDITS
  
  In alphabetical order:
  
  =over 2
  
  Adam Kennedy
  
  Adriano Ferreira
  
  Al Newkirk
  
  Alex Efros
  
  Alex Salimon
  
  Alexey Likhatskiy
  
  Anatoly Sharifulin
  
  Andre Parker
  
  Andre Vieth
  
  Andreas Jaekel
  
  Andreas Koenig
  
  Andrew Fresh
  
  Andrew Nugged
  
  Andrey Khozov
  
  Andrey Kuzmin
  
  Andy Grundman
  
  Aristotle Pagaltzis
  
  Ashley Dev
  
  Ask Bjoern Hansen
  
  Audrey Tang
  
  Ben Tyler
  
  Ben van Staveren
  
  Benjamin Erhart
  
  Bernhard Graf
  
  Breno G. de Oliveira
  
  Brian Duggan
  
  Brian Medley
  
  Burak Gursoy
  
  Ch Lamprecht
  
  Charlie Brady
  
  Chas. J. Owens IV
  
  Christian Hansen
  
  chromatic
  
  Curt Tilmes
  
  Dan Book
  
  Daniel Kimsey
  
  Danijel Tasov
  
  Danny Thomas
  
  David Davis
  
  David Webb
  
  Diego Kuperman
  
  Dmitriy Shalashov
  
  Dmitry Konstantinov
  
  Dominik Jarmulowicz
  
  Dominique Dumont
  
  Douglas Christopher Wilson
  
  Eugen Konkov
  
  Eugene Toropov
  
  Gisle Aas
  
  Graham Barr
  
  Graham Knop
  
  Henry Tang
  
  Hideki Yamamura
  
  Hiroki Toyokawa
  
  Ian Goodacre
  
  Ilya Chesnokov
  
  James Duncan
  
  Jan Jona Javorsek
  
  Jan Schmidt
  
  Jaroslav Muhin
  
  Jesse Vincent
  
  Johannes Plunien
  
  John Kingsley
  
  Jonathan Yu
  
  Josh Leder
  
  Kazuhiro Shibuya
  
  Kevin Old
  
  Kitamura Akatsuki
  
  Klaus S. Madsen
  
  Lars Balker Rasmussen
  
  Lee Johnson
  
  Leon Brocard
  
  Magnus Holm
  
  Maik Fischer
  
  Mark Fowler
  
  Mark Grimes
  
  Mark Stosberg
  
  Marty Tennison
  
  Matt S Trout
  
  Matthew Lineen
  
  Maksym Komar
  
  Maxim Vuets
  
  Michael Gregorowicz
  
  Michael Harris
  
  Mike Magowan
  
  Mirko Westermeier
  
  Mons Anderson
  
  Moritz Lenz
  
  Neil Watkiss
  
  Nic Sandfield
  
  Nils Diewald
  
  Oleg Zhelo
  
  Olivier Mengue
  
  Pascal Gaudette
  
  Paul Evans
  
  Paul Tomlin
  
  Pavel Shaydo
  
  Pedro Melo
  
  Peter Edwards
  
  Pierre-Yves Ritschard
  
  Piotr Roszatycki
  
  Quentin Carbonneaux
  
  Rafal Pocztarski
  
  Randal Schwartz
  
  Richard Elberger
  
  Rick Delaney
  
  Robert Hicks
  
  Robin Lee
  
  Roland Lammel
  
  Roy Storey
  
  Ryan Jendoubi
  
  Sascha Kiefer
  
  Scott Wiersdorf
  
  Sergey Zasenko
  
  Simon Bertrang
  
  Simone Tampieri
  
  Shu Cho
  
  Skye Shaw
  
  Stanis Trendelenburg
  
  Steffen Ullrich
  
  Stephane Este-Gracias
  
  Steve Atkins
  
  Tatsuhiko Miyagawa
  
  Terrence Brannon
  
  Tianon Gravi
  
  Tomas Znamenacek
  
  Ulrich Habel
  
  Ulrich Kautz
  
  Uwe Voelker
  
  Viacheslav Tykhanovskyi
  
  Victor Engmark
  
  Viliam Pucik
  
  Wes Cravens
  
  Yaroslav Korshak
  
  Yuki Kimoto
  
  Zak B. Elep
  
  Zoffix Znet
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2016, Sebastian Riedel and others.
  
  This program is free software, you can redistribute it and/or modify it under
  the terms of the Artistic License version 2.0.
  
  =head1 SEE ALSO
  
  L<https://github.com/kraih/mojo>, L<Mojolicious::Guides>,
  L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS

$fatpacked{"Mojolicious/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND';
  package Mojolicious::Command;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Cwd 'getcwd';
  use File::Basename 'dirname';
  use File::Path 'mkpath';
  use File::Spec::Functions qw(catdir catfile);
  use Mojo::Loader 'data_section';
  use Mojo::Server;
  use Mojo::Template;
  use Mojo::Util qw(spurt unindent);
  use Pod::Usage 'pod2usage';
  
  has app => sub { Mojo::Server->new->build_app('Mojo::HelloWorld') };
  has description => 'No description';
  has 'quiet';
  has usage => "Usage: APPLICATION\n";
  
  sub chmod_file {
    my ($self, $path, $mod) = @_;
    chmod $mod, $path or croak qq{Can't chmod file "$path": $!};
    return $self->_loud("  [chmod] $path " . sprintf('%lo', $mod));
  }
  
  sub chmod_rel_file { $_[0]->chmod_file($_[0]->rel_file($_[1]), $_[2]) }
  
  sub create_dir {
    my ($self, $path) = @_;
    return $self->_loud("  [exist] $path") if -d $path;
    mkpath $path or croak qq{Can't make directory "$path": $!};
    return $self->_loud("  [mkdir] $path");
  }
  
  sub create_rel_dir { $_[0]->create_dir($_[0]->rel_dir($_[1])) }
  
  sub extract_usage {
    my $self = shift;
  
    open my $handle, '>', \my $output;
    pod2usage -exitval => 'noexit', -input => (caller)[1], -output => $handle;
    $output =~ s/^.*\n//;
    $output =~ s/\n$//;
  
    return unindent $output;
  }
  
  sub help { print shift->usage }
  
  sub rel_dir  { catdir getcwd(),  split('/', pop) }
  sub rel_file { catfile getcwd(), split('/', pop) }
  
  sub render_data {
    my ($self, $name) = (shift, shift);
    Mojo::Template->new->name("template $name from DATA section")
      ->render(data_section(ref $self, $name), @_);
  }
  
  sub render_to_file {
    my ($self, $data, $path) = (shift, shift, shift);
    return $self->write_file($path, $self->render_data($data, @_));
  }
  
  sub render_to_rel_file {
    my $self = shift;
    $self->render_to_file(shift, $self->rel_dir(shift), @_);
  }
  
  sub run { croak 'Method "run" not implemented by subclass' }
  
  sub write_file {
    my ($self, $path, $data) = @_;
    return $self->_loud("  [exist] $path") if -f $path;
    $self->create_dir(dirname $path);
    spurt $data, $path;
    return $self->_loud("  [write] $path");
  }
  
  sub write_rel_file { $_[0]->write_file($_[0]->rel_file($_[1]), $_[2]) }
  
  sub _loud {
    my ($self, $msg) = @_;
    say $msg unless $self->quiet;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command - Command base class
  
  =head1 SYNOPSIS
  
    # Lowercase command name
    package Mojolicious::Command::mycommand;
    use Mojo::Base 'Mojolicious::Command';
  
    # Short description
    has description => 'My first Mojo command';
  
    # Short usage message
    has usage => <<EOF;
    Usage: APPLICATION mycommand [OPTIONS]
  
    Options:
      -s, --something   Does something
    EOF
  
    sub run {
      my ($self, @args) = @_;
  
      # Magic here! :)
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command> is an abstract base class for L<Mojolicious> commands.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command> implements the following attributes.
  
  =head2 app
  
    my $app  = $command->app;
    $command = $command->app(Mojolicious->new);
  
  Application for command, defaults to a L<Mojo::HelloWorld> object.
  
    # Introspect
    say "Template path: $_" for @{$command->app->renderer->paths};
  
  =head2 description
  
    my $description = $command->description;
    $command        = $command->description('Foo');
  
  Short description of command, used for the command list.
  
  =head2 quiet
  
    my $bool = $command->quiet;
    $command = $command->quiet($bool);
  
  Limited command output.
  
  =head2 usage
  
    my $usage = $command->usage;
    $command  = $command->usage('Foo');
  
  Usage information for command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 chmod_file
  
    $command = $command->chmod_file('/home/sri/foo.txt', 0644);
  
  Change mode of a file.
  
  =head2 chmod_rel_file
  
    $command = $command->chmod_rel_file('foo/foo.txt', 0644);
  
  Portably change mode of a file relative to the current working directory.
  
  =head2 create_dir
  
    $command = $command->create_dir('/home/sri/foo/bar');
  
  Create a directory.
  
  =head2 create_rel_dir
  
    $command = $command->create_rel_dir('foo/bar/baz');
  
  Portably create a directory relative to the current working directory.
  
  =head2 extract_usage
  
    my $usage = $command->extract_usage;
  
  Extract usage message from the SYNOPSIS section of the file this method was
  called from.
  
  =head2 help
  
    $command->help;
  
  Print usage information for command.
  
  =head2 rel_dir
  
    my $path = $command->rel_dir('foo/bar');
  
  Portably generate an absolute path for a directory relative to the current
  working directory.
  
  =head2 rel_file
  
    my $path = $command->rel_file('foo/bar.txt');
  
  Portably generate an absolute path for a file relative to the current working
  directory.
  
  =head2 render_data
  
    my $data = $command->render_data('foo_bar');
    my $data = $command->render_data('foo_bar', @args);
  
  Render a template from the C<DATA> section of the command class with
  L<Mojo::Loader> and L<Mojo::Template>.
  
  =head2 render_to_file
  
    $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt');
    $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt', @args);
  
  Render a template from the C<DATA> section of the command class with
  L<Mojo::Template> to a file and create directory if necessary.
  
  =head2 render_to_rel_file
  
    $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt');
    $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt', @args);
  
  Portably render a template from the C<DATA> section of the command class with
  L<Mojo::Template> to a file relative to the current working directory and
  create directory if necessary.
  
  =head2 run
  
    $command->run;
    $command->run(@ARGV);
  
  Run command. Meant to be overloaded in a subclass.
  
  =head2 write_file
  
    $command = $command->write_file('/home/sri/foo.txt', 'Hello World!');
  
  Write text to a file and create directory if necessary.
  
  =head2 write_rel_file
  
    $command = $command->write_rel_file('foo/bar.txt', 'Hello World!');
  
  Portably write text to a file relative to the current working directory and
  create directory if necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND

$fatpacked{"Mojolicious/Command/cgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CGI';
  package Mojolicious::Command::cgi;
  use Mojo::Base 'Mojolicious::Command';
  
  use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);
  use Mojo::Server::CGI;
  
  has description => 'Start application with CGI';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
    GetOptionsFromArray \@args, nph => \(my $nph = 0);
    Mojo::Server::CGI->new(app => $self->app, nph => $nph)->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::cgi - CGI command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION cgi [OPTIONS]
  
      ./myapp.pl cgi
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
          --nph           Enable non-parsed-header mode
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::cgi> starts applications with the L<Mojo::Server::CGI>
  backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::cgi> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $cgi->description;
    $cgi            = $cgi->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $cgi->usage;
    $cgi      = $cgi->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::cgi> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $cgi->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_CGI

$fatpacked{"Mojolicious/Command/cpanify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CPANIFY';
  package Mojolicious::Command::cpanify;
  use Mojo::Base 'Mojolicious::Command';
  
  use File::Basename 'basename';
  use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);
  
  has description => 'Upload distribution to CPAN';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    GetOptionsFromArray \@args,
      'p|password=s' => \(my $password = ''),
      'u|user=s'     => \(my $user     = '');
    die $self->usage unless my $file = shift @args;
  
    my $tx = $self->app->ua->tap(sub { $_->proxy->detect })->post(
      "https://$user:$password\@pause.perl.org/pause/authenquery" => form => {
        HIDDENNAME                        => $user,
        CAN_MULTIPART                     => 1,
        pause99_add_uri_upload            => basename($file),
        SUBMIT_pause99_add_uri_httpupload => ' Upload this file from my disk ',
        pause99_add_uri_uri               => '',
        pause99_add_uri_httpupload        => {file => $file},
      }
    );
  
    unless ($tx->success) {
      my $code = $tx->res->code // 0;
      my $msg = $tx->error->{message};
      if    ($code == 401) { $msg = 'Wrong username or password.' }
      elsif ($code == 409) { $msg = 'File already exists on CPAN.' }
      die qq{Problem uploading file "$file": $msg\n};
    }
  
    say 'Upload successful!';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::cpanify - CPAN-ify command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION cpanify [OPTIONS] [FILE]
  
      mojo cpanify -u sri -p secr3t Mojolicious-Plugin-MyPlugin-0.01.tar.gz
  
    Options:
      -h, --help                  Show this summary of available options
      -p, --password <password>   PAUSE password
      -u, --user <name>           PAUSE username
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::cpanify> uploads files to CPAN.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::cpanify> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $cpanify->description;
    $cpanify        = $cpanify->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $cpanify->usage;
    $cpanify  = $cpanify->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::cpanify> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $cpanify->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_CPANIFY

$fatpacked{"Mojolicious/Command/daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_DAEMON';
  package Mojolicious::Command::daemon;
  use Mojo::Base 'Mojolicious::Command';
  
  use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);
  use Mojo::Server::Daemon;
  
  has description => 'Start application with HTTP and WebSocket server';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $daemon = Mojo::Server::Daemon->new(app => $self->app);
    GetOptionsFromArray \@args,
      'b|backlog=i'            => sub { $daemon->backlog($_[1]) },
      'c|clients=i'            => sub { $daemon->max_clients($_[1]) },
      'i|inactivity-timeout=i' => sub { $daemon->inactivity_timeout($_[1]) },
      'l|listen=s'   => \my @listen,
      'p|proxy'      => sub { $daemon->reverse_proxy(1) },
      'r|requests=i' => sub { $daemon->max_requests($_[1]) };
  
    $daemon->listen(\@listen) if @listen;
    $daemon->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::daemon - Daemon command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION daemon [OPTIONS]
  
      ./myapp.pl daemon
      ./myapp.pl daemon -m production -l http://*:8080
      ./myapp.pl daemon -l http://127.0.0.1:8080 -l https://[::]:8081
      ./myapp.pl daemon -l 'https://*:443?cert=./server.crt&key=./server.key'
  
    Options:
      -b, --backlog <size>                 Listen backlog size, defaults to
                                           SOMAXCONN
      -c, --clients <number>               Maximum number of concurrent
                                           connections, defaults to 1000
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 15
      -l, --listen <location>              One or more locations you want to
                                           listen on, defaults to the value of
                                           MOJO_LISTEN or "http://*:3000"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -p, --proxy                          Activate reverse proxy support,
                                           defaults to the value of
                                           MOJO_REVERSE_PROXY
      -r, --requests <number>              Maximum number of requests per
                                           keep-alive connection, defaults to 100
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::daemon> starts applications with the
  L<Mojo::Server::Daemon> backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::daemon> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $daemon->description;
    $daemon         = $daemon->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $daemon->usage;
    $daemon   = $daemon->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::daemon> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $daemon->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_DAEMON

$fatpacked{"Mojolicious/Command/eval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_EVAL';
  package Mojolicious::Command::eval;
  use Mojo::Base 'Mojolicious::Command';
  
  use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);
  
  has description => 'Run code against application';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    GetOptionsFromArray \@args, 'v|verbose' => \my $v1, 'V' => \my $v2;
    my $code = shift @args || '';
  
    # Run code against application
    my $app = $self->app;
    no warnings;
    my $result = eval "package main; sub app; local *app = sub { \$app }; $code";
    return $@ ? die $@ : $result unless defined $result && ($v1 || $v2);
    $v2 ? print($app->dumper($result)) : say $result;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::eval - Eval command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION eval [OPTIONS] CODE
  
      ./myapp.pl eval 'say app->ua->get("/")->res->body'
      ./myapp.pl eval 'say for sort keys %{app->renderer->helpers}'
      ./myapp.pl eval -v 'app->home'
      ./myapp.pl eval -V 'app->renderer->paths'
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
      -v, --verbose       Print return value to STDOUT
      -V                  Print returned data structure to STDOUT
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::eval> runs code against applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::eval> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $eval->description;
    $eval           = $eval->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $eval->usage;
    $eval     = $eval->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::eval> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $eval->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_EVAL

$fatpacked{"Mojolicious/Command/generate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE';
  package Mojolicious::Command::generate;
  use Mojo::Base 'Mojolicious::Commands';
  
  has description => 'Generate files and directories from templates';
  has hint        => <<EOF;
  
  See 'APPLICATION generate help GENERATOR' for more information on a specific
  generator.
  EOF
  has message    => sub { shift->extract_usage . "\nGenerators:\n" };
  has namespaces => sub { ['Mojolicious::Command::generate'] };
  
  sub help { shift->run(@_) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate - Generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate GENERATOR [OPTIONS]
  
      mojo generate app
      mojo generate lite_app
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate> lists available generators.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate> inherits all attributes from
  L<Mojolicious::Commands> and implements the following new ones.
  
  =head2 description
  
    my $description = $generator->description;
    $generator      = $generator->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 hint
  
    my $hint   = $generator->hint;
    $generator = $generator->hint('Foo');
  
  Short hint shown after listing available generator commands.
  
  =head2 message
  
    my $msg    = $generator->message;
    $generator = $generator->message('Bar');
  
  Short usage message shown before listing available generator commands.
  
  =head2 namespaces
  
    my $namespaces = $generator->namespaces;
    $generator     = $generator->namespaces(['MyApp::Command::generate']);
  
  Namespaces to search for available generator commands, defaults to
  L<Mojolicious::Command::generate>.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate> inherits all methods from
  L<Mojolicious::Commands> and implements the following new ones.
  
  =head2 help
  
    $generator->help('app');
  
  Print usage information for generator command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_GENERATE

$fatpacked{"Mojolicious/Command/generate/app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_APP';
  package Mojolicious::Command::generate::app;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util qw(class_to_file class_to_path);
  
  has description => 'Generate Mojolicious application directory structure';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $class) = @_;
    $class ||= 'MyApp';
  
    # Prevent bad applications
    die <<EOF unless $class =~ /^[A-Z](?:\w|::)+$/;
  Your application name has to be a well formed (CamelCase) Perl module name
  like "MyApp".
  EOF
  
    # Script
    my $name = class_to_file $class;
    $self->render_to_rel_file('mojo', "$name/script/$name", $class);
    $self->chmod_rel_file("$name/script/$name", 0744);
  
    # Application class
    my $app = class_to_path $class;
    $self->render_to_rel_file('appclass', "$name/lib/$app", $class);
  
    # Controller
    my $controller = "${class}::Controller::Example";
    my $path       = class_to_path $controller;
    $self->render_to_rel_file('controller', "$name/lib/$path", $controller);
  
    # Test
    $self->render_to_rel_file('test', "$name/t/basic.t", $class);
  
    # Static file
    $self->render_to_rel_file('static', "$name/public/index.html");
  
    # Templates
    $self->render_to_rel_file('layout',
      "$name/templates/layouts/default.html.ep");
    $self->render_to_rel_file('welcome',
      "$name/templates/example/welcome.html.ep");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::app - App generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate app [OPTIONS] [NAME]
  
      mojo generate app
      mojo generate app TestApp
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::app> generates application directory
  structures for fully functional L<Mojolicious> applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::app> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $app->description;
    $app            = $app->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $app->usage;
    $app      = $app->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::app> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $app->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ mojo
  % my $class = shift;
  #!/usr/bin/env perl
  
  use strict;
  use warnings;
  
  use FindBin;
  BEGIN { unshift @INC, "$FindBin::Bin/../lib" }
  use Mojolicious::Commands;
  
  # Start command line interface for application
  Mojolicious::Commands->start_app('<%= $class %>');
  
  @@ appclass
  % my $class = shift;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious';
  
  # This method will run once at server start
  sub startup {
    my $self = shift;
  
    # Documentation browser under "/perldoc"
    $self->plugin('PODRenderer');
  
    # Router
    my $r = $self->routes;
  
    # Normal route to controller
    $r->get('/')->to('example#welcome');
  }
  
  1;
  
  @@ controller
  % my $class = shift;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Controller';
  
  # This action will render a template
  sub welcome {
    my $self = shift;
  
    # Render template "example/welcome.html.ep" with message
    $self->render(msg => 'Welcome to the Mojolicious real-time web framework!');
  }
  
  1;
  
  @@ static
  <!DOCTYPE html>
  <html>
    <head>
      <title>Welcome to the Mojolicious real-time web framework!</title>
    </head>
    <body>
      <h2>Welcome to the Mojolicious real-time web framework!</h2>
      This is the static document "public/index.html",
      <a href="/">click here</a> to get back to the start.
    </body>
  </html>
  
  @@ test
  % my $class = shift;
  use Mojo::Base -strict;
  
  use Test::More;
  use Test::Mojo;
  
  my $t = Test::Mojo->new('<%= $class %>');
  $t->get_ok('/')->status_is(200)->content_like(qr/Mojolicious/i);
  
  done_testing();
  
  @@ layout
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
  
  @@ welcome
  %% layout 'default';
  %% title 'Welcome';
  <h2><%%= $msg %></h2>
  This page was generated from the template "templates/example/welcome.html.ep"
  and the layout "templates/layouts/default.html.ep",
  <%%= link_to 'click here' => url_for %> to reload the page or
  <%%= link_to 'here' => '/index.html' %> to move forward to a static page. To
  learn more, you can also browse through the documentation
  <%%= link_to 'here' => '/perldoc' %>.
MOJOLICIOUS_COMMAND_GENERATE_APP

$fatpacked{"Mojolicious/Command/generate/lite_app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_LITE_APP';
  package Mojolicious::Command::generate::lite_app;
  use Mojo::Base 'Mojolicious::Command';
  
  has description => 'Generate Mojolicious::Lite application';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $name) = @_;
    $name ||= 'myapp.pl';
    $self->render_to_rel_file('liteapp', $name);
    $self->chmod_rel_file($name, 0744);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::lite_app - Lite app generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate lite_app [OPTIONS] [NAME]
  
      mojo generate lite_app
      mojo generate lite_app foo.pl
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::lite_app> generate fully functional
  L<Mojolicious::Lite> applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::lite_app> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $app->description;
    $app            = $app->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $app->usage;
    $app      = $app->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::lite_app> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $app->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ liteapp
  #!/usr/bin/env perl
  use Mojolicious::Lite;
  
  # Documentation browser under "/perldoc"
  plugin 'PODRenderer';
  
  get '/' => sub {
    my $c = shift;
    $c->render(template => 'index');
  };
  
  app->start;
  <% %>__DATA__
  
  <% %>@@ index.html.ep
  %% layout 'default';
  %% title 'Welcome';
  <h1>Welcome to the Mojolicious real-time web framework!</h1>
  To learn more, you can browse through the documentation
  <%%= link_to 'here' => '/perldoc' %>.
  
  <% %>@@ layouts/default.html.ep
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
MOJOLICIOUS_COMMAND_GENERATE_LITE_APP

$fatpacked{"Mojolicious/Command/generate/makefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE';
  package Mojolicious::Command::generate::makefile;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojolicious;
  
  has description => 'Generate "Makefile.PL"';
  has usage => sub { shift->extract_usage };
  
  sub run { shift->render_to_rel_file('makefile', 'Makefile.PL') }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::makefile - Makefile generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate makefile [OPTIONS]
  
      mojo generate makefile
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::makefile> generates C<Makefile.PL> files for
  applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::makefile> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $makefile->description;
    $makefile       = $makefile->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $makefile->usage;
    $makefile = $makefile->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::makefile> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $makefile->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ makefile
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    VERSION   => '0.01',
    PREREQ_PM => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test      => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE

$fatpacked{"Mojolicious/Command/generate/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_PLUGIN';
  package Mojolicious::Command::generate::plugin;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util qw(camelize class_to_path);
  use Mojolicious;
  
  has description => 'Generate Mojolicious plugin directory structure';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $name) = @_;
    $name ||= 'MyPlugin';
  
    # Class
    my $class = $name =~ /^[a-z]/ ? camelize $name : $name;
    $class = "Mojolicious::Plugin::$class";
    my $app = class_to_path $class;
    my $dir = join '-', split('::', $class);
    $self->render_to_rel_file('class', "$dir/lib/$app", $class, $name);
  
    # Test
    $self->render_to_rel_file('test', "$dir/t/basic.t", $name);
  
    # Makefile
    $self->render_to_rel_file('makefile', "$dir/Makefile.PL", $class, $app);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::plugin - Plugin generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate plugin [OPTIONS] [NAME]
  
      mojo generate plugin
      mojo generate plugin TestPlugin
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::plugin> generates directory structures for
  fully functional L<Mojolicious> plugins.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::plugin> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $plugin->description;
    $plugin         = $plugin->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $plugin->usage;
    $plugin   = $plugin->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::plugin> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $plugin->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ class
  % my ($class, $name) = @_;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Plugin';
  
  our $VERSION = '0.01';
  
  sub register {
    my ($self, $app) = @_;
  }
  
  1;
  <% %>__END__
  
  <% %>=encoding utf8
  
  <% %>=head1 NAME
  
  <%= $class %> - Mojolicious Plugin
  
  <% %>=head1 SYNOPSIS
  
    # Mojolicious
    $self->plugin('<%= $name %>');
  
    # Mojolicious::Lite
    plugin '<%= $name %>';
  
  <% %>=head1 DESCRIPTION
  
  L<<%= $class %>> is a L<Mojolicious> plugin.
  
  <% %>=head1 METHODS
  
  L<<%= $class %>> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  <% %>=head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register plugin in L<Mojolicious> application.
  
  <% %>=head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  <% %>=cut
  
  @@ test
  % my $name = shift;
  use Mojo::Base -strict;
  
  use Test::More;
  use Mojolicious::Lite;
  use Test::Mojo;
  
  plugin '<%= $name %>';
  
  get '/' => sub {
    my $c = shift;
    $c->render(text => 'Hello Mojo!');
  };
  
  my $t = Test::Mojo->new;
  $t->get_ok('/')->status_is(200)->content_is('Hello Mojo!');
  
  done_testing();
  
  @@ makefile
  % my ($class, $path) = @_;
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    NAME         => '<%= $class %>',
    VERSION_FROM => 'lib/<%= $path %>',
    AUTHOR       => 'A Good Programmer <nospam@cpan.org>',
    PREREQ_PM    => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test         => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_PLUGIN

$fatpacked{"Mojolicious/Command/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GET';
  package Mojolicious::Command::get;
  use Mojo::Base 'Mojolicious::Command';
  
  use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);
  use Mojo::DOM;
  use Mojo::IOLoop;
  use Mojo::JSON qw(encode_json j);
  use Mojo::JSON::Pointer;
  use Mojo::UserAgent;
  use Mojo::Util qw(decode encode);
  use Scalar::Util 'weaken';
  
  has description => 'Perform HTTP request';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    GetOptionsFromArray \@args,
      'C|charset=s' => \my $charset,
      'c|content=s' => \(my $content = ''),
      'H|header=s'  => \my @headers,
      'M|method=s'  => \(my $method = 'GET'),
      'r|redirect'  => \my $redirect,
      'v|verbose'   => \my $verbose;
  
    @args = map { decode 'UTF-8', $_ } @args;
    die $self->usage unless my $url = shift @args;
    my $selector = shift @args;
  
    # Parse header pairs
    my %headers = map { /^\s*([^:]+)\s*:\s*(.+)$/ ? ($1, $2) : () } @headers;
  
    # Detect proxy for absolute URLs
    my $ua = Mojo::UserAgent->new(ioloop => Mojo::IOLoop->singleton);
    $url !~ m!^/! ? $ua->proxy->detect : $ua->server->app($self->app);
    $ua->max_redirects(10) if $redirect;
  
    my $buffer = '';
    $ua->on(
      start => sub {
        my ($ua, $tx) = @_;
  
        # Verbose
        weaken $tx;
        $tx->res->content->on(
          body => sub { warn _header($tx->req), _header($tx->res) })
          if $verbose;
  
        # Stream content (ignore redirects)
        $tx->res->content->unsubscribe('read')->on(
          read => sub {
            return if $redirect && $tx->res->is_status_class(300);
            defined $selector ? ($buffer .= pop) : print pop;
          }
        );
      }
    );
  
    # Switch to verbose for HEAD requests
    $verbose = 1 if $method eq 'HEAD';
    STDOUT->autoflush(1);
    my $tx = $ua->start($ua->build_tx($method, $url, \%headers, $content));
    my $err = $tx->error;
    warn qq{Problem loading URL "@{[$tx->req->url]}": $err->{message}\n}
      if $err && !$err->{code};
  
    # JSON Pointer
    return unless defined $selector;
    return _json($buffer, $selector) if !length $selector || $selector =~ m!^/!;
  
    # Selector
    $charset //= $tx->res->content->charset || $tx->res->default_charset;
    _select($buffer, $selector, $charset, @args);
  }
  
  sub _header { $_[0]->build_start_line, $_[0]->headers->to_string, "\n\n" }
  
  sub _json {
    return unless my $data = j(shift);
    return unless defined($data = Mojo::JSON::Pointer->new($data)->get(shift));
    return _say($data) unless ref $data eq 'HASH' || ref $data eq 'ARRAY';
    say encode_json($data);
  }
  
  sub _say { length && say encode('UTF-8', $_) for @_ }
  
  sub _select {
    my ($buffer, $selector, $charset, @args) = @_;
  
    # Keep a strong reference to the root
    $buffer = decode($charset, $buffer) // $buffer if $charset;
    my $dom     = Mojo::DOM->new($buffer);
    my $results = $dom->find($selector);
  
    while (defined(my $command = shift @args)) {
  
      # Number
      ($results = $results->slice($command)) and next if $command =~ /^\d+$/;
  
      # Text
      return _say($results->map('text')->each) if $command eq 'text';
  
      # All text
      return _say($results->map('all_text')->each) if $command eq 'all';
  
      # Attribute
      return _say($results->map(attr => $args[0] // '')->each)
        if $command eq 'attr';
  
      # Unknown
      die qq{Unknown command "$command".\n};
    }
  
    _say($results->each);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::get - Get command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION get [OPTIONS] URL [SELECTOR|JSON-POINTER] [COMMANDS]
  
      ./myapp.pl get /
      ./myapp.pl get -H 'Accept: text/html' /hello.html 'head > title' text
      ./myapp.pl get //sri:secr3t@/secrets.json /1/content
      mojo get mojolicious.org
      mojo get -v -r google.com
      mojo get -v -H 'Host: mojolicious.org' -H 'Accept: */*' mojolicious.org
      mojo get -M POST -H 'Content-Type: text/trololo' -c 'trololo' perl.org
      mojo get mojolicious.org 'head > title' text
      mojo get mojolicious.org .footer all
      mojo get mojolicious.org a attr href
      mojo get mojolicious.org '*' attr id
      mojo get mojolicious.org 'h1, h2, h3' 3 text
      mojo get https://api.metacpan.org/v0/author/SRI /name
  
    Options:
      -C, --charset <charset>     Charset of HTML/XML content, defaults to
                                  auto-detection
      -c, --content <content>     Content to send with request
      -H, --header <name:value>   Additional HTTP header
      -h, --help                  Show this summary of available options
          --home <path>           Path to home directory of your application,
                                  defaults to the value of MOJO_HOME or
                                  auto-detection
      -M, --method <method>       HTTP method to use, defaults to "GET"
      -m, --mode <name>           Operating mode for your application, defaults to
                                  the value of MOJO_MODE/PLACK_ENV or
                                  "development"
      -r, --redirect              Follow up to 10 redirects
      -v, --verbose               Print request and response headers to STDERR
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::get> is a command line interface for
  L<Mojo::UserAgent>.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::get> performs requests to remote hosts or local
  applications.
  
  =head2 description
  
    my $description = $get->description;
    $get            = $get->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $get->usage;
    $get      = $get->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::get> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $get->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_GET

$fatpacked{"Mojolicious/Command/inflate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_INFLATE';
  package Mojolicious::Command::inflate;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Loader qw(data_section file_is_binary);
  use Mojo::Util 'encode';
  
  has description => 'Inflate embedded files to real files';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my $self = shift;
  
    # Find all embedded files
    my %all;
    my $app = $self->app;
    for my $class (@{$app->renderer->classes}, @{$app->static->classes}) {
      for my $name (keys %{data_section $class}) {
        my $data = data_section $class, $name;
        $data = encode 'UTF-8', $data unless file_is_binary $class, $name;
        $all{$name} = $data;
      }
    }
  
    # Turn them into real files
    for my $name (grep {/\.\w+$/} keys %all) {
      my $prefix = $name =~ /\.\w+\.\w+$/ ? 'templates' : 'public';
      $self->write_file($self->rel_file("$prefix/$name"), $all{$name});
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::inflate - Inflate command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION inflate [OPTIONS]
  
      ./myapp.pl inflate
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::inflate> turns templates and static files embedded in
  the C<DATA> sections of your application into real files.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::inflate> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $inflate->description;
    $inflate        = $inflate->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $inflate->usage;
    $inflate  = $inflate->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::inflate> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $inflate->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_INFLATE

$fatpacked{"Mojolicious/Command/prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PREFORK';
  package Mojolicious::Command::prefork;
  use Mojo::Base 'Mojolicious::Command';
  
  use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);
  use Mojo::Server::Prefork;
  
  has description =>
    'Start application with preforking HTTP and WebSocket server';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $prefork = Mojo::Server::Prefork->new(app => $self->app);
    GetOptionsFromArray \@args,
      'a|accepts=i'            => sub { $prefork->accepts($_[1]) },
      'b|backlog=i'            => sub { $prefork->backlog($_[1]) },
      'c|clients=i'            => sub { $prefork->max_clients($_[1]) },
      'G|graceful-timeout=i'   => sub { $prefork->graceful_timeout($_[1]) },
      'I|heartbeat-interval=i' => sub { $prefork->heartbeat_interval($_[1]) },
      'H|heartbeat-timeout=i'  => sub { $prefork->heartbeat_timeout($_[1]) },
      'i|inactivity-timeout=i' => sub { $prefork->inactivity_timeout($_[1]) },
      'l|listen=s'   => \my @listen,
      'P|pid-file=s' => sub { $prefork->pid_file($_[1]) },
      'p|proxy'      => sub { $prefork->reverse_proxy(1) },
      'r|requests=i' => sub { $prefork->max_requests($_[1]) },
      'w|workers=i'  => sub { $prefork->workers($_[1]) };
  
    $prefork->listen(\@listen) if @listen;
    $prefork->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::prefork - Prefork command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION prefork [OPTIONS]
  
      ./myapp.pl prefork
      ./myapp.pl prefork -m production -l http://*:8080
      ./myapp.pl prefork -l http://127.0.0.1:8080 -l https://[::]:8081
      ./myapp.pl prefork -l 'https://*:443?cert=./server.crt&key=./server.key'
  
    Options:
      -a, --accepts <number>               Number of connections for workers to
                                           accept, defaults to 10000
      -b, --backlog <size>                 Listen backlog size, defaults to
                                           SOMAXCONN
      -c, --clients <number>               Maximum number of concurrent
                                           connections, defaults to 1000
      -G, --graceful-timeout <seconds>     Graceful timeout, defaults to 20.
      -I, --heartbeat-interval <seconds>   Heartbeat interval, defaults to 5
      -H, --heartbeat-timeout <seconds>    Heartbeat timeout, defaults to 20
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 15
      -l, --listen <location>              One or more locations you want to
                                           listen on, defaults to the value of
                                           MOJO_LISTEN or "http://*:3000"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -P, --pid-file <path>                Path to process id file, defaults to
                                           "prefork.pid" in a temporary diretory
      -p, --proxy                          Activate reverse proxy support,
                                           defaults to the value of
                                           MOJO_REVERSE_PROXY
      -r, --requests <number>              Maximum number of requests per
                                           keep-alive connection, defaults to 100
      -w, --workers <number>               Number of workers, defaults to 4
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::prefork> starts applications with the
  L<Mojo::Server::Prefork> backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::prefork> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $prefork->description;
    $prefork        = $prefork->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $prefork->usage;
    $prefork  = $prefork->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::prefork> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $prefork->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_PREFORK

$fatpacked{"Mojolicious/Command/psgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PSGI';
  package Mojolicious::Command::psgi;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::PSGI;
  
  has description => 'Start application with PSGI';
  has usage => sub { shift->extract_usage };
  
  sub run { Mojo::Server::PSGI->new(app => shift->app)->to_psgi_app }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::psgi - PSGI command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION psgi [OPTIONS]
  
      ./myapp.pl psgi
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::psgi> starts applications with the L<Mojo::Server::PSGI>
  backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::psgi> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $psgi->description;
    $psgi           = $psgi->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $psgi->usage;
    $psgi     = $psgi->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::psgi> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    my $app = $psgi->run;
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_PSGI

$fatpacked{"Mojolicious/Command/routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_ROUTES';
  package Mojolicious::Command::routes;
  use Mojo::Base 'Mojolicious::Command';
  
  use re 'regexp_pattern';
  use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);
  use Mojo::Util qw(encode tablify);
  
  has description => 'Show available routes';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    GetOptionsFromArray \@args, 'v|verbose' => \my $verbose;
  
    my $rows = [];
    _walk($_, 0, $rows, $verbose) for @{$self->app->routes->children};
    print encode('UTF-8', tablify($rows));
  }
  
  sub _walk {
    my ($route, $depth, $rows, $verbose) = @_;
  
    # Pattern
    my $prefix = '';
    if (my $i = $depth * 2) { $prefix .= ' ' x $i . '+' }
    push @$rows, my $row = [$prefix . ($route->pattern->unparsed || '/')];
  
    # Flags
    my @flags;
    push @flags, @{$route->over || []} ? 'C' : '.';
    push @flags, (my $partial = $route->partial) ? 'D' : '.';
    push @flags, $route->inline       ? 'U' : '.';
    push @flags, $route->is_websocket ? 'W' : '.';
    push @$row, join('', @flags) if $verbose;
  
    # Methods
    my $via = $route->via;
    push @$row, !$via ? '*' : uc join ',', @$via;
  
    # Name
    my $name = $route->name;
    push @$row, $route->has_custom_name ? qq{"$name"} : $name;
  
    # Regex (verbose)
    my $pattern = $route->pattern;
    $pattern->match('/', $route->is_endpoint && !$partial);
    push @$row, (regexp_pattern $pattern->regex)[0] if $verbose;
  
    $depth++;
    _walk($_, $depth, $rows, $verbose) for @{$route->children};
    $depth--;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::routes - Routes command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION routes [OPTIONS]
  
      ./myapp.pl routes
      ./myapp.pl routes -v
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
      -v, --verbose       Print additional details about routes, flags indicate
                          C=Conditions, D=Detour, U=Under and W=WebSocket
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::routes> lists all your application routes.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::routes> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $routes->description;
    $routes         = $routes->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $routes->usage;
    $routes   = $routes->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::routes> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $routes->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_ROUTES

$fatpacked{"Mojolicious/Command/test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_TEST';
  package Mojolicious::Command::test;
  use Mojo::Base 'Mojolicious::Command';
  
  use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);
  
  has description => 'Run tests';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    GetOptionsFromArray \@args, 'v|verbose' => \$ENV{HARNESS_VERBOSE};
  
    if (!@args && (my $home = $self->app->home)) {
      die "Can't find test directory.\n" unless -d $home->rel_dir('t');
      my $files = $home->list_files('t');
      /\.t$/ and push @args, $home->rel_file("t/$_") for @$files;
      say qq{Running tests from "}, $home->rel_dir('t') . '".';
    }
  
    $ENV{HARNESS_OPTIONS} //= 'c';
    require Test::Harness;
    local $Test::Harness::switches = '';
    Test::Harness::runtests(sort @args);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::test - Test command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION test [OPTIONS] [TESTS]
  
      ./myapp.pl test
      ./myapp.pl test t/foo.t
      ./myapp.pl test -v t/foo/*.t
  
    Options:
      -h, --help      Show this summary of available options
      -v, --verbose   Print verbose debug information to STDERR
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::test> runs application tests from the C<t> directory.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::test> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $test->description;
    $test           = $test->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $test->usage;
    $test     = $test->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::test> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $test->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_TEST

$fatpacked{"Mojolicious/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_VERSION';
  package Mojolicious::Command::version;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::IOLoop::Client;
  use Mojolicious;
  
  has description => 'Show versions of available modules';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my $self = shift;
  
    my $ev    = eval 'use Mojo::Reactor::EV; 1' ? $EV::VERSION : 'n/a';
    my $class = 'Mojo::IOLoop::Client';
    my $socks = $class->SOCKS ? $IO::Socket::Socks::VERSION : 'n/a';
    my $tls   = $class->TLS ? $IO::Socket::SSL::VERSION : 'n/a';
    my $ndn   = $class->NDN ? $Net::DNS::Native::VERSION : 'n/a';
  
    print <<EOF;
  CORE
    Perl        ($^V, $^O)
    Mojolicious ($Mojolicious::VERSION, $Mojolicious::CODENAME)
  
  OPTIONAL
    EV 4.0+                 ($ev)
    IO::Socket::Socks 0.64+ ($socks)
    IO::Socket::SSL 1.94+   ($tls)
    Net::DNS::Native 0.15+  ($ndn)
  
  EOF
  
    # Check latest version on CPAN
    my $latest = eval {
      $self->app->ua->max_redirects(10)->tap(sub { $_->proxy->detect })
        ->get('api.metacpan.org/v0/release/Mojolicious')->res->json->{version};
    } or return;
  
    my $msg = 'This version is up to date, have fun!';
    $msg = 'Thanks for testing a development release, you are awesome!'
      if $latest < $Mojolicious::VERSION;
    $msg = "You might want to update your Mojolicious to $latest!"
      if $latest > $Mojolicious::VERSION;
    say $msg;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::version - Version command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION version [OPTIONS]
  
      mojo version
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::version> shows version information for available core
  and optional modules.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::version> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $v->description;
    $v              = $v->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $v->usage;
    $v        = $v->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::version> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $v->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_VERSION

$fatpacked{"Mojolicious/Commands.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMANDS';
  package Mojolicious::Commands;
  use Mojo::Base 'Mojolicious::Command';
  
  use Getopt::Long 'GetOptionsFromArray';
  use Mojo::Loader qw(find_modules find_packages load_class);
  use Mojo::Server;
  use Mojo::Util 'tablify';
  
  has hint => <<EOF;
  
  See 'APPLICATION help COMMAND' for more information on a specific command.
  EOF
  has message    => sub { shift->extract_usage . "\nCommands:\n" };
  has namespaces => sub { ['Mojolicious::Command'] };
  
  sub detect {
  
    # PSGI (Plack only for now)
    return 'psgi' if defined $ENV{PLACK_ENV};
  
    # CGI
    return 'cgi' if defined $ENV{PATH_INFO} || defined $ENV{GATEWAY_INTERFACE};
  
    # Nothing
    return undef;
  }
  
  sub run {
    my ($self, $name, @args) = @_;
  
    # Application loader
    return $self->app if defined $ENV{MOJO_APP_LOADER};
  
    # Try to detect environment
    if (!$ENV{MOJO_NO_DETECT} && (my $env = $self->detect)) { $name = $env }
  
    # Run command
    if ($name && $name =~ /^\w+$/ && ($name ne 'help' || $args[0])) {
  
      # Help
      $name = shift @args if my $help = $name eq 'help';
      $help = $ENV{MOJO_HELP} ||= $help;
  
      # Remove options shared by all commands before loading the command
      _args(\@args);
      my $module;
      $module = _command("${_}::$name", 1) and last for @{$self->namespaces};
  
      # Unknown command
      die qq{Unknown command "$name", maybe you need to install it?\n}
        unless $module;
  
      # Run command
      my $command = $module->new(app => $self->app);
      return $help ? $command->help(@args) : $command->run(@args);
    }
  
    # Hide list for tests
    return 1 if $ENV{HARNESS_ACTIVE};
  
    # Find all available commands
    my %all;
    for my $ns (@{$self->namespaces}) {
      $all{substr $_, length "${ns}::"} //= $_->new->description
        for grep { _command($_) } find_modules($ns), find_packages($ns);
    }
  
    my @rows = map { [" $_", $all{$_}] } sort keys %all;
    return print $self->message, tablify(\@rows), $self->hint;
  }
  
  sub start_app { shift; Mojo::Server->new->build_app(shift)->start(@_) }
  
  # Command line options for MOJO_HELP, MOJO_HOME and MOJO_MODE
  sub _args {
    return if __PACKAGE__->detect;
  
    my $save
      = Getopt::Long::Configure(qw(no_auto_abbrev no_ignore_case pass_through));
    GetOptionsFromArray shift,
      'h|help'   => \$ENV{MOJO_HELP},
      'home=s'   => \$ENV{MOJO_HOME},
      'm|mode=s' => \$ENV{MOJO_MODE};
    Getopt::Long::Configure($save);
  }
  
  # Do not remove options from @ARGV
  BEGIN { _args([@ARGV]) }
  
  sub _command {
    my ($module, $fatal) = @_;
    return $module->isa('Mojolicious::Command') ? $module : undef
      unless my $e = load_class $module;
    $fatal && ref $e ? die $e : return undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Commands - Command line interface
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION COMMAND [OPTIONS]
  
      mojo version
      mojo generate lite_app
      ./myapp.pl daemon -m production -l http://*:8080
      ./myapp.pl get /foo
      ./myapp.pl routes -v
  
    Tip: CGI and PSGI environments can be automatically detected very often and
         work without commands.
  
    Options (for all commands):
      -h, --help          Get more information on a specific command
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Commands> is the interactive command line interface for the
  L<Mojolicious> framework. It will automatically detect available commands in
  the C<Mojolicious::Command> namespace.
  
  =head1 COMMANDS
  
  These commands are available by default.
  
  =head2 cgi
  
    $ ./myapp.pl cgi
  
  Use L<Mojolicious::Command::cgi> to start application with CGI backend, usually
  auto detected.
  
  =head2 cpanify
  
    $ mojo cpanify -u sri -p secr3t Mojolicious-Plugin-Fun-0.1.tar.gz
  
  Use L<Mojolicious::Command::cpanify> for uploading files to CPAN.
  
  =head2 daemon
  
    $ ./myapp.pl daemon
  
  Use L<Mojolicious::Command::daemon> to start application with standalone HTTP
  and WebSocket server.
  
  =head2 eval
  
    $ ./myapp.pl eval 'say app->home'
  
  Use L<Mojolicious::Command::eval> to run code against application.
  
  =head2 generate
  
    $ mojo generate
    $ mojo generate help
    $ ./myapp.pl generate help
  
  List available generator commands with short descriptions.
  
    $ mojo generate help <generator>
    $ ./myapp.pl generate help <generator>
  
  List available options for generator command with short descriptions.
  
  =head2 generate app
  
    $ mojo generate app <AppName>
  
  Use L<Mojolicious::Command::generate::app> to generate application directory
  structure for a fully functional L<Mojolicious> application.
  
  =head2 generate lite_app
  
    $ mojo generate lite_app
  
  Use L<Mojolicious::Command::generate::lite_app> to generate a fully functional
  L<Mojolicious::Lite> application.
  
  =head2 generate makefile
  
    $ mojo generate makefile
    $ ./myapp.pl generate makefile
  
  Use L<Mojolicious::Command::generate::makefile> to generate C<Makefile.PL> file
  for application.
  
  =head2 generate plugin
  
    $ mojo generate plugin <PluginName>
  
  Use L<Mojolicious::Command::generate::plugin> to generate directory structure
  for a fully functional L<Mojolicious> plugin.
  
  =head2 get
  
    $ mojo get http://mojolicious.org
    $ ./myapp.pl get /foo
  
  Use L<Mojolicious::Command::get> to perform requests to remote host or local
  application.
  
  =head2 help
  
    $ mojo
    $ mojo help
    $ ./myapp.pl help
  
  List available commands with short descriptions.
  
    $ mojo help <command>
    $ ./myapp.pl help <command>
  
  List available options for the command with short descriptions.
  
  =head2 inflate
  
    $ ./myapp.pl inflate
  
  Use L<Mojolicious::Command::inflate> to turn templates and static files
  embedded in the C<DATA> sections of your application into real files.
  
  =head2 prefork
  
    $ ./myapp.pl prefork
  
  Use L<Mojolicious::Command::prefork> to start application with standalone
  preforking HTTP and WebSocket server.
  
  =head2 psgi
  
    $ ./myapp.pl psgi
  
  Use L<Mojolicious::Command::psgi> to start application with PSGI backend,
  usually auto detected.
  
  =head2 routes
  
    $ ./myapp.pl routes
  
  Use L<Mojolicious::Command::routes> to list application routes.
  
  =head2 test
  
    $ ./myapp.pl test
    $ ./myapp.pl test t/fun.t
  
  Use L<Mojolicious::Command::test> to run application tests from the C<t>
  directory.
  
  =head2 version
  
    $ mojo version
    $ ./myapp.pl version
  
  Use L<Mojolicious::Command::version> to show version information for available
  core and optional modules, very useful for debugging.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Commands> inherits all attributes from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 hint
  
    my $hint  = $commands->hint;
    $commands = $commands->hint('Foo');
  
  Short hint shown after listing available commands.
  
  =head2 message
  
    my $msg   = $commands->message;
    $commands = $commands->message('Hello World!');
  
  Short usage message shown before listing available commands.
  
  =head2 namespaces
  
    my $namespaces = $commands->namespaces;
    $commands      = $commands->namespaces(['MyApp::Command']);
  
  Namespaces to load commands from, defaults to C<Mojolicious::Command>.
  
    # Add another namespace to load commands from
    push @{$commands->namespaces}, 'MyApp::Command';
  
  =head1 METHODS
  
  L<Mojolicious::Commands> inherits all methods from L<Mojolicious::Command> and
  implements the following new ones.
  
  =head2 detect
  
    my $env = $commands->detect;
  
  Try to detect environment, or return C<undef> if none could be detected.
  
  =head2 run
  
    $commands->run;
    $commands->run(@ARGV);
  
  Load and run commands. Automatic deployment environment detection can be
  disabled with the C<MOJO_NO_DETECT> environment variable.
  
  =head2 start_app
  
    Mojolicious::Commands->start_app('MyApp');
    Mojolicious::Commands->start_app(MyApp => @ARGV);
  
  Load application from class and start the command line interface for it. Note
  that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
  shared by all commands, will be parsed from C<@ARGV> during compile time.
  
    # Always start daemon for application
    Mojolicious::Commands->start_app('MyApp', 'daemon', '-l', 'http://*:8080');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMANDS

$fatpacked{"Mojolicious/Controller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_CONTROLLER';
  package Mojolicious::Controller;
  use Mojo::Base -base;
  
  # No imports, for security reasons!
  use Carp ();
  use Mojo::ByteStream;
  use Mojo::URL;
  use Mojo::Util;
  use Mojolicious::Routes::Match;
  use Scalar::Util ();
  use Time::HiRes  ();
  
  has [qw(app tx)];
  has match =>
    sub { Mojolicious::Routes::Match->new(root => shift->app->routes) };
  
  # Reserved stash values
  my %RESERVED = map { $_ => 1 } (
    qw(action app cb controller data extends format handler inline json layout),
    qw(namespace path status template text variant)
  );
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call helper with current controller
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $helper = $self->app->renderer->get_helper($method);
    return $self->$helper(@_);
  }
  
  sub continue { $_[0]->app->routes->continue($_[0]) }
  
  sub cookie {
    my ($self, $name) = (shift, shift);
  
    # Response cookie
    if (@_) {
  
      # Cookie too big
      my $cookie = {name => $name, value => shift, %{shift || {}}};
      $self->app->log->error(qq{Cookie "$name" is bigger than 4096 bytes})
        if length $cookie->{value} > 4096;
  
      $self->res->cookies($cookie);
      return $self;
    }
  
    # Request cookies
    return undef unless my $cookie = $self->req->cookie($name);
    return $cookie->value;
  }
  
  sub every_cookie {
    [map { $_->value } @{shift->req->every_cookie(shift)}];
  }
  
  sub every_param {
    my ($self, $name) = @_;
  
    # Captured unreserved values
    my $captures = $self->stash->{'mojo.captures'} ||= {};
    if (!$RESERVED{$name} && exists $captures->{$name}) {
      my $value = $captures->{$name};
      return ref $value eq 'ARRAY' ? $value : [$value];
    }
  
    # Uploads or param values
    my $req     = $self->req;
    my $uploads = $req->every_upload($name);
    return @$uploads ? $uploads : $req->every_param($name);
  }
  
  sub every_signed_cookie {
    my ($self, $name) = @_;
  
    my $secrets = $self->app->secrets;
    my @results;
    for my $value (@{$self->every_cookie($name)}) {
  
      # Check signature with rotating secrets
      if ($value =~ s/--([^\-]+)$//) {
        my $signature = $1;
  
        my $valid;
        for my $secret (@$secrets) {
          my $check = Mojo::Util::hmac_sha1_sum($value, $secret);
          ++$valid and last if Mojo::Util::secure_compare($signature, $check);
        }
        if ($valid) { push @results, $value }
  
        else { $self->app->log->debug(qq{Cookie "$name" has a bad signature}) }
      }
  
      else { $self->app->log->debug(qq{Cookie "$name" is not signed}) }
    }
  
    return \@results;
  }
  
  sub finish {
    my $self = shift;
  
    # WebSocket
    my $tx = $self->tx;
    $tx->finish(@_) and return $tx->established ? $self : $self->rendered(101)
      if $tx->is_websocket;
  
    # Chunked stream
    return @_ ? $self->write_chunk(@_)->write_chunk('') : $self->write_chunk('')
      if $tx->res->content->is_chunked;
  
    # Normal stream
    return @_ ? $self->write(@_)->write('') : $self->write('');
  }
  
  sub flash {
    my $self = shift;
  
    # Check old flash
    my $session = $self->session;
    return $session->{flash} ? $session->{flash}{$_[0]} : undef
      if @_ == 1 && !ref $_[0];
  
    # Initialize new flash and merge values
    my $values = ref $_[0] ? $_[0] : {@_};
    @{$session->{new_flash} ||= {}}{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub helpers { $_[0]->app->renderer->get_helper('')->($_[0]) }
  
  sub on {
    my ($self, $name, $cb) = @_;
    my $tx = $self->tx;
    $self->rendered(101) if $tx->is_websocket && !$tx->established;
    return $tx->on($name => sub { shift; $self->$cb(@_) });
  }
  
  sub param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->stash->{'mojo.captures'}{$name} = @_ > 1 ? [@_] : $_[0];
    return $self;
  }
  
  sub redirect_to {
    my $self = shift;
  
    # Don't override 3xx status
    my $res = $self->res;
    $res->headers->location($self->url_for(@_));
    return $self->rendered($res->is_status_class(300) ? () : 302);
  }
  
  sub render {
    my $self = shift;
  
    # Template may be first argument
    my ($template, $args) = (@_ % 2 ? shift : undef, {@_});
    $args->{template} = $template if $template;
    my $app     = $self->app;
    my $plugins = $app->plugins->emit_hook(before_render => $self, $args);
    my $maybe   = delete $args->{'mojo.maybe'};
  
    my $ts = $args->{'mojo.string'};
    my ($output, $format) = $app->renderer->render($self, $args);
  
    # Maybe no 404
    return defined $output ? Mojo::ByteStream->new($output) : undef if $ts;
    return $maybe ? undef : !$self->helpers->reply->not_found
      unless defined $output;
  
    $plugins->emit_hook(after_render => $self, \$output, $format);
    my $headers = $self->res->body($output)->headers;
    $headers->content_type($app->types->type($format) || 'text/plain')
      unless $headers->content_type;
    return !!$self->rendered($self->stash->{status});
  }
  
  sub render_later { shift->stash('mojo.rendered' => 1) }
  
  sub render_maybe { shift->render(@_, 'mojo.maybe' => 1) }
  
  sub render_to_string { shift->render(@_, 'mojo.string' => 1) }
  
  sub rendered {
    my ($self, $status) = @_;
  
    # Make sure we have a status
    my $res = $self->res;
    $res->code($status || 200) if $status || !$res->code;
  
    # Finish transaction
    my $stash = $self->stash;
    if (!$stash->{'mojo.finished'} && ++$stash->{'mojo.finished'}) {
  
      # Disable auto rendering and stop timer
      my $app = $self->render_later->app;
      if (my $started = delete $stash->{'mojo.started'}) {
        my $elapsed
          = Time::HiRes::tv_interval($started, [Time::HiRes::gettimeofday()]);
        my $rps  = $elapsed == 0 ? '??' : sprintf '%.3f', 1 / $elapsed;
        my $code = $res->code;
        my $msg  = $res->message || $res->default_message($code);
        $app->log->debug("$code $msg (${elapsed}s, $rps/s)");
      }
  
      $app->plugins->emit_hook_reverse(after_dispatch => $self);
      $app->sessions->store($self);
    }
    $self->tx->resume;
    return $self;
  }
  
  sub req { shift->tx->req }
  sub res { shift->tx->res }
  
  sub respond_to {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Find target
    my $target;
    my $renderer = $self->app->renderer;
    my @formats  = @{$renderer->accepts($self)};
    for my $format (@formats ? @formats : ($renderer->default_format)) {
      next unless $target = $args->{$format};
      $self->stash->{format} = $format;
      last;
    }
  
    # Fallback
    unless ($target) {
      return $self->rendered(204) unless $target = $args->{any};
      delete $self->stash->{format};
    }
  
    # Dispatch
    ref $target eq 'CODE' ? $target->($self) : $self->render(%$target);
  
    return $self;
  }
  
  sub send {
    my ($self, $msg, $cb) = @_;
    my $tx = $self->tx;
    Carp::croak 'No WebSocket connection to send message to'
      unless $tx->is_websocket;
    $tx->send($msg, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $tx->established ? $self : $self->rendered(101);
  }
  
  sub session {
    my $self = shift;
  
    my $stash = $self->stash;
    $self->app->sessions->load($self)
      unless exists $stash->{'mojo.active_session'};
  
    # Hash
    my $session = $stash->{'mojo.session'} ||= {};
    return $session unless @_;
  
    # Get
    return $session->{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$session{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub signed_cookie {
    my ($self, $name, $value, $options) = @_;
  
    # Request cookie
    return $self->every_signed_cookie($name)->[-1] unless defined $value;
  
    # Response cookie
    my $checksum = Mojo::Util::hmac_sha1_sum($value, $self->app->secrets->[0]);
    return $self->cookie($name, "$value--$checksum", $options);
  }
  
  sub stash { Mojo::Util::_stash(stash => @_) }
  
  sub url_for {
    my ($self, $target) = (shift, shift // '');
  
    # Absolute URL
    return $target if Scalar::Util::blessed $target && $target->isa('Mojo::URL');
    return Mojo::URL->new($target) if $target =~ m!^(?:[^:/?#]+:|//|#)!;
  
    # Base
    my $url  = Mojo::URL->new;
    my $req  = $self->req;
    my $base = $url->base($req->url->base->clone)->base->userinfo(undef);
  
    # Relative URL
    my $path = $url->path;
    if ($target =~ m!^/!) {
      if (defined(my $prefix = $self->stash->{path})) {
        my $real = $req->url->path->to_route;
        $real =~ s!/?\Q$prefix\E$!$target!;
        $target = $real;
      }
      $url->parse($target);
    }
  
    # Route
    else {
      my $generated = $self->match->path_for($target, @_);
      $path->parse($generated->{path}) if $generated->{path};
      $base->scheme($base->protocol eq 'https' ? 'wss' : 'ws')
        if $generated->{websocket};
    }
  
    # Make path absolute
    my $base_path = $base->path;
    unshift @{$path->parts}, @{$base_path->parts};
    $base_path->parts([])->trailing_slash(0);
  
    return $url;
  }
  
  sub validation {
    my $self = shift;
  
    my $stash = $self->stash;
    return $stash->{'mojo.validation'} if $stash->{'mojo.validation'};
  
    my $req    = $self->req;
    my $token  = $self->session->{csrf_token};
    my $header = $req->headers->header('X-CSRF-Token');
    my $hash   = $req->params->to_hash;
    $hash->{csrf_token} //= $header if $token && $header;
    $hash->{$_} = $req->every_upload($_) for map { $_->name } @{$req->uploads};
    my $validation = $self->app->validator->validation->input($hash);
    return $stash->{'mojo.validation'} = $validation->csrf_token($token);
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
    $self->res->content->write($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }
  
  sub write_chunk {
    my ($self, $chunk, $cb) = @_;
    my $content = $self->res->content;
    $content->write_chunk($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Controller - Controller base class
  
  =head1 SYNOPSIS
  
    # Controller
    package MyApp::Controller::Foo;
    use Mojo::Base 'Mojolicious::Controller';
  
    # Action
    sub bar {
      my $self = shift;
      my $name = $self->param('name');
      $self->res->headers->cache_control('max-age=1, no-cache');
      $self->render(json => {hello => $name});
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Controller> is the base class for your L<Mojolicious>
  controllers. It is also the default controller class unless you set
  L<Mojolicious/"controller_class">.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Controller> inherits all attributes from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 app
  
    my $app = $c->app;
    $c      = $c->app(Mojolicious->new);
  
  A reference back to the application that dispatched to this controller, usually
  a L<Mojolicious> object.
  
    # Use application logger
    $c->app->log->debug('Hello Mojo');
  
    # Generate path
    my $path = $c->app->home->rel_file('templates/foo/bar.html.ep');
  
  =head2 match
  
    my $m = $c->match;
    $c    = $c->match(Mojolicious::Routes::Match->new);
  
  Router results for the current request, defaults to a
  L<Mojolicious::Routes::Match> object.
  
    # Introspect
    my $name   = $c->match->endpoint->name;
    my $foo    = $c->match->endpoint->pattern->defaults->{foo};
    my $action = $c->match->stack->[-1]{action};
  
  =head2 tx
  
    my $tx = $c->tx;
    $c     = $c->tx(Mojo::Transaction::HTTP->new);
  
  The transaction that is currently being processed, usually a
  L<Mojo::Transaction::HTTP> or L<Mojo::Transaction::WebSocket> object. Note that
  this reference is usually weakened, so the object needs to be referenced
  elsewhere as well when you're performing non-blocking operations and the
  underlying connection might get closed early.
  
    # Check peer information
    my $address = $c->tx->remote_address;
    my $port    = $c->tx->remote_port;
  
    # Increase size limit for WebSocket messages to 16MB
    $c->tx->max_websocket_size(16777216) if $c->tx->is_websocket;
  
    # Perform non-blocking operation without knowing the connection status
    my $tx = $c->tx;
    Mojo::IOLoop->timer(2 => sub {
      $c->app->log->debug($tx->is_finished ? 'Finished' : 'In progress');
    });
  
  =head1 METHODS
  
  L<Mojolicious::Controller> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 continue
  
    $c->continue;
  
  Continue dispatch chain from an intermediate destination with
  L<Mojolicious::Routes/"continue">.
  
  =head2 cookie
  
    my $value = $c->cookie('foo');
    $c        = $c->cookie(foo => 'bar');
    $c        = $c->cookie(foo => 'bar', {path => '/'});
  
  Access request cookie values and create new response cookies. If there are
  multiple values sharing the same name, and you want to access more than just
  the last one, you can use L</"every_cookie">.
  
    # Create response cookie with domain and expiration date
    $c->cookie(user => 'sri', {domain => 'example.com', expires => time + 60});
  
    # Create secure response cookie
    $c->cookie(secret => 'I <3 Mojolicious', {secure => 1, httponly => 1});
  
  =head2 every_cookie
  
    my $values = $c->every_cookie('foo');
  
  Similar to L</"cookie">, but returns all request cookie values sharing the same
  name as an array reference.
  
    $ Get first cookie value
    my $first = $c->every_cookie('foo')->[0];
  
  =head2 every_param
  
    my $values = $c->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    my $first = $c->every_param('foo')->[0];
  
  =head2 every_signed_cookie
  
    my $values = $c->every_signed_cookie('foo');
  
  Similar to L</"signed_cookie">, but returns all signed request cookie values
  sharing the same name as an array reference.
  
    # Get first signed cookie value
    my $first = $c->every_signed_cookie('foo')->[0];
  
  =head2 finish
  
    $c = $c->finish;
    $c = $c->finish(1000);
    $c = $c->finish(1003 => 'Cannot accept data!');
    $c = $c->finish('Bye!');
  
  Close WebSocket connection or long poll stream gracefully. This method will
  automatically respond to WebSocket handshake requests with a C<101> response
  status, to establish the WebSocket connection.
  
  =head2 flash
  
    my $foo = $c->flash('foo');
    $c      = $c->flash({foo => 'bar'});
    $c      = $c->flash(foo => 'bar');
  
  Data storage persistent only for the next request, stored in the L</"session">.
  
    # Show message after redirect
    $c->flash(message => 'User created successfully!');
    $c->redirect_to('show_user', id => 23);
  
  =head2 helpers
  
    my $helpers = $c->helpers;
  
  Return a proxy object containing the current controller object and on which
  helpers provided by L</"app"> can be called. This includes all helpers from
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  
    # Make sure to use the "title" helper and not the controller method
    $c->helpers->title('Welcome!');
  
    # Use a nested helper instead of the "reply" controller method
    $c->helpers->reply->not_found;
  
  =head2 on
  
    my $cb = $c->on(finish => sub {...});
  
  Subscribe to events of L</"tx">, which is usually a L<Mojo::Transaction::HTTP>
  or L<Mojo::Transaction::WebSocket> object. This method will automatically
  respond to WebSocket handshake requests with a C<101> response status, to
  establish the WebSocket connection.
  
    # Do something after the transaction has been finished
    $c->on(finish => sub {
      my $c = shift;
      $c->app->log->debug('All data has been sent');
    });
  
    # Receive WebSocket message
    $c->on(message => sub {
      my ($c, $msg) = @_;
      $c->app->log->debug("Message: $msg");
    });
  
    # Receive JSON object via WebSocket message
    $c->on(json => sub {
      my ($c, $hash) = @_;
      $c->app->log->debug("Test: $hash->{test}");
    });
  
    # Receive WebSocket "Binary" message
    $c->on(binary => sub {
      my ($c, $bytes) = @_;
      my $len = length $bytes;
      $c->app->log->debug("Received $len bytes");
    });
  
  =head2 param
  
    my $value = $c->param('foo');
    $c        = $c->param(foo => 'ba;r');
    $c        = $c->param(foo => 'ba;r', 'baz');
    $c        = $c->param(foo => ['ba;r', 'baz']);
  
  Access route placeholder values that are not reserved stash values, file
  uploads as well as C<GET> and C<POST> parameters extracted from the query
  string and C<application/x-www-form-urlencoded> or C<multipart/form-data>
  message body, in that order. If there are multiple values sharing the same
  name, and you want to access more than just the last one, you can use
  L</"every_param">. Parts of the request body need to be loaded into memory to
  parse C<POST> parameters, so you have to make sure it is not excessively large,
  there's a 16MB limit by default.
  
    # Get first value
    my $first = $c->every_param('foo')->[0];
  
  For more control you can also access request information directly.
  
    # Only GET parameters
    my $foo = $c->req->query_params->param('foo');
  
    # Only POST parameters
    my $foo = $c->req->body_params->param('foo');
  
    # Only GET and POST parameters
    my $foo = $c->req->param('foo');
  
    # Only file uploads
    my $foo = $c->req->upload('foo');
  
  =head2 redirect_to
  
    $c = $c->redirect_to('named', foo => 'bar');
    $c = $c->redirect_to('named', {foo => 'bar'});
    $c = $c->redirect_to('/index.html');
    $c = $c->redirect_to('http://example.com/index.html');
  
  Prepare a C<302> (if the status code is not already C<3xx>) redirect response
  with C<Location> header, takes the same arguments as L</"url_for">.
  
    # Moved Permanently
    $c->res->code(301);
    $c->redirect_to('some_route');
  
    # Temporary Redirect
    $c->res->code(307);
    $c->redirect_to('some_route');
  
  =head2 render
  
    my $bool = $c->render;
    my $bool = $c->render(foo => 'bar', baz => 23);
    my $bool = $c->render(template => 'foo/index');
    my $bool = $c->render(template => 'index', format => 'html');
    my $bool = $c->render(data => $bytes);
    my $bool = $c->render(text => 'Hello!');
    my $bool = $c->render(json => {foo => 'bar'});
    my $bool = $c->render(handler => 'something');
    my $bool = $c->render('foo/index');
  
  Render content with L<Mojolicious/"renderer"> and emit hooks
  L<Mojolicious/"before_render"> as well as L<Mojolicious/"after_render">, or
  call L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no
  response could be generated, all additional key/value pairs get merged into the
  L</"stash">.
  
    # Render characters
    $c->render(text => 'I ♥ Mojolicious!');
  
    # Render characters (alternative)
    $c->stash(text => 'I ♥ Mojolicious!')->render;
  
    # Render binary data
    use Mojo::JSON 'encode_json';
    $c->render(data => encode_json({test => 'I ♥ Mojolicious!'}));
  
    # Render JSON
    $c->render(json => {test => 'I ♥ Mojolicious!'});
  
    # Render inline template
    $c->render(inline => '<%= 1 + 1 %>');
  
    # Render template "foo/bar.html.ep"
    $c->render(template => 'foo/bar', format => 'html', handler => 'ep');
  
    # Render template "test.*.*" with arbitrary values "foo" and "bar"
    $c->render(template => 'test', foo => 'test', bar => 23);
  
    # Render template "test.xml.*"
    $c->render(template => 'test', format => 'xml');
  
    # Render template "test.xml.*" (alternative)
    $c->render('test', format => 'xml');
  
  =head2 render_later
  
    $c = $c->render_later;
  
  Disable automatic rendering to delay response generation, only necessary if
  automatic rendering would result in a response.
  
    # Delayed rendering
    $c->render_later;
    Mojo::IOLoop->timer(2 => sub {
      $c->render(text => 'Delayed by 2 seconds!');
    });
  
  =head2 render_maybe
  
    my $bool = $c->render_maybe;
    my $bool = $c->render_maybe(foo => 'bar', baz => 23);
    my $bool = $c->render_maybe('foo/index', format => 'html');
  
  Try to render content, but do not call
  L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no response
  could be generated, takes the same arguments as L</"render">.
  
    # Render template "index_local" only if it exists
    $c->render_maybe('index_local') or $c->render('index');
  
  =head2 render_to_string
  
    my $output = $c->render_to_string('foo/index', format => 'pdf');
  
  Try to render content and return it wrapped in a L<Mojo::ByteStream> object or
  return C<undef>, all arguments get localized automatically and are only
  available during this render operation, takes the same arguments as
  L</"render">.
  
    # Render inline template
    my $two = $c->render_to_string(inline => '<%= 1 + 1 %>');
  
  =head2 rendered
  
    $c = $c->rendered;
    $c = $c->rendered(302);
  
  Finalize response and emit hook L<Mojolicious/"after_dispatch">, defaults to
  using a C<200> response code.
  
    # Custom response
    $c->res->headers->content_type('text/plain');
    $c->res->body('Hello World!');
    $c->rendered(200);
  
  =head2 req
  
    my $req = $c->req;
  
  Get L<Mojo::Message::Request> object from L</"tx">.
  
    # Longer version
    my $req = $c->tx->req;
  
    # Extract request information
    my $url    = $c->req->url->to_abs;
    my $info   = $c->req->url->to_abs->userinfo;
    my $host   = $c->req->url->to_abs->host;
    my $agent  = $c->req->headers->user_agent;
    my $custom = $c->req->headers->header('Custom-Header');
    my $bytes  = $c->req->body;
    my $str    = $c->req->text;
    my $hash   = $c->req->params->to_hash;
    my $value  = $c->req->json;
    my $foo    = $c->req->json('/23/foo');
    my $dom    = $c->req->dom;
    my $bar    = $c->req->dom('div.bar')->first->text;
  
  =head2 res
  
    my $res = $c->res;
  
  Get L<Mojo::Message::Response> object from L</"tx">.
  
    # Longer version
    my $res = $c->tx->res;
  
    # Force file download by setting a response header
    $c->res->headers->content_disposition('attachment; filename=foo.png;');
  
    # Use a custom response header
    $c->res->headers->header('Custom-Header' => 'whatever');
  
    # Make sure response is cached correctly
    $c->res->headers->cache_control('public, max-age=300');
    $c->res->headers->append(Vary => 'Accept-Encoding');
  
  =head2 respond_to
  
    $c = $c->respond_to(
      json => {json => {message => 'Welcome!'}},
      html => {template => 'welcome'},
      any  => sub {...}
    );
  
  Automatically select best possible representation for resource from C<Accept>
  request header, C<format> stash value or C<format> C<GET>/C<POST> parameter,
  defaults to L<Mojolicious::Renderer/"default_format"> or rendering an empty
  C<204> response. Each representation can be handled with a callback or a hash
  reference containing arguments to be passed to L</"render">. Since browsers
  often don't really know what they actually want, unspecific C<Accept> request
  headers with more than one MIME type will be ignored, unless the
  C<X-Requested-With> header is set to the value C<XMLHttpRequest>.
  
    # Everything else than "json" and "xml" gets a 204 response
    $c->respond_to(
      json => sub { $c->render(json => {just => 'works'}) },
      xml  => {text => '<just>works</just>'},
      any  => {data => '', status => 204}
    );
  
  For more advanced negotiation logic you can also use the helper
  L<Mojolicious::Plugin::DefaultHelpers/"accepts">.
  
  =head2 send
  
    $c = $c->send({binary => $bytes});
    $c = $c->send({text   => $bytes});
    $c = $c->send({json   => {test => [1, 2, 3]}});
    $c = $c->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $c = $c->send($chars);
    $c = $c->send($chars => sub {...});
  
  Send message or frame non-blocking via WebSocket, the optional drain callback
  will be executed once all data has been written. This method will automatically
  respond to WebSocket handshake requests with a C<101> response status, to
  establish the WebSocket connection.
  
    # Send "Text" message
    $c->send('I ♥ Mojolicious!');
  
    # Send JSON object as "Text" message
    $c->send({json => {test => 'I ♥ Mojolicious!'}});
  
    # Send JSON object as "Binary" message
    use Mojo::JSON 'encode_json';
    $c->send({binary => encode_json({test => 'I ♥ Mojolicious!'})});
  
    # Send "Ping" frame
    use Mojo::WebSocket 'WS_PING';
    $c->send([1, 0, 0, 0, WS_PING, 'Hello World!']);
  
    # Make sure the first message has been written before continuing
    $c->send('First message!' => sub {
      my $c = shift;
      $c->send('Second message!');
    });
  
  For mostly idle WebSockets you might also want to increase the inactivity
  timeout with L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which
  usually defaults to C<15> seconds.
  
    # Increase inactivity timeout for connection to 300 seconds
    $c->inactivity_timeout(300);
  
  =head2 session
  
    my $session = $c->session;
    my $foo     = $c->session('foo');
    $c          = $c->session({foo => 'bar'});
    $c          = $c->session(foo => 'bar');
  
  Persistent data storage for the next few requests, all session data gets
  serialized with L<Mojo::JSON> and stored Base64 encoded in HMAC-SHA1 signed
  cookies, to prevent tampering. Note that cookies usually have a C<4096> byte
  (4KB) limit, depending on browser.
  
    # Manipulate session
    $c->session->{foo} = 'bar';
    my $foo = $c->session->{foo};
    delete $c->session->{foo};
  
    # Expiration date in seconds from now (persists between requests)
    $c->session(expiration => 604800);
  
    # Expiration date as absolute epoch time (only valid for one request)
    $c->session(expires => time + 604800);
  
    # Delete whole session by setting an expiration date in the past
    $c->session(expires => 1);
  
  =head2 signed_cookie
  
    my $value = $c->signed_cookie('foo');
    $c        = $c->signed_cookie(foo => 'bar');
    $c        = $c->signed_cookie(foo => 'bar', {path => '/'});
  
  Access signed request cookie values and create new signed response cookies. If
  there are multiple values sharing the same name, and you want to access more
  than just the last one, you can use L</"every_signed_cookie">. Cookies are
  cryptographically signed with HMAC-SHA1, to prevent tampering, and the ones
  failing signature verification will be automatically discarded.
  
  =head2 stash
  
    my $hash = $c->stash;
    my $foo  = $c->stash('foo');
    $c       = $c->stash({foo => 'bar', baz => 23});
    $c       = $c->stash(foo => 'bar', baz => 23);
  
  Non-persistent data storage and exchange for the current request, application
  wide default values can be set with L<Mojolicious/"defaults">. Some stash
  values have a special meaning and are reserved, the full list is currently
  C<action>, C<app>, C<cb>, C<controller>, C<data>, C<extends>, C<format>,
  C<handler>, C<inline>, C<json>, C<layout>, C<namespace>, C<path>, C<status>,
  C<template>, C<text> and C<variant>. Note that all stash values with a
  C<mojo.*> prefix are reserved for internal use.
  
    # Remove value
    my $foo = delete $c->stash->{foo};
  
    # Assign multiple values at once
    $c->stash(foo => 'test', bar => 23);
  
  =head2 url_for
  
    my $url = $c->url_for;
    my $url = $c->url_for(name => 'sebastian');
    my $url = $c->url_for({name => 'sebastian'});
    my $url = $c->url_for('test', name => 'sebastian');
    my $url = $c->url_for('test', {name => 'sebastian'});
    my $url = $c->url_for('/index.html');
    my $url = $c->url_for('//example.com/index.html');
    my $url = $c->url_for('http://example.com/index.html');
    my $url = $c->url_for('mailto:sri@example.com');
    my $url = $c->url_for('#whatever');
  
  Generate a portable L<Mojo::URL> object with base for a path, URL or route.
  
    # "http://127.0.0.1:3000/index.html" if application was started with Morbo
    $c->url_for('/index.html')->to_abs;
  
    # "https://127.0.0.1:443/index.html" if application was started with Morbo
    $c->url_for('/index.html')->to_abs->scheme('https')->port(443);
  
    # "/index.html?foo=bar" if application is deployed under "/"
    $c->url_for('/index.html')->query(foo => 'bar');
  
    # "/myapp/index.html?foo=bar" if application is deployed under "/myapp"
    $c->url_for('/index.html')->query(foo => 'bar');
  
  You can also use the helper L<Mojolicious::Plugin::DefaultHelpers/"url_with">
  to inherit query parameters from the current request.
  
    # "/list?q=mojo&page=2" if current request was for "/list?q=mojo&page=1"
    $c->url_with->query([page => 2]);
  
  =head2 validation
  
    my $validation = $c->validation;
  
  Get L<Mojolicious::Validator::Validation> object for current request to
  validate file uploads as well as C<GET> and C<POST> parameters extracted from
  the query string and C<application/x-www-form-urlencoded> or
  C<multipart/form-data> message body. Parts of the request body need to be loaded
  into memory to parse C<POST> parameters, so you have to make sure it is not
  excessively large, there's a 16MB limit by default.
  
    # Validate GET/POST parameter
    my $validation = $c->validation;
    $validation->required('title', 'trim')->size(3, 50);
    my $title = $validation->param('title');
  
    # Validate file upload
    my $validation = $c->validation;
    $validation->required('tarball')->upload->size(1, 1048576);
    my $tarball = $validation->param('tarball');
  
  =head2 write
  
    $c = $c->write;
    $c = $c->write('');
    $c = $c->write($bytes);
    $c = $c->write($bytes => sub {...});
  
  Write dynamic content non-blocking, the optional drain callback will be executed
  once all data has been written. Calling this method without a chunk of data
  will finalize the response headers and allow for dynamic content to be written
  later.
  
    # Keep connection alive (with Content-Length header)
    $c->res->headers->content_length(6);
    $c->write('Hel' => sub {
      my $c = shift;
      $c->write('lo!');
    });
  
    # Close connection when finished (without Content-Length header)
    $c->write('Hel' => sub {
      my $c = shift;
      $c->write('lo!' => sub {
        my $c = shift;
        $c->finish;
      });
    });
  
  You can call L</"finish"> or write an empty chunk of data at any time to end
  the stream.
  
    HTTP/1.1 200 OK
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Content-Length: 6
    Server: Mojolicious (Perl)
  
    Hello!
  
    HTTP/1.1 200 OK
    Connection: close
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Server: Mojolicious (Perl)
  
    Hello!
  
  For Comet (long polling) you might also want to increase the inactivity timeout
  with L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which usually
  defaults to C<15> seconds.
  
    # Increase inactivity timeout for connection to 300 seconds
    $c->inactivity_timeout(300);
  
  =head2 write_chunk
  
    $c = $c->write_chunk;
    $c = $c->write_chunk('');
    $c = $c->write_chunk($bytes);
    $c = $c->write_chunk($bytes => sub {...});
  
  Write dynamic content non-blocking with chunked transfer encoding, the optional
  drain callback will be executed once all data has been written. Calling this
  method without a chunk of data will finalize the response headers and allow for
  dynamic content to be written later.
  
    # Make sure previous chunk has been written before continuing
    $c->write_chunk('H' => sub {
      my $c = shift;
      $c->write_chunk('ell' => sub {
        my $c = shift;
        $c->finish('o!');
      });
    });
  
  You can call L</"finish"> or write an empty chunk of data at any time to end
  the stream.
  
    HTTP/1.1 200 OK
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Transfer-Encoding: chunked
    Server: Mojolicious (Perl)
  
    1
    H
    3
    ell
    2
    o!
    0
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  helpers provided by L</"app"> on L<Mojolicious::Controller> objects. This
  includes all helpers from L<Mojolicious::Plugin::DefaultHelpers> and
  L<Mojolicious::Plugin::TagHelpers>.
  
    # Call helpers
    $c->layout('green');
    $c->title('Welcome!');
  
    # Longer version
    $c->helpers->layout('green');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_CONTROLLER

$fatpacked{"Mojolicious/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_LITE';
  package Mojolicious::Lite;
  use Mojo::Base 'Mojolicious';
  
  # "Bender: Bite my shiny metal ass!"
  use File::Basename qw(basename dirname);
  use File::Spec::Functions 'catdir';
  use Mojo::UserAgent::Server;
  use Mojo::Util 'monkey_patch';
  
  sub import {
  
    # Remember executable for later
    $ENV{MOJO_EXE} ||= (caller)[1];
  
    # Reuse home directory if possible
    local $ENV{MOJO_HOME} = catdir split('/', dirname $ENV{MOJO_EXE})
      unless $ENV{MOJO_HOME};
  
    # Initialize application class
    my $caller = caller;
    no strict 'refs';
    push @{"${caller}::ISA"}, 'Mojo';
  
    # Generate moniker based on filename
    my $moniker = basename $ENV{MOJO_EXE};
    $moniker =~ s/\.(?:pl|pm|t)$//i;
    my $app = shift->new(moniker => $moniker);
  
    # Initialize routes without namespaces
    my $routes = $app->routes->namespaces([]);
    $app->static->classes->[0] = $app->renderer->classes->[0] = $caller;
  
    # The Mojolicious::Lite DSL
    my $root = $routes;
    for my $name (qw(any get options patch post put websocket)) {
      monkey_patch $caller, $name, sub { $routes->$name(@_) };
    }
    monkey_patch $caller, $_, sub {$app}
      for qw(new app);
    monkey_patch $caller, del => sub { $routes->delete(@_) };
    monkey_patch $caller, group => sub (&) {
      (my $old, $root) = ($root, $routes);
      shift->();
      ($routes, $root) = ($root, $old);
    };
    monkey_patch $caller,
      helper => sub { $app->helper(@_) },
      hook   => sub { $app->hook(@_) },
      plugin => sub { $app->plugin(@_) },
      under  => sub { $routes = $root->under(@_) };
  
    # Make sure there's a default application for testing
    Mojo::UserAgent::Server->app($app) unless Mojo::UserAgent::Server->app;
  
    # Lite apps are strict!
    Mojo::Base->import(-strict);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Lite - Micro real-time web framework
  
  =head1 SYNOPSIS
  
    # Automatically enables "strict", "warnings", "utf8" and Perl 5.10 features
    use Mojolicious::Lite;
  
    # Route with placeholder
    get '/:foo' => sub {
      my $c   = shift;
      my $foo = $c->param('foo');
      $c->render(text => "Hello from $foo.");
    };
  
    # Start the Mojolicious command system
    app->start;
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Lite> is a micro real-time web framework built around
  L<Mojolicious>.
  
  See L<Mojolicious::Guides::Tutorial> for more!
  
  =head1 FUNCTIONS
  
  L<Mojolicious::Lite> implements the following functions, which are
  automatically exported.
  
  =head2 any
  
    my $route = any '/:foo' => sub {...};
    my $route = any '/:foo' => sub {...} => 'name';
    my $route = any '/:foo' => {foo => 'bar'} => sub {...};
    my $route = any '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = any ['GET', 'POST'] => '/:foo' => sub {...};
    my $route = any ['GET', 'POST'] => '/:foo' => [foo => qr/\w+/] => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"any">, matching any of the
  listed HTTP request methods or all. See also L<Mojolicious::Guides::Tutorial>
  for many more argument variations.
  
  =head2 app
  
    my $app = app;
  
  Returns the L<Mojolicious::Lite> application object, which is a subclass of
  L<Mojolicious>.
  
    # Use all the available attributes and methods
    app->log->level('error');
    app->defaults(foo => 'bar');
  
  =head2 del
  
    my $route = del '/:foo' => sub {...};
    my $route = del '/:foo' => sub {...} => 'name';
    my $route = del '/:foo' => {foo => 'bar'} => sub {...};
    my $route = del '/:foo' => [foo => qr/\w+/] => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"delete">, matching only
  C<DELETE> requests. See also L<Mojolicious::Guides::Tutorial> for many more
  argument variations.
  
  =head2 get
  
    my $route = get '/:foo' => sub {...};
    my $route = get '/:foo' => sub {...} => 'name';
    my $route = get '/:foo' => {foo => 'bar'} => sub {...};
    my $route = get '/:foo' => [foo => qr/\w+/] => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"get">, matching only C<GET>
  requests. See also L<Mojolicious::Guides::Tutorial> for many more argument
  variations.
  
  =head2 group
  
    group {...};
  
  Start a new route group.
  
  =head2 helper
  
    helper foo => sub {...};
  
  Add a new helper with L<Mojolicious/"helper">.
  
  =head2 hook
  
    hook after_dispatch => sub {...};
  
  Share code with L<Mojolicious/"hook">.
  
  =head2 options
  
    my $route = options '/:foo' => sub {...};
    my $route = options '/:foo' => sub {...} => 'name';
    my $route = options '/:foo' => {foo => 'bar'} => sub {...};
    my $route = options '/:foo' => [foo => qr/\w+/] => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"options">, matching only
  C<OPTIONS> requests. See also L<Mojolicious::Guides::Tutorial> for many more
  argument variations.
  
  =head2 patch
  
    my $route = patch '/:foo' => sub {...};
    my $route = patch '/:foo' => sub {...} => 'name';
    my $route = patch '/:foo' => {foo => 'bar'} => sub {...};
    my $route = patch '/:foo' => [foo => qr/\w+/] => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"patch">, matching only
  C<PATCH> requests. See also L<Mojolicious::Guides::Tutorial> for many more
  argument variations.
  
  =head2 plugin
  
    plugin SomePlugin => {foo => 23};
  
  Load a plugin with L<Mojolicious/"plugin">.
  
  =head2 post
  
    my $route = post '/:foo' => sub {...};
    my $route = post '/:foo' => sub {...} => 'name';
    my $route = post '/:foo' => {foo => 'bar'} => sub {...};
    my $route = post '/:foo' => [foo => qr/\w+/] => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"post">, matching only C<POST>
  requests. See also L<Mojolicious::Guides::Tutorial> for many more argument
  variations.
  
  =head2 put
  
    my $route = put '/:foo' => sub {...};
    my $route = put '/:foo' => sub {...} => 'name';
    my $route = put '/:foo' => {foo => 'bar'} => sub {...};
    my $route = put '/:foo' => [foo => qr/\w+/] => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"put">, matching only C<PUT>
  requests. See also L<Mojolicious::Guides::Tutorial> for many more argument
  variations.
  
  =head2 under
  
    my $route = under sub {...};
    my $route = under '/:foo' => sub {...};
    my $route = under '/:foo' => {foo => 'bar'};
    my $route = under '/:foo' => [foo => qr/\w+/];
    my $route = under [format => 0];
  
  Generate nested route with L<Mojolicious::Routes::Route/"under">, to which all
  following routes are automatically appended. See also
  L<Mojolicious::Guides::Tutorial> for more argument variations.
  
  =head2 websocket
  
    my $route = websocket '/:foo' => sub {...};
    my $route = websocket '/:foo' => sub {...} => 'name';
    my $route = websocket '/:foo' => {foo => 'bar'} => sub {...};
    my $route = websocket '/:foo' => [foo => qr/\w+/] => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"websocket">, matching only
  WebSocket handshakes. See also L<Mojolicious::Guides::Tutorial> for many more
  argument variations.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Lite> inherits all attributes from L<Mojolicious>.
  
  =head1 METHODS
  
  L<Mojolicious::Lite> inherits all methods from L<Mojolicious>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_LITE

$fatpacked{"Mojolicious/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN';
  package Mojolicious::Plugin;
  use Mojo::Base -base;
  
  use Carp 'croak';
  
  sub register { croak 'Method "register" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin - Plugin base class
  
  =head1 SYNOPSIS
  
    # CamelCase plugin name
    package Mojolicious::Plugin::MyPlugin;
    use Mojo::Base 'Mojolicious::Plugin';
  
    sub register {
      my ($self, $app, $conf) = @_;
  
      # Magic here! :)
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin> is an abstract base class for L<Mojolicious> plugins.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
    $plugin->register(Mojolicious->new, {foo => 'bar'});
  
  This method will be called by L<Mojolicious::Plugins> at startup time. Meant to
  be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN

$fatpacked{"Mojolicious/Plugin/Charset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_CHARSET';
  package Mojolicious::Plugin::Charset;
  use Mojo::Base 'Mojolicious::Plugin';
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    return unless my $c = $conf->{charset};
    $app->types->type(html => "text/html;charset=$c");
    $app->renderer->encoding($c);
    $app->hook(before_dispatch =>
        sub { shift->req->default_charset($c)->url->query->charset($c) });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Charset - Charset plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin(Charset => {charset => 'Shift_JIS'});
  
    # Mojolicious::Lite
    plugin Charset => {charset => 'Shift_JIS'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Charset> is a plugin to easily set the default charset
  and encoding on all layers of L<Mojolicious>.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::Charset> supports the following options.
  
  =head2 charset
  
    # Mojolicious::Lite
    plugin Charset => {charset => 'Shift_JIS'};
  
  Application charset.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Charset> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new, {charset => 'Shift_JIS'});
  
  Register hook L<Mojolicious/"before_dispatch"> in application and change a few
  defaults.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_CHARSET

$fatpacked{"Mojolicious/Plugin/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_CONFIG';
  package Mojolicious::Plugin::Config;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use File::Spec::Functions 'file_name_is_absolute';
  use Mojo::Util qw(decode slurp);
  
  sub load {
    my ($self, $file, $conf, $app) = @_;
    $app->log->debug(qq{Reading configuration file "$file"});
    return $self->parse(decode('UTF-8', slurp $file), $file, $conf, $app);
  }
  
  sub parse {
    my ($self, $content, $file, $conf, $app) = @_;
  
    # Run Perl code in sandbox
    my $config = eval 'package Mojolicious::Plugin::Config::Sandbox; no warnings;'
      . "sub app; local *app = sub { \$app }; use Mojo::Base -strict; $content";
    die qq{Can't load configuration from file "$file": $@} if $@;
    die qq{Configuration file "$file" did not return a hash reference.\n}
      unless ref $config eq 'HASH';
  
    return $config;
  }
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    # Config file
    my $file = $conf->{file} || $ENV{MOJO_CONFIG};
    $file ||= $app->moniker . '.' . ($conf->{ext} || 'conf');
  
    # Mode specific config file
    my $mode = $file =~ /^(.*)\.([^.]+)$/ ? join('.', $1, $app->mode, $2) : '';
  
    my $home = $app->home;
    $file = $home->rel_file($file) unless file_name_is_absolute $file;
    $mode = $home->rel_file($mode) if $mode && !file_name_is_absolute $mode;
    $mode = undef unless $mode && -e $mode;
  
    # Read config file
    my $config = {};
    if (-e $file) { $config = $self->load($file, $conf, $app) }
  
    # Check for default and mode specific config file
    elsif (!$conf->{default} && !$mode) {
      die qq{Configuration file "$file" missing, maybe you need to create it?\n};
    }
  
    # Merge everything
    $config = {%$config, %{$self->load($mode, $conf, $app)}} if $mode;
    $config = {%{$conf->{default}}, %$config} if $conf->{default};
    return $app->defaults(config => $app->config)->config($config)->config;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Config - Perl-ish configuration plugin
  
  =head1 SYNOPSIS
  
    # myapp.conf (it's just Perl returning a hash)
    {
      # Just a value
      foo => "bar",
  
      # Nested data structures are fine too
      baz => ['♥'],
  
      # You have full access to the application
      music_dir => app->home->rel_dir('music')
    };
  
    # Mojolicious
    my $config = $app->plugin('Config');
    say $config->{foo};
  
    # Mojolicious::Lite
    my $config = plugin 'Config';
    say $config->{foo};
  
    # foo.html.ep
    %= $config->{foo}
  
    # The configuration is available application-wide
    my $config = app->config;
    say $config->{foo};
  
    # Everything can be customized with options
    my $config = plugin Config => {file => '/etc/myapp.stuff'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Config> is a Perl-ish configuration plugin.
  
  The application object can be accessed via C<$app> or the C<app> function,
  L<strict>, L<warnings>, L<utf8> and Perl 5.10 L<features|feature> are
  automatically enabled. You can extend the normal configuration file
  C<$moniker.conf> with C<mode> specific ones like C<$moniker.$mode.conf>. A
  default configuration filename will be generated from the value of
  L<Mojolicious/"moniker">.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::Config> supports the following options.
  
  =head2 default
  
    # Mojolicious::Lite
    plugin Config => {default => {foo => 'bar'}};
  
  Default configuration, making configuration files optional.
  
  =head2 ext
  
    # Mojolicious::Lite
    plugin Config => {ext => 'stuff'};
  
  File extension for generated configuration filenames, defaults to C<conf>.
  
  =head2 file
  
    # Mojolicious::Lite
    plugin Config => {file => 'myapp.conf'};
    plugin Config => {file => '/etc/foo.stuff'};
  
  Path to configuration file, absolute or relative to the application home
  directory, defaults to the value of the C<MOJO_CONFIG> environment variable or
  C<$moniker.conf> in the application home directory.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Config> inherits all methods from L<Mojolicious::Plugin>
  and implements the following new ones.
  
  =head2 load
  
    $plugin->load($file, $conf, $app);
  
  Loads configuration file and passes the content to L</"parse">.
  
    sub load {
      my ($self, $file, $conf, $app) = @_;
      ...
      return $self->parse($content, $file, $conf, $app);
    }
  
  =head2 parse
  
    $plugin->parse($content, $file, $conf, $app);
  
  Parse configuration file.
  
    sub parse {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      return $hash;
    }
  
  =head2 register
  
    my $config = $plugin->register(Mojolicious->new);
    my $config = $plugin->register(Mojolicious->new, {file => '/etc/app.conf'});
  
  Register plugin in L<Mojolicious> application and merge configuration.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_CONFIG

$fatpacked{"Mojolicious/Plugin/DefaultHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_DEFAULTHELPERS';
  package Mojolicious::Plugin::DefaultHelpers;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::ByteStream;
  use Mojo::Collection;
  use Mojo::Exception;
  use Mojo::IOLoop;
  use Mojo::Util qw(dumper hmac_sha1_sum steady_time);
  use Scalar::Util 'blessed';
  
  sub register {
    my ($self, $app) = @_;
  
    # Controller alias helpers
    for my $name (qw(app flash param stash session url_for validation)) {
      $app->helper($name => sub { shift->$name(@_) });
    }
  
    # Stash key shortcuts (should not generate log messages)
    for my $name (qw(extends layout title)) {
      $app->helper($name => sub { shift->stash($name, @_) });
    }
  
    $app->helper(accepts => sub { $_[0]->app->renderer->accepts(@_) });
    $app->helper(b       => sub { shift; Mojo::ByteStream->new(@_) });
    $app->helper(c       => sub { shift; Mojo::Collection->new(@_) });
    $app->helper(config  => sub { shift->app->config(@_) });
  
    $app->helper(content      => sub { _content(0, 0, @_) });
    $app->helper(content_for  => sub { _content(1, 0, @_) });
    $app->helper(content_with => sub { _content(0, 1, @_) });
  
    $app->helper($_ => $self->can("_$_"))
      for qw(csrf_token current_route delay inactivity_timeout is_fresh url_with);
  
    $app->helper(dumper => sub { shift; dumper @_ });
    $app->helper(include => sub { shift->render_to_string(@_) });
  
    $app->helper("reply.$_" => $self->can("_$_")) for qw(asset static);
  
    $app->helper('reply.exception' => sub { _development('exception', @_) });
    $app->helper('reply.not_found' => sub { _development('not_found', @_) });
  
    $app->helper(ua => sub { shift->app->ua });
  }
  
  sub _asset {
    my $c = shift;
    $c->app->static->serve_asset($c, @_);
    $c->rendered;
  }
  
  sub _block { ref $_[0] eq 'CODE' ? $_[0]() : $_[0] }
  
  sub _content {
    my ($append, $replace, $c, $name, $content) = @_;
    $name ||= 'content';
  
    my $hash = $c->stash->{'mojo.content'} ||= {};
    if (defined $content) {
      if ($append) { $hash->{$name} .= _block($content) }
      if ($replace) { $hash->{$name} = _block($content) }
      else          { $hash->{$name} //= _block($content) }
    }
  
    return Mojo::ByteStream->new($hash->{$name} // '');
  }
  
  sub _csrf_token {
    my $c = shift;
    return $c->session->{csrf_token}
      ||= hmac_sha1_sum($$ . steady_time . rand, $c->app->secrets->[0]);
  }
  
  sub _current_route {
    return '' unless my $route = shift->match->endpoint;
    return @_ ? $route->name eq shift : $route->name;
  }
  
  sub _delay {
    my $c     = shift;
    my $tx    = $c->render_later->tx;
    my $delay = Mojo::IOLoop->delay(@_);
    $delay->catch(sub { $c->helpers->reply->exception(pop) and undef $tx })->wait;
  }
  
  sub _development {
    my ($page, $c, $e) = @_;
  
    my $app = $c->app;
    $app->log->error($e = _exception($e) ? $e : Mojo::Exception->new($e)->inspect)
      if $page eq 'exception';
  
    # Filtered stash snapshot
    my $stash = $c->stash;
    my %snapshot = map { $_ => $stash->{$_} }
      grep { !/^mojo\./ and defined $stash->{$_} } keys %$stash;
  
    # Render with fallbacks
    my $mode     = $app->mode;
    my $renderer = $app->renderer;
    my $options  = {
      exception => $page eq 'exception' ? $e : undef,
      format => $stash->{format} || $renderer->default_format,
      handler  => undef,
      snapshot => \%snapshot,
      status   => $page eq 'exception' ? 500 : 404,
      template => "$page.$mode"
    };
    my $bundled = 'mojo/' . ($mode eq 'development' ? 'debug' : $page);
    return $c if _fallbacks($c, $options, $page, $bundled);
    _fallbacks($c, {%$options, format => 'html'}, $page, $bundled);
    return $c;
  }
  
  sub _exception { blessed $_[0] && $_[0]->isa('Mojo::Exception') }
  
  sub _fallbacks {
    my ($c, $options, $template, $bundled) = @_;
  
    # Mode specific template
    return 1 if $c->render_maybe(%$options);
  
    # Normal template
    return 1 if $c->render_maybe(%$options, template => $template);
  
    # Inline template
    my $stash = $c->stash;
    return undef unless $stash->{format} eq 'html';
    delete @$stash{qw(extends layout)};
    return $c->render_maybe($bundled, %$options, handler => 'ep');
  }
  
  sub _inactivity_timeout {
    my ($c, $timeout) = @_;
    my $stream = Mojo::IOLoop->stream($c->tx->connection // '');
    $stream->timeout($timeout) if $stream;
    return $c;
  }
  
  sub _is_fresh {
    my ($c, %options) = @_;
    return $c->app->static->is_fresh($c, \%options);
  }
  
  sub _static {
    my ($c, $file) = @_;
    return !!$c->rendered if $c->app->static->serve($c, $file);
    $c->app->log->debug(qq{Static file "$file" not found});
    return !$c->helpers->reply->not_found;
  }
  
  sub _url_with {
    my $c = shift;
    return $c->url_for(@_)->query($c->req->url->query->clone);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::DefaultHelpers - Default helpers plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('DefaultHelpers');
  
    # Mojolicious::Lite
    plugin 'DefaultHelpers';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::DefaultHelpers> is a collection of helpers for
  L<Mojolicious>.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::DefaultHelpers> implements the following helpers.
  
  =head2 accepts
  
    my $formats = $c->accepts;
    my $format  = $c->accepts('html', 'json', 'txt');
  
  Select best possible representation for resource from C<Accept> request header,
  C<format> stash value or C<format> C<GET>/C<POST> parameter with
  L<Mojolicious::Renderer/"accepts">, defaults to returning the first extension
  if no preference could be detected.
  
    # Check if JSON is acceptable
    $c->render(json => {hello => 'world'}) if $c->accepts('json');
  
    # Check if JSON was specifically requested
    $c->render(json => {hello => 'world'}) if $c->accepts('', 'json');
  
    # Unsupported representation
    $c->render(data => '', status => 204)
      unless my $format = $c->accepts('html', 'json');
  
    # Detected representations to select from
    my @formats = @{$c->accepts};
  
  =head2 app
  
    %= app->secrets->[0]
  
  Alias for L<Mojolicious::Controller/"app">.
  
  =head2 b
  
    %= b('test 123')->b64_encode
  
  Turn string into a L<Mojo::ByteStream> object.
  
  =head2 c
  
    %= c('a', 'b', 'c')->shuffle->join
  
  Turn list into a L<Mojo::Collection> object.
  
  =head2 config
  
    %= config 'something'
  
  Alias for L<Mojo/"config">.
  
  =head2 content
  
    %= content foo => begin
      test
    % end
    %= content bar => 'Hello World!'
    %= content 'foo'
    %= content 'bar'
    %= content
  
  Store partial rendered content in a named buffer and retrieve it later,
  defaults to retrieving the named buffer C<content>, which is used by the
  renderer for the C<layout> and C<extends> features. New content will be ignored
  if the named buffer is already in use.
  
  =head2 content_for
  
    % content_for foo => begin
      test
    % end
    %= content_for 'foo'
  
  Same as L</"content">, but appends content to named buffers if they are already
  in use.
  
    % content_for message => begin
      Hello
    % end
    % content_for message => begin
      world!
    % end
    %= content 'message'
  
  =head2 content_with
  
    % content_with foo => begin
      test
    % end
    %= content_with 'foo'
  
  Same as L</"content">, but replaces content of named buffers if they are
  already in use.
  
    % content message => begin
      world!
    % end
    % content_with message => begin
      Hello <%= content 'message' %>
    % end
    %= content 'message'
  
  =head2 csrf_token
  
    %= csrf_token
  
  Get CSRF token from L</"session">, and generate one if none exists.
  
  =head2 current_route
  
    % if (current_route 'login') {
      Welcome to Mojolicious!
    % }
    %= current_route
  
  Check or get name of current route.
  
  =head2 delay
  
    $c->delay(sub {...}, sub {...});
  
  Disable automatic rendering and use L<Mojo::IOLoop/"delay"> to manage callbacks
  and control the flow of events, which can help you avoid deep nested closures
  that often result from continuation-passing style. Also keeps a reference to
  L<Mojolicious::Controller/"tx"> in case the underlying connection gets closed
  early, and calls L</"reply-E<gt>exception"> if an exception gets thrown in one
  of the steps, breaking the chain.
  
    # Longer version
    $c->render_later;
    my $tx    = $c->tx;
    my $delay = Mojo::IOLoop->delay(sub {...}, sub {...});
    $delay->catch(sub { $c->reply->exception(pop) and undef $tx })->wait;
  
    # Non-blocking request
    $c->delay(
      sub {
        my $delay = shift;
        $c->ua->get('http://mojolicious.org' => $delay->begin);
      },
      sub {
        my ($delay, $tx) = @_;
        $c->render(json => {title => $tx->res->dom->at('title')->text});
      }
    );
  
  =head2 dumper
  
    %= dumper {some => 'data'}
  
  Dump a Perl data structure with L<Mojo::Util/"dumper">, very useful for
  debugging.
  
  =head2 extends
  
    % extends 'blue';
    % extends 'blue', title => 'Blue!';
  
  Set C<extends> stash value, all additional key/value pairs get merged into the
  L</"stash">.
  
  =head2 flash
  
    %= flash 'foo'
  
  Alias for L<Mojolicious::Controller/"flash">.
  
  =head2 inactivity_timeout
  
    $c = $c->inactivity_timeout(3600);
  
  Use L<Mojo::IOLoop/"stream"> to find the current connection and increase
  timeout if possible.
  
    # Longer version
    Mojo::IOLoop->stream($c->tx->connection)->timeout(3600);
  
  =head2 include
  
    %= include 'menubar'
    %= include 'menubar', format => 'txt'
  
  Alias for L<Mojolicious::Controller/"render_to_string">.
  
  =head2 is_fresh
  
    my $bool = $c->is_fresh;
    my $bool = $c->is_fresh(etag => 'abc');
    my $bool = $c->is_fresh(last_modified => $epoch);
  
  Check freshness of request by comparing the C<If-None-Match> and
  C<If-Modified-Since> request headers to the C<ETag> and C<Last-Modified>
  response headers with L<Mojolicious::Static/"is_fresh">.
  
    # Add ETag/Last-Modified headers and check freshness before rendering
    $c->is_fresh(etag => 'abc', last_modified => 1424985708)
      ? $c->rendered(304)
      : $c->render(text => 'I ♥ Mojolicious!');
  
  =head2 layout
  
    % layout 'green';
    % layout 'green', title => 'Green!';
  
  Set C<layout> stash value, all additional key/value pairs get merged into the
  L</"stash">.
  
  =head2 param
  
    %= param 'foo'
  
  Alias for L<Mojolicious::Controller/"param">.
  
  =head2 reply->asset
  
    $c->reply->asset(Mojo::Asset::File->new);
  
  Reply with a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object using
  L<Mojolicious::Static/"serve_asset">, and perform content negotiation with
  C<Range>, C<If-Modified-Since> and C<If-None-Match> headers.
  
    # Serve asset with custom modification time
    my $asset = Mojo::Asset::Memory->new;
    $asset->add_chunk('Hello World!')->mtime(784111777);
    $c->res->headers->content_type('text/plain');
    $c->reply->asset($asset);
  
    # Serve static file if it exists
    if (my $asset = $c->app->static->file('images/logo.png')) {
      $c->res->headers->content_type('image/png');
      $c->reply->asset($asset);
    }
  
  =head2 reply->exception
  
    $c = $c->reply->exception('Oops!');
    $c = $c->reply->exception(Mojo::Exception->new);
  
  Render the exception template C<exception.$mode.$format.*> or
  C<exception.$format.*> and set the response status code to C<500>. Also sets
  the stash values C<exception> to a L<Mojo::Exception> object and C<snapshot> to
  a copy of the L</"stash"> for use in the templates.
  
  =head2 reply->not_found
  
    $c = $c->reply->not_found;
  
  Render the not found template C<not_found.$mode.$format.*> or
  C<not_found.$format.*> and set the response status code to C<404>. Also sets
  the stash value C<snapshot> to a copy of the L</"stash"> for use in the
  templates.
  
  =head2 reply->static
  
    my $bool = $c->reply->static('images/logo.png');
    my $bool = $c->reply->static('../lib/MyApp.pm');
  
  Reply with a static file using L<Mojolicious/"static">, usually from the
  C<public> directories or C<DATA> sections of your application. Note that this
  helper uses a relative path, but does not protect from traversing to parent
  directories.
  
    # Serve file with a custom content type
    $c->res->headers->content_type('application/myapp');
    $c->reply->static('foo.txt');
  
  =head2 session
  
    %= session 'foo'
  
  Alias for L<Mojolicious::Controller/"session">.
  
  =head2 stash
  
    %= stash 'foo'
    % stash foo => 'bar';
  
  Alias for L<Mojolicious::Controller/"stash">.
  
    %= stash('name') // 'Somebody'
  
  =head2 title
  
    %= title
    % title 'Welcome!';
    % title 'Welcome!', foo => 'bar';
  
  Get or set C<title> stash value, all additional key/value pairs get merged into
  the L</"stash">.
  
  =head2 ua
  
    %= ua->get('mojolicious.org')->res->dom->at('title')->text
  
  Alias for L<Mojo/"ua">.
  
  =head2 url_for
  
    %= url_for 'named', controller => 'bar', action => 'baz'
  
  Alias for L<Mojolicious::Controller/"url_for">.
  
    %= url_for('/index.html')->query(foo => 'bar')
  
  =head2 url_with
  
    %= url_with 'named', controller => 'bar', action => 'baz'
  
  Does the same as L</"url_for">, but inherits query parameters from the current
  request.
  
    %= url_with->query([page => 2])
  
  =head2 validation
  
    %= validation->param('foo')
  
  Alias for L<Mojolicious::Controller/"validation">.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::DefaultHelpers> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register helpers in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_DEFAULTHELPERS

$fatpacked{"Mojolicious/Plugin/EPLRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPLRENDERER';
  package Mojolicious::Plugin::EPLRenderer;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Template;
  use Mojo::Util qw(encode md5_sum);
  
  sub register {
    my ($self, $app) = @_;
    $app->renderer->add_handler(
      epl => sub { _render(@_, Mojo::Template->new, $_[1]) });
  }
  
  sub _render {
    my ($renderer, $c, $output, $options, $mt, @args) = @_;
  
    # Cached
    if ($mt->compiled) {
      $c->app->log->debug("Rendering cached @{[$mt->name]}");
      $$output = $mt->process(@args);
    }
  
    # Not cached
    else {
      my $inline = $options->{inline};
      my $name = defined $inline ? md5_sum encode('UTF-8', $inline) : undef;
      return unless defined($name //= $renderer->template_name($options));
  
      # Inline
      if (defined $inline) {
        $c->app->log->debug(qq{Rendering inline template "$name"});
        $$output = $mt->name(qq{inline template "$name"})->render($inline, @args);
      }
  
      # File
      else {
        if (my $encoding = $renderer->encoding) { $mt->encoding($encoding) }
  
        # Try template
        if (defined(my $path = $renderer->template_path($options))) {
          $c->app->log->debug(qq{Rendering template "$name"});
          $$output = $mt->name(qq{template "$name"})->render_file($path, @args);
        }
  
        # Try DATA section
        elsif (defined(my $d = $renderer->get_data_template($options))) {
          $c->app->log->debug(qq{Rendering template "$name" from DATA section});
          $$output = $mt->name(qq{template "$name" from DATA section})
            ->render($d, @args);
        }
  
        # No template
        else { $c->app->log->debug(qq{Template "$name" not found}) }
      }
    }
  
    # Exception
    die $$output if ref $$output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::EPLRenderer - Embedded Perl Lite renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('EPLRenderer');
  
    # Mojolicious::Lite
    plugin 'EPLRenderer';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::EPLRenderer> is a renderer for C<epl> templates, which
  are pretty much just raw L<Mojo::Template>.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::EPLRenderer> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register renderer in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_EPLRENDERER

$fatpacked{"Mojolicious/Plugin/EPRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPRENDERER';
  package Mojolicious::Plugin::EPRenderer;
  use Mojo::Base 'Mojolicious::Plugin::EPLRenderer';
  
  use Mojo::Template;
  use Mojo::Util qw(encode md5_sum monkey_patch);
  
  sub DESTROY { Mojo::Util::_teardown(shift->{namespace}) }
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    # Auto escape by default to prevent XSS attacks
    my $ep = {auto_escape => 1, %{$conf->{template} || {}}, vars => 1};
    my $ns = $self->{namespace} = $ep->{namespace}
      //= 'Mojo::Template::Sandbox::' . md5_sum "$self";
  
    # Make "$self" and "$c" available in templates
    $ep->{prepend} = 'my $self = my $c = _C;' . ($ep->{prepend} // '');
  
    # Add "ep" handler and make it the default
    $app->renderer->default_handler('ep')->add_handler(
      $conf->{name} || 'ep' => sub {
        my ($renderer, $c, $output, $options) = @_;
  
        my $name = $options->{inline} // $renderer->template_name($options);
        return unless defined $name;
        my $key = md5_sum encode 'UTF-8', $name;
  
        my $cache = $renderer->cache;
        my $mt    = $cache->get($key);
        $cache->set($key => $mt = Mojo::Template->new($ep)) unless $mt;
  
        # Export helpers only once
        ++$self->{helpers} and _helpers($ns, $renderer->helpers)
          unless $self->{helpers};
  
        # Make current controller available and render with "epl" handler
        no strict 'refs';
        no warnings 'redefine';
        local *{"${ns}::_C"} = sub {$c};
        Mojolicious::Plugin::EPLRenderer::_render($renderer, $c, $output,
          $options, $mt, $c->stash);
      }
    );
  }
  
  sub _helpers {
    my ($class, $helpers) = @_;
    for my $method (grep {/^\w+$/} keys %$helpers) {
      my $sub = $helpers->{$method};
      monkey_patch $class, $method, sub { $class->_C->$sub(@_) };
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::EPRenderer - Embedded Perl renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('EPRenderer');
    $app->plugin(EPRenderer => {name => 'foo'});
    $app->plugin(EPRenderer => {name => 'bar', template => {line_start => '.'}});
  
    # Mojolicious::Lite
    plugin 'EPRenderer';
    plugin EPRenderer => {name => 'foo'};
    plugin EPRenderer => {name => 'bar', template => {line_start => '.'}};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::EPRenderer> is a renderer for Embedded Perl templates.
  For more information see L<Mojolicious::Guides::Rendering/"Embedded Perl">.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::EPRenderer> supports the following options.
  
  =head2 name
  
    # Mojolicious::Lite
    plugin EPRenderer => {name => 'foo'};
  
  Handler name, defaults to C<ep>.
  
  =head2 template
  
    # Mojolicious::Lite
    plugin EPRenderer => {template => {line_start => '.'}};
  
  Attribute values passed to L<Mojo::Template> object used to render templates.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::EPRenderer> inherits all methods from
  L<Mojolicious::Plugin::EPLRenderer> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
    $plugin->register(Mojolicious->new, {name => 'foo'});
  
  Register renderer in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_EPRENDERER

$fatpacked{"Mojolicious/Plugin/HeaderCondition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_HEADERCONDITION';
  package Mojolicious::Plugin::HeaderCondition;
  use Mojo::Base 'Mojolicious::Plugin';
  
  sub register {
    my ($self, $app) = @_;
  
    $app->routes->add_condition(headers => \&_headers);
    $app->routes->add_condition(
      agent => sub { _headers(@_[0 .. 2], {'User-Agent' => $_[3]}) });
    $app->routes->add_condition(
      host => sub { _check($_[1]->req->url->to_abs->host, $_[3]) });
  }
  
  sub _check {
    my ($value, $pattern) = @_;
    return 1
      if $value && $pattern && ref $pattern eq 'Regexp' && $value =~ $pattern;
    return $value && defined $pattern && $pattern eq $value;
  }
  
  sub _headers {
    my ($route, $c, $captures, $patterns) = @_;
    return undef unless $patterns && ref $patterns eq 'HASH' && keys %$patterns;
  
    # All headers need to match
    my $headers = $c->req->headers;
    _check($headers->header($_), $patterns->{$_}) || return undef
      for keys %$patterns;
    return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::HeaderCondition - Header condition plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('HeaderCondition');
    $app->routes->get('/:controller/:action')
      ->over(headers => {Referer => qr/example\.com/});
  
    # Mojolicious::Lite
    plugin 'HeaderCondition';
    get '/' => (headers => {Referer => qr/example\.com/}) => sub {...};
  
    # All headers need to match
    $app->routes->get('/:controller/:action')->over(headers => {
      'X-Secret-Header' => 'Foo',
      Referer => qr/example\.com/
    });
  
    # The "agent" condition is a shortcut for the "User-Agent" header
    get '/' => (agent => qr/Firefox/) => sub {...};
  
    # The "host" condition is a shortcut for the detected host
    get '/' => (host => qr/mojolicious\.org/) => sub {...};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::HeaderCondition> is a route condition for header-based
  routes.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::HeaderCondition> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register conditions in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_HEADERCONDITION

$fatpacked{"Mojolicious/Plugin/JSONConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_JSONCONFIG';
  package Mojolicious::Plugin::JSONConfig;
  use Mojo::Base 'Mojolicious::Plugin::Config';
  
  use Mojo::JSON 'from_json';
  use Mojo::Template;
  
  sub parse {
    my ($self, $content, $file, $conf, $app) = @_;
  
    my $config = eval { from_json $self->render($content, $file, $conf, $app) };
    die qq{Can't parse config "$file": $@} if $@;
    die qq{Invalid config "$file"} unless ref $config eq 'HASH';
  
    return $config;
  }
  
  sub register { shift->SUPER::register(shift, {ext => 'json', %{shift()}}) }
  
  sub render {
    my ($self, $content, $file, $conf, $app) = @_;
  
    # Application instance and helper
    my $prepend = q[no strict 'refs'; no warnings 'redefine';];
    $prepend .= q[my $app = shift; sub app; local *app = sub { $app };];
    $prepend .= q[use Mojo::Base -strict; no warnings 'ambiguous';];
  
    my $mt = Mojo::Template->new($conf->{template} || {})->name($file);
    my $output = $mt->prepend($prepend . $mt->prepend)->render($content, $app);
    return ref $output ? die $output : $output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::JSONConfig - JSON configuration plugin
  
  =head1 SYNOPSIS
  
    # myapp.json (it's just JSON with embedded Perl)
    {
      %# Just a value
      "foo": "bar",
  
      %# Nested data structures are fine too
      "baz": ["♥"],
  
      %# You have full access to the application
      "music_dir": "<%= app->home->rel_dir('music') %>"
    }
  
    # Mojolicious
    my $config = $app->plugin('JSONConfig');
    say $config->{foo};
  
    # Mojolicious::Lite
    my $config = plugin 'JSONConfig';
    say $config->{foo};
  
    # foo.html.ep
    %= $config->{foo}
  
    # The configuration is available application-wide
    my $config = app->config;
    say $config->{foo};
  
    # Everything can be customized with options
    my $config = plugin JSONConfig => {file => '/etc/myapp.conf'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::JSONConfig> is a JSON configuration plugin that
  preprocesses its input with L<Mojo::Template>.
  
  The application object can be accessed via C<$app> or the C<app> function. You
  can extend the normal configuration file C<$moniker.json> with C<mode> specific
  ones like C<$moniker.$mode.json>. A default configuration filename will be
  generated from the value of L<Mojolicious/"moniker">.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::JSONConfig> inherits all options from
  L<Mojolicious::Plugin::Config> and supports the following new ones.
  
  =head2 template
  
    # Mojolicious::Lite
    plugin JSONConfig => {template => {line_start => '.'}};
  
  Attribute values passed to L<Mojo::Template> object used to preprocess
  configuration files.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::JSONConfig> inherits all methods from
  L<Mojolicious::Plugin::Config> and implements the following new ones.
  
  =head2 parse
  
    $plugin->parse($content, $file, $conf, $app);
  
  Process content with L</"render"> and parse it with L<Mojo::JSON>.
  
    sub parse {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      $content = $self->render($content, $file, $conf, $app);
      ...
      return $hash;
    }
  
  =head2 register
  
    my $config = $plugin->register(Mojolicious->new);
    my $config = $plugin->register(Mojolicious->new, {file => '/etc/foo.conf'});
  
  Register plugin in L<Mojolicious> application and merge configuration.
  
  =head2 render
  
    $plugin->render($content, $file, $conf, $app);
  
  Process configuration file with L<Mojo::Template>.
  
    sub render {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      return $content;
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_JSONCONFIG

$fatpacked{"Mojolicious/Plugin/Mount.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_MOUNT';
  package Mojolicious::Plugin::Mount;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Server;
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    my $path  = (keys %$conf)[0];
    my $embed = Mojo::Server->new->load_app($conf->{$path});
    $embed->secrets($app->secrets);
  
    # Extract host
    my $host;
    ($host, $path) = ($1 ? qr/^(?:.*\.)?\Q$2\E$/i : qr/^\Q$2\E$/i, $3)
      if $path =~ m!^(\*\.)?([^/]+)(/.*)?$!;
  
    my $route = $app->routes->route($path)->detour(app => $embed);
    return $host ? $route->over(host => $host) : $route;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Mount - Application mount plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    my $route = $app->plugin(Mount => {'/prefix' => '/home/sri/myapp.pl'});
  
    # Mojolicious::Lite
    my $route = plugin Mount => {'/prefix' => '/home/sri/myapp.pl'};
  
    # Adjust the generated route and mounted application
    my $example = plugin Mount => {'/example' => '/home/sri/example.pl'};
    $example->to(message => 'It works great!');
    my $app = $example->pattern->defaults->{app};
    $app->config(foo => 'bar');
    $app->log(app->log);
  
    # Mount application with host
    plugin Mount => {'example.com' => '/home/sri/myapp.pl'};
  
    # Host and path
    plugin Mount => {'example.com/myapp' => '/home/sri/myapp.pl'};
  
    # Or even hosts with wildcard subdomains
    plugin Mount => {'*.example.com/myapp' => '/home/sri/myapp.pl'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Mount> is a plugin that allows you to mount whole
  L<Mojolicious> applications.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Mount> inherits all methods from L<Mojolicious::Plugin>
  and implements the following new ones.
  
  =head2 register
  
    my $route = $plugin->register(Mojolicious->new, {'/foo' => '/some/app.pl'});
  
  Mount L<Mojolicious> application and return the generated route, which is
  usually a L<Mojolicious::Routes::Route> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_MOUNT

$fatpacked{"Mojolicious/Plugin/PODRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_PODRENDERER';
  package Mojolicious::Plugin::PODRenderer;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Asset::File;
  use Mojo::ByteStream;
  use Mojo::DOM;
  use Mojo::URL;
  use Mojo::Util 'slurp';
  use Pod::Simple::XHTML;
  use Pod::Simple::Search;
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    my $preprocess = $conf->{preprocess} || 'ep';
    $app->renderer->add_handler(
      $conf->{name} || 'pod' => sub {
        my ($renderer, $c, $output, $options) = @_;
        $renderer->handlers->{$preprocess}($renderer, $c, $output, $options);
        $$output = _pod_to_html($$output) if defined $$output;
      }
    );
  
    $app->helper(
      pod_to_html => sub { shift; Mojo::ByteStream->new(_pod_to_html(@_)) });
  
    # Perldoc browser
    return undef if $conf->{no_perldoc};
    my $defaults = {module => 'Mojolicious/Guides', format => 'html'};
    return $app->routes->any(
      '/perldoc/:module' => $defaults => [module => qr/[^.]+/] => \&_perldoc);
  }
  
  sub _indentation {
    (sort map {/^(\s+)/} @{shift()})[0];
  }
  
  sub _html {
    my ($c, $src) = @_;
  
    # Rewrite links
    my $dom     = Mojo::DOM->new(_pod_to_html($src));
    my $perldoc = $c->url_for('/perldoc/');
    $_->{href} =~ s!^https://metacpan\.org/pod/!$perldoc!
      and $_->{href} =~ s!::!/!gi
      for $dom->find('a[href]')->map('attr')->each;
  
    # Rewrite code blocks for syntax highlighting and correct indentation
    for my $e ($dom->find('pre > code')->each) {
      my $str = $e->content;
      next if $str =~ /^\s*(?:\$|Usage:)\s+/m || $str !~ /[\$\@\%]\w|-&gt;\w/m;
      my $attrs = $e->attr;
      my $class = $attrs->{class};
      $attrs->{class} = defined $class ? "$class prettyprint" : 'prettyprint';
    }
  
    # Rewrite headers
    my $toc = Mojo::URL->new->fragment('toc');
    my @parts;
    for my $e ($dom->find('h1, h2, h3, h4')->each) {
  
      push @parts, [] if $e->tag eq 'h1' || !@parts;
      my $link = Mojo::URL->new->fragment($e->{id});
      push @{$parts[-1]}, my $text = $e->all_text, $link;
      my $permalink = $c->link_to('#' => $link, class => 'permalink');
      $e->content($permalink . $c->link_to($text => $toc));
    }
  
    # Try to find a title
    my $title = 'Perldoc';
    $dom->find('h1 + p')->first(sub { $title = shift->text });
  
    # Combine everything to a proper response
    $c->content_for(perldoc => "$dom");
    $c->render('mojo/perldoc', title => $title, parts => \@parts);
  }
  
  sub _perldoc {
    my $c = shift;
  
    # Find module or redirect to CPAN
    my $module = join '::', split('/', $c->param('module'));
    my $path
      = Pod::Simple::Search->new->find($module, map { $_, "$_/pods" } @INC);
    return $c->redirect_to("https://metacpan.org/pod/$module")
      unless $path && -r $path;
  
    my $src = slurp $path;
    $c->respond_to(txt => {data => $src}, html => sub { _html($c, $src) });
  }
  
  sub _pod_to_html {
    return '' unless defined(my $pod = ref $_[0] eq 'CODE' ? shift->() : shift);
  
    my $parser = Pod::Simple::XHTML->new;
    $parser->perldoc_url_prefix('https://metacpan.org/pod/');
    $parser->$_('') for qw(html_header html_footer);
    $parser->strip_verbatim_indent(\&_indentation);
    $parser->output_string(\(my $output));
    return $@ unless eval { $parser->parse_string_document("$pod"); 1 };
  
    return $output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::PODRenderer - POD renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious (with documentation browser under "/perldoc")
    my $route = $app->plugin('PODRenderer');
    my $route = $app->plugin(PODRenderer => {name => 'foo'});
    my $route = $app->plugin(PODRenderer => {preprocess => 'epl'});
  
    # Mojolicious::Lite (with documentation browser under "/perldoc")
    my $route = plugin 'PODRenderer';
    my $route = plugin PODRenderer => {name => 'foo'};
    my $route = plugin PODRenderer => {preprocess => 'epl'};
  
    # Without documentation browser
    plugin PODRenderer => {no_perldoc => 1};
  
    # foo.html.ep
    %= pod_to_html "=head1 TEST\n\nC<123>"
  
    # foo.html.pod
    =head1 <%= uc 'test' %>
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::PODRenderer> is a renderer for true Perl hackers, rawr!
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::PODRenderer> supports the following options.
  
  =head2 name
  
    # Mojolicious::Lite
    plugin PODRenderer => {name => 'foo'};
  
  Handler name, defaults to C<pod>.
  
  =head2 no_perldoc
  
    # Mojolicious::Lite
    plugin PODRenderer => {no_perldoc => 1};
  
  Disable L<Mojolicious::Guides> documentation browser that will otherwise be
  available under C</perldoc>.
  
  =head2 preprocess
  
    # Mojolicious::Lite
    plugin PODRenderer => {preprocess => 'epl'};
  
  Name of handler used to preprocess POD, defaults to C<ep>.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::PODRenderer> implements the following helpers.
  
  =head2 pod_to_html
  
    %= pod_to_html '=head2 lalala'
    <%= pod_to_html begin %>=head2 lalala<% end %>
  
  Render POD to HTML without preprocessing.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::PODRenderer> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    my $route = $plugin->register(Mojolicious->new);
    my $route = $plugin->register(Mojolicious->new, {name => 'foo'});
  
  Register renderer and helper in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_PODRENDERER

$fatpacked{"Mojolicious/Plugin/TagHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_TAGHELPERS';
  package Mojolicious::Plugin::TagHelpers;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::ByteStream;
  use Mojo::DOM::HTML;
  use Scalar::Util 'blessed';
  
  sub register {
    my ($self, $app) = @_;
  
    # Text field variations
    my @time = qw(date month time week);
    for my $name (@time, qw(color email number range search tel text url)) {
      $app->helper("${name}_field" => sub { _input(@_, type => $name) });
    }
    $app->helper(datetime_field => sub { _input(@_, type => 'datetime-local') });
  
    my @helpers = (
      qw(csrf_field form_for hidden_field javascript label_for link_to),
      qw(select_field stylesheet submit_button tag_with_error text_area)
    );
    $app->helper($_ => __PACKAGE__->can("_$_")) for @helpers;
  
    $app->helper(check_box => sub { _input(@_, type => 'checkbox') });
    $app->helper(file_field => sub { _empty_field('file', @_) });
    $app->helper(image => sub { _tag('img', src => shift->url_for(shift), @_) });
    $app->helper(input_tag      => sub { _input(@_) });
    $app->helper(password_field => sub { _empty_field('password', @_) });
    $app->helper(radio_button   => sub { _input(@_, type => 'radio') });
  
    # "t" is just a shortcut for the "tag" helper
    $app->helper($_ => sub { shift; _tag(@_) }) for qw(t tag);
  }
  
  sub _csrf_field {
    my $c = shift;
    return _hidden_field($c, csrf_token => $c->helpers->csrf_token, @_);
  }
  
  sub _empty_field {
    my ($type, $c, $name) = (shift, shift, shift);
    return _validation($c, $name, 'input', name => $name, @_, type => $type);
  }
  
  sub _form_for {
    my ($c, @url) = (shift, shift);
    push @url, shift if ref $_[0] eq 'HASH';
  
    # Method detection
    my $r      = $c->app->routes->lookup($url[0]);
    my $method = $r ? $r->suggested_method : 'GET';
    my @post   = $method ne 'GET' ? (method => 'POST') : ();
  
    my $url = $c->url_for(@url);
    $url->query({_method => $method}) if @post && $method ne 'POST';
    return _tag('form', action => $url, @post, @_);
  }
  
  sub _hidden_field {
    my ($c, $name, $value) = (shift, shift, shift);
    return _tag('input', name => $name, value => $value, @_, type => 'hidden');
  }
  
  sub _input {
    my ($c, $name) = (shift, shift);
    my %attrs = @_ % 2 ? (value => shift, @_) : @_;
  
    if (my @values = @{$c->every_param($name)}) {
  
      # Checkbox or radiobutton
      my $type = $attrs{type} || '';
      if ($type eq 'checkbox' || $type eq 'radio') {
        delete $attrs{checked} if @values;
        my $value = $attrs{value} // 'on';
        $attrs{checked} = undef if grep { $_ eq $value } @values;
      }
  
      # Others
      else { $attrs{value} = $values[-1] }
    }
  
    return _validation($c, $name, 'input', name => $name, %attrs);
  }
  
  sub _javascript {
    my $c = shift;
    my $content
      = ref $_[-1] eq 'CODE' ? "//<![CDATA[\n" . pop->() . "\n//]]>" : '';
    my @src = @_ % 2 ? (src => $c->url_for(shift)) : ();
    return _tag('script', @src, @_, sub {$content});
  }
  
  sub _label_for {
    my ($c, $name) = (shift, shift);
    my $content = ref $_[-1] eq 'CODE' ? pop : shift;
    return _validation($c, $name, 'label', for => $name, @_, $content);
  }
  
  sub _link_to {
    my ($c, $content) = (shift, shift);
    my @url = ($content);
  
    # Content
    unless (ref $_[-1] eq 'CODE') {
      @url = (shift);
      push @_, $content;
    }
  
    # Captures
    push @url, shift if ref $_[0] eq 'HASH';
  
    return _tag('a', href => $c->url_for(@url), @_);
  }
  
  sub _option {
    my ($values, $pair) = @_;
  
    $pair = [$pair => $pair] unless ref $pair eq 'ARRAY';
    my %attrs = (value => $pair->[1], @$pair[2 .. $#$pair]);
    delete $attrs{selected} if keys %$values;
    $attrs{selected} = undef if $values->{$pair->[1]};
  
    return _tag('option', %attrs, $pair->[0]);
  }
  
  sub _select_field {
    my ($c, $name, $options, %attrs) = (shift, shift, shift, @_);
  
    my %values = map { $_ => 1 } @{$c->every_param($name)};
  
    my $groups = '';
    for my $group (@$options) {
  
      # "optgroup" tag
      if (blessed $group && $group->isa('Mojo::Collection')) {
        my ($label, $values, %attrs) = @$group;
        my $content = join '', map { _option(\%values, $_) } @$values;
        $groups .= _tag('optgroup', label => $label, %attrs, sub {$content});
      }
  
      # "option" tag
      else { $groups .= _option(\%values, $group) }
    }
  
    return _validation($c, $name, 'select', name => $name, %attrs, sub {$groups});
  }
  
  sub _stylesheet {
    my $c = shift;
    my $content
      = ref $_[-1] eq 'CODE' ? "/*<![CDATA[*/\n" . pop->() . "\n/*]]>*/" : '';
    return _tag('style', @_, sub {$content}) unless @_ % 2;
    return _tag('link', rel => 'stylesheet', href => $c->url_for(shift), @_);
  }
  
  sub _submit_button {
    my ($c, $value) = (shift, shift // 'Ok');
    return _tag('input', value => $value, @_, type => 'submit');
  }
  
  sub _tag {
    my $tree = ['tag', shift, undef, undef];
  
    # Content
    if (ref $_[-1] eq 'CODE') { push @$tree, ['raw', pop->()] }
    elsif (@_ % 2) { push @$tree, ['text', pop] }
  
    # Attributes
    my $attrs = $tree->[2] = {@_};
    if (ref $attrs->{data} eq 'HASH' && (my $data = delete $attrs->{data})) {
      @$attrs{map { y/_/-/; lc "data-$_" } keys %$data} = values %$data;
    }
  
    return Mojo::ByteStream->new(Mojo::DOM::HTML::_render($tree));
  }
  
  sub _tag_with_error {
    my ($c, $tag) = (shift, shift);
    my ($content, %attrs) = (@_ % 2 ? pop : undef, @_);
    $attrs{class} .= $attrs{class} ? ' field-with-error' : 'field-with-error';
    return _tag($tag, %attrs, defined $content ? $content : ());
  }
  
  sub _text_area {
    my ($c, $name) = (shift, shift);
  
    my $cb = ref $_[-1] eq 'CODE' ? pop : undef;
    my $content = @_ % 2 ? shift : undef;
    $content = $c->param($name) // $content // $cb // '';
  
    return _validation($c, $name, 'textarea', name => $name, @_, $content);
  }
  
  sub _validation {
    my ($c, $name) = (shift, shift);
    return _tag(@_) unless $c->validation->has_error($name);
    return $c->helpers->tag_with_error(@_);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::TagHelpers - Tag helpers plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('TagHelpers');
  
    # Mojolicious::Lite
    plugin 'TagHelpers';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::TagHelpers> is a collection of HTML tag helpers for
  L<Mojolicious>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org>.
  
  Most form helpers can automatically pick up previous input values and will show
  them as default. You can also use
  L<Mojolicious::Plugin::DefaultHelpers/"param"> to set them manually and let
  necessary attributes always be generated automatically.
  
    % param country => 'germany' unless param 'country';
    <%= radio_button country => 'germany' %> Germany
    <%= radio_button country => 'france'  %> France
    <%= radio_button country => 'uk'      %> UK
  
  For fields that failed validation with L<Mojolicious::Controller/"validation">
  the C<field-with-error> class will be automatically added through
  L</"tag_with_error">, to make styling with CSS easier.
  
    <input class="field-with-error" name="age" type="text" value="250">
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning how to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::TagHelpers> implements the following helpers.
  
  =head2 check_box
  
    %= check_box 'employed'
    %= check_box employed => 1
    %= check_box employed => 1, checked => undef, id => 'foo'
  
  Generate C<input> tag of type C<checkbox>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="employed" type="checkbox">
    <input name="employed" type="checkbox" value="1">
    <input checked id="foo" name="employed" type="checkbox" value="1">
  
  =head2 color_field
  
    %= color_field 'background'
    %= color_field background => '#ffffff'
    %= color_field background => '#ffffff', id => 'foo'
  
  Generate C<input> tag of type C<color>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="background" type="color">
    <input name="background" type="color" value="#ffffff">
    <input id="foo" name="background" type="color" value="#ffffff">
  
  =head2 csrf_field
  
    %= csrf_field
  
  Generate C<input> tag of type C<hidden> with
  L<Mojolicious::Plugin::DefaultHelpers/"csrf_token">.
  
    <input name="csrf_token" type="hidden" value="fa6a08...">
  
  =head2 date_field
  
    %= date_field 'end'
    %= date_field end => '2012-12-21'
    %= date_field end => '2012-12-21', id => 'foo'
  
  Generate C<input> tag of type C<date>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="end" type="date">
    <input name="end" type="date" value="2012-12-21">
    <input id="foo" name="end" type="date" value="2012-12-21">
  
  =head2 datetime_field
  
    %= datetime_field 'end'
    %= datetime_field end => '2012-12-21T23:59:59'
    %= datetime_field end => '2012-12-21T23:59:59', id => 'foo'
  
  Generate C<input> tag of type C<datetime-local>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="end" type="datetime-local">
    <input name="end" type="datetime-local" value="2012-12-21T23:59:59">
    <input id="foo" name="end" type="datetime-local" value="2012-12-21T23:59:59">
  
  =head2 email_field
  
    %= email_field 'notify'
    %= email_field notify => 'nospam@example.com'
    %= email_field notify => 'nospam@example.com', id => 'foo'
  
  Generate C<input> tag of type C<email>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="notify" type="email">
    <input name="notify" type="email" value="nospam@example.com">
    <input id="foo" name="notify" type="email" value="nospam@example.com">
  
  =head2 file_field
  
    %= file_field 'avatar'
    %= file_field 'avatar', id => 'foo'
  
  Generate C<input> tag of type C<file>.
  
    <input name="avatar" type="file">
    <input id="foo" name="avatar" type="file">
  
  =head2 form_for
  
    %= form_for login => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for login => {format => 'txt'} => (method => 'POST') => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for '/login' => (enctype => 'multipart/form-data') => begin
      %= text_field 'first_name', disabled => 'disabled'
      %= submit_button
    % end
    %= form_for 'http://example.com/login' => (method => 'POST') => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for some_delete_route => begin
      %= submit_button 'Remove'
    % end
  
  Generate portable C<form> tag with L<Mojolicious::Controller/"url_for">. For
  routes that do not allow C<GET>, a C<method> attribute with the value C<POST>
  will be automatically added. And for methods other than C<GET> or C<POST>, an
  C<_method> query parameter will be added as well.
  
    <form action="/path/to/login">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/login.txt" method="POST">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/login" enctype="multipart/form-data">
      <input disabled="disabled" name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="http://example.com/login" method="POST">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input type="submit" value="Remove">
    </form>
  
  =head2 hidden_field
  
    %= hidden_field foo => 'bar'
    %= hidden_field foo => 'bar', id => 'bar'
  
  Generate C<input> tag of type C<hidden>.
  
    <input name="foo" type="hidden" value="bar">
    <input id="bar" name="foo" type="hidden" value="bar">
  
  =head2 image
  
    %= image '/images/foo.png'
    %= image '/images/foo.png', alt => 'Foo'
  
  Generate portable C<img> tag.
  
    <img src="/path/to/images/foo.png">
    <img alt="Foo" src="/path/to/images/foo.png">
  
  =head2 input_tag
  
    %= input_tag 'first_name'
    %= input_tag first_name => 'Default'
    %= input_tag 'employed', type => 'checkbox'
  
  Generate C<input> tag. Previous input values will automatically get picked up
  and shown as default.
  
    <input name="first_name">
    <input name="first_name" value="Default">
    <input name="employed" type="checkbox">
  
  =head2 javascript
  
    %= javascript '/script.js'
    %= javascript begin
      var a = 'b';
    % end
  
  Generate portable C<script> tag for JavaScript asset.
  
    <script src="/path/to/script.js"></script>
    <script><![CDATA[
      var a = 'b';
    ]]></script>
  
  =head2 label_for
  
    %= label_for first_name => 'First name'
    %= label_for first_name => 'First name', class => 'user'
    %= label_for first_name => begin
      First name
    % end
    %= label_for first_name => (class => 'user') => begin
      First name
    % end
  
  Generate C<label> tag.
  
    <label for="first_name">First name</label>
    <label class="user" for="first_name">First name</label>
    <label for="first_name">
      First name
    </label>
    <label class="user" for="first_name">
      First name
    </label>
  
  =head2 link_to
  
    %= link_to Home => 'index'
    %= link_to Home => 'index' => {format => 'txt'} => (class => 'menu')
    %= link_to index => {format => 'txt'} => (class => 'menu') => begin
      Home
    % end
    %= link_to Contact => 'mailto:sri@example.com'
    <%= link_to index => begin %>Home<% end %>
    <%= link_to '/file.txt' => begin %>File<% end %>
    <%= link_to 'http://mojolicious.org' => begin %>Mojolicious<% end %>
    <%= link_to url_for->query(foo => 'bar')->to_abs => begin %>Retry<% end %>
  
  Generate portable C<a> tag with L<Mojolicious::Controller/"url_for">, defaults
  to using the capitalized link target as content.
  
    <a href="/path/to/index">Home</a>
    <a class="menu" href="/path/to/index.txt">Home</a>
    <a class="menu" href="/path/to/index.txt">
      Home
    </a>
    <a href="mailto:sri@example.com">Contact</a>
    <a href="/path/to/index">Home</a>
    <a href="/path/to/file.txt">File</a>
    <a href="http://mojolicious.org">Mojolicious</a>
    <a href="http://127.0.0.1:3000/current/path?foo=bar">Retry</a>
  
  =head2 month_field
  
    %= month_field 'vacation'
    %= month_field vacation => '2012-12'
    %= month_field vacation => '2012-12', id => 'foo'
  
  Generate C<input> tag of type C<month>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="vacation" type="month">
    <input name="vacation" type="month" value="2012-12">
    <input id="foo" name="vacation" type="month" value="2012-12">
  
  =head2 number_field
  
    %= number_field 'age'
    %= number_field age => 25
    %= number_field age => 25, id => 'foo', min => 0, max => 200
  
  Generate C<input> tag of type C<number>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="age" type="number">
    <input name="age" type="number" value="25">
    <input id="foo" max="200" min="0" name="age" type="number" value="25">
  
  =head2 password_field
  
    %= password_field 'pass'
    %= password_field 'pass', id => 'foo'
  
  Generate C<input> tag of type C<password>.
  
    <input name="pass" type="password">
    <input id="foo" name="pass" type="password">
  
  =head2 radio_button
  
    %= radio_button 'test'
    %= radio_button country => 'germany'
    %= radio_button country => 'germany', checked => undef, id => 'foo'
  
  Generate C<input> tag of type C<radio>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="test" type="radio">
    <input name="country" type="radio" value="germany">
    <input checked id="foo" name="country" type="radio" value="germany">
  
  =head2 range_field
  
    %= range_field 'age'
    %= range_field age => 25
    %= range_field age => 25, id => 'foo', min => 0, max => 200
  
  Generate C<input> tag of type C<range>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="age" type="range">
    <input name="age" type="range" value="25">
    <input id="foo" max="200" min="200" name="age" type="range" value="25">
  
  =head2 search_field
  
    %= search_field 'q'
    %= search_field q => 'perl'
    %= search_field q => 'perl', id => 'foo'
  
  Generate C<input> tag of type C<search>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="q" type="search">
    <input name="q" type="search" value="perl">
    <input id="foo" name="q" type="search" value="perl">
  
  =head2 select_field
  
    %= select_field country => ['de', 'en']
    %= select_field country => [[Germany => 'de'], 'en'], id => 'eu'
    %= select_field country => [[Germany => 'de', selected => 'selected'], 'en']
    %= select_field country => [c(EU => [[Germany => 'de'], 'en'], id => 'eu')]
    %= select_field country => [c(EU => ['de', 'en']), c(Asia => ['cn', 'jp'])]
  
  Generate C<select> and C<option> tags from array references and C<optgroup>
  tags from L<Mojo::Collection> objects. Previous input values will automatically
  get picked up and shown as default.
  
    <select name="country">
      <option value="de">de</option>
      <option value="en">en</option>
    </select>
    <select id="eu" name="country">
      <option value="de">Germany</option>
      <option value="en">en</option>
    </select>
    <select name="country">
      <option selected="selected" value="de">Germany</option>
      <option value="en">en</option>
    </select>
    <select name="country">
      <optgroup id="eu" label="EU">
        <option value="de">Germany</option>
        <option value="en">en</option>
      </optgroup>
    </select>
    <select name="country">
      <optgroup label="EU">
        <option value="de">de</option>
        <option value="en">en</option>
      </optgroup>
      <optgroup label="Asia">
        <option value="cn">cn</option>
        <option value="jp">jp</option>
      </optgroup>
    </select>
  
  =head2 stylesheet
  
    %= stylesheet '/foo.css'
    %= stylesheet begin
      body {color: #000}
    % end
  
  Generate portable C<style> or C<link> tag for CSS asset.
  
    <link href="/path/to/foo.css" rel="stylesheet">
    <style><![CDATA[
      body {color: #000}
    ]]></style>
  
  =head2 submit_button
  
    %= submit_button
    %= submit_button 'Ok!', id => 'foo'
  
  Generate C<input> tag of type C<submit>.
  
    <input type="submit" value="Ok">
    <input id="foo" type="submit" value="Ok!">
  
  =head2 t
  
    %= t div => 'test & 123'
  
  Alias for L</"tag">.
  
    <div>test &amp; 123</div>
  
  =head2 tag
  
    %= tag 'br'
    %= tag 'div'
    %= tag 'div', id => 'foo', hidden => undef
    %= tag div => 'test & 123'
    %= tag div => (id => 'foo') => 'test & 123'
    %= tag div => (data => {my_id => 1, Name => 'test'}) => 'test & 123'
    %= tag div => begin
      test & 123
    % end
    <%= tag div => (id => 'foo') => begin %>test & 123<% end %>
  
  HTML tag generator, the C<data> attribute may contain a hash reference with
  key/value pairs to generate attributes from.
  
    <br>
    <div></div>
    <div id="foo" hidden></div>
    <div>test &amp; 123</div>
    <div id="foo">test &amp; 123</div>
    <div data-my-id="1" data-name="test">test &amp; 123</div>
    <div>
      test & 123
    </div>
    <div id="foo">test & 123</div>
  
  Very useful for reuse in more specific tag helpers.
  
    my $output = $c->tag('meta');
    my $output = $c->tag('meta', charset => 'UTF-8');
    my $output = $c->tag(div => '<p>This will be escaped</p>');
    my $output = $c->tag(div => sub { '<p>This will not be escaped</p>' });
  
  Results are automatically wrapped in L<Mojo::ByteStream> objects to prevent
  accidental double escaping in C<ep> templates.
  
  =head2 tag_with_error
  
    %= tag_with_error 'input', class => 'foo'
  
  Same as L</"tag">, but adds the class C<field-with-error>.
  
    <input class="foo field-with-error">
  
  =head2 tel_field
  
    %= tel_field 'work'
    %= tel_field work => '123456789'
    %= tel_field work => '123456789', id => 'foo'
  
  Generate C<input> tag of type C<tel>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="work" type="tel">
    <input name="work" type="tel" value="123456789">
    <input id="foo" name="work" type="tel" value="123456789">
  
  =head2 text_area
  
    %= text_area 'story'
    %= text_area 'story', cols => 40
    %= text_area story => 'Default', cols => 40
    %= text_area story => (cols => 40) => begin
      Default
    % end
  
  Generate C<textarea> tag. Previous input values will automatically get picked
  up and shown as default.
  
    <textarea name="story"></textarea>
    <textarea cols="40" name="story"></textarea>
    <textarea cols="40" name="story">Default</textarea>
    <textarea cols="40" name="story">
      Default
    </textarea>
  
  =head2 text_field
  
    %= text_field 'first_name'
    %= text_field first_name => 'Default'
    %= text_field first_name => 'Default', class => 'user'
  
  Generate C<input> tag of type C<text>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="first_name" type="text">
    <input name="first_name" type="text" value="Default">
    <input class="user" name="first_name" type="text" value="Default">
  
  =head2 time_field
  
    %= time_field 'start'
    %= time_field start => '23:59:59'
    %= time_field start => '23:59:59', id => 'foo'
  
  Generate C<input> tag of type C<time>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="start" type="time">
    <input name="start" type="time" value="23:59:59">
    <input id="foo" name="start" type="time" value="23:59:59">
  
  =head2 url_field
  
    %= url_field 'address'
    %= url_field address => 'http://mojolicious.org'
    %= url_field address => 'http://mojolicious.org', id => 'foo'
  
  Generate C<input> tag of type C<url>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="address" type="url">
    <input name="address" type="url" value="http://mojolicious.org">
    <input id="foo" name="address" type="url" value="http://mojolicious.org">
  
  =head2 week_field
  
    %= week_field 'vacation'
    %= week_field vacation => '2012-W17'
    %= week_field vacation => '2012-W17', id => 'foo'
  
  Generate C<input> tag of type C<week>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="vacation" type="week">
    <input name="vacation" type="week" value="2012-W17">
    <input id="foo" name="vacation" type="week" value="2012-W17">
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::TagHelpers> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register helpers in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_TAGHELPERS

$fatpacked{"Mojolicious/Plugins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGINS';
  package Mojolicious::Plugins;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::Loader 'load_class';
  use Mojo::Util 'camelize';
  
  has namespaces => sub { ['Mojolicious::Plugin'] };
  
  sub emit_chain {
    my ($self, $name, @args) = @_;
  
    my $wrapper;
    for my $cb (reverse @{$self->subscribers($name)}) {
      my $next = $wrapper;
      $wrapper = sub { $cb->($next, @args) };
    }
  
    !$wrapper ? return : return $wrapper->();
  }
  
  sub emit_hook {
    my $self = shift;
    for my $cb (@{$self->subscribers(shift)}) { $cb->(@_) }
    return $self;
  }
  
  sub emit_hook_reverse {
    my $self = shift;
    for my $cb (reverse @{$self->subscribers(shift)}) { $cb->(@_) }
    return $self;
  }
  
  sub load_plugin {
    my ($self, $name) = @_;
  
    # Try all namespaces and full module name
    my $suffix = $name =~ /^[a-z]/ ? camelize $name : $name;
    my @classes = map {"${_}::$suffix"} @{$self->namespaces};
    for my $class (@classes, $name) { return $class->new if _load($class) }
  
    # Not found
    die qq{Plugin "$name" missing, maybe you need to install it?\n};
  }
  
  sub register_plugin {
    shift->load_plugin(shift)->register(shift, ref $_[0] ? $_[0] : {@_});
  }
  
  sub _load {
    my $module = shift;
    return $module->isa('Mojolicious::Plugin') unless my $e = load_class $module;
    ref $e ? die $e : return undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugins - Plugin manager
  
  =head1 SYNOPSIS
  
    use Mojolicious::Plugins;
  
    my $plugins = Mojolicious::Plugins->new;
    push @{$plugins->namespaces}, 'MyApp::Plugin';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugins> is the plugin manager of L<Mojolicious>.
  
  =head1 PLUGINS
  
  The following plugins are included in the L<Mojolicious> distribution as
  examples.
  
  =over 2
  
  =item L<Mojolicious::Plugin::Charset>
  
  Change the application charset.
  
  =item L<Mojolicious::Plugin::Config>
  
  Perl-ish configuration files.
  
  =item L<Mojolicious::Plugin::DefaultHelpers>
  
  General purpose helper collection, loaded automatically.
  
  =item L<Mojolicious::Plugin::EPLRenderer>
  
  Renderer for plain embedded Perl templates, loaded automatically.
  
  =item L<Mojolicious::Plugin::EPRenderer>
  
  Renderer for more sophisticated embedded Perl templates, loaded automatically.
  
  =item L<Mojolicious::Plugin::HeaderCondition>
  
  Route condition for all kinds of headers, loaded automatically.
  
  =item L<Mojolicious::Plugin::JSONConfig>
  
  JSON configuration files.
  
  =item L<Mojolicious::Plugin::Mount>
  
  Mount whole L<Mojolicious> applications.
  
  =item L<Mojolicious::Plugin::PODRenderer>
  
  Renderer for turning POD into HTML and documentation browser for
  L<Mojolicious::Guides>.
  
  =item L<Mojolicious::Plugin::TagHelpers>
  
  Template specific helper collection, loaded automatically.
  
  =back
  
  =head1 EVENTS
  
  L<Mojolicious::Plugins> inherits all events from L<Mojo::EventEmitter>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Plugins> implements the following attributes.
  
  =head2 namespaces
  
    my $namespaces = $plugins->namespaces;
    $plugins       = $plugins->namespaces(['Mojolicious::Plugin']);
  
  Namespaces to load plugins from, defaults to L<Mojolicious::Plugin>.
  
    # Add another namespace to load plugins from
    push @{$plugins->namespaces}, 'MyApp::Plugin';
  
  =head1 METHODS
  
  L<Mojolicious::Plugins> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 emit_chain
  
    $plugins->emit_chain('foo');
    $plugins->emit_chain(foo => 123);
  
  Emit events as chained hooks.
  
  =head2 emit_hook
  
    $plugins = $plugins->emit_hook('foo');
    $plugins = $plugins->emit_hook(foo => 123);
  
  Emit events as hooks.
  
  =head2 emit_hook_reverse
  
    $plugins = $plugins->emit_hook_reverse('foo');
    $plugins = $plugins->emit_hook_reverse(foo => 123);
  
  Emit events as hooks in reverse order.
  
  =head2 load_plugin
  
    my $plugin = $plugins->load_plugin('some_thing');
    my $plugin = $plugins->load_plugin('SomeThing');
    my $plugin = $plugins->load_plugin('MyApp::Plugin::SomeThing');
  
  Load a plugin from the configured namespaces or by full module name.
  
  =head2 register_plugin
  
    $plugins->register_plugin('some_thing', Mojolicious->new);
    $plugins->register_plugin('some_thing', Mojolicious->new, foo => 23);
    $plugins->register_plugin('some_thing', Mojolicious->new, {foo => 23});
    $plugins->register_plugin('SomeThing', Mojolicious->new);
    $plugins->register_plugin('SomeThing', Mojolicious->new, foo => 23);
    $plugins->register_plugin('SomeThing', Mojolicious->new, {foo => 23});
    $plugins->register_plugin('MyApp::Plugin::SomeThing', Mojolicious->new);
    $plugins->register_plugin(
      'MyApp::Plugin::SomeThing', Mojolicious->new, foo => 23);
    $plugins->register_plugin(
      'MyApp::Plugin::SomeThing', Mojolicious->new, {foo => 23});
  
  Load a plugin from the configured namespaces or by full module name and run
  C<register>, optional arguments are passed through.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGINS

$fatpacked{"Mojolicious/Renderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_RENDERER';
  package Mojolicious::Renderer;
  use Mojo::Base -base;
  
  use File::Spec::Functions 'catfile';
  use Mojo::Cache;
  use Mojo::JSON 'encode_json';
  use Mojo::Home;
  use Mojo::Loader 'data_section';
  use Mojo::Util qw(decamelize encode md5_sum monkey_patch slurp);
  
  has cache   => sub { Mojo::Cache->new };
  has classes => sub { ['main'] };
  has default_format => 'html';
  has 'default_handler';
  has encoding => 'UTF-8';
  has [qw(handlers helpers)] => sub { {} };
  has paths => sub { [] };
  
  # Bundled templates
  my $TEMPLATES = Mojo::Home->new(Mojo::Home->new->mojo_lib_dir)
    ->rel_dir('Mojolicious/resources/templates');
  
  sub DESTROY { Mojo::Util::_teardown($_) for @{shift->{namespaces}} }
  
  sub accepts {
    my ($self, $c) = (shift, shift);
  
    # List representations
    my $req = $c->req;
    my @exts = @{$c->app->types->detect($req->headers->accept, $req->is_xhr)};
    if (!@exts && (my $format = $c->stash->{format} || $req->param('format'))) {
      push @exts, $format;
    }
    return \@exts unless @_;
  
    # Find best representation
    for my $ext (@exts) { $ext eq $_ and return $ext for @_ }
    return @exts ? undef : shift;
  }
  
  sub add_handler { $_[0]->handlers->{$_[1]} = $_[2] and return $_[0] }
  
  sub add_helper {
    my ($self, $name, $cb) = @_;
    $self->helpers->{$name} = $cb;
    delete $self->{proxy};
    return $self;
  }
  
  sub get_data_template {
    my ($self, $options) = @_;
    return undef unless my $template = $self->template_name($options);
    return data_section $self->{index}{$template}, $template;
  }
  
  sub get_helper {
    my ($self, $name) = @_;
  
    if (my $h = $self->{proxy}{$name} || $self->helpers->{$name}) { return $h }
  
    my $found;
    my $class = 'Mojolicious::Renderer::Helpers::' . md5_sum "$name:$self";
    my $re = length $name ? qr/^(\Q$name\E\.([^.]+))/ : qr/^(([^.]+))/;
    for my $key (keys %{$self->helpers}) {
      $key =~ $re ? ($found, my $method) = (1, $2) : next;
      my $sub = $self->get_helper($1);
      monkey_patch $class, $method => sub { ${shift()}->$sub(@_) };
    }
  
    $found ? push @{$self->{namespaces}}, $class : return undef;
    return $self->{proxy}{$name} = sub { bless \(my $dummy = shift), $class };
  }
  
  sub render {
    my ($self, $c, $args) = @_;
  
    # Localize "extends" and "layout" to allow argument overrides
    my $stash = $c->stash;
    local $stash->{layout}  = $stash->{layout}  if exists $stash->{layout};
    local $stash->{extends} = $stash->{extends} if exists $stash->{extends};
  
    # Rendering to string
    local @{$stash}{keys %$args} if my $string = delete $args->{'mojo.string'};
    delete @{$stash}{qw(layout extends)} if $string;
  
    # All other arguments just become part of the stash
    @$stash{keys %$args} = values %$args;
  
    my $options = {
      encoding => $self->encoding,
      handler  => $stash->{handler},
      template => delete $stash->{template},
      variant  => $stash->{variant}
    };
    my $inline = $options->{inline} = delete $stash->{inline};
    $options->{handler} //= $self->default_handler if defined $inline;
    $options->{format} = $stash->{format} || $self->default_format;
  
    # Data
    return delete $stash->{data}, $options->{format} if defined $stash->{data};
  
    # JSON
    return encode_json(delete $stash->{json}), 'json' if exists $stash->{json};
  
    # Text
    my $output = delete $stash->{text};
  
    # Template or templateless handler
    unless (defined $output) {
      $options->{template} //= $self->template_for($c);
      return () unless $self->_render_template($c, \$output, $options);
    }
  
    # Inheritance
    my $content = $stash->{'mojo.content'} ||= {};
    local $content->{content} = $output =~ /\S/ ? $output : undef
      if $stash->{extends} || $stash->{layout};
    while ((my $next = _next($stash)) && !defined $inline) {
      @$options{qw(handler template)} = ($stash->{handler}, $next);
      $options->{format} = $stash->{format} || $self->default_format;
      if ($self->_render_template($c, \my $tmp, $options)) { $output = $tmp }
      $content->{content} //= $output if $output =~ /\S/;
    }
  
    # Encoding
    $output = encode $options->{encoding}, $output
      if !$string && $options->{encoding} && $output;
  
    return $output, $options->{format};
  }
  
  sub template_for {
    my ($self, $c) = @_;
  
    # Normal default template
    my $stash = $c->stash;
    my ($controller, $action) = @$stash{qw(controller action)};
    return join '/', split('-', decamelize $controller), $action
      if $controller && $action;
  
    # Try the route name if we don't have controller and action
    return undef unless my $route = $c->match->endpoint;
    return $route->name;
  }
  
  sub template_handler {
    my ($self, $options) = @_;
    return undef unless my $file = $self->template_name($options);
    return $self->default_handler unless my $handlers = $self->{templates}{$file};
    return $handlers->[0];
  }
  
  sub template_name {
    my ($self, $options) = @_;
  
    return undef unless defined(my $template = $options->{template});
    return undef unless my $format = $options->{format};
    $template .= ".$format";
  
    $self->warmup unless $self->{templates};
  
    # Variants
    my $handler = $options->{handler};
    if (defined(my $variant = $options->{variant})) {
      $variant = "$template+$variant";
      my $handlers = $self->{templates}{$variant} // [];
      $template = $variant
        if @$handlers && !defined $handler || grep { $_ eq $handler } @$handlers;
    }
  
    return defined $handler ? "$template.$handler" : $template;
  }
  
  sub template_path {
    my ($self, $options) = @_;
    return undef unless my $name = $self->template_name($options);
    my @parts = split '/', $name;
    -r and return $_ for map { catfile $_, @parts } @{$self->paths}, $TEMPLATES;
    return undef;
  }
  
  sub warmup {
    my $self = shift;
  
    my ($index, $templates) = @$self{qw(index templates)} = ({}, {});
  
    # Handlers for templates
    s/\.(\w+)$// and push @{$templates->{$_}}, $1
      for map { @{Mojo::Home->new($_)->list_files} } @{$self->paths}, $TEMPLATES;
  
    # Handlers and classes for DATA templates
    for my $class (reverse @{$self->classes}) {
      $index->{$_} = $class for my @keys = sort keys %{data_section $class};
      s/\.(\w+)$// and unshift @{$templates->{$_}}, $1 for reverse @keys;
    }
  }
  
  sub _next {
    my $stash = shift;
    return delete $stash->{extends} if $stash->{extends};
    return undef unless my $layout = delete $stash->{layout};
    return join '/', 'layouts', $layout;
  }
  
  sub _render_template {
    my ($self, $c, $output, $options) = @_;
  
    my $handler = $options->{handler} ||= $self->template_handler($options);
    return undef unless $handler;
    $c->app->log->error(qq{No handler for "$handler" available}) and return undef
      unless my $renderer = $self->handlers->{$handler};
  
    $renderer->($self, $c, $output, $options);
    return 1 if defined $$output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Renderer - Generate dynamic content
  
  =head1 SYNOPSIS
  
    use Mojolicious::Renderer;
  
    my $renderer = Mojolicious::Renderer->new;
    push @{$renderer->classes}, 'MyApp::Controller::Foo';
    push @{$renderer->paths}, '/home/sri/templates';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Renderer> is the standard L<Mojolicious> renderer.
  
  See L<Mojolicious::Guides::Rendering> for more.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Renderer> implements the following attributes.
  
  =head2 cache
  
    my $cache = $renderer->cache;
    $renderer = $renderer->cache(Mojo::Cache->new);
  
  Renderer cache, defaults to a L<Mojo::Cache> object.
  
  =head2 classes
  
    my $classes = $renderer->classes;
    $renderer   = $renderer->classes(['main']);
  
  Classes to use for finding templates in C<DATA> sections with L<Mojo::Loader>,
  first one has the highest precedence, defaults to C<main>. Only files with
  exactly two extensions will be used, like C<index.html.ep>. Note that for
  templates to be detected, these classes need to have already been loaded and
  added before L</"warmup"> is called, which usually happens automatically during
  application startup.
  
    # Add another class with templates in DATA section
    push @{$renderer->classes}, 'Mojolicious::Plugin::Fun';
  
    # Add another class with templates in DATA section and higher precedence
    unshift @{$renderer->classes}, 'Mojolicious::Plugin::MoreFun';
  
  =head2 default_format
  
    my $default = $renderer->default_format;
    $renderer   = $renderer->default_format('html');
  
  The default format to render if C<format> is not set in the stash, defaults to
  C<html>.
  
  =head2 default_handler
  
    my $default = $renderer->default_handler;
    $renderer   = $renderer->default_handler('ep');
  
  The default template handler to use for rendering in cases where auto-detection
  doesn't work, like for C<inline> templates.
  
  =head2 encoding
  
    my $encoding = $renderer->encoding;
    $renderer    = $renderer->encoding('koi8-r');
  
  Will encode generated content if set, defaults to C<UTF-8>. Note that many
  renderers such as L<Mojolicious::Plugin::EPRenderer> also use this value to
  determine if template files should be decoded before processing.
  
  =head2 handlers
  
    my $handlers = $renderer->handlers;
    $renderer    = $renderer->handlers({epl => sub {...}});
  
  Registered handlers.
  
  =head2 helpers
  
    my $helpers = $renderer->helpers;
    $renderer   = $renderer->helpers({url_for => sub {...}});
  
  Registered helpers.
  
  =head2 paths
  
    my $paths = $renderer->paths;
    $renderer = $renderer->paths(['/home/sri/templates']);
  
  Directories to look for templates in, first one has the highest precedence.
  
    # Add another "templates" directory
    push @{$renderer->paths}, '/home/sri/templates';
  
    # Add another "templates" directory with higher precedence
    unshift @{$renderer->paths}, '/home/sri/themes/blue/templates';
  
  =head1 METHODS
  
  L<Mojolicious::Renderer> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 accepts
  
    my $all  = $renderer->accepts(Mojolicious::Controller->new);
    my $best = $renderer->accepts(Mojolicious::Controller->new, 'html', 'json');
  
  Select best possible representation for L<Mojolicious::Controller> object from
  C<Accept> request header, C<format> stash value or C<format> C<GET>/C<POST>
  parameter, defaults to returning the first extension if no preference could be
  detected. Since browsers often don't really know what they actually want,
  unspecific C<Accept> request headers with more than one MIME type will be
  ignored, unless the C<X-Requested-With> header is set to the value
  C<XMLHttpRequest>.
  
  =head2 add_handler
  
    $renderer = $renderer->add_handler(epl => sub {...});
  
  Register a handler.
  
    $renderer->add_handler(foo => sub {
      my ($renderer, $c, $output, $options) = @_;
      ...
      $$output = 'Hello World!';
    });
  
  =head2 add_helper
  
    $renderer = $renderer->add_helper(url_for => sub {...});
  
  Register a helper.
  
    $renderer->add_helper(foo => sub {
      my ($c, @args) = @_;
      ...
    });
  
  =head2 get_data_template
  
    my $template = $renderer->get_data_template({
      template       => 'foo/bar',
      format         => 'html',
      handler        => 'epl'
    });
  
  Return a C<DATA> section template from L</"classes"> for an options hash
  reference with C<template>, C<format>, C<variant> and C<handler> values, or
  C<undef> if no template could be found, usually used by handlers.
  
  =head2 get_helper
  
    my $helper = $renderer->get_helper('url_for');
  
  Get a helper by full name, generate a helper dynamically for a prefix, or return
  C<undef> if no helper or prefix could be found. Generated helpers return a
  proxy object containing the current controller object and on which nested
  helpers can be called.
  
  =head2 render
  
    my ($output, $format) = $renderer->render(Mojolicious::Controller->new, {
      template => 'foo/bar',
      foo      => 'bar'
    });
  
  Render output through one of the renderers. See
  L<Mojolicious::Controller/"render"> for a more user-friendly interface.
  
  =head2 template_for
  
    my $name = $renderer->template_for(Mojolicious::Controller->new);
  
  Return default template name for L<Mojolicious::Controller> object, or C<undef>
  if no name could be generated.
  
  =head2 template_handler
  
    my $handler = $renderer->template_handler({
      template => 'foo/bar',
      format   => 'html'
    });
  
  Return handler for an options hash reference with C<template>, C<format> and
  C<variant> values, or C<undef> if no handler could be found.
  
  =head2 template_name
  
    my $template = $renderer->template_name({
      template => 'foo/bar',
      format   => 'html',
      handler  => 'epl'
    });
  
  Return a template name for an options hash reference with C<template>,
  C<format>, C<variant> and C<handler> values, or C<undef> if no template could be
  found, usually used by handlers.
  
  =head2 template_path
  
    my $path = $renderer->template_path({
      template => 'foo/bar',
      format   => 'html',
      handler  => 'epl'
    });
  
  Return the full template path for an options hash reference with C<template>,
  C<format>, C<variant> and C<handler> values, or C<undef> if the file does not
  exist in L</"paths">, usually used by handlers.
  
  =head2 warmup
  
    $renderer->warmup;
  
  Prepare templates from L</"classes"> for future use.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_RENDERER

$fatpacked{"Mojolicious/Routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES';
  package Mojolicious::Routes;
  use Mojo::Base 'Mojolicious::Routes::Route';
  
  use List::Util 'first';
  use Mojo::Cache;
  use Mojo::Loader 'load_class';
  use Mojo::Util 'camelize';
  use Mojolicious::Routes::Match;
  use Scalar::Util 'weaken';
  
  has base_classes => sub { [qw(Mojolicious::Controller Mojo)] };
  has cache        => sub { Mojo::Cache->new };
  has [qw(conditions shortcuts)] => sub { {} };
  has hidden     => sub { [qw(attr has new tap)] };
  has namespaces => sub { [] };
  
  sub add_condition { $_[0]->conditions->{$_[1]} = $_[2] and return $_[0] }
  sub add_shortcut  { $_[0]->shortcuts->{$_[1]}  = $_[2] and return $_[0] }
  
  sub continue {
    my ($self, $c) = @_;
  
    my $match    = $c->match;
    my $stack    = $match->stack;
    my $position = $match->position;
    return _render($c) unless my $field = $stack->[$position];
  
    # Merge captures into stash
    my $stash = $c->stash;
    @{$stash->{'mojo.captures'} //= {}}{keys %$field} = values %$field;
    @$stash{keys %$field} = values %$field;
  
    my $continue;
    my $last = !$stack->[++$position];
    if (my $cb = $field->{cb}) { $continue = $self->_callback($c, $cb, $last) }
    else { $continue = $self->_controller($c, $field, $last) }
    $match->position($position);
    $self->continue($c) if $last || $continue;
  }
  
  sub dispatch {
    my ($self, $c) = @_;
    $self->match($c);
    @{$c->match->stack} ? $self->continue($c) : return undef;
    return 1;
  }
  
  sub hide { push @{shift->hidden}, @_ }
  
  sub is_hidden {
    my ($self, $method) = @_;
    my $h = $self->{hiding} ||= {map { $_ => 1 } @{$self->hidden}};
    return !!($h->{$method} || $method =~ /^_/ || $method =~ /^[A-Z_]+$/);
  }
  
  sub lookup { ($_[0]{reverse} //= $_[0]->_index)->{$_[1]} }
  
  sub match {
    my ($self, $c) = @_;
  
    # Path (partial path gets priority)
    my $req  = $c->req;
    my $path = $c->stash->{path};
    if (defined $path) { $path = "/$path" if $path !~ m!^/! }
    else               { $path = $req->url->path->to_route }
  
    # Method (HEAD will be treated as GET)
    my $method = uc($req->url->query->clone->param('_method') || $req->method);
    $method = 'GET' if $method eq 'HEAD';
  
    # Check cache
    my $ws = $c->tx->is_websocket ? 1 : 0;
    my $match = Mojolicious::Routes::Match->new(root => $self);
    $c->match($match);
    my $cache = $self->cache;
    if (my $result = $cache->get("$method:$path:$ws")) {
      return $match->endpoint($result->{endpoint})->stack($result->{stack});
    }
  
    # Check routes
    $match->find($c => {method => $method, path => $path, websocket => $ws});
    return unless my $route = $match->endpoint;
    $cache->set(
      "$method:$path:$ws" => {endpoint => $route, stack => $match->stack});
  }
  
  sub _action { shift->plugins->emit_chain(around_action => @_) }
  
  sub _callback {
    my ($self, $c, $cb, $last) = @_;
    $c->stash->{'mojo.routed'} = 1 if $last;
    my $app = $c->app;
    $app->log->debug('Routing to a callback');
    return _action($app, $c, $cb, $last);
  }
  
  sub _class {
    my ($self, $c, $field) = @_;
  
    # Application instance
    return $field->{app} if ref $field->{app};
  
    # Application class
    my @classes;
    my $class = $field->{controller} ? camelize $field->{controller} : '';
    if ($field->{app}) { push @classes, $field->{app} }
  
    # Specific namespace
    elsif (defined(my $ns = $field->{namespace})) {
      if ($class) { push @classes, $ns ? "${ns}::$class" : $class }
      elsif ($ns) { push @classes, $ns }
    }
  
    # All namespaces
    elsif ($class) { push @classes, "${_}::$class" for @{$self->namespaces} }
  
    # Try to load all classes
    my $log = $c->app->log;
    for my $class (@classes) {
  
      # Failed
      next unless defined(my $found = $self->_load($class));
      return !$log->debug(qq{Class "$class" is not a controller}) unless $found;
  
      # Success
      my $new = $class->new(%$c);
      weaken $new->{$_} for qw(app tx);
      return $new;
    }
  
    # Nothing found
    $log->debug(qq{Controller "$classes[-1]" does not exist}) if @classes;
    return @classes ? undef : 0;
  }
  
  sub _controller {
    my ($self, $old, $field, $last) = @_;
  
    # Load and instantiate controller/application
    my $new;
    unless ($new = $self->_class($old, $field)) { return !!defined $new }
  
    # Application
    my $class = ref $new;
    my $app   = $old->app;
    my $log   = $app->log;
    if ($new->isa('Mojo')) {
      $log->debug(qq{Routing to application "$class"});
  
      # Try to connect routes
      if (my $sub = $new->can('routes')) {
        my $r = $new->$sub;
        weaken $r->parent($old->match->endpoint)->{parent} unless $r->parent;
      }
      $new->handler($old);
      $old->stash->{'mojo.routed'} = 1;
    }
  
    # Action
    elsif (my $method = $field->{action}) {
      if (!$self->is_hidden($method)) {
        $log->debug(qq{Routing to controller "$class" and action "$method"});
  
        if (my $sub = $new->can($method)) {
          $old->stash->{'mojo.routed'} = 1 if $last;
          return 1 if _action($app, $new, $sub, $last);
        }
  
        else { $log->debug('Action not found in controller') }
      }
      else { $log->debug(qq{Action "$method" is not allowed}) }
    }
  
    return undef;
  }
  
  sub _load {
    my ($self, $app) = @_;
  
    # Load unless already loaded
    return 1 if $self->{loaded}{$app};
    if (my $e = load_class $app) { ref $e ? die $e : return undef }
  
    # Check base classes
    return 0 unless first { $app->isa($_) } @{$self->base_classes};
    return $self->{loaded}{$app} = 1;
  }
  
  sub _render {
    my $c     = shift;
    my $stash = $c->stash;
    return if $stash->{'mojo.rendered'};
    $c->render_maybe or $stash->{'mojo.routed'} or $c->helpers->reply->not_found;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes - Always find your destination with routes
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes;
  
    # Simple route
    my $r = Mojolicious::Routes->new;
    $r->route('/')->to(controller => 'blog', action => 'welcome');
  
    # More advanced routes
    my $blog = $r->under('/blog');
    $blog->get('/list')->to('blog#list');
    $blog->get('/:id' => [id => qr/\d+/])->to('blog#show', id => 23);
    $blog->patch(sub { shift->render(text => 'Go away!', status => 405) });
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes> is the core of the L<Mojolicious> web framework.
  
  See L<Mojolicious::Guides::Routing> for more.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes> inherits all attributes from
  L<Mojolicious::Routes::Route> and implements the following new ones.
  
  =head2 base_classes
  
    my $classes = $r->base_classes;
    $r          = $r->base_classes(['MyApp::Controller']);
  
  Base classes used to identify controllers, defaults to
  L<Mojolicious::Controller> and L<Mojo>.
  
  =head2 cache
  
    my $cache = $r->cache;
    $r        = $r->cache(Mojo::Cache->new);
  
  Routing cache, defaults to a L<Mojo::Cache> object.
  
  =head2 conditions
  
    my $conditions = $r->conditions;
    $r             = $r->conditions({foo => sub {...}});
  
  Contains all available conditions.
  
  =head2 hidden
  
    my $hidden = $r->hidden;
    $r         = $r->hidden(['attr', 'has', 'new']);
  
  Controller attributes and methods that are hidden from router, defaults to
  C<attr>, C<has>, C<new> and C<tap>.
  
  =head2 namespaces
  
    my $namespaces = $r->namespaces;
    $r             = $r->namespaces(['MyApp::Controller', 'MyApp']);
  
  Namespaces to load controllers from.
  
    # Add another namespace to load controllers from
    push @{$r->namespaces}, 'MyApp::MyController';
  
  =head2 shortcuts
  
    my $shortcuts = $r->shortcuts;
    $r            = $r->shortcuts({foo => sub {...}});
  
  Contains all available shortcuts.
  
  =head1 METHODS
  
  L<Mojolicious::Routes> inherits all methods from L<Mojolicious::Routes::Route>
  and implements the following new ones.
  
  =head2 add_condition
  
    $r = $r->add_condition(foo => sub {...});
  
  Register a condition.
  
    $r->add_condition(foo => sub {
      my ($route, $c, $captures, $arg) = @_;
      ...
      return 1;
    });
  
  =head2 add_shortcut
  
    $r = $r->add_shortcut(foo => sub {...});
  
  Register a shortcut.
  
    $r->add_shortcut(foo => sub {
      my ($route, @args) = @_;
      ...
    });
  
  =head2 continue
  
    $r->continue(Mojolicious::Controller->new);
  
  Continue dispatch chain and emit the hook L<Mojolicious/"around_action"> for
  every action.
  
  =head2 dispatch
  
    my $bool = $r->dispatch(Mojolicious::Controller->new);
  
  Match routes with L</"match"> and dispatch with L</"continue">.
  
  =head2 hide
  
    $r = $r->hide('foo', 'bar');
  
  Hide controller attributes and methods from router.
  
  =head2 is_hidden
  
    my $bool = $r->is_hidden('foo');
  
  Check if controller attribute or method is hidden from router.
  
  =head2 lookup
  
    my $route = $r->lookup('foo');
  
  Find route by name with L<Mojolicious::Routes::Route/"find"> and cache all
  results for future lookups.
  
  =head2 match
  
    $r->match(Mojolicious::Controller->new);
  
  Match routes with L<Mojolicious::Routes::Match>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES

$fatpacked{"Mojolicious/Routes/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_MATCH';
  package Mojolicious::Routes::Match;
  use Mojo::Base -base;
  
  use Mojo::Util;
  
  has [qw(endpoint root)];
  has position => 0;
  has stack => sub { [] };
  
  sub find { $_[0]->_match($_[0]->root, $_[1], $_[2]) }
  
  sub path_for {
    my ($self, $name, %values) = (shift, Mojo::Util::_options(@_));
  
    # Current route
    my $route;
    if (!$name || $name eq 'current') {
      return {} unless $route = $self->endpoint;
    }
  
    # Find endpoint
    else { return {path => $name} unless $route = $self->root->lookup($name) }
  
    # Merge values (clear format)
    my $captures = $self->stack->[-1] || {};
    %values = (%$captures, format => undef, %values);
    my $pattern = $route->pattern;
    $values{format}
      //= defined $captures->{format}
      ? $captures->{format}
      : $pattern->defaults->{format}
      if $pattern->constraints->{format};
  
    my $path = $route->render(\%values);
    return {path => $path, websocket => $route->has_websocket};
  }
  
  sub _match {
    my ($self, $r, $c, $options) = @_;
  
    # Pattern
    my $path    = $options->{path};
    my $partial = $r->partial;
    my $detect  = (my $endpoint = $r->is_endpoint) && !$partial;
    return undef
      unless my $captures = $r->pattern->match_partial(\$path, $detect);
    local $options->{path} = $path;
    local @{$self->{captures} ||= {}}{keys %$captures} = values %$captures;
    $captures = $self->{captures};
  
    # Method
    my $methods = $r->via;
    return undef if $methods && !grep { $_ eq $options->{method} } @$methods;
  
    # Conditions
    if (my $over = $r->over) {
      my $conditions = $self->{conditions} ||= $self->root->conditions;
      for (my $i = 0; $i < @$over; $i += 2) {
        return undef unless my $condition = $conditions->{$over->[$i]};
        return undef if !$condition->($r, $c, $captures, $over->[$i + 1]);
      }
    }
  
    # WebSocket
    return undef if $r->is_websocket && !$options->{websocket};
  
    # Partial
    my $empty = !length $path || $path eq '/';
    if ($partial) {
      $captures->{path} = $path;
      $self->endpoint($r);
      $empty = 1;
    }
  
    # Endpoint (or intermediate destination)
    if (($endpoint && $empty) || $r->inline) {
      push @{$self->stack}, {%$captures};
      if ($endpoint && $empty) {
        my $format = $captures->{format};
        if ($format) { $_->{format} = $format for @{$self->stack} }
        return !!$self->endpoint($r);
      }
      delete @$captures{qw(app cb)};
    }
  
    # Match children
    my @snapshot = $r->parent ? ([@{$self->stack}], $captures) : ([], {});
    for my $child (@{$r->children}) {
      return 1 if $self->_match($child, $c, $options);
      $self->stack([@{$snapshot[0]}])->{captures} = $snapshot[1];
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Match - Find routes
  
  =head1 SYNOPSIS
  
    use Mojolicious::Controller;
    use Mojolicious::Routes;
    use Mojolicious::Routes::Match;
  
    # Routes
    my $r = Mojolicious::Routes->new;
    $r->get('/:controller/:action');
    $r->put('/:controller/:action');
  
    # Match
    my $c = Mojolicious::Controller->new;
    my $match = Mojolicious::Routes::Match->new(root => $r);
    $match->find($c => {method => 'PUT', path => '/foo/bar'});
    say $match->stack->[0]{controller};
    say $match->stack->[0]{action};
  
    # Render
    say $match->path_for->{path};
    say $match->path_for(action => 'baz')->{path};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Match> finds routes in L<Mojolicious::Routes>
  structures.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Match> implements the following attributes.
  
  =head2 endpoint
  
    my $route = $match->endpoint;
    $match    = $match->endpoint(Mojolicious::Routes::Route->new);
  
  The route endpoint that matched, usually a L<Mojolicious::Routes::Route>
  object.
  
  =head2 position
  
    my $position = $match->position;
    $match       = $match->position(2);
  
  Current position on the L</"stack">, defaults to C<0>.
  
  =head2 root
  
    my $root = $match->root;
    $match   = $match->root(Mojolicious::Routes->new);
  
  The root of the route structure, usually a L<Mojolicious::Routes> object.
  
  =head2 stack
  
    my $stack = $match->stack;
    $match    = $match->stack([{action => 'foo'}, {action => 'bar'}]);
  
  Captured parameters with nesting history.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Match> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 find
  
    $match->find(Mojolicious::Controller->new, {method => 'GET', path => '/'});
  
  Match controller and options against L</"root"> to find an appropriate
  L</"endpoint">.
  
  =head2 path_for
  
    my $info = $match->path_for;
    my $info = $match->path_for(foo => 'bar');
    my $info = $match->path_for({foo => 'bar'});
    my $info = $match->path_for('named');
    my $info = $match->path_for('named', foo => 'bar');
    my $info = $match->path_for('named', {foo => 'bar'});
  
  Render matching route with parameters into path.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_MATCH

$fatpacked{"Mojolicious/Routes/Pattern.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_PATTERN';
  package Mojolicious::Routes::Pattern;
  use Mojo::Base -base;
  
  has [qw(constraints defaults)] => sub { {} };
  has placeholder_start => ':';
  has [qw(placeholders tree)] => sub { [] };
  has quote_end   => ')';
  has quote_start => '(';
  has [qw(regex unparsed)];
  has relaxed_start  => '#';
  has wildcard_start => '*';
  
  sub match {
    my ($self, $path, $detect) = @_;
    my $captures = $self->match_partial(\$path, $detect);
    return !$path || $path eq '/' ? $captures : undef;
  }
  
  sub match_partial {
    my ($self, $pathref, $detect) = @_;
  
    # Compile on demand
    $self->_compile($detect) unless $self->{regex};
  
    return undef unless my @captures = $$pathref =~ $self->regex;
    $$pathref = ${^POSTMATCH};
    @captures = () if $#+ == 0;
    my $captures = {%{$self->defaults}};
    for my $placeholder (@{$self->placeholders}, 'format') {
      last unless @captures;
      my $capture = shift @captures;
      $captures->{$placeholder} = $capture if defined $capture;
    }
  
    return $captures;
  }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my $self = shift;
  
    my $pattern = @_ % 2 ? (shift // '/') : '/';
    $pattern =~ s!^/*|/+!/!g;
    return $self->constraints({@_}) if $pattern eq '/';
  
    $pattern =~ s!/$!!;
    return $self->constraints({@_})->_tokenize($pattern);
  }
  
  sub render {
    my ($self, $values, $endpoint) = @_;
  
    # Placeholders can only be optional without a format
    my $optional = !(my $format = $values->{format});
  
    my $str = '';
    for my $token (reverse @{$self->tree}) {
      my ($op, $value) = @$token;
      my $fragment = '';
  
      # Text
      if ($op eq 'text') { ($fragment, $optional) = ($value, 0) }
  
      # Slash
      elsif ($op eq 'slash') { $fragment = '/' unless $optional }
  
      # Placeholder
      else {
        my $default = $self->defaults->{$value};
        $fragment = $values->{$value} // $default // '';
        if (!defined $default || ($default ne $fragment)) { $optional = 0 }
        elsif ($optional) { $fragment = '' }
      }
  
      $str = $fragment . $str;
    }
  
    # Format can be optional
    return $endpoint && $format ? "$str.$format" : $str;
  }
  
  sub _compile {
    my ($self, $detect) = @_;
  
    my $placeholders = $self->placeholders;
    my $constraints  = $self->constraints;
    my $defaults     = $self->defaults;
  
    my $block = my $regex = '';
    my $optional = 1;
    for my $token (reverse @{$self->tree}) {
      my ($op, $value, $type) = @$token;
      my $fragment = '';
  
      # Text
      if ($op eq 'text') { ($fragment, $optional) = (quotemeta $value, 0) }
  
      # Slash
      elsif ($op eq 'slash') {
        $regex = ($optional ? "(?:/$block)?" : "/$block") . $regex;
        ($block, $optional) = ('', 1);
        next;
      }
  
      # Placeholder
      else {
        unshift @$placeholders, $value;
        $fragment = $type ? $type eq 'relaxed' ? '([^/]+)' : '(.+)' : '([^/.]+)';
  
        # Custom regex
        if (my $c = $constraints->{$value}) { $fragment = _compile_req($c) }
  
        # Optional placeholder
        exists $defaults->{$value} ? ($fragment .= '?') : ($optional = 0);
      }
  
      $block = $fragment . $block;
    }
  
    # Not rooted with a slash
    $regex = $block . $regex if $block;
  
    # Format
    $regex .= _compile_format($constraints->{format}, $defaults->{format})
      if $detect;
  
    $self->regex(qr/^$regex/ps);
  }
  
  sub _compile_format {
    my ($format, $default) = @_;
  
    # Default regex
    return '/?(?:\.([^/]+))?$' unless defined $format;
  
    # No regex
    return '' unless $format;
  
    # Compile custom regex
    my $regex = '\.' . _compile_req($format);
    return $default ? "/?(?:$regex)?\$" : "/?$regex\$";
  }
  
  sub _compile_req {
    my $req = shift;
    return "($req)" if ref $req ne 'ARRAY';
    return '(' . join('|', map {quotemeta} reverse sort @$req) . ')';
  }
  
  sub _tokenize {
    my ($self, $pattern) = @_;
  
    my $quote_end   = $self->quote_end;
    my $quote_start = $self->quote_start;
    my $start       = $self->placeholder_start;
    my $relaxed     = $self->relaxed_start;
    my $wildcard    = $self->wildcard_start;
  
    my (@tree, $spec);
    for my $char (split '', $pattern) {
  
      # Quoted
      if ($char eq $quote_start) { push @tree, ['placeholder', ''] if ++$spec }
      elsif ($char eq $quote_end) { $spec = 0 }
  
      # Placeholder
      elsif ($char eq $start) { push @tree, ['placeholder', ''] unless $spec++ }
  
      # Relaxed or wildcard (upgrade when quoted)
      elsif ($char eq $relaxed || $char eq $wildcard) {
        push @tree, ['placeholder', ''] unless $spec++;
        $tree[-1][2] = $char eq $relaxed ? 'relaxed' : 'wildcard';
      }
  
      # Slash
      elsif ($char eq '/') {
        push @tree, ['slash'];
        $spec = 0;
      }
  
      # Placeholder
      elsif ($spec) { $tree[-1][1] .= $char }
  
      # Text (optimize slash+text and *+text+slash+text)
      elsif ($tree[-1][0] eq 'text') { $tree[-1][-1] .= $char }
      elsif (!$tree[-2] && $tree[-1][0] eq 'slash') {
        @tree = (['text', "/$char"]);
      }
      elsif ($tree[-2] && $tree[-2][0] eq 'text' && $tree[-1][0] eq 'slash') {
        pop @tree && ($tree[-1][-1] .= "/$char");
      }
      else { push @tree, ['text', $char] }
    }
  
    return $self->unparsed($pattern)->tree(\@tree);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Pattern - Route pattern
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes::Pattern;
  
    # Create pattern
    my $pattern = Mojolicious::Routes::Pattern->new('/test/:name');
  
    # Match routes
    my $captures = $pattern->match('/test/sebastian');
    say $captures->{name};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Pattern> is the core of L<Mojolicious::Routes>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Pattern> implements the following attributes.
  
  =head2 constraints
  
    my $constraints = $pattern->constraints;
    $pattern        = $pattern->constraints({foo => qr/\w+/});
  
  Regular expression constraints.
  
  =head2 defaults
  
    my $defaults = $pattern->defaults;
    $pattern     = $pattern->defaults({foo => 'bar'});
  
  Default parameters.
  
  =head2 placeholder_start
  
    my $start = $pattern->placeholder_start;
    $pattern  = $pattern->placeholder_start(':');
  
  Character indicating a placeholder, defaults to C<:>.
  
  =head2 placeholders
  
    my $placeholders = $pattern->placeholders;
    $pattern         = $pattern->placeholders(['foo', 'bar']);
  
  Placeholder names.
  
  =head2 quote_end
  
    my $end  = $pattern->quote_end;
    $pattern = $pattern->quote_end(']');
  
  Character indicating the end of a quoted placeholder, defaults to C<)>.
  
  =head2 quote_start
  
    my $start = $pattern->quote_start;
    $pattern  = $pattern->quote_start('[');
  
  Character indicating the start of a quoted placeholder, defaults to C<(>.
  
  =head2 regex
  
    my $regex = $pattern->regex;
    $pattern  = $pattern->regex($regex);
  
  Pattern in compiled regular expression form.
  
  =head2 relaxed_start
  
    my $start = $pattern->relaxed_start;
    $pattern  = $pattern->relaxed_start('*');
  
  Character indicating a relaxed placeholder, defaults to C<#>.
  
  =head2 tree
  
    my $tree = $pattern->tree;
    $pattern = $pattern->tree([['text', '/foo']]);
  
  Pattern in parsed form. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 unparsed
  
    my $unparsed = $pattern->unparsed;
    $pattern     = $pattern->unparsed('/(foo)/(bar)');
  
  Raw unparsed pattern.
  
  =head2 wildcard_start
  
    my $start = $pattern->wildcard_start;
    $pattern  = $pattern->wildcard_start('*');
  
  Character indicating the start of a wildcard placeholder, defaults to C<*>.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Pattern> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 match
  
    my $captures = $pattern->match('/foo/bar');
    my $captures = $pattern->match('/foo/bar', 1);
  
  Match pattern against entire path, format detection is disabled by default.
  
  =head2 match_partial
  
    my $captures = $pattern->match_partial(\$path);
    my $captures = $pattern->match_partial(\$path, 1);
  
  Match pattern against path and remove matching parts, format detection is
  disabled by default.
  
  =head2 new
  
    my $pattern = Mojolicious::Routes::Pattern->new;
    my $pattern = Mojolicious::Routes::Pattern->new('/:action');
    my $pattern
      = Mojolicious::Routes::Pattern->new('/:action', action => qr/\w+/);
    my $pattern = Mojolicious::Routes::Pattern->new(format => 0);
  
  Construct a new L<Mojolicious::Routes::Pattern> object and L</"parse"> pattern
  if necessary.
  
  =head2 parse
  
    $pattern = $pattern->parse('/:action');
    $pattern = $pattern->parse('/:action', action => qr/\w+/);
    $pattern = $pattern->parse(format => 0);
  
  Parse pattern.
  
  =head2 render
  
    my $path = $pattern->render({action => 'foo'});
    my $path = $pattern->render({action => 'foo'}, 1);
  
  Render pattern into a path with parameters, format rendering is disabled by
  default.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_PATTERN

$fatpacked{"Mojolicious/Routes/Route.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_ROUTE';
  package Mojolicious::Routes::Route;
  use Mojo::Base -base;
  
  use Carp ();
  use Mojo::Util;
  use Mojolicious::Routes::Pattern;
  use Scalar::Util ();
  
  has [qw(inline parent partial)];
  has 'children' => sub { [] };
  has pattern    => sub { Mojolicious::Routes::Pattern->new };
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call shortcut with current route
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $shortcut = $self->root->shortcuts->{$method};
    return $self->$shortcut(@_);
  }
  
  sub add_child {
    my ($self, $route) = @_;
    Scalar::Util::weaken $route->remove->parent($self)->{parent};
    push @{$self->children}, $route;
    return $self;
  }
  
  sub any { shift->_generate_route(ref $_[0] eq 'ARRAY' ? shift : [], @_) }
  
  sub delete { shift->_generate_route(DELETE => @_) }
  
  sub detour { shift->partial(1)->to(@_) }
  
  sub find { shift->_index->{shift()} }
  
  sub get { shift->_generate_route(GET => @_) }
  
  sub has_custom_name { !!shift->{custom} }
  
  sub has_websocket {
    my $self = shift;
    return $self->{has_websocket} if exists $self->{has_websocket};
    return $self->{has_websocket} = grep { $_->is_websocket } @{$self->_chain};
  }
  
  sub is_endpoint { $_[0]->inline ? undef : !@{$_[0]->children} }
  
  sub is_websocket { !!shift->{websocket} }
  
  sub name {
    my $self = shift;
    return $self->{name} unless @_;
    @$self{qw(name custom)} = (shift, 1);
    return $self;
  }
  
  sub options { shift->_generate_route(OPTIONS => @_) }
  
  sub over {
    my $self = shift;
  
    # Routes with conditions can't be cached
    return $self->{over} unless @_;
    my $conditions = ref $_[0] eq 'ARRAY' ? $_[0] : [@_];
    return $self unless @$conditions;
    $self->{over} = $conditions;
    $self->root->cache->max_keys(0);
  
    return $self;
  }
  
  sub parse {
    my $self = shift;
    $self->{name} = $self->pattern->parse(@_)->unparsed // '';
    $self->{name} =~ s/\W+//g;
    return $self;
  }
  
  sub patch { shift->_generate_route(PATCH => @_) }
  sub post  { shift->_generate_route(POST  => @_) }
  sub put   { shift->_generate_route(PUT   => @_) }
  
  sub remove {
    my $self = shift;
    return $self unless my $parent = $self->parent;
    @{$parent->children} = grep { $_ ne $self } @{$parent->children};
    return $self->parent(undef);
  }
  
  sub render {
    my ($self, $values) = @_;
    my $path = join '',
      map { $_->pattern->render($values, !@{$_->children} && !$_->partial) }
      @{$self->_chain};
    return $path || '/';
  }
  
  sub root { shift->_chain->[0] }
  
  sub route {
    my $self   = shift;
    my $route  = $self->add_child(__PACKAGE__->new->parse(@_))->children->[-1];
    my $format = $self->pattern->constraints->{format};
    $route->pattern->constraints->{format} //= 0 if defined $format && !$format;
    return $route;
  }
  
  sub suggested_method {
    my $self = shift;
  
    my %via;
    for my $route (@{$self->_chain}) {
      next unless my @via = @{$route->via || []};
      %via = map { $_ => 1 } keys %via ? grep { $via{$_} } @via : @via;
    }
  
    return 'POST' if $via{POST} && !$via{GET};
    return $via{GET} ? 'GET' : (sort keys %via)[0] || 'GET';
  }
  
  sub to {
    my $self = shift;
  
    my $pattern = $self->pattern;
    return $pattern->defaults unless @_;
    my ($shortcut, %defaults) = Mojo::Util::_options(@_);
  
    if ($shortcut) {
  
      # Application
      if (ref $shortcut || $shortcut =~ /^[\w:]+$/) {
        $defaults{app} = $shortcut;
      }
  
      # Controller and action
      elsif ($shortcut =~ /^([\w\-:]+)?\#(\w+)?$/) {
        $defaults{controller} = $1 if defined $1;
        $defaults{action}     = $2 if defined $2;
      }
    }
  
    @{$pattern->defaults}{keys %defaults} = values %defaults;
  
    return $self;
  }
  
  sub to_string {
    join '', map { $_->pattern->unparsed // '' } @{shift->_chain};
  }
  
  sub under { shift->_generate_route(under => @_) }
  
  sub via {
    my $self = shift;
    return $self->{via} unless @_;
    my $methods = [map uc($_), @{ref $_[0] ? $_[0] : [@_]}];
    $self->{via} = $methods if @$methods;
    return $self;
  }
  
  sub websocket {
    my $route = shift->get(@_);
    $route->{websocket} = 1;
    return $route;
  }
  
  sub _chain {
    my @chain = (my $parent = shift);
    unshift @chain, $parent while $parent = $parent->parent;
    return \@chain;
  }
  
  sub _generate_route {
    my ($self, $methods, @args) = @_;
  
    my (@conditions, @constraints, %defaults, $name, $pattern);
    while (defined(my $arg = shift @args)) {
  
      # First scalar is the pattern
      if (!ref $arg && !$pattern) { $pattern = $arg }
  
      # Scalar
      elsif (!ref $arg && @args) { push @conditions, $arg, shift @args }
  
      # Last scalar is the route name
      elsif (!ref $arg) { $name = $arg }
  
      # Callback
      elsif (ref $arg eq 'CODE') { $defaults{cb} = $arg }
  
      # Constraints
      elsif (ref $arg eq 'ARRAY') { push @constraints, @$arg }
  
      # Defaults
      elsif (ref $arg eq 'HASH') { %defaults = (%defaults, %$arg) }
    }
  
    my $route
      = $self->route($pattern, @constraints)->over(\@conditions)->to(\%defaults);
    $methods eq 'under' ? $route->inline(1) : $route->via($methods);
  
    return defined $name ? $route->name($name) : $route;
  }
  
  sub _index {
    my $self = shift;
  
    my (%auto, %custom);
    my @children = (@{$self->children});
    while (my $child = shift @children) {
      if   ($child->has_custom_name) { $custom{$child->name} ||= $child }
      else                           { $auto{$child->name}   ||= $child }
      push @children, @{$child->children};
    }
  
    return {%auto, %custom};
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Route - Route
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes::Route;
  
    my $r = Mojolicious::Routes::Route->new;
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Route> is the route container used by
  L<Mojolicious::Routes>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Route> implements the following attributes.
  
  =head2 children
  
    my $children = $r->children;
    $r           = $r->children([Mojolicious::Routes::Route->new]);
  
  The children of this route, used for nesting routes.
  
  =head2 inline
  
    my $bool = $r->inline;
    $r       = $r->inline($bool);
  
  Allow L</"under"> semantics for this route.
  
  =head2 parent
  
    my $parent = $r->parent;
    $r         = $r->parent(Mojolicious::Routes::Route->new);
  
  The parent of this route, usually a L<Mojolicious::Routes::Route> object.
  
  =head2 partial
  
    my $bool = $r->partial;
    $r       = $r->partial($bool);
  
  Route has no specific end, remaining characters will be captured in C<path>.
  
  =head2 pattern
  
    my $pattern = $r->pattern;
    $r          = $r->pattern(Mojolicious::Routes::Pattern->new);
  
  Pattern for this route, defaults to a L<Mojolicious::Routes::Pattern> object.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Route> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_child
  
    $r = $r->add_child(Mojolicious::Routes::Route->new);
  
  Add a child to this route, it will be automatically removed from its current
  parent if necessary.
  
    # Reattach route
    $r->add_child($r->find('foo'));
  
  =head2 any
  
    my $route = $r->any('/:foo');
    my $route = $r->any('/:foo' => sub {...});
    my $route = $r->any('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->any('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->any(['GET', 'POST'] => '/:foo' => sub {...});
    my $route = $r->any(['GET', 'POST'] => '/:foo' => [foo => qr/\w+/]);
  
  Generate L<Mojolicious::Routes::Route> object matching any of the listed HTTP
  request methods or all. See also L<Mojolicious::Guides::Tutorial> for many more
  argument variations.
  
    # Route with destination
    $r->any('/user')->to('user#whatever');
  
  =head2 delete
  
    my $route = $r->delete('/:foo');
    my $route = $r->delete('/:foo' => sub {...});
    my $route = $r->delete('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->delete('/:foo' => [foo => qr/\w+/] => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<DELETE> requests.
  See also L<Mojolicious::Guides::Tutorial> for many more argument variations.
  
    # Route with destination
    $r->delete('/user')->to('user#remove');
  
  =head2 detour
  
    $r = $r->detour(action => 'foo');
    $r = $r->detour('controller#action');
    $r = $r->detour(Mojolicious->new, foo => 'bar');
    $r = $r->detour('MyApp', {foo => 'bar'});
  
  Set default parameters for this route and allow partial matching to simplify
  application embedding, takes the same arguments as L</"to">.
  
  =head2 find
  
    my $route = $r->find('foo');
  
  Find child route by name, custom names have precedence over automatically
  generated ones.
  
    # Change default parameters of a named route
    $r->find('show_user')->to(foo => 'bar');
  
  =head2 get
  
    my $route = $r->get('/:foo');
    my $route = $r->get('/:foo' => sub {...});
    my $route = $r->get('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->get('/:foo' => [foo => qr/\w+/] => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<GET> requests.
  See also L<Mojolicious::Guides::Tutorial> for many more argument variations.
  
    # Route with destination
    $r->get('/user')->to('user#show');
  
  =head2 has_custom_name
  
    my $bool = $r->has_custom_name;
  
  Check if this route has a custom name.
  
  =head2 has_websocket
  
    my $bool = $r->has_websocket;
  
  Check if this route has a WebSocket ancestor and cache the result for future
  checks.
  
  =head2 is_endpoint
  
    my $bool = $r->is_endpoint;
  
  Check if this route qualifies as an endpoint.
  
  =head2 is_websocket
  
    my $bool = $r->is_websocket;
  
  Check if this route is a WebSocket.
  
  =head2 name
  
    my $name = $r->name;
    $r       = $r->name('foo');
  
  The name of this route, defaults to an automatically generated name based on
  the route pattern. Note that the name C<current> is reserved for referring to
  the current route.
  
    # Route with destination and custom name
    $r->get('/user')->to('user#show')->name('show_user');
  
  =head2 options
  
    my $route = $r->options('/:foo');
    my $route = $r->options('/:foo' => sub {...});
    my $route = $r->options('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->options('/:foo' => [foo => qr/\w+/] => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<OPTIONS>
  requests. See also L<Mojolicious::Guides::Tutorial> for many more argument
  variations.
  
    # Route with destination
    $r->options('/user')->to('user#overview');
  
  =head2 over
  
    my $over = $r->over;
    $r       = $r->over(foo => 1);
    $r       = $r->over(foo => 1, bar => {baz => 'yada'});
    $r       = $r->over([foo => 1, bar => {baz => 'yada'}]);
  
  Activate conditions for this route. Note that this automatically disables the
  routing cache, since conditions are too complex for caching.
  
    # Route with condition and destination
    $r->get('/foo')->over(host => qr/mojolicious\.org/)->to('foo#bar');
  
  =head2 parse
  
    $r = $r->parse('/:action');
    $r = $r->parse('/:action', action => qr/\w+/);
    $r = $r->parse(format => 0);
  
  Parse pattern.
  
  =head2 patch
  
    my $route = $r->patch('/:foo');
    my $route = $r->patch('/:foo' => sub {...});
    my $route = $r->patch('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->patch('/:foo' => [foo => qr/\w+/] => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<PATCH> requests.
  See also L<Mojolicious::Guides::Tutorial> for many more argument variations.
  
    # Route with destination
    $r->patch('/user')->to('user#update');
  
  =head2 post
  
    my $route = $r->post('/:foo');
    my $route = $r->post('/:foo' => sub {...});
    my $route = $r->post('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->post('/:foo' => [foo => qr/\w+/] => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<POST> requests.
  See also L<Mojolicious::Guides::Tutorial> for many more argument variations.
  
    # Route with destination
    $r->post('/user')->to('user#create');
  
  =head2 put
  
    my $route = $r->put('/:foo');
    my $route = $r->put('/:foo' => sub {...});
    my $route = $r->put('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->put('/:foo' => [foo => qr/\w+/] => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<PUT> requests.
  See also L<Mojolicious::Guides::Tutorial> for many more argument variations.
  
    # Route with destination
    $r->put('/user')->to('user#replace');
  
  =head2 remove
  
    $r = $r->remove;
  
  Remove route from parent.
  
    # Remove route completely
    $r->find('foo')->remove;
  
    # Reattach route to new parent
    $r->route('/foo')->add_child($r->find('bar')->remove);
  
  =head2 render
  
    my $path = $r->render({foo => 'bar'});
  
  Render route with parameters into a path.
  
  =head2 root
  
    my $root = $r->root;
  
  The L<Mojolicious::Routes> object this route is a descendant of.
  
  =head2 route
  
    my $route = $r->route;
    my $route = $r->route('/:action');
    my $route = $r->route('/:action', action => qr/\w+/);
    my $route = $r->route(format => 0);
  
  Low-level generator for routes matching all HTTP request methods, returns a
  L<Mojolicious::Routes::Route> object.
  
  =head2 suggested_method
  
    my $method = $r->suggested_method;
  
  Suggested HTTP method for reaching this route, C<GET> and C<POST> are
  preferred.
  
  =head2 to
  
    my $defaults = $r->to;
    $r           = $r->to(action => 'foo');
    $r           = $r->to({action => 'foo'});
    $r           = $r->to('controller#action');
    $r           = $r->to('controller#action', foo => 'bar');
    $r           = $r->to('controller#action', {foo => 'bar'});
    $r           = $r->to(Mojolicious->new);
    $r           = $r->to(Mojolicious->new, foo => 'bar');
    $r           = $r->to(Mojolicious->new, {foo => 'bar'});
    $r           = $r->to('MyApp');
    $r           = $r->to('MyApp', foo => 'bar');
    $r           = $r->to('MyApp', {foo => 'bar'});
  
  Set default parameters for this route.
  
  =head2 to_string
  
    my $str = $r->to_string;
  
  Stringify the whole route.
  
  =head2 under
  
    my $route = $r->under(sub {...});
    my $route = $r->under('/:foo' => sub {...});
    my $route = $r->under('/:foo' => {foo => 'bar'});
    my $route = $r->under('/:foo' => [foo => qr/\w+/]);
    my $route = $r->under([format => 0]);
  
  Generate L<Mojolicious::Routes::Route> object for a nested route with its own
  intermediate destination. See also L<Mojolicious::Guides::Tutorial> for many
  more argument variations.
  
    # Intermediate destination and prefix shared between two routes
    my $auth = $r->under('/user')->to('user#auth');
    $auth->get('/show')->to('#show');
    $auth->post('/create')->to('#create');
  
  =head2 via
  
    my $methods = $r->via;
    $r          = $r->via('GET');
    $r          = $r->via('GET', 'POST');
    $r          = $r->via(['GET', 'POST']);
  
  Restrict HTTP methods this route is allowed to handle, defaults to no
  restrictions.
  
    # Route with two methods and destination
    $r->route('/foo')->via('GET', 'POST')->to('foo#bar');
  
  =head2 websocket
  
    my $route = $r->websocket('/:foo');
    my $route = $r->websocket('/:foo' => sub {...});
    my $route = $r->websocket('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->websocket('/:foo' => [foo => qr/\w+/] => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only WebSocket
  handshakes. See also L<Mojolicious::Guides::Tutorial> for many more argument
  variations.
  
    # Route with destination
    $r->websocket('/echo')->to('example#echo');
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  shortcuts provided by L</"root"> on L<Mojolicious::Routes::Route> objects.
  
    # Add a "firefox" shortcut
    $r->root->add_shortcut(firefox => sub {
      my ($r, $path) = @_;
      $r->get($path, agent => qr/Firefox/);
    });
  
    # Use "firefox" shortcut to generate routes
    $r->firefox('/welcome')->to('firefox#welcome');
    $r->firefox('/bye')->to('firefox#bye');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_ROUTE

$fatpacked{"Mojolicious/Sessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_SESSIONS';
  package Mojolicious::Sessions;
  use Mojo::Base -base;
  
  use Mojo::JSON;
  use Mojo::Util qw(b64_decode b64_encode);
  
  has [qw(cookie_domain secure)];
  has cookie_name        => 'mojolicious';
  has cookie_path        => '/';
  has default_expiration => 3600;
  has deserialize        => sub { \&Mojo::JSON::j };
  has serialize          => sub { \&Mojo::JSON::encode_json };
  
  sub load {
    my ($self, $c) = @_;
  
    return unless my $value = $c->signed_cookie($self->cookie_name);
    $value =~ y/-/=/;
    return unless my $session = $self->deserialize->(b64_decode $value);
  
    # "expiration" value is inherited
    my $expiration = $session->{expiration} // $self->default_expiration;
    return if !(my $expires = delete $session->{expires}) && $expiration;
    return if defined $expires && $expires <= time;
  
    my $stash = $c->stash;
    return unless $stash->{'mojo.active_session'} = keys %$session;
    $stash->{'mojo.session'} = $session;
    $session->{flash} = delete $session->{new_flash} if $session->{new_flash};
  }
  
  sub store {
    my ($self, $c) = @_;
  
    # Make sure session was active
    my $stash = $c->stash;
    return unless my $session = $stash->{'mojo.session'};
    return unless keys %$session || $stash->{'mojo.active_session'};
  
    # Don't reset flash for static files
    my $old = delete $session->{flash};
    $session->{new_flash} = $old if $stash->{'mojo.static'};
    delete $session->{new_flash} unless keys %{$session->{new_flash}};
  
    # Generate "expires" value from "expiration" if necessary
    my $expiration = $session->{expiration} // $self->default_expiration;
    my $default = delete $session->{expires};
    $session->{expires} = $default || time + $expiration
      if $expiration || $default;
  
    my $value = b64_encode $self->serialize->($session), '';
    $value =~ y/=/-/;
    my $options = {
      domain   => $self->cookie_domain,
      expires  => $session->{expires},
      httponly => 1,
      path     => $self->cookie_path,
      secure   => $self->secure
    };
    $c->signed_cookie($self->cookie_name, $value, $options);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Sessions - Session manager based on signed cookies
  
  =head1 SYNOPSIS
  
    use Mojolicious::Sessions;
  
    my $sessions = Mojolicious::Sessions->new;
    $sessions->cookie_name('myapp');
    $sessions->default_expiration(86400);
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Sessions> manages sessions based on signed cookies for
  L<Mojolicious>. All data gets serialized with L<Mojo::JSON> and stored Base64
  encoded on the client-side, but is protected from unwanted changes with a
  HMAC-SHA1 signature.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Sessions> implements the following attributes.
  
  =head2 cookie_domain
  
    my $domain = $sessions->cookie_domain;
    $sessions  = $sessions->cookie_domain('.example.com');
  
  Domain for session cookies, not defined by default.
  
  =head2 cookie_name
  
    my $name  = $sessions->cookie_name;
    $sessions = $sessions->cookie_name('session');
  
  Name for session cookies, defaults to C<mojolicious>.
  
  =head2 cookie_path
  
    my $path  = $sessions->cookie_path;
    $sessions = $sessions->cookie_path('/foo');
  
  Path for session cookies, defaults to C</>.
  
  =head2 default_expiration
  
    my $time  = $sessions->default_expiration;
    $sessions = $sessions->default_expiration(3600);
  
  Default time for sessions to expire in seconds from now, defaults to C<3600>.
  The expiration timeout gets refreshed for every request. Setting the value to
  C<0> will allow sessions to persist until the browser window is closed, this
  can have security implications though. For more control you can also use the
  C<expiration> and C<expires> session values.
  
    # Expiration date in seconds from now (persists between requests)
    $c->session(expiration => 604800);
  
    # Expiration date as absolute epoch time (only valid for one request)
    $c->session(expires => time + 604800);
  
    # Delete whole session by setting an expiration date in the past
    $c->session(expires => 1);
  
  =head2 deserialize
  
    my $cb    = $sessions->deserialize;
    $sessions = $sessions->deserialize(sub {...});
  
  A callback used to deserialize sessions, defaults to L<Mojo::JSON/"j">.
  
    $sessions->deserialize(sub {
      my $bytes = shift;
      return {};
    });
  
  =head2 secure
  
    my $bool  = $sessions->secure;
    $sessions = $sessions->secure($bool);
  
  Set the secure flag on all session cookies, so that browsers send them only
  over HTTPS connections.
  
  =head2 serialize
  
    my $cb    = $sessions->serialize;
    $sessions = $sessions->serialize(sub {...});
  
  A callback used to serialize sessions, defaults to L<Mojo::JSON/"encode_json">.
  
    $sessions->serialize(sub {
      my $hash = shift;
      return '';
    });
  
  =head1 METHODS
  
  L<Mojolicious::Sessions> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 load
  
    $sessions->load(Mojolicious::Controller->new);
  
  Load session data from signed cookie.
  
  =head2 store
  
    $sessions->store(Mojolicious::Controller->new);
  
  Store session data in signed cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_SESSIONS

$fatpacked{"Mojolicious/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_STATIC';
  package Mojolicious::Static;
  use Mojo::Base -base;
  
  use File::Spec::Functions 'catfile';
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Date;
  use Mojo::Home;
  use Mojo::Loader 'data_section';
  use Mojo::Util 'md5_sum';
  
  has classes => sub { ['main'] };
  has paths   => sub { [] };
  
  # Bundled files
  my $PUBLIC = Mojo::Home->new(Mojo::Home->new->mojo_lib_dir)
    ->rel_dir('Mojolicious/resources/public');
  
  sub dispatch {
    my ($self, $c) = @_;
  
    # Method (GET or HEAD)
    my $req    = $c->req;
    my $method = $req->method;
    return undef unless $method eq 'GET' || $method eq 'HEAD';
  
    # Canonical path
    my $stash = $c->stash;
    my $path  = $req->url->path;
    $path = $stash->{path} ? $path->new($stash->{path}) : $path->clone;
    return undef unless my @parts = @{$path->canonicalize->parts};
  
    # Serve static file and prevent path traversal
    return undef if $parts[0] eq '..' || !$self->serve($c, join('/', @parts));
    $stash->{'mojo.static'} = 1;
    return !!$c->rendered;
  }
  
  sub file {
    my ($self, $rel) = @_;
  
    # Search all paths
    for my $path (@{$self->paths}) {
      next unless my $asset = $self->_get_file(catfile $path, split('/', $rel));
      return $asset;
    }
  
    # Search DATA
    if (my $asset = $self->_get_data_file($rel)) { return $asset }
  
    # Search bundled files
    return $self->_get_file(catfile($PUBLIC, split('/', $rel)));
  }
  
  sub is_fresh {
    my ($self, $c, $options) = @_;
  
    my $res_headers = $c->res->headers;
    my ($last, $etag) = @$options{qw(last_modified etag)};
    $res_headers->last_modified(Mojo::Date->new($last)->to_string) if $last;
    $res_headers->etag($etag = qq{"$etag"}) if $etag;
  
    # Unconditional
    my $req_headers = $c->req->headers;
    my $match       = $req_headers->if_none_match;
    return undef unless (my $since = $req_headers->if_modified_since) || $match;
  
    # If-None-Match
    return undef if $match && ($etag // $res_headers->etag // '') ne $match;
  
    # If-Modified-Since
    return !!$match unless ($last //= $res_headers->last_modified) && $since;
    return _epoch($last) <= (_epoch($since) // 0);
  }
  
  sub serve {
    my ($self, $c, $rel) = @_;
  
    return undef unless my $asset = $self->file($rel);
    my $headers = $c->res->headers;
    return !!$self->serve_asset($c, $asset) if $headers->content_type;
  
    # Content-Type
    my $types = $c->app->types;
    my $type = $rel =~ /\.(\w+)$/ ? $types->type($1) : undef;
    $headers->content_type($type || $types->type('txt'));
    return !!$self->serve_asset($c, $asset);
  }
  
  sub serve_asset {
    my ($self, $c, $asset) = @_;
  
    # Last-Modified and ETag
    my $res = $c->res;
    $res->code(200)->headers->accept_ranges('bytes');
    my $mtime = $asset->mtime;
    my $options = {etag => md5_sum($mtime), last_modified => $mtime};
    return $res->code(304) if $self->is_fresh($c, $options);
  
    # Range
    return $res->content->asset($asset)
      unless my $range = $c->req->headers->range;
  
    # Not satisfiable
    return $res->code(416) unless my $size = $asset->size;
    return $res->code(416) unless $range =~ /^bytes=(\d+)?-(\d+)?/;
    my ($start, $end) = ($1 // 0, defined $2 && $2 < $size ? $2 : $size - 1);
    return $res->code(416) if $start > $end;
  
    # Satisfiable
    $res->code(206)->headers->content_length($end - $start + 1)
      ->content_range("bytes $start-$end/$size");
    return $res->content->asset($asset->start_range($start)->end_range($end));
  }
  
  sub warmup {
    my $self = shift;
    my $index = $self->{index} = {};
    for my $class (reverse @{$self->classes}) {
      $index->{$_} = $class for keys %{data_section $class};
    }
  }
  
  sub _epoch { Mojo::Date->new(shift)->epoch }
  
  sub _get_data_file {
    my ($self, $rel) = @_;
  
    # Protect files without extensions and templates with two extensions
    return undef if $rel !~ /\.\w+$/ || $rel =~ /\.\w+\.\w+$/;
  
    $self->warmup unless $self->{index};
  
    # Find file
    return undef
      unless defined(my $data = data_section($self->{index}{$rel}, $rel));
    return Mojo::Asset::Memory->new->add_chunk($data);
  }
  
  sub _get_file {
    my ($self, $path) = @_;
    no warnings 'newline';
    return -f $path && -r _ ? Mojo::Asset::File->new(path => $path) : undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Static - Serve static files
  
  =head1 SYNOPSIS
  
    use Mojolicious::Static;
  
    my $static = Mojolicious::Static->new;
    push @{$static->classes}, 'MyApp::Controller::Foo';
    push @{$static->paths}, '/home/sri/public';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Static> is a static file server with C<Range>,
  C<If-Modified-Since> and C<If-None-Match> support, based on
  L<RFC 7232|http://tools.ietf.org/html/rfc7232> and
  L<RFC 7233|http://tools.ietf.org/html/rfc7233>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Static> implements the following attributes.
  
  =head2 classes
  
    my $classes = $static->classes;
    $static     = $static->classes(['main']);
  
  Classes to use for finding files in C<DATA> sections with L<Mojo::Loader>,
  first one has the highest precedence, defaults to C<main>. Only files with
  exactly one extension will be used, like C<index.html>. Note that for files to
  be detected, these classes need to have already been loaded and added before
  L</"warmup"> is called, which usually happens automatically during application
  startup.
  
    # Add another class with static files in DATA section
    push @{$static->classes}, 'Mojolicious::Plugin::Fun';
  
    # Add another class with static files in DATA section and higher precedence
    unshift @{$static->classes}, 'Mojolicious::Plugin::MoreFun';
  
  =head2 paths
  
    my $paths = $static->paths;
    $static   = $static->paths(['/home/sri/public']);
  
  Directories to serve static files from, first one has the highest precedence.
  
    # Add another "public" directory
    push @{$static->paths}, '/home/sri/public';
  
    # Add another "public" directory with higher precedence
    unshift @{$static->paths}, '/home/sri/themes/blue/public';
  
  =head1 METHODS
  
  L<Mojolicious::Static> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 dispatch
  
    my $bool = $static->dispatch(Mojolicious::Controller->new);
  
  Serve static file for L<Mojolicious::Controller> object.
  
  =head2 file
  
    my $asset = $static->file('images/logo.png');
    my $asset = $static->file('../lib/MyApp.pm');
  
  Build L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object for a file,
  relative to L</"paths"> or from L</"classes">, or return C<undef> if it doesn't
  exist. Note that this method uses a relative path, but does not protect from
  traversing to parent directories.
  
    my $content = $static->file('foo/bar.html')->slurp;
  
  =head2 is_fresh
  
    my $bool = $static->is_fresh(Mojolicious::Controller->new, {etag => 'abc'});
  
  Check freshness of request by comparing the C<If-None-Match> and
  C<If-Modified-Since> request headers to the C<ETag> and C<Last-Modified>
  response headers.
  
  These options are currently available:
  
  =over 2
  
  =item etag
  
    etag => 'abc'
  
  Add C<ETag> header before comparing.
  
  =item last_modified
  
    last_modified => $epoch
  
  Add C<Last-Modified> header before comparing.
  
  =back
  
  =head2 serve
  
    my $bool = $static->serve(Mojolicious::Controller->new, 'images/logo.png');
    my $bool = $static->serve(Mojolicious::Controller->new, '../lib/MyApp.pm');
  
  Serve a specific file, relative to L</"paths"> or from L</"classes">. Note that
  this method uses a relative path, but does not protect from traversing to parent
  directories.
  
  =head2 serve_asset
  
    $static->serve_asset(Mojolicious::Controller->new, Mojo::Asset::File->new);
  
  Serve a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object with C<Range>,
  C<If-Modified-Since> and C<If-None-Match> support.
  
  =head2 warmup
  
    $static->warmup;
  
  Prepare static files from L</"classes"> for future use.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_STATIC

$fatpacked{"Mojolicious/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_TYPES';
  package Mojolicious::Types;
  use Mojo::Base -base;
  
  has mapping => sub {
    {
      appcache => ['text/cache-manifest'],
      atom     => ['application/atom+xml'],
      bin      => ['application/octet-stream'],
      css      => ['text/css'],
      gif      => ['image/gif'],
      gz       => ['application/x-gzip'],
      htm      => ['text/html'],
      html     => ['text/html;charset=UTF-8'],
      ico      => ['image/x-icon'],
      jpeg     => ['image/jpeg'],
      jpg      => ['image/jpeg'],
      js       => ['application/javascript'],
      json     => ['application/json;charset=UTF-8'],
      mp3      => ['audio/mpeg'],
      mp4      => ['video/mp4'],
      ogg      => ['audio/ogg'],
      ogv      => ['video/ogg'],
      pdf      => ['application/pdf'],
      png      => ['image/png'],
      rss      => ['application/rss+xml'],
      svg      => ['image/svg+xml'],
      txt      => ['text/plain;charset=UTF-8'],
      webm     => ['video/webm'],
      woff     => ['application/font-woff'],
      xml      => ['application/xml', 'text/xml'],
      zip      => ['application/zip']
    };
  };
  
  sub detect {
    my ($self, $accept, $prioritize) = @_;
  
    # Extract and prioritize MIME types
    my %types;
    /^\s*([^,; ]+)(?:\s*\;\s*q\s*=\s*(\d+(?:\.\d+)?))?\s*$/i
      and $types{lc $1} = $2 // 1
      for split ',', $accept // '';
    my @detected = sort { $types{$b} <=> $types{$a} } sort keys %types;
    return [] if !$prioritize && @detected > 1;
  
    # Detect extensions from MIME types
    my %reverse;
    my $mapping = $self->mapping;
    for my $ext (sort keys %$mapping) {
      my @types = @{$mapping->{$ext}};
      push @{$reverse{$_}}, $ext for map { s/\;.*$//; lc $_ } @types;
    }
    return [map { @{$reverse{$_} // []} } @detected];
  }
  
  sub type {
    my ($self, $ext, $type) = @_;
    return $self->mapping->{lc $ext}[0] unless $type;
    $self->mapping->{lc $ext} = ref $type ? $type : [$type];
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Types - MIME types
  
  =head1 SYNOPSIS
  
    use Mojolicious::Types;
  
    my $types = Mojolicious::Types->new;
    $types->type(foo => 'text/foo');
    say $types->type('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Types> manages MIME types for L<Mojolicious>.
  
    appcache -> text/cache-manifest
    atom     -> application/atom+xml
    bin      -> application/octet-stream
    css      -> text/css
    gif      -> image/gif
    gz       -> application/x-gzip
    htm      -> text/html
    html     -> text/html;charset=UTF-8
    ico      -> image/x-icon
    jpeg     -> image/jpeg
    jpg      -> image/jpeg
    js       -> application/javascript
    json     -> application/json;charset=UTF-8
    mp3      -> audio/mpeg
    mp4      -> video/mp4
    ogg      -> audio/ogg
    ogv      -> video/ogg
    pdf      -> application/pdf
    png      -> image/png
    rss      -> application/rss+xml
    svg      -> image/svg+xml
    txt      -> text/plain;charset=UTF-8
    webm     -> video/webm
    woff     -> application/font-woff
    xml      -> application/xml,text/xml
    zip      -> application/zip
  
  The most common ones are already defined.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Types> implements the following attributes.
  
  =head2 mapping
  
    my $mapping = $types->mapping;
    $types      = $types->mapping({png => ['image/png']});
  
  MIME type mapping.
  
  =head1 METHODS
  
  L<Mojolicious::Types> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 detect
  
    my $exts = $types->detect('application/json;q=9');
    my $exts = $types->detect('text/html, application/json;q=9', 1);
  
  Detect file extensions from C<Accept> header value, prioritization of
  unspecific values that contain more than one MIME type is disabled by default.
  
    # List detected extensions prioritized
    say for @{$types->detect('application/json, text/xml;q=0.1', 1)};
  
  =head2 type
  
    my $type = $types->type('png');
    $types   = $types->type(png => 'image/png');
    $types   = $types->type(json => ['application/json', 'text/x-json']);
  
  Get or set MIME types for file extension, alternatives are only used for
  detection.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_TYPES

$fatpacked{"Mojolicious/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR';
  package Mojolicious::Validator;
  use Mojo::Base -base;
  
  use Mojo::Util 'trim';
  use Mojolicious::Validator::Validation;
  
  has checks => sub {
    {
      equal_to => \&_equal_to,
      in       => \&_in,
      like     => sub { $_[2] !~ $_[3] },
      size     => \&_size,
      upload   => sub { !ref $_[2] || !$_[2]->isa('Mojo::Upload') }
    };
  };
  has filters => sub { {trim => \&_trim} };
  
  sub add_check  { $_[0]->checks->{$_[1]}  = $_[2] and return $_[0] }
  sub add_filter { $_[0]->filters->{$_[1]} = $_[2] and return $_[0] }
  
  sub validation {
    Mojolicious::Validator::Validation->new(validator => shift);
  }
  
  sub _equal_to {
    my ($validation, $name, $value, $to) = @_;
    return 1 unless defined(my $other = $validation->input->{$to});
    return $value ne $other;
  }
  
  sub _in {
    my ($validation, $name, $value) = (shift, shift, shift);
    $value eq $_ && return undef for @_;
    return 1;
  }
  
  sub _size {
    my ($validation, $name, $value, $min, $max) = @_;
    my $len = ref $value ? $value->size : length $value;
    return $len < $min || $len > $max;
  }
  
  sub _trim { trim $_[2] // '' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Validator - Validate values
  
  =head1 SYNOPSIS
  
    use Mojolicious::Validator;
  
    my $validator  = Mojolicious::Validator->new;
    my $validation = $validator->validation;
    $validation->input({foo => 'bar'});
    $validation->required('foo')->like(qr/ar$/);
    say $validation->param('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Validator> validates values for L<Mojolicious>.
  
  =head1 CHECKS
  
  These validation checks are available by default.
  
  =head2 equal_to
  
    $validation = $validation->equal_to('foo');
  
  String value needs to be equal to the value of another field.
  
  =head2 in
  
    $validation = $validation->in('foo', 'bar', 'baz');
  
  String value needs to match one of the values in the list.
  
  =head2 like
  
    $validation = $validation->like(qr/^[A-Z]/);
  
  String value needs to match the regular expression.
  
  =head2 size
  
    $validation = $validation->size(2, 5);
  
  String value length or size of L<Mojo::Upload> object in bytes needs to be
  between these two values.
  
  =head2 upload
  
    $validation = $validation->upload;
  
  Value needs to be a L<Mojo::Upload> object, representing a file upload.
  
  =head1 FILTERS
  
  These filters are available by default.
  
  =head2 trim
  
    $validation = $validation->optional('foo', 'trim');
  
  Trim whitespace characters from both ends of string value with
  L<Mojo::Util/"trim">.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Validator> implements the following attributes.
  
  =head2 checks
  
    my $checks = $validator->checks;
    $validator = $validator->checks({size => sub {...}});
  
  Registered validation checks, by default only L</"equal_to">, L</"in">,
  L</"like">, L</"size"> and L</"upload"> are already defined.
  
  =head1 METHODS
  
  L<Mojolicious::Validator> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_check
  
    $validator = $validator->add_check(size => sub {...});
  
  Register a validation check.
  
    $validator->add_check(foo => sub {
      my ($validation, $name, $value, @args) = @_;
      ...
      return undef;
    });
  
  =head2 add_filter
  
    $validator = $validator->add_filter(trim => sub {...});
  
  Register a new filter.
  
    $validator->add_filter(foo => sub {
      my ($validation, $name, $value) = @_;
      ...
      return $value;
    });
  
  =head2 validation
  
    my $validation = $validator->validation;
  
  Build L<Mojolicious::Validator::Validation> object to perform validations.
  
    my $validation = $validator->validation;
    $validation->input({foo => 'bar'});
    $validation->required('foo')->size(1, 5);
    say $validation->param('foo');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_VALIDATOR

$fatpacked{"Mojolicious/Validator/Validation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR_VALIDATION';
  package Mojolicious::Validator::Validation;
  use Mojo::Base -base;
  
  use Carp         ();
  use Scalar::Util ();
  
  has [qw(csrf_token topic validator)];
  has [qw(input output)] => sub { {} };
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    return $self->check($method => @_) if $self->validator->checks->{$method};
    Carp::croak qq{Can't locate object method "$method" via package "$package"};
  }
  
  sub check {
    my ($self, $check) = (shift, shift);
  
    return $self unless $self->is_valid;
  
    my $cb     = $self->validator->checks->{$check};
    my $name   = $self->topic;
    my $values = $self->output->{$name};
    for my $value (ref $values eq 'ARRAY' ? @$values : $values) {
      next unless my $result = $self->$cb($name, $value, @_);
      return $self->error($name => [$check, $result, @_]);
    }
  
    return $self;
  }
  
  sub csrf_protect {
    my $self  = shift;
    my $token = $self->input->{csrf_token};
    $self->error(csrf_token => ['csrf_protect'])
      unless $token && $token eq ($self->csrf_token // '');
    return $self;
  }
  
  sub error {
    my ($self, $name) = (shift, shift);
    return $self->{error}{$name} unless @_;
    $self->{error}{$name} = shift;
    delete $self->output->{$name};
    return $self;
  }
  
  sub every_param {
    return [] unless defined(my $value = shift->output->{shift()});
    return [ref $value eq 'ARRAY' ? @$value : $value];
  }
  
  sub failed { [sort keys %{shift->{error}}] }
  
  sub has_data { !!keys %{shift->input} }
  
  sub has_error { $_[1] ? exists $_[0]{error}{$_[1]} : !!keys %{$_[0]{error}} }
  
  sub is_valid { exists $_[0]->output->{$_[1] // $_[0]->topic} }
  
  sub optional {
    my ($self, $name, @filters) = @_;
  
    return $self->topic($name) unless defined(my $input = $self->input->{$name});
  
    my @input = ref $input eq 'ARRAY' ? @$input : ($input);
    for my $cb (map { $self->validator->filters->{$_} } @filters) {
      @input = map { $self->$cb($name, $_) } @input;
    }
    $self->output->{$name} = ref $input eq 'ARRAY' ? \@input : $input[0]
      if @input && !grep { !length } @input;
  
    return $self->topic($name);
  }
  
  sub param { shift->every_param(shift)->[-1] }
  
  sub passed { [sort keys %{shift->output}] }
  
  sub required {
    my ($self, $name) = (shift, shift);
    return $self if $self->optional($name, @_)->is_valid;
    return $self->error($name => ['required']);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Validator::Validation - Perform validations
  
  =head1 SYNOPSIS
  
    use Mojolicious::Validator;
    use Mojolicious::Validator::Validation;
  
    my $validator = Mojolicious::Validator->new;
    my $validation
      = Mojolicious::Validator::Validation->new(validator => $validator);
    $validation->input({foo => 'bar'});
    $validation->required('foo')->in('bar', 'baz');
    say $validation->param('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Validator::Validation> performs L<Mojolicious::Validator>
  validation checks.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Validator::Validation> implements the following attributes.
  
  =head2 csrf_token
  
    my $token   = $validation->csrf_token;
    $validation = $validation->csrf_token('fa6a08...');
  
  CSRF token.
  
  =head2 input
  
    my $input   = $validation->input;
    $validation = $validation->input({foo => 'bar', baz => [123, 'yada']});
  
  Data to be validated.
  
  =head2 output
  
    my $output  = $validation->output;
    $validation = $validation->output({foo => 'bar', baz => [123, 'yada']});
  
  Validated data.
  
  =head2 topic
  
    my $topic   = $validation->topic;
    $validation = $validation->topic('foo');
  
  Name of field currently being validated.
  
  =head2 validator
  
    my $validator = $validation->validator;
    $validation   = $validation->validator(Mojolicious::Validator->new);
  
  L<Mojolicious::Validator> object this validation belongs to.
  
  =head1 METHODS
  
  L<Mojolicious::Validator::Validation> inherits all methods from L<Mojo::Base>
  and implements the following new ones.
  
  =head2 check
  
    $validation = $validation->check('size', 2, 7);
  
  Perform validation check on all values of the current L</"topic">, no more
  checks will be performed on them after the first one failed. All checks from
  L<Mojolicious::Validator/"CHECKS"> are supported.
  
  =head2 csrf_protect
  
    $validation = $validation->csrf_protect;
  
  Validate C<csrf_token> and protect from cross-site request forgery.
  
  =head2 error
  
    my $err     = $validation->error('foo');
    $validation = $validation->error(foo => ['custom_check']);
    $validation = $validation->error(foo => [$check, $result, @args]);
  
  Get or set details for failed validation check, at any given time there can
  only be one per field.
  
    # Details about failed validation
    my ($check, $result, @args) = @{$validation->error('foo')};
  
  =head2 every_param
  
    my $values = $validation->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    my $first = $validation->every_param('foo')->[0];
  
  =head2 failed
  
    my $names = $validation->failed;
  
  Return an array reference with all names for values that failed validation.
  
    # Names of all values that failed
    say for @{$validation->failed};
  
  =head2 has_data
  
    my $bool = $validation->has_data;
  
  Check if L</"input"> is available for validation.
  
  =head2 has_error
  
    my $bool = $validation->has_error;
    my $bool = $validation->has_error('foo');
  
  Check if validation resulted in errors, defaults to checking all fields.
  
  =head2 is_valid
  
    my $bool = $validation->is_valid;
    my $bool = $validation->is_valid('foo');
  
  Check if validation was successful and field has a value, defaults to checking
  the current L</"topic">.
  
  =head2 optional
  
    $validation = $validation->optional('foo');
    $validation = $validation->optional('foo', 'filter1', 'filter2');
  
  Change validation L</"topic"> and apply filters. All filters from
  L<Mojolicious::Validator/"FILTERS"> are supported.
  
    # Trim value and check size
    $validation->optional('user', 'trim')->size(1, 15);
  
  =head2 param
  
    my $value = $validation->param('foo');
  
  Access validated values. If there are multiple values sharing the same name, and
  you want to access more than just the last one, you can use L</"every_param">.
  
  =head2 passed
  
    my $names = $validation->passed;
  
  Return an array reference with all names for values that passed validation.
  
    # Names of all values that passed
    say for @{$validation->passed};
  
  =head2 required
  
    $validation = $validation->required('foo');
    $validation = $validation->required('foo', 'filter1', 'filter2');
  
  Change validation L</"topic">, apply filters, and make sure a value is present
  and not an empty string. All filters from L<Mojolicious::Validator/"FILTERS">
  are supported.All filters from L<Mojolicious::Validator/"FILTERS">
  are supported.
  
    # Trim value and check size
    $validation->required('user', 'trim')->size(1, 15);
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above, you can also call
  validation checks provided by L</"validator"> on
  L<Mojolicious::Validator::Validation> objects, similar to L</"check">.
  
    # Call validation checks
    $validation->required('foo')->size(2, 5)->like(qr/^[A-Z]/);
    $validation->optional('bar')->equal_to('foo');
    $validation->optional('baz')->in('test', '123');
  
    # Longer version
    $validation->required('foo')->check('size', 2, 5)->check('like', qr/^[A-Z]/);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
MOJOLICIOUS_VALIDATOR_VALIDATION

$fatpacked{"RSS/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'RSS_CHECK';
  package RSS::Check;
  
  use Mojo::UserAgent;
  
  my $ua = Mojo::UserAgent->new();
  
  sub read {
    my ($class, $url) = @_;
  
    my %rss = parse($url, $ua->get($url));
  
    bless \%rss, $class;
  }
  
  sub parse {
    my ($url, $tx) = @_;
  
    my $dom = $tx->res->dom;
  
    if ($dom->children->first->tag eq 'feed') { return parse_atom($dom); }
  
    if ($dom->children->first->tag eq 'rss') { return parse_rss($dom); }
  
    if ($dom->children->first->tag eq 'rdf:RDF') { return parse_rdf($dom); }
  
    die "Not an Atom or RSS feed in $url\n";
  }
  
  sub parse_atom {
    my $dom = shift;
  
    my $title = $dom->at('feed > title')->all_text;
  
    my @articles = @{ $dom->find('feed > entry')->map(sub {
      +{
         title => $_->at('title')->all_text,
         content => $_->at('content')->all_text,
         id => $_->at('id')->all_text,
      }}) };
  
    return title => $title, articles => \@articles;
  }
  
  sub parse_rss {
    my $dom = shift;
  
    my $title = $dom->at('rss > channel > title')->all_text;
  
    my @articles = @{ $dom->find('rss > channel > item')->map(sub {
      my $t = $_->at('title'); $t = $t->all_text if defined $t;
      my $c = $_->at('description'); $c = $c->all_text if defined $c;
      my $i = $_->at('guid'); $i = $i->all_text if defined $i;
      +{
         title => $t // '',
         content => $c // '',
         id => $i // $_,
      }}) };
  
    return title => $title, articles => \@articles;
  }
  
  sub parse_rdf {
    my $dom = shift;
  
    my $title = $dom->at('rdf\:RDF > channel > title')->all_text;
  
    my @articles = @{ $dom->find('rdf\:RDF > item')->map(sub {
      my $t = $_->at('title'); $t = $t->all_text if defined $t;
      my $c = $_->at('description'); $c = $c->all_text if defined $c;
      my $i = $_->attr('rdf:about');
      +{
         title => $t // '',
         content => $c // '',
         id => $i // $_,
      }}) };
  
    return title => $title, articles => \@articles;
  }
  
  sub until {
    my $rss = shift;
    my $id = shift;
  
    my @res;
  
    foreach my $article (@{ $rss->{articles} }) {
      last if length $id and $id eq $article->{id};
      push @res, $article;
    }
  
    return @res;
  }
  
  sub last_id {
    my $rss = shift;
  
    my @articles = @{ $rss->{articles} };
  
    return '' unless @articles;
  
    return $articles[0]->{id};
  }
  
  
  
  1;
RSS_CHECK

$fatpacked{"Test/Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MOJO';
  package Test::Mojo;
  use Mojo::Base -base;
  
  # "Amy: He knows when you are sleeping.
  #  Professor: He knows when you're on the can.
  #  Leela: He'll hunt you down and blast your ass from here to Pakistan.
  #  Zoidberg: Oh.
  #  Hermes: You'd better not breathe, you'd better not move.
  #  Bender: You're better off dead, I'm telling you, dude.
  #  Fry: Santa Claus is gunning you down!"
  use Mojo::IOLoop;
  use Mojo::JSON 'j';
  use Mojo::JSON::Pointer;
  use Mojo::Server;
  use Mojo::UserAgent;
  use Mojo::Util qw(decode encode);
  use Test::More ();
  
  has [qw(message success tx)];
  has ua => sub { Mojo::UserAgent->new->ioloop(Mojo::IOLoop->singleton) };
  
  # Silent or loud tests
  $ENV{MOJO_LOG_LEVEL} ||= $ENV{HARNESS_IS_VERBOSE} ? 'debug' : 'fatal';
  
  sub app {
    my ($self, $app) = @_;
    return $self->ua->server->app unless $app;
    $self->ua->server->app($app);
    return $self;
  }
  
  sub content_is {
    my ($self, $value, $desc) = @_;
    $desc ||= 'exact match for content';
    return $self->_test('is', $self->tx->res->text, $value, $desc);
  }
  
  sub content_isnt {
    my ($self, $value, $desc) = @_;
    $desc ||= 'no match for content';
    return $self->_test('isnt', $self->tx->res->text, $value, $desc);
  }
  
  sub content_like {
    my ($self, $regex, $desc) = @_;
    $desc ||= 'content is similar';
    return $self->_test('like', $self->tx->res->text, $regex, $desc);
  }
  
  sub content_type_is {
    my ($self, $type, $desc) = @_;
    $desc ||= "Content-Type: $type";
    return $self->_test('is', $self->tx->res->headers->content_type, $type,
      $desc);
  }
  
  sub content_type_isnt {
    my ($self, $type, $desc) = @_;
    $desc ||= "not Content-Type: $type";
    return $self->_test('isnt', $self->tx->res->headers->content_type, $type,
      $desc);
  }
  
  sub content_type_like {
    my ($self, $regex, $desc) = @_;
    $desc ||= 'Content-Type is similar';
    return $self->_test('like', $self->tx->res->headers->content_type, $regex,
      $desc);
  }
  
  sub content_type_unlike {
    my ($self, $regex, $desc) = @_;
    $desc ||= 'Content-Type is not similar';
    return $self->_test('unlike', $self->tx->res->headers->content_type, $regex,
      $desc);
  }
  
  sub content_unlike {
    my ($self, $regex, $desc) = @_;
    $desc ||= 'content is not similar';
    return $self->_test('unlike', $self->tx->res->text, $regex, $desc);
  }
  
  sub delete_ok { shift->_build_ok(DELETE => @_) }
  
  sub element_count_is {
    my ($self, $selector, $count, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{element count for selector "$selector"};
    my $size = $self->tx->res->dom->find($selector)->size;
    return $self->_test('is', $size, $count, $desc);
  }
  
  sub element_exists {
    my ($self, $selector, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{element for selector "$selector" exists};
    return $self->_test('ok', $self->tx->res->dom->at($selector), $desc);
  }
  
  sub element_exists_not {
    my ($self, $selector, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{no element for selector "$selector"};
    return $self->_test('ok', !$self->tx->res->dom->at($selector), $desc);
  }
  
  sub finish_ok {
    my $self = shift;
    $self->tx->finish(@_) if $self->tx->is_websocket;
    Mojo::IOLoop->one_tick while !$self->{finished};
    return $self->_test('ok', 1, 'closed WebSocket');
  }
  
  sub finished_ok {
    my ($self, $code) = @_;
    Mojo::IOLoop->one_tick while !$self->{finished};
    Test::More::diag "WebSocket closed with status $self->{finished}[0]"
      unless my $ok = grep { $self->{finished}[0] == $_ } $code, 1006;
    return $self->_test('ok', $ok, "WebSocket closed with status $code");
  }
  
  sub get_ok  { shift->_build_ok(GET  => @_) }
  sub head_ok { shift->_build_ok(HEAD => @_) }
  
  sub header_is {
    my ($self, $name, $value, $desc) = @_;
    $desc ||= "$name: " . ($value // '');
    return $self->_test('is', $self->tx->res->headers->header($name), $value,
      $desc);
  }
  
  sub header_isnt {
    my ($self, $name, $value, $desc) = @_;
    $desc ||= "not $name: " . ($value // '');
    return $self->_test('isnt', $self->tx->res->headers->header($name), $value,
      $desc);
  }
  
  sub header_like {
    my ($self, $name, $regex, $desc) = @_;
    $desc ||= "$name is similar";
    return $self->_test('like', $self->tx->res->headers->header($name), $regex,
      $desc);
  }
  
  sub header_unlike {
    my ($self, $name, $regex, $desc) = @_;
    $desc ||= "$name is not similar";
    return $self->_test('unlike', $self->tx->res->headers->header($name),
      $regex, $desc);
  }
  
  sub json_has {
    my ($self, $p, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{has value for JSON Pointer "$p"};
    return $self->_test('ok',
      !!Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
  }
  
  sub json_hasnt {
    my ($self, $p, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{has no value for JSON Pointer "$p"};
    return $self->_test('ok',
      !Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
  }
  
  sub json_is {
    my $self = shift;
    my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
    my $desc = encode 'UTF-8', shift || qq{exact match for JSON Pointer "$p"};
    return $self->_test('is_deeply', $self->tx->res->json($p), $data, $desc);
  }
  
  sub json_like {
    my ($self, $p, $regex, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{similar match for JSON Pointer "$p"};
    return $self->_test('like', $self->tx->res->json($p), $regex, $desc);
  }
  
  sub json_message_has {
    my ($self, $p, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{has value for JSON Pointer "$p"};
    return $self->_test('ok', $self->_json(contains => $p), $desc);
  }
  
  sub json_message_hasnt {
    my ($self, $p, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{has no value for JSON Pointer "$p"};
    return $self->_test('ok', !$self->_json(contains => $p), $desc);
  }
  
  sub json_message_is {
    my $self = shift;
    my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
    my $desc = encode 'UTF-8', shift || qq{exact match for JSON Pointer "$p"};
    return $self->_test('is_deeply', $self->_json(get => $p), $data, $desc);
  }
  
  sub json_message_like {
    my ($self, $p, $regex, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{similar match for JSON Pointer "$p"};
    return $self->_test('like', $self->_json(get => $p), $regex, $desc);
  }
  
  sub json_message_unlike {
    my ($self, $p, $regex, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{no similar match for JSON Pointer "$p"};
    return $self->_test('unlike', $self->_json(get => $p), $regex, $desc);
  }
  
  sub json_unlike {
    my ($self, $p, $regex, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{no similar match for JSON Pointer "$p"};
    return $self->_test('unlike', $self->tx->res->json($p), $regex, $desc);
  }
  
  sub message_is {
    my ($self, $value, $desc) = @_;
    return $self->_message('is', $value, $desc || 'exact match for message');
  }
  
  sub message_isnt {
    my ($self, $value, $desc) = @_;
    return $self->_message('isnt', $value, $desc || 'no match for message');
  }
  
  sub message_like {
    my ($self, $regex, $desc) = @_;
    return $self->_message('like', $regex, $desc || 'message is similar');
  }
  
  sub message_ok {
    my ($self, $desc) = @_;
    return $self->_test('ok', !!$self->_wait, $desc || 'message received');
  }
  
  sub message_unlike {
    my ($self, $regex, $desc) = @_;
    return $self->_message('unlike', $regex, $desc || 'message is not similar');
  }
  
  sub new {
    my $self = shift->SUPER::new;
    return $self unless my $app = shift;
    return $self->app(ref $app ? $app : Mojo::Server->new->build_app($app));
  }
  
  sub options_ok { shift->_build_ok(OPTIONS => @_) }
  
  sub or {
    my ($self, $cb) = @_;
    $self->$cb unless $self->success;
    return $self;
  }
  
  sub patch_ok { shift->_build_ok(PATCH => @_) }
  sub post_ok  { shift->_build_ok(POST  => @_) }
  sub put_ok   { shift->_build_ok(PUT   => @_) }
  
  sub request_ok { shift->_request_ok($_[0], $_[0]->req->url->to_string) }
  
  sub reset_session {
    my $self = shift;
    $self->ua->cookie_jar->empty;
    return $self->tx(undef);
  }
  
  sub send_ok {
    my ($self, $msg, $desc) = @_;
  
    $desc ||= 'send message';
    return $self->_test('ok', 0, $desc) unless $self->tx->is_websocket;
  
    $self->tx->send($msg => sub { Mojo::IOLoop->stop });
    Mojo::IOLoop->start;
    return $self->_test('ok', 1, $desc);
  }
  
  sub status_is {
    my ($self, $status, $desc) = @_;
    $desc ||= "$status " . $self->tx->res->default_message($status);
    return $self->_test('is', $self->tx->res->code, $status, $desc);
  }
  
  sub status_isnt {
    my ($self, $status, $desc) = @_;
    $desc ||= "not $status " . $self->tx->res->default_message($status);
    return $self->_test('isnt', $self->tx->res->code, $status, $desc);
  }
  
  sub text_is {
    my ($self, $selector, $value, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{exact match for selector "$selector"};
    return $self->_test('is', $self->_text($selector), $value, $desc);
  }
  
  sub text_isnt {
    my ($self, $selector, $value, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{no match for selector "$selector"};
    return $self->_test('isnt', $self->_text($selector), $value, $desc);
  }
  
  sub text_like {
    my ($self, $selector, $regex, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{similar match for selector "$selector"};
    return $self->_test('like', $self->_text($selector), $regex, $desc);
  }
  
  sub text_unlike {
    my ($self, $selector, $regex, $desc) = @_;
    $desc ||= encode 'UTF-8', qq{no similar match for selector "$selector"};
    return $self->_test('unlike', $self->_text($selector), $regex, $desc);
  }
  
  sub websocket_ok {
    my $self = shift;
    return $self->_request_ok($self->ua->build_websocket_tx(@_), $_[0]);
  }
  
  sub _build_ok {
    my ($self, $method, $url) = (shift, shift, shift);
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    return $self->_request_ok($self->ua->build_tx($method, $url, @_), $url);
  }
  
  sub _json {
    my ($self, $method, $p) = @_;
    return Mojo::JSON::Pointer->new(j(@{$self->message // []}[1]))->$method($p);
  }
  
  sub _message {
    my ($self, $name, $value, $desc) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    my ($type, $msg) = @{$self->message // []};
  
    # Type check
    if (ref $value eq 'HASH') {
      my $expect = exists $value->{text} ? 'text' : 'binary';
      $value = $value->{$expect};
      $msg = '' unless ($type // '') eq $expect;
    }
  
    # Decode text frame if there is no type check
    else { $msg = decode 'UTF-8', $msg if ($type // '') eq 'text' }
  
    return $self->_test($name, $msg // '', $value, $desc);
  }
  
  sub _request_ok {
    my ($self, $tx, $url) = @_;
  
    local $Test::Builder::Level = $Test::Builder::Level + 1;
  
    # Establish WebSocket connection
    if ($tx->req->is_handshake) {
      @$self{qw(finished messages)} = (undef, []);
      $self->ua->start(
        $tx => sub {
          my ($ua, $tx) = @_;
          $self->{finished} = [] unless $self->tx($tx)->tx->is_websocket;
          $tx->on(finish => sub { shift; $self->{finished} = [@_] });
          $tx->on(binary => sub { push @{$self->{messages}}, [binary => pop] });
          $tx->on(text   => sub { push @{$self->{messages}}, [text   => pop] });
          Mojo::IOLoop->stop;
        }
      );
      Mojo::IOLoop->start;
  
      my $desc = encode 'UTF-8', "WebSocket handshake with $url";
      return $self->_test('ok', $self->tx->is_websocket, $desc);
    }
  
    # Perform request
    $self->tx($self->ua->start($tx));
    my $err = $self->tx->error;
    Test::More::diag $err->{message}
      if !(my $ok = !$err->{message} || $err->{code}) && $err;
    my $desc = encode 'UTF-8', "@{[uc $tx->req->method]} $url";
    return $self->_test('ok', $ok, $desc);
  }
  
  sub _test {
    my ($self, $name, @args) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 2;
    return $self->success(!!Test::More->can($name)->(@args));
  }
  
  sub _text {
    return '' unless my $e = shift->tx->res->dom->at(shift);
    return $e->text;
  }
  
  sub _wait {
    my $self = shift;
    Mojo::IOLoop->one_tick while !$self->{finished} && !@{$self->{messages}};
    return $self->message(shift @{$self->{messages}})->message;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Test::Mojo - Testing Mojo
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Test::Mojo;
  
    my $t = Test::Mojo->new('MyApp');
  
    # HTML/XML
    $t->get_ok('/welcome')->status_is(200)->text_is('div#message' => 'Hello!');
  
    # JSON
    $t->post_ok('/search.json' => form => {q => 'Perl'})
      ->status_is(200)
      ->header_is('Server' => 'Mojolicious (Perl)')
      ->header_isnt('X-Bender' => 'Bite my shiny metal ass!')
      ->json_is('/results/4/title' => 'Perl rocks!')
      ->json_like('/results/7/title' => qr/Perl/);
  
    # WebSocket
    $t->websocket_ok('/echo')
      ->send_ok('hello')
      ->message_ok
      ->message_is('echo: hello')
      ->finish_ok;
  
    done_testing();
  
  =head1 DESCRIPTION
  
  L<Test::Mojo> is a test user agent based on L<Mojo::UserAgent>, it is usually
  used together with L<Test::More> to test L<Mojolicious> applications. Just run
  your tests with the command L<Mojolicious::Command::test> or L<prove>.
  
    $ ./script/my_app test
    $ ./script/my_app test -v t/foo.t
    $ prove -l -v t/foo.t
  
  If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will
  be set to C<debug> or C<fatal>, depending on the value of the
  C<HARNESS_IS_VERBOSE> environment variable.
  
  =head1 ATTRIBUTES
  
  L<Test::Mojo> implements the following attributes.
  
  =head2 message
  
    my $msg = $t->message;
    $t      = $t->message([text => $bytes]);
  
  Current WebSocket message represented as an array reference containing the
  frame type and payload.
  
    # More specific tests
    use Mojo::JSON 'decode_json';
    my $hash = decode_json $t->message->[1];
    is ref $hash, 'HASH', 'right reference';
    is $hash->{foo}, 'bar', 'right value';
  
    # Test custom message
    $t->message([binary => $bytes])
      ->json_message_has('/foo/bar')
      ->json_message_hasnt('/bar')
      ->json_message_is('/foo/baz' => {yada => [1, 2, 3]});
  
  =head2 success
  
    my $bool = $t->success;
    $t       = $t->success($bool);
  
  True if the last test was successful.
  
    # Build custom tests
    my $location_is = sub {
      my ($t, $value, $desc) = @_;
      $desc ||= "Location: $value";
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      return $t->success(is($t->tx->res->headers->location, $value, $desc));
    };
    $t->get_ok('/')
      ->status_is(302)
      ->$location_is('http://mojolicious.org')
      ->or(sub { diag 'Must have been Joel!' });
  
  =head2 tx
  
    my $tx = $t->tx;
    $t     = $t->tx(Mojo::Transaction::HTTP->new);
  
  Current transaction, usually a L<Mojo::Transaction::HTTP> or
  L<Mojo::Transaction::WebSocket> object.
  
    # More specific tests
    is $t->tx->res->json->{foo}, 'bar', 'right value';
    ok $t->tx->res->content->is_multipart, 'multipart content';
    is $t->tx->previous->res->code, 302, 'right status';
  
  =head2 ua
  
    my $ua = $t->ua;
    $t     = $t->ua(Mojo::UserAgent->new);
  
  User agent used for testing, defaults to a L<Mojo::UserAgent> object.
  
    # Allow redirects
    $t->ua->max_redirects(10);
    $t->get_ok('/redirect')->status_is(200)->content_like(qr/redirected/);
  
    # Switch protocol from HTTP to HTTPS
    $t->ua->server->url('https');
    $t->get_ok('/secure')->status_is(200)->content_like(qr/secure/);
  
    # Use absolute URL for request with Basic authentication
    my $url = $t->ua->server->url->userinfo('sri:secr3t')->path('/secrets.json');
    $t->post_ok($url => json => {limit => 10})
      ->status_is(200)
      ->json_is('/1/content', 'Mojo rocks!');
  
    # Customize all transactions (including followed redirects)
    $t->ua->on(start => sub {
      my ($ua, $tx) = @_;
      $tx->req->headers->accept_language('en-US');
    });
    $t->get_ok('/hello')->status_is(200)->content_like(qr/Howdy/);
  
  =head1 METHODS
  
  L<Test::Mojo> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 app
  
    my $app = $t->app;
    $t      = $t->app(Mojolicious->new);
  
  Access application with L<Mojo::UserAgent::Server/"app">.
  
    # Change log level
    $t->app->log->level('fatal');
  
    # Test application directly
    is $t->app->defaults->{foo}, 'bar', 'right value';
    ok $t->app->routes->find('echo')->is_websocket, 'WebSocket route';
    my $c = $t->app->build_controller;
    ok $c->render(template => 'foo'), 'rendering was successful';
    is $c->res->status, 200, 'right status';
    is $c->res->body, 'Foo!', 'right content';
  
    # Change application behavior
    $t->app->hook(before_dispatch => sub {
      my $c = shift;
      $c->render(text => 'This request did not reach the router.')
        if $c->req->url->path->contains('/user');
    });
    $t->get_ok('/user')->status_is(200)->content_like(qr/not reach the router/);
  
    # Extract additional information
    my $stash;
    $t->app->hook(after_dispatch => sub { $stash = shift->stash });
    $t->get_ok('/hello')->status_is(200);
    is $stash->{foo}, 'bar', 'right value';
  
  =head2 content_is
  
    $t = $t->content_is('working!');
    $t = $t->content_is('working!', 'right content');
  
  Check response content for exact match after retrieving it from
  L<Mojo::Message/"text">.
  
  =head2 content_isnt
  
    $t = $t->content_isnt('working!');
    $t = $t->content_isnt('working!', 'different content');
  
  Opposite of L</"content_is">.
  
  =head2 content_like
  
    $t = $t->content_like(qr/working!/);
    $t = $t->content_like(qr/working!/, 'right content');
  
  Check response content for similar match after retrieving it from
  L<Mojo::Message/"text">.
  
  =head2 content_type_is
  
    $t = $t->content_type_is('text/html');
    $t = $t->content_type_is('text/html', 'right content type');
  
  Check response C<Content-Type> header for exact match.
  
  =head2 content_type_isnt
  
    $t = $t->content_type_isnt('text/html');
    $t = $t->content_type_isnt('text/html', 'different content type');
  
  Opposite of L</"content_type_is">.
  
  =head2 content_type_like
  
    $t = $t->content_type_like(qr/text/);
    $t = $t->content_type_like(qr/text/, 'right content type');
  
  Check response C<Content-Type> header for similar match.
  
  =head2 content_type_unlike
  
    $t = $t->content_type_unlike(qr/text/);
    $t = $t->content_type_unlike(qr/text/, 'different content type');
  
  Opposite of L</"content_type_like">.
  
  =head2 content_unlike
  
    $t = $t->content_unlike(qr/working!/);
    $t = $t->content_unlike(qr/working!/, 'different content');
  
  Opposite of L</"content_like">.
  
  =head2 delete_ok
  
    $t = $t->delete_ok('http://example.com/foo');
    $t = $t->delete_ok('/foo');
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => 'Hi!');
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<DELETE> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"delete">, except for the callback.
  
  =head2 element_count_is
  
    $t = $t->element_count_is('div.foo[x=y]', 5);
    $t = $t->element_count_is('html body div', 30, 'thirty elements');
  
  Checks the number of HTML/XML elements matched by the CSS selector with
  L<Mojo::DOM/"find">.
  
  =head2 element_exists
  
    $t = $t->element_exists('div.foo[x=y]');
    $t = $t->element_exists('html head title', 'has a title');
  
  Checks for existence of the CSS selectors first matching HTML/XML element with
  L<Mojo::DOM/"at">.
  
    # Check attribute values
    $t->get_ok('/login')
      ->element_exists('label[for=email]')
      ->element_exists('input[name=email][type=text][value*="example.com"]')
      ->element_exists('label[for=pass]')
      ->element_exists('input[name=pass][type=password]')
      ->element_exists('input[type=submit][value]');
  
  =head2 element_exists_not
  
    $t = $t->element_exists_not('div.foo[x=y]');
    $t = $t->element_exists_not('html head title', 'has no title');
  
  Opposite of L</"element_exists">.
  
  =head2 finish_ok
  
    $t = $t->finish_ok;
    $t = $t->finish_ok(1000);
    $t = $t->finish_ok(1003 => 'Cannot accept data!');
  
  Close WebSocket connection gracefully.
  
  =head2 finished_ok
  
    $t = $t->finished_ok(1000);
  
  Wait for WebSocket connection to be closed gracefully and check status.
  
  =head2 get_ok
  
    $t = $t->get_ok('http://example.com/foo');
    $t = $t->get_ok('/foo');
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => 'Hi!');
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<GET> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"get">, except for the callback.
  
    # Run tests against remote host
    $t->get_ok('http://mojolicious.org/perldoc')->status_is(200);
  
    # Use relative URL for request with Basic authentication
    $t->get_ok('//sri:secr3t@/secrets.json')
      ->status_is(200)
      ->json_is('/1/content', 'Mojo rocks!');
  
    # Run additional tests on the transaction
    $t->get_ok('/foo')->status_is(200);
    is $t->tx->res->dom->at('input')->val, 'whatever', 'right value';
  
  =head2 head_ok
  
    $t = $t->head_ok('http://example.com/foo');
    $t = $t->head_ok('/foo');
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => 'Hi!');
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<HEAD> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"head">, except for the callback.
  
  =head2 header_is
  
    $t = $t->header_is(ETag => '"abc321"');
    $t = $t->header_is(ETag => '"abc321"', 'right header');
  
  Check response header for exact match.
  
  =head2 header_isnt
  
    $t = $t->header_isnt(Etag => '"abc321"');
    $t = $t->header_isnt(ETag => '"abc321"', 'different header');
  
  Opposite of L</"header_is">.
  
  =head2 header_like
  
    $t = $t->header_like(ETag => qr/abc/);
    $t = $t->header_like(ETag => qr/abc/, 'right header');
  
  Check response header for similar match.
  
  =head2 header_unlike
  
    $t = $t->header_unlike(ETag => qr/abc/);
    $t = $t->header_unlike(ETag => qr/abc/, 'different header');
  
  Opposite of L</"header_like">.
  
  =head2 json_has
  
    $t = $t->json_has('/foo');
    $t = $t->json_has('/minibar', 'has a minibar');
  
  Check if JSON response contains a value that can be identified using the given
  JSON Pointer with L<Mojo::JSON::Pointer>.
  
  =head2 json_hasnt
  
    $t = $t->json_hasnt('/foo');
    $t = $t->json_hasnt('/minibar', 'no minibar');
  
  Opposite of L</"json_has">.
  
  =head2 json_is
  
    $t = $t->json_is({foo => [1, 2, 3]});
    $t = $t->json_is('/foo' => [1, 2, 3]);
    $t = $t->json_is('/foo/1' => 2, 'right value');
  
  Check the value extracted from JSON response using the given JSON Pointer with
  L<Mojo::JSON::Pointer>, which defaults to the root value if it is omitted.
  
  =head2 json_like
  
    $t = $t->json_like('/foo/1' => qr/^\d+$/);
    $t = $t->json_like('/foo/1' => qr/^\d+$/, 'right value');
  
  Check the value extracted from JSON response using the given JSON Pointer with
  L<Mojo::JSON::Pointer> for similar match.
  
  =head2 json_message_has
  
    $t = $t->json_message_has('/foo');
    $t = $t->json_message_has('/minibar', 'has a minibar');
  
  Check if JSON WebSocket message contains a value that can be identified using
  the given JSON Pointer with L<Mojo::JSON::Pointer>.
  
  =head2 json_message_hasnt
  
    $t = $t->json_message_hasnt('/foo');
    $t = $t->json_message_hasnt('/minibar', 'no minibar');
  
  Opposite of L</"json_message_has">.
  
  =head2 json_message_is
  
    $t = $t->json_message_is({foo => [1, 2, 3]});
    $t = $t->json_message_is('/foo' => [1, 2, 3]);
    $t = $t->json_message_is('/foo/1' => 2, 'right value');
  
  Check the value extracted from JSON WebSocket message using the given JSON
  Pointer with L<Mojo::JSON::Pointer>, which defaults to the root value if it is
  omitted.
  
  =head2 json_message_like
  
    $t = $t->json_message_like('/foo/1' => qr/^\d+$/);
    $t = $t->json_message_like('/foo/1' => qr/^\d+$/, 'right value');
  
  Check the value extracted from JSON WebSocket message using the given JSON
  Pointer with L<Mojo::JSON::Pointer> for similar match.
  
  =head2 json_message_unlike
  
    $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/);
    $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/, 'different value');
  
  Opposite of L</"json_message_like">.
  
  =head2 json_unlike
  
    $t = $t->json_unlike('/foo/1' => qr/^\d+$/);
    $t = $t->json_unlike('/foo/1' => qr/^\d+$/, 'different value');
  
  Opposite of L</"json_like">.
  
  =head2 message_is
  
    $t = $t->message_is({binary => $bytes});
    $t = $t->message_is({text   => $bytes});
    $t = $t->message_is('working!');
    $t = $t->message_is('working!', 'right message');
  
  Check WebSocket message for exact match.
  
  =head2 message_isnt
  
    $t = $t->message_isnt({binary => $bytes});
    $t = $t->message_isnt({text   => $bytes});
    $t = $t->message_isnt('working!');
    $t = $t->message_isnt('working!', 'different message');
  
  Opposite of L</"message_is">.
  
  =head2 message_like
  
    $t = $t->message_like({binary => qr/$bytes/});
    $t = $t->message_like({text   => qr/$bytes/});
    $t = $t->message_like(qr/working!/);
    $t = $t->message_like(qr/working!/, 'right message');
  
  Check WebSocket message for similar match.
  
  =head2 message_ok
  
    $t = $t->message_ok;
    $t = $t->message_ok('got a message');
  
  Wait for next WebSocket message to arrive.
  
    # Wait for message and perform multiple tests on it
    $t->websocket_ok('/time')
      ->message_ok
      ->message_like(qr/\d+/)
      ->message_unlike(qr/\w+/)
      ->finish_ok;
  
  =head2 message_unlike
  
    $t = $t->message_unlike({binary => qr/$bytes/});
    $t = $t->message_unlike({text   => qr/$bytes/});
    $t = $t->message_unlike(qr/working!/);
    $t = $t->message_unlike(qr/working!/, 'different message');
  
  Opposite of L</"message_like">.
  
  =head2 new
  
    my $t = Test::Mojo->new;
    my $t = Test::Mojo->new('MyApp');
    my $t = Test::Mojo->new(MyApp->new);
  
  Construct a new L<Test::Mojo> object.
  
  =head2 options_ok
  
    $t = $t->options_ok('http://example.com/foo');
    $t = $t->options_ok('/foo');
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => 'Hi!');
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<OPTIONS> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"options">, except for the callback.
  
  =head2 or
  
    $t = $t->or(sub {...});
  
  Execute callback if the value of L</"success"> is false.
  
    # Diagnostics
    $t->get_ok('/bad')->or(sub { diag 'Must have been Glen!' })
      ->status_is(200)->or(sub { diag $t->tx->res->dom->at('title')->text });
  
  =head2 patch_ok
  
    $t = $t->patch_ok('http://example.com/foo');
    $t = $t->patch_ok('/foo');
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => 'Hi!');
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<PATCH> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"patch">, except for the callback.
  
  =head2 post_ok
  
    $t = $t->post_ok('http://example.com/foo');
    $t = $t->post_ok('/foo');
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => 'Hi!');
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<POST> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"post">, except for the callback.
  
    # Test file upload
    my $upload = {foo => {content => 'bar', filename => 'baz.txt'}};
    $t->post_ok('/upload' => form => $upload)->status_is(200);
  
    # Test JSON API
    $t->post_ok('/hello.json' => json => {hello => 'world'})
      ->status_is(200)
      ->json_is({bye => 'world'});
  
  =head2 put_ok
  
    $t = $t->put_ok('http://example.com/foo');
    $t = $t->put_ok('/foo');
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => 'Hi!');
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<PUT> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"put">, except for the callback.
  
  =head2 request_ok
  
    $t = $t->request_ok(Mojo::Transaction::HTTP->new);
  
  Perform request and check for transport errors.
  
    # Request with custom method
    my $tx = $t->ua->build_tx(FOO => '/test.json' => json => {foo => 1});
    $t->request_ok($tx)->status_is(200)->json_is({success => 1});
  
    # Request with custom cookie
    my $tx = $t->ua->build_tx(GET => '/account');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $t->request_ok($tx)->status_is(200)->text_is('head > title' => 'Hello sri');
  
    # Custom WebSocket handshake
    my $tx = $t->ua->build_websocket_tx('/foo');
    $tx->req->headers->remove('User-Agent');
    $t->request_ok($tx)->message_ok->message_is('bar')->finish_ok;
  
  =head2 reset_session
  
    $t = $t->reset_session;
  
  Reset user agent session.
  
  =head2 send_ok
  
    $t = $t->send_ok({binary => $bytes});
    $t = $t->send_ok({text   => $bytes});
    $t = $t->send_ok({json   => {test => [1, 2, 3]}});
    $t = $t->send_ok([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $t = $t->send_ok($chars);
    $t = $t->send_ok($chars, 'sent successfully');
  
  Send message or frame via WebSocket.
  
    # Send JSON object as "Text" message
    $t->websocket_ok('/echo.json')
      ->send_ok({json => {test => 'I ♥ Mojolicious!'}})
      ->message_ok
      ->json_message_is('/test' => 'I ♥ Mojolicious!')
      ->finish_ok;
  
  =head2 status_is
  
    $t = $t->status_is(200);
    $t = $t->status_is(200, 'right status');
  
  Check response status for exact match.
  
  =head2 status_isnt
  
    $t = $t->status_isnt(200);
    $t = $t->status_isnt(200, 'different status');
  
  Opposite of L</"status_is">.
  
  =head2 text_is
  
    $t = $t->text_is('div.foo[x=y]' => 'Hello!');
    $t = $t->text_is('html head title' => 'Hello!', 'right title');
  
  Checks text content of the CSS selectors first matching HTML/XML element for
  exact match with L<Mojo::DOM/"at">.
  
  =head2 text_isnt
  
    $t = $t->text_isnt('div.foo[x=y]' => 'Hello!');
    $t = $t->text_isnt('html head title' => 'Hello!', 'different title');
  
  Opposite of L</"text_is">.
  
  =head2 text_like
  
    $t = $t->text_like('div.foo[x=y]' => qr/Hello/);
    $t = $t->text_like('html head title' => qr/Hello/, 'right title');
  
  Checks text content of the CSS selectors first matching HTML/XML element for
  similar match with L<Mojo::DOM/"at">.
  
  =head2 text_unlike
  
    $t = $t->text_unlike('div.foo[x=y]' => qr/Hello/);
    $t = $t->text_unlike('html head title' => qr/Hello/, 'different title');
  
  Opposite of L</"text_like">.
  
  =head2 websocket_ok
  
    $t = $t->websocket_ok('http://example.com/echo');
    $t = $t->websocket_ok('/echo');
    $t = $t->websocket_ok('/echo' => {DNT => 1} => ['v1.proto']);
  
  Open a WebSocket connection with transparent handshake, takes the same
  arguments as L<Mojo::UserAgent/"websocket">, except for the callback.
  
    # WebSocket with permessage-deflate compression
    $t->websocket_ok('/' => {'Sec-WebSocket-Extensions' => 'permessage-deflate'})
      ->send_ok('y' x 50000)
      ->message_ok
      ->message_is('z' x 50000)
      ->finish_ok;
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
TEST_MOJO

$fatpacked{"ojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OJO';
  package ojo;
  use Mojo::Base -strict;
  
  use Benchmark qw(timeit timestr :hireswallclock);
  use Mojo::ByteStream 'b';
  use Mojo::Collection 'c';
  use Mojo::DOM;
  use Mojo::JSON 'j';
  use Mojo::Util qw(dumper monkey_patch);
  
  # Silent one-liners
  $ENV{MOJO_LOG_LEVEL} ||= 'fatal';
  
  sub import {
  
    # Mojolicious::Lite
    my $caller = caller;
    eval "package $caller; use Mojolicious::Lite; 1" or die $@;
    my $ua = $caller->app->ua;
    $ua->server->app->hook(around_action => sub { local $_ = $_[1]; $_[0]() });
  
    $ua->max_redirects(10) unless defined $ENV{MOJO_MAX_REDIRECTS};
    $ua->proxy->detect unless defined $ENV{MOJO_PROXY};
  
    # The ojo DSL
    monkey_patch $caller,
      a => sub { $caller->can('any')->(@_) and return $ua->server->app },
      b => \&b,
      c => \&c,
      d => sub { _request($ua, 'DELETE', @_) },
      g => sub { _request($ua, 'GET',    @_) },
      h => sub { _request($ua, 'HEAD',   @_) },
      j => \&j,
      n => sub (&@) { say STDERR timestr timeit($_[1] // 1, $_[0]) },
      o => sub { _request($ua, 'OPTIONS', @_) },
      p => sub { _request($ua, 'POST',    @_) },
      r => \&dumper,
      t => sub { _request($ua, 'PATCH',   @_) },
      u => sub { _request($ua, 'PUT',     @_) },
      x => sub { Mojo::DOM->new(@_) };
  }
  
  sub _request {
    my $ua = shift;
  
    my $tx  = $ua->start($ua->build_tx(@_));
    my $err = $tx->error;
    warn qq/Problem loading URL "@{[$tx->req->url]}": $err->{message}\n/
      if $err && !$err->{code};
  
    return $tx->res;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  ojo - Fun one-liners with Mojo
  
  =head1 SYNOPSIS
  
    $ perl -Mojo -E 'say g("mojolicious.org")->dom->at("title")->text'
  
  =head1 DESCRIPTION
  
  A collection of automatically exported functions for fun Perl one-liners. Ten
  redirects will be followed by default, you can change this behavior with the
  C<MOJO_MAX_REDIRECTS> environment variable.
  
    $ MOJO_MAX_REDIRECTS=0 perl -Mojo -E 'say g("example.com")->code'
  
  Proxy detection is enabled by default, but you can disable it with the
  C<MOJO_PROXY> environment variable.
  
    $ MOJO_PROXY=0 perl -Mojo -E 'say g("example.com")->body'
  
  Every L<ojo> one-liner is also a L<Mojolicious::Lite> application.
  
    $ perl -Mojo -E 'get "/" => {inline => "%= time"}; app->start' get /
  
  If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will
  be set to C<fatal>.
  
  =head1 FUNCTIONS
  
  L<ojo> implements the following functions, which are automatically exported.
  
  =head2 a
  
    my $app = a('/hello' => sub { $_->render(json => {hello => 'world'}) });
  
  Create a route with L<Mojolicious::Lite/"any"> and return the current
  L<Mojolicious::Lite> object. The current controller object is also available to
  actions as C<$_>. See also L<Mojolicious::Guides::Tutorial> for more argument
  variations.
  
    $ perl -Mojo -E 'a("/hello" => {text => "Hello Mojo!"})->start' daemon
  
  =head2 b
  
    my $stream = b('lalala');
  
  Turn string into a L<Mojo::ByteStream> object.
  
    $ perl -Mojo -E 'b(g("mojolicious.org")->body)->html_unescape->say'
  
  =head2 c
  
    my $collection = c(1, 2, 3);
  
  Turn list into a L<Mojo::Collection> object.
  
  =head2 d
  
    my $res = d('example.com');
    my $res = d('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = d('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = d('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<DELETE> request with L<Mojo::UserAgent/"delete"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 g
  
    my $res = g('example.com');
    my $res = g('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = g('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = g('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<GET> request with L<Mojo::UserAgent/"get"> and return resulting
  L<Mojo::Message::Response> object.
  
    $ perl -Mojo -E 'say g("mojolicious.org")->dom("h1")->map("text")->join("\n")'
  
  =head2 h
  
    my $res = h('example.com');
    my $res = h('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = h('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = h('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<HEAD> request with L<Mojo::UserAgent/"head"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 j
  
    my $bytes = j([1, 2, 3]);
    my $bytes = j({foo => 'bar'});
    my $value = j($bytes);
  
  Encode Perl data structure or decode JSON with L<Mojo::JSON/"j">.
  
    $ perl -Mojo -E 'b(j({hello => "world!"}))->spurt("hello.json")'
  
  =head2 n
  
    n {...};
    n {...} 100;
  
  Benchmark block and print the results to C<STDERR>, with an optional number of
  iterations, which defaults to C<1>.
  
    $ perl -Mojo -E 'n { say g("mojolicious.org")->code }'
  
  =head2 o
  
    my $res = o('example.com');
    my $res = o('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = o('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = o('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<OPTIONS> request with L<Mojo::UserAgent/"options"> and return
  resulting L<Mojo::Message::Response> object.
  
  =head2 p
  
    my $res = p('example.com');
    my $res = p('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = p('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = p('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<POST> request with L<Mojo::UserAgent/"post"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 r
  
    my $perl = r({data => 'structure'});
  
  Dump a Perl data structure with L<Mojo::Util/"dumper">.
  
    perl -Mojo -E 'say r(g("example.com")->headers->to_hash)'
  
  =head2 t
  
    my $res = t('example.com');
    my $res = t('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = t('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = t('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<PATCH> request with L<Mojo::UserAgent/"patch"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 u
  
    my $res = u('example.com');
    my $res = u('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = u('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = u('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<PUT> request with L<Mojo::UserAgent/"put"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 x
  
    my $dom = x('<div>Hello!</div>');
  
  Turn HTML/XML input into L<Mojo::DOM> object.
  
    $ perl -Mojo -E 'say x(b("test.html")->slurp)->at("title")->text'
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
OJO

$fatpacked{"x86_64-linux-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.45";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of the all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.45";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-thread-multi/Net/SSLeay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_NET_SSLEAY';
  # Net::SSLeay.pm - Perl module for using Eric Young's implementation of SSL
  #
  # Copyright (c) 1996-2003 Sampo Kellomaki <sampo@iki.fi>, All Rights Reserved.
  # Copyright (C) 2005 Florian Ragwitz <rafl@debian.org>, All Rights Reserved.
  # Copyright (C) 2005 Mike McCauley <mikem@airspayce.com>, All Rights Reserved.
  #
  # $Id: SSLeay.pm 464 2016-04-11 00:16:31Z mikem-guest $
  #
  # Change data removed from here. See Changes
  # The distribution and use of this module are subject to the conditions
  # listed in LICENSE file at the root of the Net-SSLeay
  # distribution (i.e. same license as Perl itself).
  
  package Net::SSLeay;
  
  use strict;
  use Carp;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD $CRLF);
  use Socket;
  use Errno;
  require 5.005_000;
  
  require Exporter;
  use AutoLoader;
  
  # 0=no warns, 1=only errors, 2=ciphers, 3=progress, 4=dump data
  $Net::SSLeay::trace = 0;  # Do not change here, use
                            # $Net::SSLeay::trace = [1-4]  in caller
  
  # 2 = insist on v2 SSL protocol
  # 3 = insist on v3 SSL
  # 10 = insist on TLSv1
  # 11 = insist on TLSv1.1
  # 12 = insist on TLSv1.2
  # 0 or undef = guess (v23)
  #
  $Net::SSLeay::ssl_version = 0;  # don't change here, use
                                  # Net::SSLeay::version=[2,3,0] in caller
  
  #define to enable the "cat /proc/$$/stat" stuff
  $Net::SSLeay::linux_debug = 0;
  
  # Number of seconds to sleep after sending message and before half
  # closing connection. Useful with antiquated broken servers.
  $Net::SSLeay::slowly = 0;
  
  # RANDOM NUMBER INITIALIZATION
  #
  # Edit to your taste. Using /dev/random would be more secure, but may
  # block if randomness is not available, thus the default is
  # /dev/urandom. $how_random determines how many bits of randomness to take
  # from the device. You should take enough (read SSLeay/doc/rand), but
  # beware that randomness is limited resource so you should not waste
  # it either or you may end up with randomness depletion (situation where
  # /dev/random would block and /dev/urandom starts to return predictable
  # numbers).
  #
  # N.B. /dev/urandom does not exit on all systems, such as Solaris 2.6. In that
  #      case you should get a third party package that emulates /dev/urandom
  #      (e.g. via named pipe) or supply a random number file. Some such
  #      packages are documented in Caveat section of the POD documentation.
  
  $Net::SSLeay::random_device = '/dev/urandom';
  $Net::SSLeay::how_random = 512;
  
  $VERSION = '1.74'; # Dont forget to set version in META.yml too
  @ISA = qw(Exporter);
  
  #BEWARE:
  # 3-columns part of @EXPORT_OK related to constants is the output of command:
  # perl helper_script/regen_openssl_constants.pl -gen-pod
  # if you add/remove any constant you need to update it manually
  
  @EXPORT_OK = qw(
   ASN1_STRFLGS_ESC_CTRL           NID_ext_key_usage                      OP_CRYPTOPRO_TLSEXT_BUG
   ASN1_STRFLGS_ESC_MSB            NID_ext_req                            OP_DONT_INSERT_EMPTY_FRAGMENTS
   ASN1_STRFLGS_ESC_QUOTE          NID_friendlyName                       OP_EPHEMERAL_RSA
   ASN1_STRFLGS_RFC2253            NID_givenName                          OP_LEGACY_SERVER_CONNECT
   CB_ACCEPT_EXIT                  NID_hmacWithSHA1                       OP_MICROSOFT_BIG_SSLV3_BUFFER
   CB_ACCEPT_LOOP                  NID_id_ad                              OP_MICROSOFT_SESS_ID_BUG
   CB_ALERT                        NID_id_ce                              OP_MSIE_SSLV2_RSA_PADDING
   CB_CONNECT_EXIT                 NID_id_kp                              OP_NETSCAPE_CA_DN_BUG
   CB_CONNECT_LOOP                 NID_id_pbkdf2                          OP_NETSCAPE_CHALLENGE_BUG
   CB_EXIT                         NID_id_pe                              OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
   CB_HANDSHAKE_DONE               NID_id_pkix                            OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
   CB_HANDSHAKE_START              NID_id_qt_cps                          OP_NON_EXPORT_FIRST
   CB_LOOP                         NID_id_qt_unotice                      OP_NO_COMPRESSION
   CB_READ                         NID_idea_cbc                           OP_NO_QUERY_MTU
   CB_READ_ALERT                   NID_idea_cfb64                         OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
   CB_WRITE                        NID_idea_ecb                           OP_NO_SSLv2
   CB_WRITE_ALERT                  NID_idea_ofb64                         OP_NO_SSLv3
   ERROR_NONE                      NID_info_access                        OP_NO_TICKET
   ERROR_SSL                       NID_initials                           OP_NO_TLSv1
   ERROR_SYSCALL                   NID_invalidity_date                    OP_NO_TLSv1_1
   ERROR_WANT_ACCEPT               NID_issuer_alt_name                    OP_NO_TLSv1_2
   ERROR_WANT_CONNECT              NID_keyBag                             OP_PKCS1_CHECK_1
   ERROR_WANT_READ                 NID_key_usage                          OP_PKCS1_CHECK_2
   ERROR_WANT_WRITE                NID_localKeyID                         OP_SINGLE_DH_USE
   ERROR_WANT_X509_LOOKUP          NID_localityName                       OP_SINGLE_ECDH_USE
   ERROR_ZERO_RETURN               NID_md2                                OP_SSLEAY_080_CLIENT_DH_BUG
   EVP_PKS_DSA                     NID_md2WithRSAEncryption               OP_SSLREF2_REUSE_CERT_TYPE_BUG
   EVP_PKS_EC                      NID_md5                                OP_TLS_BLOCK_PADDING_BUG
   EVP_PKS_RSA                     NID_md5WithRSA                         OP_TLS_D5_BUG
   EVP_PKT_ENC                     NID_md5WithRSAEncryption               OP_TLS_ROLLBACK_BUG
   EVP_PKT_EXCH                    NID_md5_sha1                           READING
   EVP_PKT_EXP                     NID_mdc2                               RECEIVED_SHUTDOWN
   EVP_PKT_SIGN                    NID_mdc2WithRSA                        RSA_3
   EVP_PK_DH                       NID_ms_code_com                        RSA_F4
   EVP_PK_DSA                      NID_ms_code_ind                        R_BAD_AUTHENTICATION_TYPE
   EVP_PK_EC                       NID_ms_ctl_sign                        R_BAD_CHECKSUM
   EVP_PK_RSA                      NID_ms_efs                             R_BAD_MAC_DECODE
   FILETYPE_ASN1                   NID_ms_ext_req                         R_BAD_RESPONSE_ARGUMENT
   FILETYPE_PEM                    NID_ms_sgc                             R_BAD_SSL_FILETYPE
   F_CLIENT_CERTIFICATE            NID_name                               R_BAD_SSL_SESSION_ID_LENGTH
   F_CLIENT_HELLO                  NID_netscape                           R_BAD_STATE
   F_CLIENT_MASTER_KEY             NID_netscape_base_url                  R_BAD_WRITE_RETRY
   F_D2I_SSL_SESSION               NID_netscape_ca_policy_url             R_CHALLENGE_IS_DIFFERENT
   F_GET_CLIENT_FINISHED           NID_netscape_ca_revocation_url         R_CIPHER_TABLE_SRC_ERROR
   F_GET_CLIENT_HELLO              NID_netscape_cert_extension            R_INVALID_CHALLENGE_LENGTH
   F_GET_CLIENT_MASTER_KEY         NID_netscape_cert_sequence             R_NO_CERTIFICATE_SET
   F_GET_SERVER_FINISHED           NID_netscape_cert_type                 R_NO_CERTIFICATE_SPECIFIED
   F_GET_SERVER_HELLO              NID_netscape_comment                   R_NO_CIPHER_LIST
   F_GET_SERVER_VERIFY             NID_netscape_data_type                 R_NO_CIPHER_MATCH
   F_I2D_SSL_SESSION               NID_netscape_renewal_url               R_NO_PRIVATEKEY
   F_READ_N                        NID_netscape_revocation_url            R_NO_PUBLICKEY
   F_REQUEST_CERTIFICATE           NID_netscape_ssl_server_name           R_NULL_SSL_CTX
   F_SERVER_HELLO                  NID_ns_sgc                             R_PEER_DID_NOT_RETURN_A_CERTIFICATE
   F_SSL_CERT_NEW                  NID_organizationName                   R_PEER_ERROR
   F_SSL_GET_NEW_SESSION           NID_organizationalUnitName             R_PEER_ERROR_CERTIFICATE
   F_SSL_NEW                       NID_pbeWithMD2AndDES_CBC               R_PEER_ERROR_NO_CIPHER
   F_SSL_READ                      NID_pbeWithMD2AndRC2_CBC               R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE
   F_SSL_RSA_PRIVATE_DECRYPT       NID_pbeWithMD5AndCast5_CBC             R_PUBLIC_KEY_ENCRYPT_ERROR
   F_SSL_RSA_PUBLIC_ENCRYPT        NID_pbeWithMD5AndDES_CBC               R_PUBLIC_KEY_IS_NOT_RSA
   F_SSL_SESSION_NEW               NID_pbeWithMD5AndRC2_CBC               R_READ_WRONG_PACKET_TYPE
   F_SSL_SESSION_PRINT_FP          NID_pbeWithSHA1AndDES_CBC              R_SHORT_READ
   F_SSL_SET_FD                    NID_pbeWithSHA1AndRC2_CBC              R_SSL_SESSION_ID_IS_DIFFERENT
   F_SSL_SET_RFD                   NID_pbe_WithSHA1And128BitRC2_CBC       R_UNABLE_TO_EXTRACT_PUBLIC_KEY
   F_SSL_SET_WFD                   NID_pbe_WithSHA1And128BitRC4           R_UNKNOWN_REMOTE_ERROR_TYPE
   F_SSL_USE_CERTIFICATE           NID_pbe_WithSHA1And2_Key_TripleDES_CBC R_UNKNOWN_STATE
   F_SSL_USE_CERTIFICATE_ASN1      NID_pbe_WithSHA1And3_Key_TripleDES_CBC R_X509_LIB
   F_SSL_USE_CERTIFICATE_FILE      NID_pbe_WithSHA1And40BitRC2_CBC        SENT_SHUTDOWN
   F_SSL_USE_PRIVATEKEY            NID_pbe_WithSHA1And40BitRC4            SESSION_ASN1_VERSION
   F_SSL_USE_PRIVATEKEY_ASN1       NID_pbes2                              ST_ACCEPT
   F_SSL_USE_PRIVATEKEY_FILE       NID_pbmac1                             ST_BEFORE
   F_SSL_USE_RSAPRIVATEKEY         NID_pkcs                               ST_CONNECT
   F_SSL_USE_RSAPRIVATEKEY_ASN1    NID_pkcs3                              ST_INIT
   F_SSL_USE_RSAPRIVATEKEY_FILE    NID_pkcs7                              ST_OK
   F_WRITE_PENDING                 NID_pkcs7_data                         ST_READ_BODY
   GEN_DIRNAME                     NID_pkcs7_digest                       ST_READ_HEADER
   GEN_DNS                         NID_pkcs7_encrypted                    TLSEXT_STATUSTYPE_ocsp
   GEN_EDIPARTY                    NID_pkcs7_enveloped                    VERIFY_CLIENT_ONCE
   GEN_EMAIL                       NID_pkcs7_signed                       VERIFY_FAIL_IF_NO_PEER_CERT
   GEN_IPADD                       NID_pkcs7_signedAndEnveloped           VERIFY_NONE
   GEN_OTHERNAME                   NID_pkcs8ShroudedKeyBag                VERIFY_PEER
   GEN_RID                         NID_pkcs9                              V_OCSP_CERTSTATUS_GOOD
   GEN_URI                         NID_pkcs9_challengePassword            V_OCSP_CERTSTATUS_REVOKED
   GEN_X400                        NID_pkcs9_contentType                  V_OCSP_CERTSTATUS_UNKNOWN
   LIBRESSL_VERSION_NUMBER         NID_pkcs9_countersignature             WRITING
   MBSTRING_ASC                    NID_pkcs9_emailAddress                 X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
   MBSTRING_BMP                    NID_pkcs9_extCertAttributes            X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
   MBSTRING_FLAG                   NID_pkcs9_messageDigest                X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
   MBSTRING_UNIV                   NID_pkcs9_signingTime                  X509_CHECK_FLAG_NO_WILDCARDS
   MBSTRING_UTF8                   NID_pkcs9_unstructuredAddress          X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS
   MIN_RSA_MODULUS_LENGTH_IN_BYTES NID_pkcs9_unstructuredName             X509_LOOKUP
   MODE_ACCEPT_MOVING_WRITE_BUFFER NID_private_key_usage_period           X509_PURPOSE_ANY
   MODE_AUTO_RETRY                 NID_rc2_40_cbc                         X509_PURPOSE_CRL_SIGN
   MODE_ENABLE_PARTIAL_WRITE       NID_rc2_64_cbc                         X509_PURPOSE_NS_SSL_SERVER
   MODE_RELEASE_BUFFERS            NID_rc2_cbc                            X509_PURPOSE_OCSP_HELPER
   NID_OCSP_sign                   NID_rc2_cfb64                          X509_PURPOSE_SMIME_ENCRYPT
   NID_SMIMECapabilities           NID_rc2_ecb                            X509_PURPOSE_SMIME_SIGN
   NID_X500                        NID_rc2_ofb64                          X509_PURPOSE_SSL_CLIENT
   NID_X509                        NID_rc4                                X509_PURPOSE_SSL_SERVER
   NID_ad_OCSP                     NID_rc4_40                             X509_PURPOSE_TIMESTAMP_SIGN
   NID_ad_ca_issuers               NID_rc5_cbc                            X509_TRUST_COMPAT
   NID_algorithm                   NID_rc5_cfb64                          X509_TRUST_EMAIL
   NID_authority_key_identifier    NID_rc5_ecb                            X509_TRUST_OBJECT_SIGN
   NID_basic_constraints           NID_rc5_ofb64                          X509_TRUST_OCSP_REQUEST
   NID_bf_cbc                      NID_ripemd160                          X509_TRUST_OCSP_SIGN
   NID_bf_cfb64                    NID_ripemd160WithRSA                   X509_TRUST_SSL_CLIENT
   NID_bf_ecb                      NID_rle_compression                    X509_TRUST_SSL_SERVER
   NID_bf_ofb64                    NID_rsa                                X509_TRUST_TSA
   NID_cast5_cbc                   NID_rsaEncryption                      X509_V_FLAG_ALLOW_PROXY_CERTS
   NID_cast5_cfb64                 NID_rsadsi                             X509_V_FLAG_CB_ISSUER_CHECK
   NID_cast5_ecb                   NID_safeContentsBag                    X509_V_FLAG_CHECK_SS_SIGNATURE
   NID_cast5_ofb64                 NID_sdsiCertificate                    X509_V_FLAG_CRL_CHECK
   NID_certBag                     NID_secretBag                          X509_V_FLAG_CRL_CHECK_ALL
   NID_certificate_policies        NID_serialNumber                       X509_V_FLAG_EXPLICIT_POLICY
   NID_client_auth                 NID_server_auth                        X509_V_FLAG_EXTENDED_CRL_SUPPORT
   NID_code_sign                   NID_sha                                X509_V_FLAG_IGNORE_CRITICAL
   NID_commonName                  NID_sha1                               X509_V_FLAG_INHIBIT_ANY
   NID_countryName                 NID_sha1WithRSA                        X509_V_FLAG_INHIBIT_MAP
   NID_crlBag                      NID_sha1WithRSAEncryption              X509_V_FLAG_NOTIFY_POLICY
   NID_crl_distribution_points     NID_shaWithRSAEncryption               X509_V_FLAG_POLICY_CHECK
   NID_crl_number                  NID_stateOrProvinceName                X509_V_FLAG_POLICY_MASK
   NID_crl_reason                  NID_subject_alt_name                   X509_V_FLAG_TRUSTED_FIRST
   NID_delta_crl                   NID_subject_key_identifier             X509_V_FLAG_USE_CHECK_TIME
   NID_des_cbc                     NID_surname                            X509_V_FLAG_USE_DELTAS
   NID_des_cfb64                   NID_sxnet                              X509_V_FLAG_X509_STRICT
   NID_des_ecb                     NID_time_stamp                         X509_V_OK
   NID_des_ede                     NID_title                              XN_FLAG_COMPAT
   NID_des_ede3                    NID_undef                              XN_FLAG_DN_REV
   NID_des_ede3_cbc                NID_uniqueIdentifier                   XN_FLAG_DUMP_UNKNOWN_FIELDS
   NID_des_ede3_cfb64              NID_x509Certificate                    XN_FLAG_FN_ALIGN
   NID_des_ede3_ofb64              NID_x509Crl                            XN_FLAG_FN_LN
   NID_des_ede_cbc                 NID_zlib_compression                   XN_FLAG_FN_MASK
   NID_des_ede_cfb64               NOTHING                                XN_FLAG_FN_NONE
   NID_des_ede_ofb64               OCSP_RESPONSE_STATUS_INTERNALERROR     XN_FLAG_FN_OID
   NID_des_ofb64                   OCSP_RESPONSE_STATUS_MALFORMEDREQUEST  XN_FLAG_FN_SN
   NID_description                 OCSP_RESPONSE_STATUS_SIGREQUIRED       XN_FLAG_MULTILINE
   NID_desx_cbc                    OCSP_RESPONSE_STATUS_SUCCESSFUL        XN_FLAG_ONELINE
   NID_dhKeyAgreement              OCSP_RESPONSE_STATUS_TRYLATER          XN_FLAG_RFC2253
   NID_dnQualifier                 OCSP_RESPONSE_STATUS_UNAUTHORIZED      XN_FLAG_SEP_COMMA_PLUS
   NID_dsa                         OPENSSL_VERSION_NUMBER                 XN_FLAG_SEP_CPLUS_SPC
   NID_dsaWithSHA                  OP_ALL                                 XN_FLAG_SEP_MASK
   NID_dsaWithSHA1                 OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION   XN_FLAG_SEP_MULTILINE
   NID_dsaWithSHA1_2               OP_CIPHER_SERVER_PREFERENCE            XN_FLAG_SEP_SPLUS_SPC
   NID_dsa_2                       OP_CISCO_ANYCONNECT                    XN_FLAG_SPC_EQ
   NID_email_protect               OP_COOKIE_EXCHANGE                     
      BIO_eof
      BIO_f_ssl
      BIO_free
      BIO_new
      BIO_new_file
      BIO_pending
      BIO_read
      BIO_s_mem
      BIO_wpending
      BIO_write
      CTX_free
      CTX_get_cert_store
      CTX_new
      CTX_use_RSAPrivateKey_file
      CTX_use_certificate_file
      CTX_v23_new
      CTX_v2_new
      CTX_v3_new
      ERR_error_string
      ERR_get_error
      ERR_load_RAND_strings
      ERR_load_SSL_strings
      PEM_read_bio_X509_CRL
      RSA_free
      RSA_generate_key
      SESSION
      SESSION_free
      SESSION_get_master_key
      SESSION_new
      SESSION_print
      X509_NAME_get_text_by_NID
      X509_NAME_oneline
      X509_STORE_CTX_set_flags
      X509_STORE_add_cert
      X509_STORE_add_crl
      X509_check_email
      X509_check_host
      X509_check_ip
      X509_check_ip_asc
      X509_free
      X509_get_issuer_name
      X509_get_subject_name
      X509_load_cert_crl_file
      X509_load_cert_file
      X509_load_crl_file
      accept
      add_session
      clear
      clear_error
      connect
      copy_session_id
      d2i_SSL_SESSION
      die_if_ssl_error
      die_now
      do_https
      dump_peer_certificate
      err
      flush_sessions
      free
      get_cipher
      get_cipher_list
      get_client_random
      get_fd
      get_http
      get_http4
      get_https
      get_https3
      get_https4
      get_httpx
      get_httpx4
      get_peer_certificate
      get_peer_cert_chain
      get_rbio
      get_read_ahead
      get_server_random
      get_shared_ciphers
      get_time
      get_timeout
      get_wbio
      i2d_SSL_SESSION
      load_error_strings
      make_form
      make_headers
      new
      peek
      pending
      post_http
      post_http4
      post_https
      post_https3
      post_https4
      post_httpx
      post_httpx4
      print_errs
      read
      remove_session
      rstate_string
      rstate_string_long
      set_bio
      set_cert_and_key
      set_cipher_list
      set_fd
      set_read_ahead
      set_rfd
      set_server_cert_and_key
      set_session
      set_time
      set_timeout
      set_verify
      set_wfd
      ssl_read_CRLF
      ssl_read_all
      ssl_read_until
      ssl_write_CRLF
      ssl_write_all
      sslcat
      state_string
      state_string_long
      tcp_read_CRLF
      tcp_read_all
      tcp_read_until
      tcp_write_CRLF
      tcp_write_all
      tcpcat
      tcpxcat
      use_PrivateKey
      use_PrivateKey_ASN1
      use_PrivateKey_file
      use_RSAPrivateKey
      use_RSAPrivateKey_ASN1
      use_RSAPrivateKey_file
      use_certificate
      use_certificate_ASN1
      use_certificate_file
      write
      d2i_OCSP_RESPONSE
      i2d_OCSP_RESPONSE
      OCSP_RESPONSE_free
      d2i_OCSP_REQUEST
      i2d_OCSP_REQUEST
      OCSP_REQUEST_free
      OCSP_cert2ids
      OCSP_ids2req
      OCSP_response_status
      OCSP_response_status_str
      OCSP_response_verify
      OCSP_response_results
      OCSP_RESPONSE_STATUS_INTERNALERROR
      OCSP_RESPONSE_STATUS_MALFORMEDREQUEST
      OCSP_RESPONSE_STATUS_SIGREQUIRED
      OCSP_RESPONSE_STATUS_SUCCESSFUL
      OCSP_RESPONSE_STATUS_TRYLATER
      OCSP_RESPONSE_STATUS_UNAUTHORIZED
      TLSEXT_STATUSTYPE_ocsp
      V_OCSP_CERTSTATUS_GOOD
      V_OCSP_CERTSTATUS_REVOKED
      V_OCSP_CERTSTATUS_UNKNOWN
  );
  
  sub AUTOLOAD {
      # This AUTOLOAD is used to 'autoload' constants from the constant()
      # XS function.  If a constant is not found then control is passed
      # to the AUTOLOAD in AutoLoader.
  
      my $constname;
      ($constname = $AUTOLOAD) =~ s/.*:://;
      my $val = constant($constname);
      if ($! != 0) {
  	if ($! =~ /((Invalid)|(not valid))/i || $!{EINVAL}) {
  	    $AutoLoader::AUTOLOAD = $AUTOLOAD;
  	    goto &AutoLoader::AUTOLOAD;
  	}
  	else {
  	  croak "Your vendor has not defined SSLeay macro $constname";
  	}
      }
      eval "sub $AUTOLOAD { $val }";
      goto &$AUTOLOAD;
  }
  
  eval {
  	require XSLoader;
  	XSLoader::load('Net::SSLeay', $VERSION);
  	1;
  } or do {
  	require DynaLoader;
  	push @ISA, 'DynaLoader';
  	bootstrap Net::SSLeay $VERSION;
  };
  
  # Preloaded methods go here.
  
  $CRLF = "\x0d\x0a";  # because \r\n is not fully portable
  
  ### Print SSLeay error stack
  
  sub print_errs {
      my ($msg) = @_;
      my ($count, $err, $errs, $e) = (0,0,'');
      while ($err = ERR_get_error()) {
          $count ++;
  	$e = "$msg $$: $count - " . ERR_error_string($err) . "\n";
  	$errs .= $e;
  	warn $e if $Net::SSLeay::trace;
      }
      return $errs;
  }
  
  # Death is conditional to SSLeay errors existing, i.e. this function checks
  # for errors and only dies in affirmative.
  # usage: Net::SSLeay::write($ssl, "foo") or die_if_ssl_error("SSL write ($!)");
  
  sub die_if_ssl_error {
      my ($msg) = @_;
      die "$$: $msg\n" if print_errs($msg);
  }
  
  # Unconditional death. Used to print SSLeay errors before dying.
  # usage: Net::SSLeay::connect($ssl) or die_now("Failed SSL connect ($!)");
  
  sub die_now {
      my ($msg) = @_;
      print_errs($msg);
      die "$$: $msg\n";
  }
  
  # Perl 5.6.* unicode support causes that length() no longer reliably
  # reflects the byte length of a string. This eval is to fix that.
  # Thanks to Sean Burke for the snippet.
  
  BEGIN{
  eval 'use bytes; sub blength ($) { defined $_[0] ? length $_[0] : 0  }';
  $@ and eval '    sub blength ($) { defined $_[0] ? length $_[0] : 0 }' ;
  }
  
  # Autoload methods go after __END__, and are processed by the autosplit program.
  
  
  1;
  __END__
  
  ### Some methods that are macros in C
  
  sub want_nothing { want(shift) == 1 }
  sub want_read { want(shift) == 2 }
  sub want_write { want(shift) == 3 }
  sub want_X509_lookup { want(shift) == 4 }
  
  ###
  ### Open TCP stream to given host and port, looking up the details
  ### from system databases or DNS.
  ###
  
  sub open_tcp_connection {
      my ($dest_serv, $port) = @_;
      my ($errs);
  
      $port = getservbyname($port, 'tcp') unless $port =~ /^\d+$/;
      my $dest_serv_ip = gethostbyname($dest_serv);
      unless (defined($dest_serv_ip)) {
  	$errs = "$0 $$: open_tcp_connection: destination host not found:"
              . " `$dest_serv' (port $port) ($!)\n";
  	warn $errs if $trace;
          return wantarray ? (0, $errs) : 0;
      }
      my $sin = sockaddr_in($port, $dest_serv_ip);
  
      warn "Opening connection to $dest_serv:$port (" .
  	inet_ntoa($dest_serv_ip) . ")" if $trace>2;
  
      my $proto = &Socket::IPPROTO_TCP; # getprotobyname('tcp') not available on android
      if (socket (SSLCAT_S, &PF_INET(), &SOCK_STREAM(), $proto)) {
          warn "next connect" if $trace>3;
          if (CORE::connect (SSLCAT_S, $sin)) {
              my $old_out = select (SSLCAT_S); $| = 1; select ($old_out);
              warn "connected to $dest_serv, $port" if $trace>3;
              return wantarray ? (1, undef) : 1; # Success
          }
      }
      $errs = "$0 $$: open_tcp_connection: failed `$dest_serv', $port ($!)\n";
      warn $errs if $trace;
      close SSLCAT_S;
      return wantarray ? (0, $errs) : 0; # Fail
  }
  
  ### Open connection via standard web proxy, if one was defined
  ### using set_proxy().
  
  sub open_proxy_tcp_connection {
      my ($dest_serv, $port) = @_;
      return open_tcp_connection($dest_serv, $port) if !$proxyhost;
  
      warn "Connect via proxy: $proxyhost:$proxyport" if $trace>2;
      my ($ret, $errs) = open_tcp_connection($proxyhost, $proxyport);
      return wantarray ? (0, $errs) : 0 if !$ret;  # Connection fail
  
      warn "Asking proxy to connect to $dest_serv:$port" if $trace>2;
      #print SSLCAT_S "CONNECT $dest_serv:$port HTTP/1.0$proxyauth$CRLF$CRLF";
      #my $line = <SSLCAT_S>;   # *** bug? Mixing stdio with syscall read?
      ($ret, $errs) =
  	tcp_write_all("CONNECT $dest_serv:$port HTTP/1.0$proxyauth$CRLF$CRLF");
      return wantarray ? (0,$errs) : 0 if $errs;
      ($line, $errs) = tcp_read_until($CRLF . $CRLF, 1024);
      warn "Proxy response: $line" if $trace>2;
      return wantarray ? (0,$errs) : 0 if $errs;
      return wantarray ? (1,'') : 1;  # Success
  }
  
  ###
  ### read and write helpers that block
  ###
  
  sub debug_read {
      my ($replyr, $gotr) = @_;
      my $vm = $trace>2 && $linux_debug ?
  	(split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
      warn "  got " . blength($$gotr) . ':'
  	. blength($$replyr) . " bytes (VM=$vm).\n" if $trace == 3;
      warn "  got `$$gotr' (" . blength($$gotr) . ':'
  	. blength($$replyr) . " bytes, VM=$vm)\n" if $trace>3;
  }
  
  sub ssl_read_all {
      my ($ssl,$how_much) = @_;
      $how_much = 2000000000 unless $how_much;
      my ($got, $errs);
      my $reply = '';
  
      while ($how_much > 0) {
          $got = Net::SSLeay::read($ssl,
                  ($how_much > 32768) ? 32768 : $how_much
          );
          last if $errs = print_errs('SSL_read');
          $how_much -= blength($got);
          debug_read(\$reply, \$got) if $trace>1;
          last if $got eq '';  # EOF
          $reply .= $got;
      }
  
      return wantarray ? ($reply, $errs) : $reply;
  }
  
  sub tcp_read_all {
      my ($how_much) = @_;
      $how_much = 2000000000 unless $how_much;
      my ($n, $got, $errs);
      my $reply = '';
  
      my $bsize = 0x10000;
      while ($how_much > 0) {
  	$n = sysread(SSLCAT_S,$got, (($bsize < $how_much) ? $bsize : $how_much));
  	warn "Read error: $! ($n,$how_much)" unless defined $n;
  	last if !$n;  # EOF
  	$how_much -= $n;
  	debug_read(\$reply, \$got) if $trace>1;
  	$reply .= $got;
      }
      return wantarray ? ($reply, $errs) : $reply;
  }
  
  sub ssl_write_all {
      my $ssl = $_[0];
      my ($data_ref, $errs);
      if (ref $_[1]) {
  	$data_ref = $_[1];
      } else {
  	$data_ref = \$_[1];
      }
      my ($wrote, $written, $to_write) = (0,0, blength($$data_ref));
      my $vm = $trace>2 && $linux_debug ?
  	(split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
      warn "  write_all VM at entry=$vm\n" if $trace>2;
      while ($to_write) {
  	#sleep 1; # *** DEBUG
  	warn "partial `$$data_ref'\n" if $trace>3;
  	$wrote = write_partial($ssl, $written, $to_write, $$data_ref);
  	if (defined $wrote && ($wrote > 0)) {  # write_partial can return -1
  	    $written += $wrote;
  	    $to_write -= $wrote;
  	} else {
  	  if (defined $wrote) {
  	    # check error conditions via SSL_get_error per man page
  	    if ( my $sslerr = get_error($ssl, $wrote) ) {
  	      my $errstr = ERR_error_string($sslerr);
  	      my $errname = '';
  	      SWITCH: {
  		$sslerr == constant("ERROR_NONE") && do {
  		  # according to map page SSL_get_error(3ssl):
  		  #  The TLS/SSL I/O operation completed.
  		  #  This result code is returned if and only if ret > 0
                    # so if we received it here complain...
  		  warn "ERROR_NONE unexpected with invalid return value!"
  		    if $trace;
  		  $errname = "SSL_ERROR_NONE";
  		};
  		$sslerr == constant("ERROR_WANT_READ") && do {
  		  # operation did not complete, call again later, so do not
  		  # set errname and empty err_que since this is a known
  		  # error that is expected but, we should continue to try
  		  # writing the rest of our data with same io call and params.
  		  warn "ERROR_WANT_READ (TLS/SSL Handshake, will continue)\n"
  		    if $trace;
  		  print_errs('SSL_write(want read)');
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_WANT_WRITE") && do {
  		  # operation did not complete, call again later, so do not
  		  # set errname and empty err_que since this is a known
  		  # error that is expected but, we should continue to try
  		  # writing the rest of our data with same io call and params.
  		  warn "ERROR_WANT_WRITE (TLS/SSL Handshake, will continue)\n"
  		    if $trace;
  		  print_errs('SSL_write(want write)');
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_ZERO_RETURN") && do {
  		  # valid protocol closure from other side, no longer able to
  		  # write, since there is no longer a session...
  		  warn "ERROR_ZERO_RETURN($wrote): TLS/SSLv3 Closure alert\n"
  		    if $trace;
  		  $errname = "SSL_ERROR_ZERO_RETURN";
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_SSL") && do {
  		  # library/protocol error
  		  warn "ERROR_SSL($wrote): Library/Protocol error occured\n"
  		    if $trace;
  		  $errname = "SSL_ERROR_SSL";
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_WANT_CONNECT") && do {
  		  # according to man page, should never happen on call to
  		  # SSL_write, so complain, but handle as known error type
  		  warn "ERROR_WANT_CONNECT: Unexpected error for SSL_write\n"
  		    if $trace;
  		  $errname = "SSL_ERROR_WANT_CONNECT";
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_WANT_ACCEPT") && do {
  		  # according to man page, should never happen on call to
  		  # SSL_write, so complain, but handle as known error type
  		  warn "ERROR_WANT_ACCEPT: Unexpected error for SSL_write\n"
  		    if $trace;
  		  $errname = "SSL_ERROR_WANT_ACCEPT";
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_WANT_X509_LOOKUP") && do {
  		  # operation did not complete: waiting on call back,
  		  # call again later, so do not set errname and empty err_que
  		  # since this is a known error that is expected but, we should
  		  # continue to try writing the rest of our data with same io
  		  # call parameter.
  		  warn "ERROR_WANT_X509_LOOKUP: (Cert Callback asked for in ".
  		    "SSL_write will contine)\n" if $trace;
  		  print_errs('SSL_write(want x509');
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_SYSCALL") && do {
  		  # some IO error occured. According to man page:
  		  # Check retval, ERR, fallback to errno
  		  if ($wrote==0) { # EOF
  		    warn "ERROR_SYSCALL($wrote): EOF violates protocol.\n"
  		      if $trace;
  		    $errname = "SSL_ERROR_SYSCALL(EOF)";
  		  } else { # -1 underlying BIO error reported.
  		    # check error que for details, don't set errname since we
  		    # are directly appending to errs
  		    my $chkerrs = print_errs('SSL_write (syscall)');
  		    if ($chkerrs) {
  		      warn "ERROR_SYSCALL($wrote): Have errors\n" if $trace;
  		      $errs .= "ssl_write_all $$: 1 - ERROR_SYSCALL($wrote,".
  			"$sslerr,$errstr,$!)\n$chkerrs";
  		    } else { # que was empty, use errno
  		      warn "ERROR_SYSCALL($wrote): errno($!)\n" if $trace;
  		      $errs .= "ssl_write_all $$: 1 - ERROR_SYSCALL($wrote,".
  			"$sslerr) : $!\n";
  		    }
  		  }
  		  last SWITCH;
  		};
  		warn "Unhandled val $sslerr from SSL_get_error(SSL,$wrote)\n"
  		  if $trace;
  		$errname = "SSL_ERROR_?($sslerr)";
  	      } # end of SWITCH block
  	      if ($errname) { # if we had an errname set add the error
  		$errs .= "ssl_write_all $$: 1 - $errname($wrote,$sslerr,".
  		  "$errstr,$!)\n";
  	      }
  	    } # endif on have SSL_get_error val
  	  } # endif on $wrote defined
  	} # endelse on $wrote > 0
  	$vm = $trace>2 && $linux_debug ?
  	    (split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
  	warn "  written so far $wrote:$written bytes (VM=$vm)\n" if $trace>2;
  	# append remaining errors in que and report if errs exist
  	$errs .= print_errs('SSL_write');
  	return (wantarray ? (undef, $errs) : undef) if $errs;
      }
      return wantarray ? ($written, $errs) : $written;
  }
  
  sub tcp_write_all {
      my ($data_ref, $errs);
      if (ref $_[0]) {
  	$data_ref = $_[0];
      } else {
  	$data_ref = \$_[0];
      }
      my ($wrote, $written, $to_write) = (0,0, blength($$data_ref));
      my $vm = $trace>2 && $linux_debug ?
  	(split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
      warn "  write_all VM at entry=$vm to_write=$to_write\n" if $trace>2;
      while ($to_write) {
  	warn "partial `$$data_ref'\n" if $trace>3;
  	$wrote = syswrite(SSLCAT_S, $$data_ref, $to_write, $written);
  	if (defined $wrote && ($wrote > 0)) {  # write_partial can return -1
  	    $written += $wrote;
  	    $to_write -= $wrote;
  	} elsif (!defined($wrote)) {
  	    warn "tcp_write_all: $!";
  	    return (wantarray ? (undef, "$!") : undef);
  	}
  	$vm = $trace>2 && $linux_debug ?
  	    (split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
  	warn "  written so far $wrote:$written bytes (VM=$vm)\n" if $trace>2;
      }
      return wantarray ? ($written, '') : $written;
  }
  
  ### from patch by Clinton Wong <clintdw@netcom.com>
  
  # ssl_read_until($ssl [, $delimit [, $max_length]])
  #  if $delimit missing, use $/ if it exists, otherwise use \n
  #  read until delimiter reached, up to $max_length chars if defined
  
  sub ssl_read_until ($;$$) {
      my ($ssl,$delim, $max_length) = @_;
  
      # guess the delim string if missing
      if ( ! defined $delim ) {
        if ( defined $/ && length $/  ) { $delim = $/ }
        else { $delim = "\n" }      # Note: \n,$/ value depends on the platform
      }
      my $len_delim = length $delim;
  
      my ($got);
      my $reply = '';
  
      # If we have OpenSSL 0.9.6a or later, we can use SSL_peek to
      # speed things up.
      # N.B. 0.9.6a has security problems, so the support for
      #      anything earlier than 0.9.6e will be dropped soon.
      if (&Net::SSLeay::OPENSSL_VERSION_NUMBER >= 0x0090601f) {
  	$max_length = 2000000000 unless (defined $max_length);
  	my ($pending, $peek_length, $found, $done);
  	while (blength($reply) < $max_length and !$done) {
  	    #Block if necessary until we get some data
  	    $got = Net::SSLeay::peek($ssl,1);
  	    last if print_errs('SSL_peek');
  
  	    $pending = Net::SSLeay::pending($ssl) + blength($reply);
  	    $peek_length = ($pending > $max_length) ? $max_length : $pending;
  	    $peek_length -= blength($reply);
  	    $got = Net::SSLeay::peek($ssl, $peek_length);
  	    last if print_errs('SSL_peek');
  	    $peek_length = blength($got);
  
  	    #$found = index($got, $delim);  # Old and broken
  
  	    # the delimiter may be split across two gets, so we prepend
  	    # a little from the last get onto this one before we check
  	    # for a match
  	    my $match;
  	    if(blength($reply) >= blength($delim) - 1) {
  		#if what we've read so far is greater or equal
  		#in length of what we need to prepatch
  		$match = substr $reply, blength($reply) - blength($delim) + 1;
  	    } else {
  		$match = $reply;
  	    }
  
  	    $match .= $got;
  	    $found = index($match, $delim);
  
  	    if ($found > -1) {
  		#$got = Net::SSLeay::read($ssl, $found+$len_delim);
  		#read up to the end of the delimiter
  		$got = Net::SSLeay::read($ssl,
  					 $found + $len_delim
  					 - ((blength($match)) - (blength($got))));
  		$done = 1;
  	    } else {
  		$got = Net::SSLeay::read($ssl, $peek_length);
  		$done = 1 if ($peek_length == $max_length - blength($reply));
  	    }
  
  	    last if print_errs('SSL_read');
  	    debug_read(\$reply, \$got) if $trace>1;
  	    last if $got eq '';
  	    $reply .= $got;
  	}
      } else {
  	while (!defined $max_length || length $reply < $max_length) {
  	    $got = Net::SSLeay::read($ssl,1);  # one by one
  	    last if print_errs('SSL_read');
  	    debug_read(\$reply, \$got) if $trace>1;
  	    last if $got eq '';
  	    $reply .= $got;
  	    last if $len_delim
  		&& substr($reply, blength($reply)-$len_delim) eq $delim;
  	}
      }
      return $reply;
  }
  
  sub tcp_read_until {
      my ($delim, $max_length) = @_;
  
      # guess the delim string if missing
      if ( ! defined $delim ) {
        if ( defined $/ && length $/  ) { $delim = $/ }
        else { $delim = "\n" }      # Note: \n,$/ value depends on the platform
      }
      my $len_delim = length $delim;
  
      my ($n,$got);
      my $reply = '';
  
      while (!defined $max_length || length $reply < $max_length) {
  	$n = sysread(SSLCAT_S, $got, 1);  # one by one
  	warn "tcp_read_until: $!" if !defined $n;
  	debug_read(\$reply, \$got) if $trace>1;
  	last if !$n;  # EOF
  	$reply .= $got;
  	last if $len_delim
  	    && substr($reply, blength($reply)-$len_delim) eq $delim;
      }
      return $reply;
  }
  
  # ssl_read_CRLF($ssl [, $max_length])
  sub ssl_read_CRLF ($;$) { ssl_read_until($_[0], $CRLF, $_[1]) }
  sub tcp_read_CRLF { tcp_read_until($CRLF, $_[0]) }
  
  # ssl_write_CRLF($ssl, $message) writes $message and appends CRLF
  sub ssl_write_CRLF ($$) {
    # the next line uses less memory but might use more network packets
    return ssl_write_all($_[0], $_[1]) + ssl_write_all($_[0], $CRLF);
  
    # the next few lines do the same thing at the expense of memory, with
    # the chance that it will use less packets, since CRLF is in the original
    # message and won't be sent separately.
  
    #my $data_ref;
    #if (ref $_[1]) { $data_ref = $_[1] }
    # else { $data_ref = \$_[1] }
    #my $message = $$data_ref . $CRLF;
    #return ssl_write_all($_[0], \$message);
  }
  
  sub tcp_write_CRLF {
    # the next line uses less memory but might use more network packets
    return tcp_write_all($_[0]) + tcp_write_all($CRLF);
  
    # the next few lines do the same thing at the expense of memory, with
    # the chance that it will use less packets, since CRLF is in the original
    # message and won't be sent separately.
  
    #my $data_ref;
    #if (ref $_[1]) { $data_ref = $_[1] }
    # else { $data_ref = \$_[1] }
    #my $message = $$data_ref . $CRLF;
    #return tcp_write_all($_[0], \$message);
  }
  
  ### Quickly print out with whom we're talking
  
  sub dump_peer_certificate ($) {
      my ($ssl) = @_;
      my $cert = get_peer_certificate($ssl);
      return if print_errs('get_peer_certificate');
      print "no cert defined\n" if !defined($cert);
      # Cipher=NONE with empty cert fix
      if (!defined($cert) || ($cert == 0)) {
  	warn "cert = `$cert'\n" if $trace;
  	return "Subject Name: undefined\nIssuer  Name: undefined\n";
      } else {
  	my $x = 'Subject Name: '
  	    . X509_NAME_oneline(X509_get_subject_name($cert)) . "\n"
  		. 'Issuer  Name: '
  		    . X509_NAME_oneline(X509_get_issuer_name($cert))  . "\n";
  	Net::SSLeay::X509_free($cert);
  	return $x;
      }
  }
  
  ### Arrange some randomness for eay PRNG
  
  sub randomize (;$$$) {
      my ($rn_seed_file, $seed, $egd_path) = @_;
      my $rnsf = defined($rn_seed_file) && -r $rn_seed_file;
  
  	$egd_path = '';
      $egd_path = $ENV{'EGD_PATH'} if $ENV{'EGD_PATH'};
  
      RAND_seed(rand() + $$);  # Stir it with time and pid
  
      unless ($rnsf || -r $Net::SSLeay::random_device || $seed || -S $egd_path) {
  	my $poll_retval = Net::SSLeay::RAND_poll();
  	warn "Random number generator not seeded!!!" if $trace && !$poll_retval;
      }
  
      RAND_load_file($rn_seed_file, -s _) if $rnsf;
      RAND_seed($seed) if $seed;
      RAND_seed($ENV{RND_SEED}) if $ENV{RND_SEED};
      RAND_load_file($Net::SSLeay::random_device, $Net::SSLeay::how_random/8)
  	if -r $Net::SSLeay::random_device;
  }
  
  sub new_x_ctx {
      if ($ssl_version == 2)  {
  	unless (exists &Net::SSLeay::CTX_v2_new) {
  	    warn "ssl_version has been set to 2, but this version of OpenSSL has been compiled without SSLv2 support";
  	    return undef;
  	}
  	$ctx = CTX_v2_new();
      }
      elsif ($ssl_version == 3)  { $ctx = CTX_v3_new(); }
      elsif ($ssl_version == 10) { $ctx = CTX_tlsv1_new(); }
      elsif ($ssl_version == 11) {
  	unless (exists &Net::SSLeay::CTX_tlsv1_1_new) {
  	    warn "ssl_version has been set to 11, but this version of OpenSSL has been compiled without TLSv1.1 support";
  	    return undef;
  	}
          $ctx = CTX_tlsv1_1_new;
      }
      elsif ($ssl_version == 12) {
  	unless (exists &Net::SSLeay::CTX_tlsv1_2_new) {
  	    warn "ssl_version has been set to 12, but this version of OpenSSL has been compiled without TLSv1.2 support";
  	    return undef;
  	}
          $ctx = CTX_tlsv1_2_new;
      }
      else                       { $ctx = CTX_new(); }
      return $ctx;
  }
  
  ###
  ### Standard initialisation. Initialise the ssl library in the usual way
  ###  at most once. Override this if you need differnet initialisation
  ###  SSLeay_add_ssl_algorithms is also protected against multiple runs in SSLeay.xs
  ###  and is also mutex protected in threading perls
  ###
  
  my $library_initialised;
  sub initialize
  {
      if (!$library_initialised)
      {
  	load_error_strings();         # Some bloat, but I'm after ease of use
  	SSLeay_add_ssl_algorithms();  # and debuggability.
  	randomize();
  	$library_initialised++;
      }
  }
  
  ###
  ### Basic request - response primitive (don't use for https)
  ###
  
  sub sslcat { # address, port, message, $crt, $key --> reply / (reply,errs,cert)
      my ($dest_serv, $port, $out_message, $crt_path, $key_path) = @_;
      my ($ctx, $ssl, $got, $errs, $written);
  
      ($got, $errs) = open_proxy_tcp_connection($dest_serv, $port);
      return (wantarray ? (undef, $errs) : undef) unless $got;
  
      ### Do SSL negotiation stuff
  
      warn "Creating SSL $ssl_version context...\n" if $trace>2;
      initialize(); # Will init at most once
  
      $ctx = new_x_ctx();
      goto cleanup2 if $errs = print_errs('CTX_new') or !$ctx;
  
      CTX_set_options($ctx, &OP_ALL);
      goto cleanup2 if $errs = print_errs('CTX_set_options');
  
      warn "Cert `$crt_path' given without key" if $crt_path && !$key_path;
      set_cert_and_key($ctx, $crt_path, $key_path) if $crt_path;
  
      warn "Creating SSL connection (context was '$ctx')...\n" if $trace>2;
      $ssl = new($ctx);
      goto cleanup if $errs = print_errs('SSL_new') or !$ssl;
  
      warn "Setting fd (ctx $ctx, con $ssl)...\n" if $trace>2;
      set_fd($ssl, fileno(SSLCAT_S));
      goto cleanup if $errs = print_errs('set_fd');
  
      warn "Entering SSL negotiation phase...\n" if $trace>2;
  
      if ($trace>2) {
  	my $i = 0;
  	my $p = '';
  	my $cipher_list = 'Cipher list: ';
  	$p=Net::SSLeay::get_cipher_list($ssl,$i);
  	$cipher_list .= $p if $p;
  	do {
  	    $i++;
  	    $cipher_list .= ', ' . $p if $p;
  	    $p=Net::SSLeay::get_cipher_list($ssl,$i);
  	} while $p;
  	$cipher_list .= '\n';
  	warn $cipher_list;
      }
  
      $got = Net::SSLeay::connect($ssl);
      warn "SSLeay connect returned $got\n" if $trace>2;
      goto cleanup if $errs = print_errs('SSL_connect');
  
      my $server_cert = get_peer_certificate($ssl);
      print_errs('get_peer_certificate');
      if ($trace>1) {
  	warn "Cipher `" . get_cipher($ssl) . "'\n";
  	print_errs('get_ciper');
  	warn dump_peer_certificate($ssl);
      }
  
      ### Connected. Exchange some data (doing repeated tries if necessary).
  
      warn "sslcat $$: sending " . blength($out_message) . " bytes...\n"
  	if $trace==3;
      warn "sslcat $$: sending `$out_message' (" . blength($out_message)
  	. " bytes)...\n" if $trace>3;
      ($written, $errs) = ssl_write_all($ssl, $out_message);
      goto cleanup unless $written;
  
      sleep $slowly if $slowly;  # Closing too soon can abort broken servers
      CORE::shutdown SSLCAT_S, 1;  # Half close --> No more output, send EOF to server
  
      warn "waiting for reply...\n" if $trace>2;
      ($got, $errs) = ssl_read_all($ssl);
      warn "Got " . blength($got) . " bytes.\n" if $trace==3;
      warn "Got `$got' (" . blength($got) . " bytes)\n" if $trace>3;
  
  cleanup:
      free ($ssl);
      $errs .= print_errs('SSL_free');
  cleanup2:
      CTX_free ($ctx);
      $errs .= print_errs('CTX_free');
      close SSLCAT_S;
      return wantarray ? ($got, $errs, $server_cert) : $got;
  }
  
  sub tcpcat { # address, port, message, $crt, $key --> reply / (reply,errs,cert)
      my ($dest_serv, $port, $out_message) = @_;
      my ($got, $errs, $written);
  
      ($got, $errs) = open_proxy_tcp_connection($dest_serv, $port);
      return (wantarray ? (undef, $errs) : undef) unless $got;
  
      ### Connected. Exchange some data (doing repeated tries if necessary).
  
      warn "tcpcat $$: sending " . blength($out_message) . " bytes...\n"
  	if $trace==3;
      warn "tcpcat $$: sending `$out_message' (" . blength($out_message)
  	. " bytes)...\n" if $trace>3;
      ($written, $errs) = tcp_write_all($out_message);
      goto cleanup unless $written;
  
      sleep $slowly if $slowly;  # Closing too soon can abort broken servers
      CORE::shutdown SSLCAT_S, 1;  # Half close --> No more output, send EOF to server
  
      warn "waiting for reply...\n" if $trace>2;
      ($got, $errs) = tcp_read_all();
      warn "Got " . blength($got) . " bytes.\n" if $trace==3;
      warn "Got `$got' (" . blength($got) . " bytes)\n" if $trace>3;
  
  cleanup:
      close SSLCAT_S;
      return wantarray ? ($got, $errs) : $got;
  }
  
  sub tcpxcat {
      my ($usessl, $site, $port, $req, $crt_path, $key_path) = @_;
      if ($usessl) {
  	return sslcat($site, $port, $req, $crt_path, $key_path);
      } else {
  	return tcpcat($site, $port, $req);
      }
  }
  
  ###
  ### Basic request - response primitive, this is different from sslcat
  ###                 because this does not shutdown the connection.
  ###
  
  sub https_cat { # address, port, message --> returns reply / (reply,errs,cert)
      my ($dest_serv, $port, $out_message, $crt_path, $key_path) = @_;
      my ($ctx, $ssl, $got, $errs, $written);
  
      ($got, $errs) = open_proxy_tcp_connection($dest_serv, $port);
      return (wantarray ? (undef, $errs) : undef) unless $got;
  
      ### Do SSL negotiation stuff
  
      warn "Creating SSL $ssl_version context...\n" if $trace>2;
      initialize();
  
      $ctx = new_x_ctx();
      goto cleanup2 if $errs = print_errs('CTX_new') or !$ctx;
  
      CTX_set_options($ctx, &OP_ALL);
      goto cleanup2 if $errs = print_errs('CTX_set_options');
  
      warn "Cert `$crt_path' given without key" if $crt_path && !$key_path;
      set_cert_and_key($ctx, $crt_path, $key_path) if $crt_path;
  
      warn "Creating SSL connection (context was '$ctx')...\n" if $trace>2;
      $ssl = new($ctx);
      goto cleanup if $errs = print_errs('SSL_new') or !$ssl;
  
      warn "Setting fd (ctx $ctx, con $ssl)...\n" if $trace>2;
      set_fd($ssl, fileno(SSLCAT_S));
      goto cleanup if $errs = print_errs('set_fd');
  
      warn "Entering SSL negotiation phase...\n" if $trace>2;
  
      if ($trace>2) {
  	my $i = 0;
  	my $p = '';
  	my $cipher_list = 'Cipher list: ';
  	$p=Net::SSLeay::get_cipher_list($ssl,$i);
  	$cipher_list .= $p if $p;
  	do {
  	    $i++;
  	    $cipher_list .= ', ' . $p if $p;
  	    $p=Net::SSLeay::get_cipher_list($ssl,$i);
  	} while $p;
  	$cipher_list .= '\n';
  	warn $cipher_list;
      }
  
      $got = Net::SSLeay::connect($ssl);
      warn "SSLeay connect failed" if $trace>2 && $got==0;
      goto cleanup if $errs = print_errs('SSL_connect');
  
      my $server_cert = get_peer_certificate($ssl);
      print_errs('get_peer_certificate');
      if ($trace>1) {
  	warn "Cipher `" . get_cipher($ssl) . "'\n";
  	print_errs('get_ciper');
  	warn dump_peer_certificate($ssl);
      }
  
      ### Connected. Exchange some data (doing repeated tries if necessary).
  
      warn "https_cat $$: sending " . blength($out_message) . " bytes...\n"
  	if $trace==3;
      warn "https_cat $$: sending `$out_message' (" . blength($out_message)
  	. " bytes)...\n" if $trace>3;
      ($written, $errs) = ssl_write_all($ssl, $out_message);
      goto cleanup unless $written;
  
      warn "waiting for reply...\n" if $trace>2;
      ($got, $errs) = ssl_read_all($ssl);
      warn "Got " . blength($got) . " bytes.\n" if $trace==3;
      warn "Got `$got' (" . blength($got) . " bytes)\n" if $trace>3;
  
  cleanup:
      free ($ssl);
      $errs .= print_errs('SSL_free');
  cleanup2:
      CTX_free ($ctx);
      $errs .= print_errs('CTX_free');
      close SSLCAT_S;
      return wantarray ? ($got, $errs, $server_cert) : $got;
  }
  
  sub http_cat { # address, port, message --> returns reply / (reply,errs,cert)
      my ($dest_serv, $port, $out_message) = @_;
      my ($got, $errs, $written);
  
      ($got, $errs) = open_proxy_tcp_connection($dest_serv, $port);
      return (wantarray ? (undef, $errs) : undef) unless $got;
  
      ### Connected. Exchange some data (doing repeated tries if necessary).
  
      warn "http_cat $$: sending " . blength($out_message) . " bytes...\n"
  	if $trace==3;
      warn "http_cat $$: sending `$out_message' (" . blength($out_message)
  	. " bytes)...\n" if $trace>3;
      ($written, $errs) = tcp_write_all($out_message);
      goto cleanup unless $written;
  
      warn "waiting for reply...\n" if $trace>2;
      ($got, $errs) = tcp_read_all();
      warn "Got " . blength($got) . " bytes.\n" if $trace==3;
      warn "Got `$got' (" . blength($got) . " bytes)\n" if $trace>3;
  
  cleanup:
      close SSLCAT_S;
      return wantarray ? ($got, $errs) : $got;
  }
  
  sub httpx_cat {
      my ($usessl, $site, $port, $req, $crt_path, $key_path) = @_;
      warn "httpx_cat: usessl=$usessl ($site:$port)" if $trace;
      if ($usessl) {
  	return https_cat($site, $port, $req, $crt_path, $key_path);
      } else {
  	return http_cat($site, $port, $req);
      }
  }
  
  ###
  ### Easy set up of private key and certificate
  ###
  
  sub set_cert_and_key ($$$) {
      my ($ctx, $cert_path, $key_path) = @_;
      my $errs = '';
      # Following will ask password unless private key is not encrypted
      CTX_use_PrivateKey_file ($ctx, $key_path, &FILETYPE_PEM);
      $errs .= print_errs("private key `$key_path' ($!)");
      CTX_use_certificate_file ($ctx, $cert_path, &FILETYPE_PEM);
      $errs .= print_errs("certificate `$cert_path' ($!)");
      return wantarray ? (undef, $errs) : ($errs eq '');
  }
  
  ### Old deprecated API
  
  sub set_server_cert_and_key ($$$) { &set_cert_and_key }
  
  ### Set up to use web proxy
  
  sub set_proxy ($$;**) {
      ($proxyhost, $proxyport, $proxyuser, $proxypass) = @_;
      require MIME::Base64 if $proxyuser;
      $proxyauth = $proxyuser
           ? $CRLF . 'Proxy-authorization: Basic '
  	 . MIME::Base64::encode("$proxyuser:$proxypass", '')
  	 : '';
  }
  
  ###
  ### Easy https manipulation routines
  ###
  
  sub make_form {
      my (@fields) = @_;
      my $form;
      while (@fields) {
  	my ($name, $data) = (shift(@fields), shift(@fields));
  	$data =~ s/([^\w\-.\@\$ ])/sprintf("%%%2.2x",ord($1))/gse;
      	$data =~ tr[ ][+];
  	$form .= "$name=$data&";
      }
      chop $form;
      return $form;
  }
  
  sub make_headers {
      my (@headers) = @_;
      my $headers;
      while (@headers) {
  	my $header = shift(@headers);
  	my $value = shift(@headers);
  	$header =~ s/:$//;
  	$value =~ s/\x0d?\x0a$//; # because we add it soon, see below
  	$headers .= "$header: $value$CRLF";
      }
      return $headers;
  }
  
  sub do_httpx3 {
      my ($method, $usessl, $site, $port, $path, $headers,
  	$content, $mime_type, $crt_path, $key_path) = @_;
      my ($response, $page, $h,$v);
  
      my $len = blength($content);
      if ($len) {
  	$mime_type = "application/x-www-form-urlencoded" unless $mime_type;
  	$content = "Content-Type: $mime_type$CRLF"
  	    . "Content-Length: $len$CRLF$CRLF$content";
      } else {
  	$content = "$CRLF$CRLF";
      }
      my $req = "$method $path HTTP/1.0$CRLF";
      unless (defined $headers && $headers =~ /^Host:/m) {
          $req .= "Host: $site";
          unless (($port == 80 && !$usessl) || ($port == 443 && $usessl)) {
              $req .= ":$port";
          }
          $req .= $CRLF;
  	}
      $req .= (defined $headers ? $headers : '') . "Accept: */*$CRLF$content";
  
      warn "do_httpx3($method,$usessl,$site:$port)" if $trace;
      my ($http, $errs, $server_cert)
  	= httpx_cat($usessl, $site, $port, $req, $crt_path, $key_path);
      return (undef, "HTTP/1.0 900 NET OR SSL ERROR$CRLF$CRLF$errs") if $errs;
  
      $http = '' if !defined $http;
      ($headers, $page) = split /\s?\n\s?\n/, $http, 2;
      warn "headers >$headers< page >>$page<< http >>>$http<<<" if $trace>1;
      ($response, $headers) = split /\s?\n/, $headers, 2;
      return ($page, $response, $headers, $server_cert);
  }
  
  sub do_https3 { splice(@_,1,0) = 1; do_httpx3; }  # Legacy undocumented
  
  ### do_https2() is a legacy version in the sense that it is unable
  ### to return all instances of duplicate headers.
  
  sub do_httpx2 {
      my ($page, $response, $headers, $server_cert) = &do_httpx3;
      X509_free($server_cert) if defined $server_cert;
      return ($page, $response, defined $headers ?
  	    map( { ($h,$v)=/^(\S+)\:\s*(.*)$/; (uc($h),$v); }
  		split(/\s?\n/, $headers)
  		) : ()
  	    );
  }
  
  sub do_https2 { splice(@_,1,0) = 1; do_httpx2; }  # Legacy undocumented
  
  ### Returns headers as a hash where multiple instances of same header
  ### are handled correctly.
  
  sub do_httpx4 {
      my ($page, $response, $headers, $server_cert) = &do_httpx3;
      my %hr = ();
      for my $hh (split /\s?\n/, $headers) {
  	my ($h,$v) = ($hh =~ /^(\S+)\:\s*(.*)$/);
  	push @{$hr{uc($h)}}, $v;
      }
      return ($page, $response, \%hr, $server_cert);
  }
  
  sub do_https4 { splice(@_,1,0) = 1; do_httpx4; }  # Legacy undocumented
  
  # https
  
  sub get_https  { do_httpx2(GET  => 1, @_) }
  sub post_https { do_httpx2(POST => 1, @_) }
  sub put_https  { do_httpx2(PUT  => 1, @_) }
  sub head_https { do_httpx2(HEAD => 1, @_) }
  
  sub get_https3  { do_httpx3(GET  => 1, @_) }
  sub post_https3 { do_httpx3(POST => 1, @_) }
  sub put_https3  { do_httpx3(PUT  => 1, @_) }
  sub head_https3 { do_httpx3(HEAD => 1, @_) }
  
  sub get_https4  { do_httpx4(GET  => 1, @_) }
  sub post_https4 { do_httpx4(POST => 1, @_) }
  sub put_https4  { do_httpx4(PUT  => 1, @_) }
  sub head_https4 { do_httpx4(HEAD => 1, @_) }
  
  # http
  
  sub get_http  { do_httpx2(GET  => 0, @_) }
  sub post_http { do_httpx2(POST => 0, @_) }
  sub put_http  { do_httpx2(PUT  => 0, @_) }
  sub head_http { do_httpx2(HEAD => 0, @_) }
  
  sub get_http3  { do_httpx3(GET  => 0, @_) }
  sub post_http3 { do_httpx3(POST => 0, @_) }
  sub put_http3  { do_httpx3(PUT  => 0, @_) }
  sub head_http3 { do_httpx3(HEAD => 0, @_) }
  
  sub get_http4  { do_httpx4(GET  => 0, @_) }
  sub post_http4 { do_httpx4(POST => 0, @_) }
  sub put_http4  { do_httpx4(PUT  => 0, @_) }
  sub head_http4 { do_httpx4(HEAD => 0, @_) }
  
  # Either https or http
  
  sub get_httpx  { do_httpx2(GET  => @_) }
  sub post_httpx { do_httpx2(POST => @_) }
  sub put_httpx  { do_httpx2(PUT  => @_) }
  sub head_httpx { do_httpx2(HEAD => @_) }
  
  sub get_httpx3  { do_httpx3(GET  => @_) }
  sub post_httpx3 { do_httpx3(POST => @_) }
  sub put_httpx3  { do_httpx3(PUT  => @_) }
  sub head_httpx3 { do_httpx3(HEAD => @_) }
  
  sub get_httpx4  { do_httpx4(GET  => @_) }
  sub post_httpx4 { do_httpx4(POST => @_) }
  sub put_httpx4  { do_httpx4(PUT  => @_) }
  sub head_httpx4 { do_httpx4(HEAD => @_) }
  
  ### Legacy, don't use
  # ($page, $respone_or_err, %headers) = do_https(...);
  
  sub do_https {
      my ($site, $port, $path, $method, $headers,
  	$content, $mime_type, $crt_path, $key_path) = @_;
  
      do_https2($method, $site, $port, $path, $headers,
  	     $content, $mime_type, $crt_path, $key_path);
  }
  
  1;
  __END__
  
X86_64-LINUX-THREAD-MULTI_NET_SSLEAY

$fatpacked{"x86_64-linux-thread-multi/Net/SSLeay/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_NET_SSLEAY_HANDLE';
  package Net::SSLeay::Handle;
  
  require 5.005_03;
  use strict;
  
  use Socket;
  use Net::SSLeay;
  
  require Exporter;
  
  =head1 NAME
  
  Net::SSLeay::Handle - Perl module that lets SSL (HTTPS) sockets be
  handled as standard file handles.
  
  =head1 SYNOPSIS
  
    use Net::SSLeay::Handle qw/shutdown/;
    my ($host, $port) = ("localhost", 443);
  
    tie(*SSL, "Net::SSLeay::Handle", $host, $port);
  
    print SSL "GET / HTTP/1.0\r\n";
    shutdown(\*SSL, 1);
    print while (<SSL>);
    close SSL;                                                       
  
  =head1 DESCRIPTION
  
  Net::SSLeay::Handle allows you to request and receive HTTPS web pages
  using "old-fashion" file handles as in:
  
      print SSL "GET / HTTP/1.0\r\n";
  
  and
  
      print while (<SSL>);
  
  If you export the shutdown routine, then the only extra code that
  you need to add to your program is the tie function as in:
  
      my $socket;
      if ($scheme eq "https") {
          tie(*S2, "Net::SSLeay::Handle", $host, $port);
          $socket = \*S2;
      else {
          $socket = Net::SSLeay::Handle->make_socket($host, $port);
      }
      print $socket $request_headers;
      ... 
  
  =cut
  
  use vars qw(@ISA @EXPORT_OK $VERSION);
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(shutdown);
  $VERSION = '0.61';
  
  my $Initialized;       #-- only _initialize() once
  my $Debug = 0;         #-- pretty hokey
  my %Glob_Ref;          #-- used to make unique \*S names for versions < 5.6
  
  #== Tie Handle Methods ========================================================
  #
  # see perldoc perltie for details.
  #
  #==============================================================================
  
  sub TIEHANDLE {
      my ($class, $socket, $port) = @_;
      $Debug > 10 and print "TIEHANDLE(@{[join ', ', @_]})\n";
  
      ref $socket eq "GLOB" or $socket = $class->make_socket($socket, $port);
  
      $class->_initialize();
  
      my $ctx = Net::SSLeay::CTX_new() or die_now("Failed to create SSL_CTX $!");
      my $ssl = Net::SSLeay::new($ctx) or die_now("Failed to create SSL $!");
  
      my $fileno = fileno($socket);
  
    Net::SSLeay::set_fd($ssl, $fileno);   # Must use fileno
  
      my $resp = Net::SSLeay::connect($ssl);
  
      $Debug and print "Cipher '" . Net::SSLeay::get_cipher($ssl) . "'\n";
  
  	my $self = bless {
          ssl    => $ssl, 
          ctx    => $ctx,
          socket => $socket,
          fileno => $fileno,
      }, $class;
  
      return $self;
  }
  
  sub PRINT {
      my $self = shift;
  
      my $ssl  = _get_ssl($self);
      my $resp = 0;
      for my $msg (@_) {
          defined $msg or last;
          $resp = Net::SSLeay::write($ssl, $msg) or last;
      }
      return $resp;
  }
  
  sub READLINE {
      my $self = shift;
      my $ssl  = _get_ssl($self);
  	if (wantarray) {
  		my @lines;
  		while (my $line = Net::SSLeay::ssl_read_until($ssl)) {
  			push @lines, $line;
  		}
  		return @lines;
  	} else {
  		my $line = Net::SSLeay::ssl_read_until($ssl); 
  		return $line ? $line : undef;
  	}
  }
  
  sub READ {
      my ($self, $buf, $len, $offset) = \ (@_);
      my $ssl = _get_ssl($$self);
      defined($$offset) or 
        return length($$buf = Net::SSLeay::ssl_read_all($ssl, $$len));
  
      defined(my $read = Net::SSLeay::ssl_read_all($ssl, $$len))
        or return undef;
  
      my $buf_len = length($$buf);
      $$offset > $buf_len and $$buf .= chr(0) x ($$offset - $buf_len);
      substr($$buf, $$offset) = $read;
      return length($read);
  }
  
  sub WRITE {
      my $self = shift;
      my ($buf, $len, $offset) = @_;
      $offset = 0 unless defined $offset;
  
      # Return number of characters written.
      my $ssl  = $self->_get_ssl();
      return $len if Net::SSLeay::write($ssl, substr($buf, $offset, $len));
      return undef;
  }
  
  sub CLOSE {
      my $self = shift;
      my $fileno = $self->{fileno};
      $Debug > 10 and print "close($fileno)\n";
      Net::SSLeay::free ($self->{ssl});
      Net::SSLeay::CTX_free ($self->{ctx});
      close $self->{socket};
  }
  
  sub FILENO  { $_[0]->{fileno} }
  
  
  =head1 FUNCTIONS
  
  =over
  
  =item shutdown
  
    shutdown(\*SOCKET, $mode)
  
  Calls to the main shutdown() don't work with tied sockets created with this
  module.  This shutdown should be able to distinquish between tied and untied
  sockets and do the right thing.
  
  =cut
  
  sub shutdown {
      my ($obj, @params) = @_;
  
  	my $socket = UNIVERSAL::isa($obj, 'Net::SSLeay::Handle') ?
  		$obj->{socket} : $obj;
      return shutdown($socket, @params);
  }
  
  =item debug
  
    my $debug = Net::SSLeay::Handle->debug()
    Net::SSLeay::Handle->debug(1)
  
  Get/set debuging mode. Always returns the debug value before the function call.
  if an additional argument is given the debug option will be set to this value.
  
  =cut
  
  sub debug {
      my ($class, $debug) = @_;
      my $old_debug = $Debug;
      @_ >1 and $Debug = $debug || 0;
      return $old_debug;
  }
  
  #=== Internal Methods =========================================================
  
  =item make_socket
  
    my $sock = Net::SSLeay::Handle->make_socket($host, $port);
  
  Creates a socket that is connected to $post using $port. It uses
  $Net::SSLeay::proxyhost and proxyport if set and authentificates itself against
  this proxy depending on $Net::SSLeay::proxyauth. It also turns autoflush on for
  the created socket.
  
  =cut
  
  sub make_socket {
      my ($class, $host, $port) = @_;
      $Debug > 10 and print "_make_socket(@{[join ', ', @_]})\n";
      $host ||= 'localhost';
      $port ||= 443;
  
      my $phost = $Net::SSLeay::proxyhost;
      my $pport = $Net::SSLeay::proxyhost ? $Net::SSLeay::proxyport : $port;
  
      my $dest_ip     = gethostbyname($phost || $host);
      my $host_params = sockaddr_in($pport, $dest_ip);
      my $socket = $^V ? undef : $class->_glob_ref("$host:$port");
      
      socket($socket, &PF_INET(), &SOCK_STREAM(), 0) or die "socket: $!";
      connect($socket, $host_params)                 or die "connect: $!";
  
      my $old_select = select($socket); $| = 1; select($old_select);
      $phost and do {
          my $auth = $Net::SSLeay::proxyauth;
          my $CRLF = $Net::SSLeay::CRLF;
          print $socket "CONNECT $host:$port HTTP/1.0$auth$CRLF$CRLF";
          my $line = <$socket>;
      };
      return $socket;
  }
  
  =back
  
  =cut
  
  #--- _glob_ref($strings) ------------------------------------------------------
  #
  # Create a unique namespace name and return a glob ref to it.  Would be great
  # to use the fileno but need this before we get back the fileno.
  # NEED TO LOCK THIS ROUTINE IF USING THREADS. (but it is only used for
  # versions < 5.6 :)
  #------------------------------------------------------------------------------
  
  sub _glob_ref {
      my $class = shift;
      my $preamb = join("", @_) || "_glob_ref";
      my $num = ++$Glob_Ref{$preamb};
      my $name = "$preamb:$num";
      no strict 'refs';
      my $glob_ref = \*$name;
      use strict 'refs';
  
      $Debug and do {
          print "GLOB_REF $preamb\n";
          while (my ($k, $v) = each %Glob_Ref) {print "$k = $v\n"} 
          print "\n";
      };
  
      return $glob_ref;
  }
  
  sub _initialize {
      $Initialized++ and return;
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();
  }
  
  sub __dummy {
      my $host = $Net::SSLeay::proxyhost;
      my $port = $Net::SSLeay::proxyport;
      my $auth = $Net::SSLeay::proxyauth;
  }
  
  #--- _get_self($socket) -------------------------------------------------------
  # Returns a hash containing attributes for $socket (= \*SOMETHING) based
  # on fileno($socket).  Will return undef if $socket was not created here.
  #------------------------------------------------------------------------------
  
  sub _get_self { return $_[0]; }
  
  #--- _get_ssl($socket) --------------------------------------------------------
  # Returns a the "ssl" attribute for $socket (= \*SOMETHING) based
  # on fileno($socket).  Will cause a warning and return undef if $socket was not
  # created here.
  #------------------------------------------------------------------------------
  
  sub _get_ssl {
      return $_[0]->{ssl};
  }
  
  1;
  
  __END__
  
  =head2 USING EXISTING SOCKETS
  
  One of the motivations for writing this module was to avoid
  duplicating socket creation code (which is mostly error handling).
  The calls to tie() above where it is passed a $host and $port is
  provided for convenience testing.  If you already have a socket
  connected to the right host and port, S1, then you can do something
  like:
  
      my $socket \*S1;
      if ($scheme eq "https") {
          tie(*S2, "Net::SSLeay::Handle", $socket);
          $socket = \*S2;
      }
      my $last_sel = select($socket); $| = 1; select($last_sel);
      print $socket $request_headers;
      ... 
  
  Note: As far as I know you must be careful with the globs in the tie()
  function.  The first parameter must be a glob (*SOMETHING) and the
  last parameter must be a reference to a glob (\*SOMETHING_ELSE) or a
  scaler that was assigned to a reference to a glob (as in the example
  above)
  
  Also, the two globs must be different.  When I tried to use the same
  glob, I got a core dump.
  
  =head2 EXPORT
  
  None by default.
  
  You can export the shutdown() function.
  
  It is suggested that you do export shutdown() or use the fully
  qualified Net::SSLeay::Handle::shutdown() function to shutdown SSL
  sockets.  It should be smart enough to distinguish between SSL and
  non-SSL sockets and do the right thing.
  
  =head1 EXAMPLES
  
    use Net::SSLeay::Handle qw/shutdown/;
    my ($host, $port) = ("localhost", 443);
  
    tie(*SSL, "Net::SSLeay::Handle", $host, $port);
  
    print SSL "GET / HTTP/1.0\r\n";
    shutdown(\*SSL, 1);
    print while (<SSL>);
    close SSL; 
  
  =head1 TODO
  
  Better error handling.  Callback routine?
  
  =head1 CAVEATS
  
  Tying to a file handle is a little tricky (for me at least).
  
  The first parameter to tie() must be a glob (*SOMETHING) and the last
  parameter must be a reference to a glob (\*SOMETHING_ELSE) or a scaler
  that was assigned to a reference to a glob ($s = \*SOMETHING_ELSE).
  Also, the two globs must be different.  When I tried to use the same
  glob, I got a core dump.
  
  I was able to associate attributes to globs created by this module
  (like *SSL above) by making a hash of hashes keyed by the file head1.
  
  Support for old perls may not be 100%. If in trouble try 5.6.0 or
  newer.
  
  =head1 CHANGES
  
  Please see Net-SSLeay-Handle-0.50/Changes file.
  
  =head1 KNOWN BUGS
  
  If you let this module construct sockets for you with Perl versions
  below v.5.6 then there is a slight memory leak.  Other upgrade your
  Perl, or create the sockets yourself.  The leak was created to let
  these older versions of Perl access more than one Handle at a time.
  
  =head1 AUTHOR
  
  Jim Bowlin jbowlin@linklint.org
  
  =head1 SEE ALSO
  
  Net::SSLeay, perl(1), http://openssl.org/
  
  =cut
X86_64-LINUX-THREAD-MULTI_NET_SSLEAY_HANDLE

$fatpacked{"x86_64-linux-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.45";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-thread-multi/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.45";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;
use utf8;

use File::HomeDir;
use Getopt::Long;
use List::Util qw/ any /;
use Mojo::JSON qw/ decode_json encode_json /;
use RSS::Check;

our $VERSION = '0.01';

my $enc = 'iso-8859-1';
if (defined $ENV{LANG} and $ENV{LANG} =~ /\.utf-?8$/i) { $enc = 'UTF-8'; }
binmode STDOUT, ":encoding($enc)";

GetOptions(
    'help|h'       => \my $help,
    'version|v'    => \my $version,
    'data-dir|d=s' => \my $data_dir,
    'add|a=s'      => \my $add,
);

sub show_copy {
    print <<"COPY";
Copyright © 2017. Andreas Guldstrand.
COPY
}

sub show_ver {
    print <<"VERSION";
$0 $VERSION

VERSION
}

sub show_usage {
    show_ver();

    print <<"USAGE";
$0 [options]

  --help|-h              Show usage.
  --version|-v           Show version.
  --data-dir|-d <dir>    Use <dir> to store data. Defaults to "~/.rss-check".
  --add|-a <url>         Add <url> to subscriptions.

USAGE
}

if ($version) { show_ver(); show_copy(); exit 0; }

if ($help) { show_usage(); show_copy(); exit 0; }

$data_dir //= File::HomeDir->my_home() . "/.rss-check";
my $sub_file = $data_dir . '/subscriptions';

mkdir $data_dir or die "Could not create directory $data_dir: $!\n" unless -d $data_dir;

if ($add) {
  my @subscriptions = get_subscriptions();

  if (any { $_->{url} eq $add } @subscriptions) {
    die "Already subscribed to $add.\n";
  }

  my $id = 0;
  $id = $subscriptions[-1]->{id} + 1 if @subscriptions;
  unlink "$data_dir/$id" if -e "$data_dir/$id";
  my $sub = { id => $id, url => $add };
  push @subscriptions, $sub;

  write_subscriptions(@subscriptions);

  get_updates($sub);

  exit;
}

my @subscriptions = get_subscriptions();

for my $sub (@subscriptions) { get_updates($sub); }
exit;

sub fopen {
  my ($fn, $mode) = @_;
  $mode //= 'r';
  open my $fh, ($mode eq 'w' ? '>' : '<'), $fn or die "Could not open $fn: $!\n";
  return $fh;
}

sub slurp {
  my $fn = shift;
  my $fh = fopen $fn;
  local $/;
  return readline $fh;
}

sub get_subscriptions {
  return if not -e $sub_file;
  return if not -s $sub_file;

  return @{ decode_json slurp $sub_file };
}

sub write_subscriptions {
  my $fh = fopen($sub_file, 'w');
  print {$fh} encode_json [ @_ ];
}

sub get_updates {
  my $sub = shift;
  my $feed_file = "$data_dir/$sub->{id}";

  my $last_id;
  if (-e $feed_file) {
    $last_id = slurp($feed_file);
  }

  my $rss = RSS::Check->read($sub->{url});

  my @articles = $rss->until($last_id);

  printf "%s: %s\n", $rss->{title}, $_->{title} for @articles;

  my $fh = fopen($feed_file, 'w');
  print {$fh} $rss->last_id;
}
